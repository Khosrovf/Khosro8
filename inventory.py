# ==== MEGATITE Inventory – Transformed Build (OC/QA Enhanced Stub) ====
# Build Date: 2025-08-14 23:15:57
# Notes: Non-invasive augmentation: OperationsCenter stub + hooks.
# =====================================================================

# ------------------ بخش ۱: کتابخانه‌های استاندارد پایتون ------------------
import os
import sys
from passlib.context import CryptContext
import hashlib

import json
import tempfile
import time
import traceback
import subprocess
import datetime as dt
from datetime import datetime
from pathlib import Path
from threading import Timer
import weakref
from functools import partial
from typing import List
from contextlib import contextmanager

# ------------------ بخش ۲: کتابخانه‌های جانبی (Third-Party) ------------------
# --- PyQt5 ---
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QIcon, QFont, QPalette, QColor, QDoubleValidator, QPixmap, QDesktopServices
from PyQt5.QtCore import Qt, QSize, QPoint, QRect, QPropertyAnimation, QAbstractAnimation, QEasingCurve, pyqtSignal
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QFrame, QLabel, QLineEdit, QTextEdit,
    QPushButton, QComboBox, QTableWidget, QTableWidgetItem, QListWidget, QListWidgetItem,
    QHBoxLayout, QVBoxLayout, QFormLayout, QDialogButtonBox, QAction, QMenu,
    QMessageBox, QInputDialog, QFileDialog, QSplashScreen, QToolBar, QSplitter,
    QStackedWidget, QCheckBox, QGroupBox, QScrollArea, QTreeWidget, QTreeWidgetItem,
    QHeaderView, QAbstractItemView, QStyle, QStyledItemDelegate, QGraphicsDropShadowEffect,
    QGraphicsOpacityEffect, QWidgetAction
)

# --- پایگاه داده ---
import psycopg2
from psycopg2 import pool # <-- این خط جدید را اضافه کنید

from psycopg2.extras import DictCursor
import psycopg2.errors

# --- تحلیل داده و گزارش‌گیری ---
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.font_manager as fm
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas

# --- فارسی‌سازی و تاریخ ---
import jdatetime as jd
from arabic_reshaper import reshape
from bidi.algorithm import get_display

# --- اسکنر (فقط ویندوز) ---
try:
    import win32com.client
    import pythoncom
except ImportError:
    win32com = None # برای جلوگیری از خطا در سیستم‌های غیر ویندوزی
    pythoncom = None

# ------------------ بخش ۳: کدهای داخلی برنامه (در آینده می‌توان منظم‌تر کرد) ------------------
# (فعلا توابع و کلاس‌های اصلی در ادامه همین فایل قرار دارند)

BASE_DIR    = Path(__file__).resolve().parent
BACKUP_INT  = 86400                     # 24h
VIEWS_FILE = BASE_DIR / 'views.json'
DEBUG_BOOTSTRAP = str(os.getenv('DEBUG_BOOTSTRAP', '')).strip().lower() in ('1','true','yes','on')
DEBUG_DB_SETTINGS = str(os.getenv('DEBUG_DB_SETTINGS', '')).strip().lower() in ('1','true','yes','on')
DEBUG_DB_RESOLVE = str(os.getenv('DEBUG_DB_RESOLVE', '')).strip().lower() in ('1','true','yes','on')

_hash_legacy = lambda s: hashlib.sha256(s.encode('utf-8')).hexdigest()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """رمز عبور را به صورت امن هش می‌کند."""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """رمز وارد شده را با هش ذخیره شده مقایسه می‌کند."""
    return pwd_context.verify(plain_password, hashed_password)

def create_config_if_not_exists(default_config: dict = None) -> bool:
    """
    نسخه نهایی: از کلیدهای استاندارد psycopg2 برای ساخت فایل کانفیگ استفاده می‌کند.
    """
    config_path = BASE_DIR / 'config.json'
    if not config_path.exists():
        print("INFO: 'config.json' not found. Creating a default file.")

        if default_config is None:
            # --- اصلاح کلیدی: استفاده از نام‌های استاندارد ---
            default_config = {
                "host": "localhost",
                "port": 5433,
                "dbname": "megatite_db",
                "user": "postgres",
                "password": "YOUR_POSTGRES_PASSWORD",
                "sslmode": "prefer"
            }

        try:
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(default_config, f, indent=4, ensure_ascii=False)
            print(f"SUCCESS: Default 'config.json' created at {config_path}")
            return True
        except Exception as e:
            print(f"ERROR: Could not create default 'config.json'. Reason: {e}")
            raise IOError(f"قادر به ساخت فایل تنظیمات در مسیر {config_path} نیست. لطفاً دسترسی‌ها را بررسی کنید.") from e

    return False
            
from dateutil.parser import parse, ParserError
import jdatetime as jd
import datetime as dt

# این تابع را به طور کامل با نسخه فعلی جایگزین کنید
def to_shamsi(date_input, include_time=False) -> str:
    """
    نسخه نهایی و کامل: تاریخ میلادی را به شمسی تبدیل می‌کند.
    - از dateutil.parser برای تشخیص هوشمند فرمت‌های مختلف تاریخ استفاده می‌کند.
    - با پارامتر include_time، نمایش زمان را کنترل می‌کند.
    """
    if not date_input:
        return ''

    try:
        # اگر ورودی از قبل یک شیء datetime معتبر پایتون بود
        if isinstance(date_input, (dt.datetime, dt.date)):
            dt_g = date_input
        # در غیر این صورت، آن را به عنوان رشته در نظر گرفته و با parse به صورت هوشمند تبدیلش کن
        else:
            from dateutil.parser import parse, ParserError
            dt_g = parse(str(date_input))

        # حالا که شیء datetime را داریم، آن را به شمسی تبدیل می‌کنیم
        if isinstance(dt_g, dt.datetime):
            dt_j = jd.datetime.fromgregorian(datetime=dt_g)
            # اگر زمان خواسته شده بود، آن را نمایش بده
            if include_time:
                return dt_j.strftime('%Y/%m/%d - %H:%M')
            return dt_j.strftime('%Y/%m/%d')
        elif isinstance(dt_g, dt.date):
            # اگر ورودی فقط تاریخ بود، زمان ندارد
            dt_j = jd.date.fromgregorian(date=dt_g)
            return dt_j.strftime('%Y/%m/%d')
        else:
            return ''

    except (ValueError, TypeError, NameError, ImportError) as e:
        # NameError و ImportError برای زمانی است که dateutil نصب نیست
        print(f"WARNING: Could not convert '{date_input}' to Shamsi date. Error: {e}")
        return ''
        
# این تابع جدید را بالای فایل، کنار تابع to_shamsi اضافه کن
def shamsi_to_gregorian(shamsi_date_str: str) -> dt.date | None:
    """
    یک رشته تاریخ شمسی را به شیء تاریخ میلادی تبدیل می‌کند.
    در صورت نامعتبر بودن ورودی، None برمی‌گرداند.
    """
    if not shamsi_date_str or '_' in shamsi_date_str:
        return None
    try:
        parts = shamsi_date_str.split('/')
        if len(parts) == 3:
            y, m, d = map(int, parts)
            return jd.date(y, m, d).togregorian()
    except (ValueError, TypeError):
        return None
    return None
    
                        
def export_table_to_excel(widget: QtWidgets.QWidget, parent):
    """
    نسخه نهایی و یکپارچه:
    محتوای یک ویجت (جدول یا درخت) را به صورت هوشمند استخراج کرده و به یک فایل اکسل زیبا صادر می‌کند.
    این تابع تمام مراحل از جمله استایل‌دهی را مدیریت می‌کند.
    """
    path, _ = QtWidgets.QFileDialog.getSaveFileName(
        parent, 'ذخیره خروجی اکسل', 'Report.xlsx', 'Excel (*.xlsx)')
    if not path:
        return

    headers = []
    data = []

    try:
        if isinstance(widget, QtWidgets.QTableWidget):
            table = widget
            headers = [table.horizontalHeaderItem(c).text() for c in range(table.columnCount()) if not table.isColumnHidden(c)]
            for r in range(table.rowCount()):
                if table.isRowHidden(r): continue
                row = []
                for c in range(table.columnCount()):
                    if not table.isColumnHidden(c):
                        if table.cellWidget(r, c):
                            row.append('')
                        else:
                            cell = table.item(r, c)
                            row.append(cell.text() if cell else '')
                data.append(row)

        elif isinstance(widget, QtWidgets.QTreeWidget):
            tree = widget
            headers = [tree.headerItem().text(i) for i in range(tree.columnCount())]
            iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()
                if not item.isHidden():
                    row_data = [item.text(i) for i in range(tree.columnCount())]
                    if item.parent():
                        row_data[0] = "    " + row_data[0]
                    elif data:
                        data.append([''] * len(headers))
                    data.append(row_data)
                iterator += 1
        else:
            parent.toast.show_message("این ویجت برای خروجی اکسل پشتیبانی نمی‌شود.", "error")
            return

        if not data:
            parent.toast.show_message("داده‌ای برای خروجی گرفتن وجود ندارد.", "warning")
            return

        df = pd.DataFrame(data, columns=headers)
        
        # --- بخش استایل‌دهی (ادغام شده از تابع حذف شده) ---
        from openpyxl.styles import Font, Alignment, PatternFill
        from openpyxl.utils import get_column_letter

        with pd.ExcelWriter(path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name="Report", index=False, startrow=1)
            
            workbook = writer.book
            worksheet = writer.sheets["Report"]

            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            center_align = Alignment(horizontal='center', vertical='center')

            for col_num, value in enumerate(df.columns.values, 1):
                cell = worksheet.cell(row=2, column=col_num)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = center_align

            for col_num, column_cells in enumerate(worksheet.columns, 1):
                max_length = max(len(str(cell.value or '')) for cell in column_cells)
                adjusted_width = (max_length + 2)
                worksheet.column_dimensions[get_column_letter(col_num)].width = adjusted_width

            worksheet.sheet_view.rightToLeft = True
            worksheet.freeze_panes = 'A3'

        if hasattr(parent, 'toast'):
            parent.toast.show_message(f'✔ گزارش با موفقیت در فایل اکسل ذخیره شد.', 'success')

    except ImportError:
        QtWidgets.QMessageBox.critical(parent, "خطای کتابخانه", "برای ایجاد گزارش حرفه‌ای، لطفاً کتابخانه‌های `pandas` و `openpyxl` را نصب کنید.")
    except Exception as e:
        QtWidgets.QMessageBox.critical(parent, "خطای پیش‌بینی نشده", f"یک خطای ناشناخته در هنگام ایجاد گزارش اکسل رخ داد: {e}")
        print(traceback.format_exc())

# این تابع را با نسخه نهایی و خلاصه‌ شده زیر جایگزین کنید

def add_filter_export_tools(target_widget, layout: QtWidgets.QVBoxLayout, custom_filter_dialog_class=None, quick_filter_widget: QtWidgets.QLineEdit = None):
    """
    نسخه نهایی و یکپارچه:
    - نوار وضعیت فیلتر را هم برای فیلتر پیشرفته و هم برای جستجوی سریع (در صورت ارائه) نمایش می‌دهد.
    """
    tool_widget = QtWidgets.QWidget()
    tool_layout = QtWidgets.QHBoxLayout(tool_widget)
    tool_layout.setContentsMargins(0, 5, 0, 8)

    btn_filter = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), " فیلتر پیشرفته")
    btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل")

    tool_layout.addStretch()
    tool_layout.addWidget(btn_filter)
    tool_layout.addWidget(btn_export)
    layout.insertWidget(0, tool_widget)

    filter_status_widget = QtWidgets.QFrame(); filter_status_widget.setObjectName("filterStatus"); filter_status_widget.hide()
    filter_status_layout = QtWidgets.QHBoxLayout(filter_status_widget); filter_status_layout.setContentsMargins(10, 5, 10, 5)
    filter_status_icon = QtWidgets.QLabel("ℹ️"); filter_status_label = QtWidgets.QLabel("")
    filter_status_layout.addWidget(filter_status_icon); filter_status_layout.addWidget(filter_status_label, 1)
    btn_clear_quick = QtWidgets.QPushButton("حذف فیلترها"); btn_clear_quick.setProperty("class", "danger")
    filter_status_layout.addWidget(btn_clear_quick)
    filter_status_widget.setStyleSheet("#filterStatus { background-color: #e7f1ff; border: 1px solid #b3d1ff; border-radius: 4px; }")
    layout.insertWidget(1, filter_status_widget)

    def get_active_widget():
        if hasattr(target_widget, 'currentWidget'): return target_widget.currentWidget()
        return target_widget

    def update_filter_status():
        table = get_active_widget()
        total_items = 0; visible_items = 0
        
        # --- *** بخش اصلاح شده برای تشخیص نوع فیلتر *** ---
        is_advanced_filtered = hasattr(table, '_active_filters') and table._active_filters
        is_quick_filtered = quick_filter_widget and quick_filter_widget.text().strip()
        is_filtered = is_advanced_filtered or is_quick_filtered
        # --- ****************************************** ---

        if isinstance(table, QtWidgets.QTableWidget):
            total_items = table.rowCount()
            if total_items > 0:
                visible_items = total_items - sum(1 for r in range(total_items) if table.isRowHidden(r))
        elif isinstance(table, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value():
                if iterator.value().parent():
                    total_items += 1
                    if not iterator.value().isHidden(): visible_items += 1
                iterator += 1
        
        if is_filtered:
            filter_type_text = "فیلتر پیشرفته" if is_advanced_filtered else "جستجوی سریع"
            filter_status_label.setText(f"<b>{filter_type_text} فعال است:</b> نمایش {visible_items} از {total_items} رکورد.")
            filter_status_widget.show()
        else:
            filter_status_widget.hide()

    def open_filter_dialog():
        active_widget = get_active_widget()
        dlg_class = custom_filter_dialog_class or FilterDialog
        dlg = dlg_class(active_widget, active_widget.parent(), on_finish=update_filter_status)
        dlg.exec_()

    def reset_all_filters():
        table = get_active_widget()
        if hasattr(table, '_active_filters'): table._active_filters = []
        if quick_filter_widget: quick_filter_widget.clear() # این خط فیلتر سریع را هم پاک می‌کند
        
        if isinstance(table, QtWidgets.QTableWidget):
            for r in range(table.rowCount()): table.setRowHidden(r, False)
        elif isinstance(table, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value(): iterator.value().setHidden(False); iterator += 1
        update_filter_status()

    btn_filter.clicked.connect(open_filter_dialog)
    btn_export.clicked.connect(lambda: export_table_to_excel(get_active_widget(), get_active_widget().parent()))
    btn_clear_quick.clicked.connect(reset_all_filters)
    
    # --- *** اتصال سیگنال ویجت جستجوی سریع (در صورت وجود) *** ---
    if quick_filter_widget:
        quick_filter_widget.textChanged.connect(update_filter_status)                
    

# این نسخه نهایی و صحیح تابع اسکن است که باید در برنامه شما قرار گیرد
def scan_document(parent_widget=None):
    try:
        import win32com.client
        import pythoncom
        import tempfile
        import time
    except ImportError:
        QtWidgets.QMessageBox.critical(parent_widget, "خطا", "کتابخانه pywin32 نصب نیست. لطفا با دستور 'pip install pywin32' آن را نصب کنید.")
        return None

    pythoncom.CoInitialize()
    try:
        device_manager = win32com.client.Dispatch("WIA.DeviceManager")
        
        if device_manager.Devices.Count == 0:
            QtWidgets.QMessageBox.warning(parent_widget, "عدم وجود دستگاه", "هیچ دستگاه تصویربرداری (اسکنر یا دوربین) روی سیستم شما یافت نشد.")
            return None
            
        scanner_device = None
        devices = [d for d in device_manager.Devices if d.Type == 1]
        
        if not devices:
            QtWidgets.QMessageBox.warning(parent_widget, "عدم وجود اسکنر", "هیچ دستگاه اسکنری یافت نشد (ممکن است فقط دوربین متصل باشد).")
            return None
        
        if len(devices) == 1:
            scanner_device = devices[0]
        else:
            scanner_names = [d.Properties("Name").Value for d in devices]
            name, ok = QtWidgets.QInputDialog.getItem(parent_widget, "انتخاب اسکنر", "چندین اسکنر یافت شد، لطفا یکی را انتخاب کنید:", scanner_names, 0, False)
            if ok and name:
                for d in devices:
                    if d.Properties("Name").Value == name: scanner_device = d; break
            else: return None
        
        if not scanner_device: return None

        item = scanner_device.Items[0]
        image = item.Transfer()
        temp_filename = tempfile.gettempdir() + f"\\scan_{int(time.time())}.jpg"
        image.SaveFile(temp_filename)
        return temp_filename

    except Exception as e:
        if hasattr(e, 'excepinfo') and e.excepinfo and e.excepinfo[5] == -2145320829:
            print("User cancelled the scan operation.")
            return None
        else:
            print(f"An unexpected WIA error occurred: {e}")
            QtWidgets.QMessageBox.critical(parent_widget, "خطای اسکن", f"یک خطای پیش‌بینی نشده در هنگام اسکن رخ داد.\nمطمئن شوید اسکنر روشن و آماده به کار است.\n\n{e}")
            return None
    finally:
        pythoncom.CoUninitialize()
        
        
# این بلوک کد را جایگزین سه تابع مرتبط با پشتیبان‌گیری و بازیابی کنید

def _get_pg_common_args(config: dict) -> tuple:
    """
    (تابع کمکی جدید)
    پارامترهای اتصال و متغیرهای محیطی مشترک برای pg_dump و pg_restore را برمی‌گرداند.
    """
    db_name = config.get("dbname")
    user = config.get("user")
    password = config.get("password")
    host = config.get("host", "localhost")
    port = str(config.get("port", "5432"))

    if not all([db_name, user, password]):
        raise ValueError("اطلاعات اتصال به دیتابیس در فایل config.json ناقص است.")

    env = os.environ.copy()
    env['PGPASSWORD'] = password
    
    base_args = ["-U", user, "-h", host, "-p", port]
    
    return db_name, base_args, env

def backup_database(config: dict, backup_file_path: str):
    """
    نسخه بازنویسی شده: از تابع کمکی برای حذف کد تکراری استفاده می‌کند.
    """
    try:
        db_name, base_args, env = _get_pg_common_args(config)
        
        command = ["pg_dump", *base_args, "-F", "c", "--clean", "-f", backup_file_path, db_name]
        
        process = subprocess.Popen(command, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8')
        stdout, stderr = process.communicate()
        
        if process.returncode == 0:
            return True, f"✔ پشتیبان‌گیری کامل با موفقیت انجام شد."
        else:
            return False, f"خطا در پشتیبان‌گیری:\n{stderr}"
            
    except FileNotFoundError:
        return False, "خطا: دستور pg_dump یافت نشد.\nآیا PostgreSQL به درستی نصب شده و در PATH سیستم قرار دارد؟"
    except (ValueError, Exception) as e:
        return False, f"یک خطای پیش‌بینی نشده رخ داد: {e}"
        
def restore_database(config: dict, backup_file_path: str):
    """
    نسخه بازنویسی شده: از تابع کمکی برای حذف کد تکراری استفاده می‌کند.
    """
    try:
        db_name, base_args, env = _get_pg_common_args(config)

        command = ["pg_restore", *base_args, "-d", db_name, "--clean", "--if-exists", backup_file_path]

        process = subprocess.Popen(command, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8')
        stdout, stderr = process.communicate()

        if process.returncode == 0:
            return True, "✔ بازیابی اطلاعات با موفقیت کامل انجام شد."
        else:
            return False, f"فرآیند بازیابی با خطا مواجه شد:\n{stderr}"

    except FileNotFoundError:
        return False, "خطا: دستور pg_restore یافت نشد.\nآیا PostgreSQL به درستی نصب شده و در PATH سیستم قرار دارد؟"
    except (ValueError, Exception) as e:
        return False, f"یک خطای پیش‌بینی نشده در زمان بازیابی رخ داد: {e}"
        
# این تابع کاملا جدید را برای مدیریت متون ترکیبی اضافه کنید
def create_mixed_font_paragraph(text, base_style):
    """
    یک پاراگراف reportlab ایجاد می‌کند که قادر است متن‌های ترکیبی فارسی و انگلیسی را
    با فونت‌های مجزا به درستی نمایش دهد.
    """
    # --- *** اصلاح کلیدی: استفاده از کتابخانه استاندارد html *** ---
    import html
    import re
    from reportlab.platypus import Table, TableStyle, Paragraph

    font_fa = 'B-Nazanin'
    font_en = 'Helvetica'
    
    parts = re.split(r'([\u0600-\u06FF][\u0600-\u06FF\s\d]*)', text)
    
    processed_text = ""
    for part in parts:
        if not part: continue
        if re.search(r'[\u0600-\u06FF]', part):
            processed_text += f'<font name="{font_fa}">{get_display(reshape(part))}</font>'
        else:
            # --- استفاده از html.escape به جای escape از reportlab ---
            processed_text += f'<font name="{font_en}">{html.escape(part)}</font>'
            
    return Paragraph(processed_text, base_style)

    
# این تابع را به طور کامل با نسخه نهایی زیر جایگزین کنید
def create_invoice_pdf(invoice_data: dict, file_path: str):
    """
    با استفاده از reportlab، یک فایل PDF پیش فاکتور حرفه‌ای و فارسی تولید می‌کند.
    نسخه نهایی با چیدمان دینامیک و بدون تداخل.
    """
    import re
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import mm
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    from reportlab.platypus import Table, TableStyle, Paragraph
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_RIGHT, TA_LEFT

    font_name_fa = 'B-Nazanin'
    font_name_en = 'Helvetica'
    try:
        font_path = BASE_DIR / "BNazanin.ttf"
        if font_path.exists():
            pdfmetrics.registerFont(TTFont(font_name_fa, font_path))
        else:
            print(f"WARNING: '{font_path.name}' not found.")
    except Exception as e:
        print(f"ERROR: Could not load or register font '{font_name_fa}'. Reason: {e}")

    styles = getSampleStyleSheet()
    style_fa_right = ParagraphStyle(name='PersianRight', parent=styles['Normal'], fontName=font_name_fa, alignment=TA_RIGHT, fontSize=10, leading=14)
    style_fa_left = ParagraphStyle(name='PersianLeft', parent=styles['Normal'], fontName=font_name_fa, alignment=TA_LEFT, fontSize=10)
    style_en_center = ParagraphStyle(name='EnglishCenter', parent=styles['Normal'], fontName=font_name_en, alignment=TA_CENTER, fontSize=10)
    style_fa_header = ParagraphStyle(name='PersianHeader', parent=style_fa_right, textColor=colors.whitesmoke, alignment=TA_CENTER, fontSize=11)

    c = canvas.Canvas(file_path, pagesize=A4)
    width, height = A4

    def fa_text(text):
        return get_display(reshape(str(text)))

    c.setFont(font_name_fa, 20)
    c.drawCentredString(width / 2, height - 25 * mm, fa_text("پیش فاکتور"))

    cust_info = invoice_data['header']
    
    p_so_number = create_mixed_font_paragraph(f"شماره سفارش: {cust_info['so_number']}", style_fa_left)
    p_so_date = create_mixed_font_paragraph(f"تاریخ صدور: {to_shamsi(cust_info['issue_date'])}", style_fa_left)
    
    p_so_number.wrapOn(c, 100 * mm, 10 * mm); p_so_date.wrapOn(c, 100 * mm, 10 * mm)
    p_so_number.drawOn(c, 30 * mm, height - 40 * mm); p_so_date.drawOn(c, 30 * mm, height - 46 * mm)

    c.setFont(font_name_fa, 12); c.drawRightString(width - 30 * mm, height - 40 * mm, fa_text("مشخصات خریدار:"))
    c.setFont(font_name_fa, 10)
    c.drawRightString(width - 30 * mm, height - 48 * mm, fa_text(f"نام شرکت: {cust_info['customer_name']}"))
    c.drawRightString(width - 30 * mm, height - 54 * mm, fa_text(f"آدرس: {cust_info['address']}"))
    c.drawRightString(width - 30 * mm, height - 60 * mm, fa_text(f"تلفن: {cust_info['phone']}"))
    c.drawRightString(width - 30 * mm, height - 66 * mm, fa_text(f"کد اقتصادی: {cust_info['tax_id']}"))

    table_headers = [Paragraph(fa_text(h), style_fa_header) for h in ["قیمت کل", "قیمت واحد", "مقدار", "شرح کالا", "ردیف"]]
    table_data = [table_headers]
    
    total_amount = 0
    for i, item in enumerate(invoice_data['items']):
        total_price = item['quantity'] * item['unit_price']
        total_amount += total_price
        
        sku = item.get('sku', '')
        description_text = item['full_item_name']
        if sku:
            description_text += f"\n(SKU: {sku})"

        table_data.append([
            Paragraph(f"{total_price:,.0f}", style_en_center),
            Paragraph(f"{item['unit_price']:,.0f}", style_en_center),
            Paragraph(f"{item['quantity']:,}", style_en_center),
            create_mixed_font_paragraph(description_text, style_fa_right),
            Paragraph(str(i + 1), style_en_center)
        ])

    col_widths = [30*mm, 30*mm, 20*mm, 85*mm, 15*mm]
    table = Table(table_data, colWidths=col_widths)
    
    style = TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor("#4a6572")),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor("#f1f2f6")),
    ])
    table.setStyle(style)
    
    table_width = sum(col_widths)
    table_x_position = (width - table_width) / 2
    
    # --- *** اصلاح کلیدی اینجاست: محاسبه دینامیک موقعیت *** ---
    table_height = table.wrapOn(c, width - 40 * mm, height)[1]
    table_y_position = height - 80 * mm - table_height
    table.drawOn(c, table_x_position, table_y_position)

    total_box_width = 80 * mm
    total_box_height = 12 * mm
    total_box_x = table_x_position # هم‌راستا با شروع جدول
    # موقعیت باکس جمع کل، ۵ میلی‌متر پایین‌تر از انتهای جدول محاسبه می‌شود
    total_box_y = table_y_position - 5 * mm - total_box_height 
    # --- ****************************************************** ---

    c.setFillColor(colors.HexColor("#4a6572"))
    c.roundRect(total_box_x, total_box_y, total_box_width, total_box_height, 4, fill=1, stroke=0)
    
    c.setFont(font_name_fa, 12)
    c.setFillColor(colors.white)
    text_y_position = total_box_y + (total_box_height - (c._fontsize * 1.2)) / 2
    c.drawString(total_box_x + 5*mm, text_y_position, fa_text(f"جمع کل: {total_amount:,.0f} ریال"))

    c.save()
            
                    
SYSTEM_DATA_CATALOG = {
    "SALES": {
        "SO_NUMBER": "شماره سفارش فروش",
        "CUSTOMER_NAME": "نام مشتری",
        "CUSTOMER_ADDRESS": "آدرس مشتری",
        "CUSTOMER_TAX_ID": "کد اقتصادی مشتری",
        "SO_ITEMS_SUMMARY": "خلاصه کل اقلام سفارش"
    },
    # --- *** دسته جدید برای اطلاعات دقیق هر قلم کالا در سفارش فروش *** ---
    "SALES_ITEMS": {
        "SO_ITEM_NAME": "نام کالای فروخته شده",
        "SO_ITEM_QTY": "تعداد کالای فروخته شده",
        "SO_ITEM_PRICE": "قیمت واحد فروش"
    },
    "PURCHASING": {
        "PO_NUMBER": "شماره سفارش خرید",
        "SUPPLIER_NAME": "نام تامین‌کننده",
        "PR_ITEM_NAME": "نام کالای درخواستی",
        "PR_REQUESTED_QTY": "مقدار کالای درخواستی"
    },
    "PRODUCTION": {
        "PROD_BATCH_NO": "شماره بچ تولید",
        "PROD_PRODUCT_NAME": "نام محصول تولیدی",
        "PROD_QUANTITY": "مقدار تولید شده"
    }
}
        
from enum import Enum

# این کلاس را به طور کامل جایگزین نسخه قبلی کنید

class TransactionStatus(Enum):
    """
    مجموعه استاندارد و متمرکز وضعیت‌ها برای تمام فرآیندهای سیستم (نسخه نهایی و بدون تکرار).
    """
    # --- وضعیت‌های عمومی ---
    APPROVED = 'تایید شده'
    REJECTED = 'رد شده'
    VOIDED = 'باطل شده'
    CANCELLED = 'لغو شده'
    PENDING_APPROVAL = 'در انتظار تایید'
    PENDING_VOID_APPROVAL = 'در انتظار تایید ابطال'

    # --- چرخه درخواست خرید (Purchase Request) ---
    PR_CREATED = 'ایجاد شده'
    PR_AWAITING_MANAGER = 'در انتظار تایید مدیر واحد'
    PR_AWAITING_CEO = 'در انتظار تایید مدیرعامل'
    PR_CEO_APPROVED = 'تایید شده توسط مدیرعامل'
    PR_CEO_REJECTED = 'رد شده توسط مدیرعامل'
    PR_SUPPLIER_SELECTED = 'تامین‌کننده انتخاب شد'
    PR_ORDERED = 'سفارش خرید صادر شد'
    PR_ASSIGNED_TO_AGENT = 'ارجاع به کارپرداز'
    PR_COMPLETED = 'تکمیل شده'
    
    # --- چرخه مواد اولیه تولید (Material Request to Production) ---
    MR_PENDING = 'در انتظار رسیدگی انبار'
    MR_FULFILLED = 'ارسال شده به تولید'
    MR_REJECTED_BY_WAREHOUSE = 'رد شده توسط انبار'
    MR_REWORK_WAREHOUSE = 'نیازمند بازبینی انبار'
    PENDING_PRODUCTION_APPROVAL = 'در انتظار تایید تولید'
    MR_DELIVERED_TO_PROD = 'تحویل شده به تولید'

    # --- چرخه تحویل محصول از تولید (Production Delivery) ---
    PENDING_WAREHOUSE_APPROVAL = 'در انتظار تایید انبار'

    # --- چرخه درخواست داخلی (Internal Request from other Depts) ---
    IR_PENDING_FULFILLMENT = 'در انتظار رسیدگی انبار'
    IR_PENDING_PURCHASE = 'نیازمند تامین کالا'
    IR_FULFILLED = 'تحویل شده به واحد'
    IR_REJECTED = 'رد شده توسط انبار'
    
    # --- وضعیت‌های موجودی انبار (Stock Statuses) ---
    STOCK_AVAILABLE = 'موجود'
    STOCK_QUARANTINED = 'قرنطینه'
    STOCK_REJECTED = 'رد شده'

    # --- وضعیت‌های عمومی فرآیند (Workflow & Production) ---
    PRODUCED = 'تولید شده'
    CONSUMED = 'مصرف شده'
    WF_DRAFT = 'DRAFT'
    PI_IN_PROGRESS = 'IN_PROGRESS'
        
    def __str__(self):
        return self.value
                    
# <<< IMPROVEMENT
class MatplotlibConfig:
    """
    پیکربندی امن و یک‌بارهٔ matplotlib برای فونت فارسی و rcParams.
    این کلاس امکان چندبار صدا زدن را بدون اثر جانبی می‌دهد (idempotent).
    """
    _configured = False
    _chosen_font = None  # 'B Nazanin' یا 'Tahoma'

    @classmethod
    def ensure(cls):
        if cls._configured:
            return

        from pathlib import Path
        import matplotlib as mpl
        import matplotlib.font_manager as fm

        this_dir = Path(__file__).resolve().parent

        # 1) تلاش برای بارگذاری فونت محلی (سازگار با ساختار فعلی پروژه)
        local_candidates = ('BNazanin.ttf', 'B Nazanin.ttf', 'BTitr.ttf', 'B Titr.ttf')
        found_any = False
        for fn in local_candidates:
            fp = this_dir / fn
            if fp.exists():
                try:
                    fm.fontManager.addfont(str(fp))
                    found_any = True
                except Exception:
                    pass

        # 2) انتخاب خانواده‌ی پیش‌فرض (ترجیح BNazanin اگر موجود بود)
        cls._chosen_font = "B Nazanin" if any(
            n for n in ["B Nazanin", "BNazanin"] if n in [f.name for f in fm.fontManager.ttflist]
        ) else "Tahoma"

        # 3) rcParams یک‌دست
        try:
            mpl.rcParams['font.family'] = 'sans-serif'
            mpl.rcParams['font.sans-serif'] = [cls._chosen_font, 'Tahoma']
            # سایز کلیِ نمودارها (با UI تداخل نداره)
            mpl.rcParams['font.size'] = 12
            mpl.rcParams['axes.unicode_minus'] = False
        except Exception:
            # اگر به هر دلیل نشد، لااقل منفی درست نمایش داده بشه
            mpl.rcParams['axes.unicode_minus'] = False

        # پرچم نهایی
        cls._configured = True

# کل کلاس FilterDialog را با این نسخه نهایی جایگزین کنید
class FilterDialog(QtWidgets.QDialog):
    """
    نسخه نهایی:
    - پس از اعمال یا ریست فیلتر، یک تابع callback را برای به‌روزرسانی نوار وضعیت فراخوانی می‌کند.
    """
    # ... (بخش OPS و متدهای استاتیک بدون تغییر باقی می‌مانند) ...
    @staticmethod
    def _to_num(s: str):
        try: return float(str(s).replace(',', ''))
        except: return float('nan')

    # در کلاس FilterDialog

    # --- REPLACE this static method in FilterDialog ---
    @staticmethod
    def _to_date(s: str):
        try:
            import re  # ensure available even if module-level import changes
            s_cleaned = str(s).strip().split(' ')[0]
            if not s_cleaned or '_' in s_cleaned:
                return None
            parts = re.split(r'[/.\-]', s_cleaned)
            if len(parts) == 3:
                return jd.date(int(parts[0]), int(parts[1]), int(parts[2]))
        except (ValueError, TypeError, AttributeError):
            return None
        return None
    # --- اصلاح: تابع on_finish را به عنوان ورودی می‌پذیرد ---
    def __init__(self, table, parent=None, on_finish=None):
        super().__init__(parent)
        self.tbl = table
        self.on_finish = on_finish # ذخیره تابع callback
        self.setWindowTitle('فیلتر پیشرفته')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(450, 350)

        v_layout = QtWidgets.QVBoxLayout(self); self.lst_filters = QtWidgets.QListWidget(); v_layout.addWidget(self.lst_filters, 1); grid = QtWidgets.QGridLayout(); grid.setSpacing(10); self.c_col = QtWidgets.QComboBox(); self.c_op = QtWidgets.QComboBox(); self.e_val = QtWidgets.QLineEdit(); btn_add = QtWidgets.QPushButton("افزودن شرط ➕"); grid.addWidget(QtWidgets.QLabel("ستون:"), 0, 0); grid.addWidget(self.c_col, 0, 1); grid.addWidget(QtWidgets.QLabel("شرط:"), 1, 0); grid.addWidget(self.c_op, 1, 1); grid.addWidget(QtWidgets.QLabel("مقدار:"), 2, 0); grid.addWidget(self.e_val, 2, 1); grid.addWidget(btn_add, 3, 0, 1, 2); v_layout.addLayout(grid); btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Reset | QtWidgets.QDialogButtonBox.Close); btns.button(QtWidgets.QDialogButtonBox.Ok).setText("اعمال فیلتر"); btns.button(QtWidgets.QDialogButtonBox.Reset).setText("حذف همه شرط‌ها"); v_layout.addWidget(btns)

        self.header_map = {}
        headers = []
        if isinstance(self.tbl, QtWidgets.QTableWidget):
            for i in range(self.tbl.columnCount()):
                if not self.tbl.isColumnHidden(i) and self.tbl.horizontalHeaderItem(i):
                    header_text = self.tbl.horizontalHeaderItem(i).text()
                    headers.append(header_text)
                    self.header_map[header_text] = i
        elif isinstance(self.tbl, QtWidgets.QTreeWidget):
            headers = [self.tbl.headerItem().text(i) for i in range(self.tbl.columnCount())]
            for i, header_text in enumerate(headers): self.header_map[header_text] = i

        self.c_col.addItems(headers)
        if hasattr(self.tbl, '_active_filters'):
            for f in self.tbl._active_filters: self._re_add_cond(f['name'], f['op_key'], f['val'])

        self.c_col.currentIndexChanged.connect(self._update_operators); btn_add.clicked.connect(self._add_cond); btns.accepted.connect(self.apply_filter); btns.button(QtWidgets.QDialogButtonBox.Reset).clicked.connect(self.reset_filter); btns.rejected.connect(self.close); self._update_operators()
    # ... (متدهای _re_add_cond, _update_operators, _add_cond بدون تغییر) ...
    def _re_add_cond(self, col_name, op_key, val): # ... (بدون تغییر)
        item = QtWidgets.QListWidgetItem(f"«{col_name}» {op_key} «{val}»"); real_col_index = self.header_map.get(col_name)
        if real_col_index is not None: item.setData(Qt.UserRole, (real_col_index, op_key, val)); self.lst_filters.addItem(item)
    def _update_operators(self): # ... (بدون تغییر)
        self.c_op.clear(); selected_column = self.c_col.currentText().lower()
        if 'تاریخ' in selected_column: self.c_op.addItems(['از تاریخ', 'تا تاریخ', 'برابر با']); self.e_val.setInputMask("0000/00/00;_")
        else: self.c_op.addItems(['شامل', 'برابر با', 'بزرگتر از', 'کوچکتر از', 'بزرگتر مساوی', 'کوچکتر مساوی']); self.e_val.setInputMask("")
    def _add_cond(self): # ... (بدون تغییر)
        col_name = self.c_col.currentText(); op_key = self.c_op.currentText(); val = self.e_val.text().strip()
        if not val: return
        self._re_add_cond(col_name, op_key, val); self.e_val.clear()

    # BEGIN REWRITE: FilterDialog.apply_filter
    def apply_filter(self):
        """
        اعمال فیلتر روی Table/Tree به‌صورت خودکار با تشخیص ساختار:
        - اگر مقصد Table باشد، روی همه‌ی ردیف‌ها اعمال می‌شود.
        - اگر Tree باشد:
            * اگر درخت سلسله‌مراتبی است: ابتدا روی برگ‌ها (آیتم‌های بدون فرزند) اعمال می‌شود
            و سپس از پایین به بالا والدهایی که هیچ فرزندِ مرئی ندارند و خودشان هم منطبق نیستند، پنهان می‌شوند.
            * اگر تخت باشد (فقط آیتم‌های سطح اول): مستقیم روی همان‌ها اعمال می‌شود.
        """
        from PyQt5 import QtWidgets
        from PyQt5.QtCore import Qt
        import math

        # --- helpers ---
        def _s(txt):     return str(txt).strip()
        def _sl(txt):    return _s(txt).lower()
        def _cmp_num(a, b, op):
            try:
                na = self._to_num(a); nb = self._to_num(b)
                if math.isnan(na) or math.isnan(nb): return False
                return op(na, nb)
            except Exception:
                return False
        def _cmp_date(a, b, op):
            da = self._to_date(a); db = self._to_date(b)
            if da is None or db is None:
                return op(_s(a), _s(b))
            return op(da, db)
        def _depth(it):
            d = 0; p = it.parent()
            while p is not None: d += 1; p = p.parent()
            return d

        # نگاشت عملگرها (محلی؛ وابسته به self.OPS نیست)
        OPS_MAP = {
            # متنی
            'شامل':             lambda cell, val: _sl(val) in _sl(cell),
            'برابر با':         lambda cell, val: _s(cell) == _s(val),
            'شروع با':          lambda cell, val: _sl(cell).startswith(_sl(val)),
            'پایان با':         lambda cell, val: _sl(cell).endswith(_sl(val)),
            # عددی
            'بزرگتر از':        lambda cell, val: _cmp_num(cell, val, lambda a,b: a >  b),
            'بزرگتر مساوی':     lambda cell, val: _cmp_num(cell, val, lambda a,b: a >= b),
            'کوچکتر از':        lambda cell, val: _cmp_num(cell, val, lambda a,b: a <  b),
            'کوچکتر مساوی':     lambda cell, val: _cmp_num(cell, val, lambda a,b: a <= b),
            # تاریخی
            'از تاریخ':         lambda cell, val: _cmp_date(cell, val, lambda a,b: a >= b),
            'تا تاریخ':         lambda cell, val: _cmp_date(cell, val, lambda a,b: a <= b),
            'برابر با تاریخ':   lambda cell, val: _cmp_date(cell, val, lambda a,b: a == b),
        }

        # تصمیم عملگر تاریخی/متنی بر اساس نام ستون
        def _resolve_op(op_key, col_name):
            if ('تاریخ' in str(col_name)) and (op_key == 'برابر با'):
                return OPS_MAP['برابر با تاریخ']
            return OPS_MAP.get(op_key, OPS_MAP['برابر با'])

        # --- جمع‌آوری شرط‌ها از UI ---
        conditions = []
        active_filters_to_save = []
        for i in range(self.lst_filters.count()):
            real_col_idx, op_key, val = self.lst_filters.item(i).data(Qt.UserRole)
            col_name = next((name for name, idx in self.header_map.items() if idx == real_col_idx), None)
            op_func = _resolve_op(op_key, col_name)
            conditions.append({'col': int(real_col_idx), 'op': op_func, 'val': val})
            if col_name:
                active_filters_to_save.append({'name': col_name, 'op_key': op_key, 'val': val})

        # نگهداری وضعیت فیلتر فعال روی ویجت هدف
        try: self.tbl._active_filters = active_filters_to_save
        except Exception: pass

        # اگر شرطی نیست → ریست و خروج
        if not conditions:
            self._reset_widget_filter()
            if self.on_finish:
                try: self.on_finish()
                except Exception: pass
            self.close()
            return

        # --- Table ---
        if isinstance(self.tbl, QtWidgets.QTableWidget):
            for r in range(self.tbl.rowCount()):
                ok = all(self._check_match_table(self.tbl.item(r, c['col']), c['op'], c['val']) for c in conditions)
                self.tbl.setRowHidden(r, not ok)

        # --- Tree ---
        elif isinstance(self.tbl, QtWidgets.QTreeWidget):
            root = self.tbl.invisibleRootItem()
            top_count = root.childCount()
            has_hierarchy = any(root.child(i).childCount() > 0 for i in range(top_count))

            # لیست همه آیتم‌ها و برگ‌ها
            all_items, leaves = [], []
            stack = [root.child(i) for i in range(top_count)]
            while stack:
                item = stack.pop()
                all_items.append(item)
                child_cnt = item.childCount()
                if child_cnt == 0:
                    leaves.append(item)
                else:
                    for j in range(child_cnt - 1, -1, -1):
                        stack.append(item.child(j))

            # اگر درخت تخت است، سطح اول‌ها را برگ در نظر بگیر
            if not has_hierarchy:
                leaves = [root.child(i) for i in range(top_count)]

            # 1) اعمال فیلتر روی برگ‌ها
            for leaf in leaves:
                ok = all(self._check_match_tree(leaf, c['col'], c['op'], c['val']) for c in conditions)
                leaf.setHidden(not ok)

            # 2) وضعیت انطباق خودِ والدها
            parent_match = {}
            for item in all_items:
                if item.childCount() > 0:
                    ok = all(self._check_match_tree(item, c['col'], c['op'], c['val']) for c in conditions)
                    parent_match[item] = ok

            # 3) از پایین به بالا: والد فقط وقتی پنهان شود که
            #    هیچ فرزند مرئی نداشته باشد و خودش هم منطبق نباشد.
            all_items_sorted = sorted(all_items, key=lambda it: _depth(it))
            for item in reversed(all_items_sorted):
                if item.childCount() > 0:
                    any_visible = any(not item.child(j).isHidden() for j in range(item.childCount()))
                    show_me = any_visible or parent_match.get(item, False)
                    item.setHidden(not show_me)

        # پایان
        if self.on_finish:
            try: self.on_finish()
            except Exception: pass
        self.close()
    # END REWRITE: FilterDialog.apply_filter

    def reset_filter(self):
        self.lst_filters.clear()
        if hasattr(self.tbl, '_active_filters'): self.tbl._active_filters = []
        self._reset_widget_filter()
        # --- اصلاح: فراخوانی callback پس از ریست فیلتر ---
        if self.on_finish: self.on_finish()

    def _reset_widget_filter(self): # ... (این متد و متدهای check_match بدون تغییر)
        if isinstance(self.tbl, QtWidgets.QTableWidget):
            for r in range(self.tbl.rowCount()): self.tbl.setRowHidden(r, False)
        elif isinstance(self.tbl, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(self.tbl, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value(): iterator.value().setHidden(False); iterator += 1
    def _check_match_table(self, item, func, value): # ...
        cell_text = item.text() if item else "";
        try: return func(cell_text, value)
        except: return False
    def _check_match_tree(self, item, col_idx, func, value): # ...
        cell_text = item.text(col_idx) if item else "";
        try: return func(cell_text, value)
        except: return False
            
                    
                                                        
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas
import matplotlib.pyplot as plt

# ─── ثبت فونت فارسی + تابع fa() (نسخه نهایی و پایدار) ──────────────────
from bidi.algorithm    import get_display
import matplotlib as mpl
import matplotlib.font_manager as fm
from pathlib import Path

_THIS_DIR = Path(__file__).resolve().parent

def fa(txt: str) -> str:
    """متن فارسی را برای نمایش صحیح در نمودارهای matplotlib آماده می‌کند."""
    return get_display(reshape(str(txt)))

# تلاش برای پیدا کردن و ثبت فونت فارسی از فایل محلی
font_path = _THIS_DIR / "BNazanin.ttf"
if font_path.exists():
    fm.fontManager.addfont(str(font_path))
    FONT_FAMILY_MATPLOTLIB = "B Nazanin"
    print("INFO: Local 'B Nazanin' font loaded for matplotlib.")
else:
    # اگر فونت محلی نبود، به فونت‌های سیستمی اکتفا می‌کنیم
    FONT_FAMILY_MATPLOTLIB = "Tahoma"
    print("WARNING: 'BNazanin.ttf' not found. Falling back to system's 'Tahoma' font for charts.")

mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = [FONT_FAMILY_MATPLOTLIB]
mpl.rcParams['axes.unicode_minus'] = False

# فایل‌های فونت قابل قبول
for fn in ('BNazanin.ttf', 'B Nazanin.ttf', 'BTitr.ttf', 'B Titr.ttf'):
    fp = _THIS_DIR / fn
    if fp.exists():
        fm.fontManager.addfont(str(fp))

mpl.rcParams['font.family']      = 'sans-serif'
mpl.rcParams['font.sans-serif']  = ['B Nazanin', 'Tahoma']   # fallback اگر نازنین نبود
mpl.rcParams['font.size']        = 12
mpl.rcParams['axes.unicode_minus'] = False                   # علامت منفی درست

FONT_FAMILY = 'B Nazanin'
FONT_SIZE   = 11
# ───── پالت رنگ سراسری
PRIMARY  = '#3949ab'
ERROR    = '#c62828'
WARNING  = '#f9a825'
SURFACE  = '#f5f5f5'

# فونت تیتر (اگر نصب نیست BYekan یا هر فونت تیتری فارسی انتخاب کن)
FONT_TITLE = 'B Titr'        # یا 'BTitr' بسته به سیستم

_hash = lambda s: hashlib.sha256(s.encode('utf-8')).hexdigest()

from typing import List
import pandas as pd       # فرض بر این‌که pandas نصب است

CATEGORY_FINAL_PRODUCT = 'محصول نهایی'
CATEGORY_RAW_MATERIAL  = 'مواد اولیه'
CATEGORY_PACKAGING     = 'لوازم بسته‌بندی' # <-- این خط جدید را اضافه کنید
CATEGORY_CONSUMABLES   = 'لوازم مصرفی و ابزارآلات' # <-- ثابت جدید
CATEGORY_BULK_PRODUCT = 'محصول فله'

# --- *** بخش جدید برای افزودن *** ---
PRODUCTION_WAREHOUSE_NAME = 'Production'
MAIN_WAREHOUSE_NAME = 'Main'

def export_transactions_of_items(db: 'DB', item_ids: List[int], path: str, parent):
    """
    نسخه نهایی (V10.2):
    - 'موجودی اولیه' به‌عنوان ورودی شناسایی می‌شود.
    - تراکنش‌هایی که در notes عبارت 'موجودی اولیه' دارند، در گزارش با همین عنوان نمایش داده می‌شوند.
    - باقی رفتارها و استایل اکسل بدون تغییر.
    """
    if not item_ids:
        QtWidgets.QMessageBox.information(parent, '', 'هیچ کالایی انتخاب نشده است')
        return
    
    if not path:
        return

    try:
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from openpyxl.utils import get_column_letter
        import pandas as pd
        import datetime

        sheets_to_write = []
        for item_id in item_ids:
            item_details = db.get_item_details(item_id)
            if not item_details:
                continue
            item_name = item_details.get('name', f"کالای {item_id}")

            q_trans = """
                SELECT 
                    t.*, 
                    u.username,
                    orig_trans.t_type as voided_t_type,
                    (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin) AS src_loc_full,
                    (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin) AS dst_loc_full
                FROM trans t
                LEFT JOIN users u ON u.id = t.user_id
                LEFT JOIN trans orig_trans ON t.voids_trans_id = orig_trans.id
                LEFT JOIN locations src_l ON t.src_loc = src_l.id
                LEFT JOIN warehouses src_w ON src_l.warehouse_id = src_w.id
                LEFT JOIN locations dst_l ON t.dest_loc = dst_l.id
                LEFT JOIN warehouses dst_w ON dst_l.warehouse_id = dst_w.id
                WHERE t.item_id = %s AND t.status IN ('تایید شده', 'باطل شده')
                ORDER BY t.t_date, t.id
            """
            all_transactions = db.execute_query(q_trans, (item_id,))
            transactions = [t for t in all_transactions if t.get('t_date')]
            if not transactions:
                continue

            report_data_list = []
            running_balance = 0

            for t in transactions:
                qty = t.get('qty', 0)
                t_type_raw = str(t.get('t_type', '') or '')
                notes_str = str(t.get('notes', '') or '')

                # نرمال‌سازی برچسب نمایش
                # - اگر t_type انگلیسیِ قدیمی بود یا در توضیحات «موجودی اولیه» داشت → برچسب نهایی = «موجودی اولیه»
                if t_type_raw in ('INITIAL_ENTRY', 'INITIAL ENTRY') or ('موجودی اولیه' in notes_str) or (t_type_raw == 'موجودی اولیه'):
                    t_type_disp = 'موجودی اولیه'
                else:
                    t_type_disp = t_type_raw

                in_qty, out_qty = 0, 0

                # تشخیص ورودی/خروجی
                if t_type_disp.startswith('ورود') \
                   or t_type_disp == 'موجودی اولیه' \
                   or t_type_disp == 'برگشت' \
                   or t_type_disp == 'اضافه شدنی انبارگردانی':
                    in_qty = abs(qty)

                elif t_type_disp.startswith('خروج') \
                     or t_type_disp == 'کسری انبارگردانی' \
                     or t_type_disp == 'ضایعات':
                    out_qty = abs(qty)

                elif t_type_disp.startswith('ابطال'):
                    original_type = str(t.get('voided_t_type', '') or '')
                    if original_type.startswith('خروج'):
                        in_qty = abs(qty)
                    else:
                        out_qty = abs(qty)

                elif t_type_disp == 'انتقال':
                    running_balance -= abs(qty)
                    report_data_list.append({
                        'تاریخ': to_shamsi(t.get('t_date')),
                        'نوع عملیات': 'خروج (انتقال)',
                        'ورودی': '',
                        'خروجی': abs(qty),
                        'موجودی لحظه‌ای': running_balance,
                        'توضیحات': f"به: {t.get('dst_loc_full', '')} (سند: {t.get('t_no', '')})"
                    })
                    running_balance += abs(qty)
                    report_data_list.append({
                        'تاریخ': to_shamsi(t.get('t_date')),
                        'نوع عملیات': 'ورود (انتقال)',
                        'ورودی': abs(qty),
                        'خروجی': '',
                        'موجودی لحظه‌ای': running_balance,
                        'توضیحات': f"از: {t.get('src_loc_full', '')} (سند: {t.get('t_no', '')})"
                    })
                    continue

                running_balance += (in_qty - out_qty)
                report_data_list.append({
                    'تاریخ': to_shamsi(t.get('t_date')),
                    'نوع عملیات': t_type_disp,  # برچسب نهایی
                    'ورودی': in_qty if in_qty else '',
                    'خروجی': out_qty if out_qty else '',
                    'موجودی لحظه‌ای': running_balance,
                    'توضیحات': f"{notes_str} (کاربر: {t.get('username', '')})"
                })

            if not report_data_list:
                continue

            final_df = pd.DataFrame(report_data_list, columns=['تاریخ', 'نوع عملیات', 'ورودی', 'خروجی', 'موجودی لحظه‌ای', 'توضیحات'])
            safe_sheet_name = item_name.replace('/', '-').replace('\\', '-').replace(':', '')[:30]
            sheets_to_write.append({'name': safe_sheet_name, 'data': final_df})

        if sheets_to_write:
            try:
                with pd.ExcelWriter(path, engine='openpyxl') as writer:
                    # استایل‌دهی اکسل (بدون تغییر نسبت به نسخه‌ی شما)
                    REPORT_FONT_NAME = 'Tahoma'; REPORT_FONT_SIZE = 11
                    default_font = Font(name=REPORT_FONT_NAME, size=REPORT_FONT_SIZE)
                    bold_font = Font(name=REPORT_FONT_NAME, size=REPORT_FONT_SIZE, bold=True)
                    title_font = Font(name=REPORT_FONT_NAME, size=16, bold=True, color="FFFFFF")
                    header_font = Font(name=REPORT_FONT_NAME, size=REPORT_FONT_SIZE, bold=True, color="FFFFFF")
                    timestamp_font = Font(name=REPORT_FONT_NAME, size=9, italic=True, color="7F7F7F")
                    center_align = Alignment(horizontal='center', vertical='center')
                    right_align = Alignment(horizontal='right', vertical='center')
                    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
                    title_fill = PatternFill(start_color="2F5597", fill_type="solid")
                    header_fill = PatternFill(start_color="4F81BD", fill_type="solid")
                    alternating_fill = PatternFill(start_color="F2F2F2", fill_type="solid")
                    positive_fill = PatternFill(start_color="E7F5E8", fill_type="solid")
                    negative_fill = PatternFill(start_color="FDEDED", fill_type="solid")

                    for sheet_info in sheets_to_write:
                        sheet_name = sheet_info['name']
                        df_for_excel = sheet_info['data']
                        worksheet = writer.book.create_sheet(title=sheet_name)
                        writer.sheets[sheet_name] = worksheet

                        headers = list(df_for_excel.columns)
                        worksheet.merge_cells(start_row=1, start_column=1, end_row=1, end_column=len(headers))
                        title_cell = worksheet.cell(row=1, column=1, value=f"کارتکس انبار: {sheet_name}")
                        title_cell.font = title_font; title_cell.fill = title_fill; title_cell.alignment = center_align

                        worksheet.append(headers)
                        for col_num, header_title in enumerate(headers, 1):
                            cell = worksheet.cell(row=2, column=col_num)
                            cell.font = header_font; cell.fill = header_fill; cell.alignment = center_align; cell.border = thin_border

                        for r_idx, record in enumerate(df_for_excel.itertuples(index=True), 3):
                            worksheet.append(list(record[1:]))
                            for c_idx, col_name in enumerate(headers, 1):
                                cell = worksheet.cell(row=r_idx, column=c_idx)
                                cell.font = default_font; cell.border = thin_border; cell.alignment = right_align
                                if (r_idx % 2) != 0: cell.fill = alternating_fill
                                if col_name == 'ورودی' and isinstance(cell.value, (int, float)) and cell.value > 0: cell.fill = positive_fill
                                if col_name == 'خروجی' and isinstance(cell.value, (int, float)) and cell.value > 0: cell.fill = negative_fill
                                if col_name == 'موجودی لحظه‌ای': cell.font = bold_font

                        from openpyxl.utils import get_column_letter
                        for qty_col_name in ['ورودی', 'خروجی', 'موجودی لحظه‌ای']:
                            try:
                                qty_col_index = headers.index(qty_col_name) + 1
                                qty_col_letter = get_column_letter(qty_col_index)
                                for cell in worksheet[qty_col_letter]:
                                    if isinstance(cell.value, (int, float)):
                                        cell.number_format = '#,##0.###;[Red]-#,##0.###;0'
                                        cell.alignment = center_align
                            except ValueError:
                                pass

                        for col_num, column_cells in enumerate(worksheet.columns, 1):
                            max_length = max(len(str(cell.value or '')) for cell in column_cells)
                            adjusted_width = (max_length + 2) * 1.2 if max_length < 40 else 50
                            worksheet.column_dimensions[get_column_letter(col_num)].width = adjusted_width

                        worksheet.sheet_view.rightToLeft = True
                        worksheet.freeze_panes = 'A3'
                        last_row = worksheet.max_row
                        from openpyxl.utils import get_column_letter as _gcl
                        timestamp_cell_range = f'A{last_row + 2}:{_gcl(len(headers))}{last_row + 2}'
                        worksheet.merge_cells(timestamp_cell_range)
                        now_shamsi = to_shamsi(datetime.datetime.now())
                        timestamp_cell = worksheet.cell(row=last_row + 2, column=1, value=f"گزارش تهیه شده در تاریخ {now_shamsi}")
                        timestamp_cell.font = timestamp_font; timestamp_cell.alignment = Alignment(horizontal='left', vertical='center')

                    if 'Sheet' in writer.book.sheetnames and len(writer.book.sheetnames) > 1:
                        del writer.book['Sheet']

                QtWidgets.QMessageBox.information(parent, 'عملیات موفق', f'✔ کارتکس هوشمند برای {len(sheets_to_write)} کالا در فایل اکسل ذخیره شد.')
            except PermissionError:
                from pathlib import Path
                QtWidgets.QMessageBox.critical(parent, "خطای دسترسی به فایل",
                    f"<b>امکان ذخیره فایل اکسل وجود ندارد.</b><br><br>"
                    f"احتمالاً فایل <code>{Path(path).name}</code> در حال حاضر در برنامه اکسل باز است. لطفاً آن را ببندید و دوباره امتحان کنید.")
        else:
            QtWidgets.QMessageBox.information(parent, 'اطلاعات ناکافی', 'هیچ تراکنشی برای کالاهای انتخاب شده یافت نشد تا گزارشی ایجاد شود.')

    except Exception as e:
        print(traceback.format_exc())
        QtWidgets.QMessageBox.critical(parent, "خطای پیش‌بینی نشده", f"یک خطای ناشناخته در هنگام ایجاد گزارش رخ داد: {e}")
    finally:
        QtWidgets.QApplication.restoreOverrideCursor()

import re, hashlib

_ALLOWED_EXTS = {"pdf", "png", "jpg", "jpeg", "webp"}
_MAX_FILE_BYTES_PER_ROW = 2 * 1024 * 1024       # ۲ مگابایت به‌ازای هر ردیف
_MAX_FILE_BYTES_PER_GROUP = 10 * 1024 * 1024    # ۱۰ مگابایت به‌ازای کل گروه


def _is_allowed_attachment(filename: str, size_bytes: int) -> tuple[bool, str]:
    """برمی‌گرداند (قبول/رد، پیام)."""
    if size_bytes is None:
        size_bytes = 0
    ext = (filename.rsplit('.', 1)[-1] if '.' in (filename or '') else '').lower()
    if ext not in _ALLOWED_EXTS:
        return False, "فقط فایل‌های pdf/png/jpg/jpeg/webp پذیرفته می‌شود."
    if size_bytes <= 0:
        return False, "حجم فایل صفر است یا خوانده نشد."
    if size_bytes > _MAX_FILE_BYTES_PER_ROW:
        return False, "حجم فایل بیش از حد مجازِ هر ردیف (۲MB) است."
    return True, ""
DEBUG_TRACE=True

def _trace_prod(obj, msg: str):
    if DEBUG_TRACE:
        try:
            print(f"[TRACE:PROD-CONV] {msg}")
        except Exception:
            pass


class TransactionType(Enum):
    """یک واژه‌نامه استاندارد و متمرکز برای تمام انواع تراکنش."""
    ENTRY = 'ورود'
    INITIAL_ENTRY = 'ورود اولیه'
    ENTRY_FROM_PROD = 'ورود از تولید'
    EXIT = 'خروج'
    EXIT_TO_PROD = 'خروج به تولید'
    EXIT_TO_LAB = 'خروج به آزمایشگاه' # <-- عضو جدید اضافه شد
    RETURN = 'برگشت'
    RETURN_FROM_PROD = 'برگشت از تولید'
    TRANSFER = 'انتقال'
    WASTE = 'ضایعات'
    INV_COUNT_ADD = 'اضافه شدنی انبارگردانی'
    INV_COUNT_SUB = 'کسری انبارگردانی'
    VOID_PREFIX = 'ابطال'

    def __str__(self):
        return self.value

        
# این کلاس جدید را برای اجرای عملیات در پس‌زمینه اضافه کنید
class RefreshWorker(QtCore.QObject):
    """
    یک Worker برای اجرای عملیات خواندن داده‌های اصلی برنامه در یک رشته مجزا.
    """
    finished = QtCore.pyqtSignal(dict)

# در کلاس RefreshWorker این دو متد را جایگزین کنید
    def __init__(self, db_instance: 'DB', user_id: int, user_role_id: int, permissions: set, role_name: str):
        super().__init__()
        self.db = db_instance
        self.user_id = user_id
        self.user_role_id = user_role_id
        self.permissions = permissions
        self.role_name = role_name # دریافت نقش کاربر

    def run(self):
        """این متد در رشته جدید اجرا خواهد شد و تمام داده‌ها را واکشی می‌کند."""
        results = {}
        try:
            # ارسال نقش کاربر به تابع اعلان‌ها
            results['actionable_notifications'] = self.db.get_actionable_notifications(self.permissions, self.user_id, self.role_name)
            
            results['kpi_stats'] = self.db.stats()
            results['min_alert'] = self.db.min_alert()
            results['exp_alert'] = self.db.exp_alert()
            results['category_value_stats'] = self.db.get_category_value_stats()
            results['last_cleared_trans_id'] = self.db.get_setting('last_cleared_trans_id', '0')
        except Exception as e:
            print(f"Error in RefreshWorker: {e}")
            traceback.print_exc()
        
        self.finished.emit(results)
                        
                                                                                                                                        
# این کلاس جدید را برای اجرای عملیات در پس‌زمینه اضافه کنید
class BackupWorker(QtCore.QObject):
    """
    یک Worker برای اجرای عملیات پشتیبان‌گیری در یک رشته مجزا.
    """
    # سیگنالی که نتیجه عملیات (بولین موفقیت و پیام متنی) را برمی‌گرداند
    finished = QtCore.pyqtSignal(bool, str)

    def __init__(self, config, backup_path):
        super().__init__()
        self.config = config
        self.backup_path = backup_path

    def run(self):
        """این متد در رشته جدید اجرا خواهد شد."""
        success, message = backup_database(self.config, self.backup_path)
        self.finished.emit(success, message)
        
# در بخش CONSTANTS، این کلاس جدید را اضافه کنید
class AssetStatus(Enum):
    IN_STOCK = 'در انبار'
    ASSIGNED = 'در اختیار پرسنل'
    OUT_FOR_REPAIR = 'خروج (تعمیرات)'
    OUT_FOR_PROJECT = 'خروج (پروژه)'
    SCRAPPED = 'اسقاط شده'
    DELIVERED = 'تحویل شده'
    

    
def setup_database(db_instance: 'DB'):
    """
    راه‌اندازی امن و ایدم‌پوتنت دیتابیس.
    - اگر schema_sql_path در db_instance.config ست شده باشد: فایل اسکیمای کامل (مثل base.sql) اجرا می‌شود،
      با فیلتر DROP/CREATE DATABASE و \connect.
    - در غیر این صورت: جداول پایه و conversion_* ساخته/بررسی می‌شوند.
    - ناسازگاری sequences(current/value) هندل می‌شود و get_next_seq روی value پیاده می‌شود.
    - همه چیز با لاگ کامل و کنترل خطا. هیچ چیزی پاک نمی‌شود.
    """

    import re
    import psycopg2
    import traceback
    from contextlib import contextmanager
    
    def _fetch_scalar(cur):
        """
        یک مقدار اسکالر از نتیجهٔ کوئری برمی‌دارد، چه DictRow باشد چه tuple.
        """
        row = cur.fetchone()
        if row is None:
            return None
        # اگر DictRow/Mapping بود
        if hasattr(row, "keys"):
            try:
                # اگر alias داده باشیم
                if "val" in row: 
                    return row["val"]
                if "has_tbl" in row:
                    return row["has_tbl"]
                if "cnt" in row:
                    return row["cnt"]
            except Exception:
                pass
            # اولین مقدار
            return next(iter(row.values()))
        # اگر tuple/list بود
        return row[0]


    @contextmanager
    def _cx():
        with db_instance._conn() as conn:
            with conn.cursor() as cur:
                yield conn, cur

    def _exec(conn, cur, sql, params=None, quiet=False, ignore_codes=()):
        """
        اجرای امن با لاگ کامل. اگر quiet=True یا کد خطا در ignore_codes بود، rollback و False برمی‌گرداند.
        در غیر این صورت خطا را بالا می‌دهد.
        """
        try:
            cur.execute(sql, params or ())
            return True
        except Exception as e:
            code = getattr(e, "pgcode", None)
            msg  = getattr(e, "pgerror", None) or str(e)
            tb   = traceback.format_exc()
            print(f"\n=== SQL ERROR ===\nCODE: {code}\nSQL : {sql}\nMSG : {msg}\nTRACE:\n{tb}\n=== END SQL ERROR ===\n")
            if quiet or (code and code in ignore_codes):
                conn.rollback()
                return False
            raise

    def _run_sql_file_filtered(path, conn, cur):
        """
        اجرای فایل اسکیمای کامل (pg_dump -s)، با حذف DROP/CREATE DATABASE و \connect.
        """
        with open(path, 'r', encoding='utf-8') as f:
            text = f.read()

        # حذف دستورات دیتابیس-لول و meta
        text = re.sub(r'(?mi)^\s*DROP\s+DATABASE\b.*?;', '', text)
        text = re.sub(r'(?mi)^\s*CREATE\s+DATABASE\b.*?;', '', text)
        text = re.sub(r'(?mi)^\s*\\connect\b.*$', '', text)

        statements = [s.strip() for s in text.split(';') if s.strip()]
        for stmt in statements:
            if re.match(r'(?mi)^(begin|commit)\b', stmt):
                continue
            # اجازه بده اگر «already exists» بود، رد شود
            ok = _exec(conn, cur, stmt + ';', ignore_codes=("42P06","42P07","42710","42P04","42723","23505"))
            if not ok:
                # دوباره تلاش نکن؛ ادامه بده
                continue

    # 0) پیش‌نیازها
    try:
        with _cx() as (conn, cur):
            _exec(conn, cur, "CREATE EXTENSION IF NOT EXISTS plpgsql;", quiet=True)
            _exec(conn, cur, "CREATE SCHEMA IF NOT EXISTS public;")
            _exec(conn, cur, "SET search_path = public;")
            conn.commit()
    except Exception as e:
        print(f"CRITICAL: preflight failed: {e}")
        raise

    # 1) اجرای فایل اسکیمای کامل (در صورت تنظیم)
    schema_path = None
    try:
        schema_path = (getattr(db_instance, 'config', {}) or {}).get('schema_sql_path')
    except Exception:
        schema_path = None

    if schema_path:
        print(f"INFO: Applying full schema from file: {schema_path}")
        try:
            with _cx() as (conn, cur):
                _run_sql_file_filtered(schema_path, conn, cur)
                conn.commit()
            print("SUCCESS: Full schema file applied (filtered).")
        except Exception as e:
            print(f"WARNING: Could not apply full schema file cleanly: {e}. Will continue with minimal DDL.")

    # 2) جداول پایه (حداقلی)
    table_creation_commands = [
        # warehouses, locations
        """CREATE TABLE IF NOT EXISTS warehouses(id SERIAL PRIMARY KEY, name TEXT UNIQUE);""",
        """CREATE TABLE IF NOT EXISTS locations(
               id SERIAL PRIMARY KEY,
               warehouse_id INTEGER REFERENCES warehouses(id) ON DELETE CASCADE,
               rack TEXT, shelf TEXT, bin TEXT,
               UNIQUE(warehouse_id, rack, shelf, bin));""",
        # roles, dashboards, permissions
        """CREATE TABLE IF NOT EXISTS roles(
               id SERIAL PRIMARY KEY,
               name TEXT UNIQUE NOT NULL,
               dashboard_type TEXT DEFAULT 'DEFAULT');""",
        """CREATE TABLE IF NOT EXISTS role_dashboards(
               role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
               dashboard_key TEXT NOT NULL,
               PRIMARY KEY(role_id, dashboard_key));""",
        """CREATE TABLE IF NOT EXISTS permissions(
               id SERIAL PRIMARY KEY, code TEXT UNIQUE NOT NULL, description TEXT);""",
        """CREATE TABLE IF NOT EXISTS role_permissions(
               role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
               permission_id INTEGER NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
               PRIMARY KEY(role_id, permission_id));""",
        # departments, users
        """CREATE TABLE IF NOT EXISTS departments(
               id SERIAL PRIMARY KEY,
               name TEXT UNIQUE NOT NULL,
               parent_id INTEGER REFERENCES departments(id) ON DELETE SET NULL,
               manager_user_id INTEGER,
               pos_x REAL, pos_y REAL);""",
        """CREATE TABLE IF NOT EXISTS users(
               id SERIAL PRIMARY KEY,
               username TEXT UNIQUE NOT NULL,
               passhash TEXT NOT NULL,
               role_id INTEGER REFERENCES roles(id) ON DELETE SET NULL,
               department_id INTEGER REFERENCES departments(id) ON DELETE SET NULL);""",
        # units, items, recipes
        """CREATE TABLE IF NOT EXISTS units (id SERIAL PRIMARY KEY, name TEXT UNIQUE NOT NULL, abbreviation TEXT);""",
        """CREATE TABLE IF NOT EXISTS items(
               id SERIAL PRIMARY KEY,
               name TEXT UNIQUE NOT NULL,
               category TEXT,
               unit_id INTEGER REFERENCES units(id) ON DELETE SET NULL,
               cost REAL DEFAULT 0.0, min_qty REAL DEFAULT 0.0, max_qty REAL DEFAULT 0.0,
               supplier TEXT, reporting_group TEXT, ent_date DATE, expiry_lead_days INTEGER DEFAULT 30,
               notes TEXT, default_loc INTEGER REFERENCES locations(id) ON DELETE SET NULL,
               is_packed BOOLEAN DEFAULT FALSE, sku TEXT UNIQUE,
               is_parent_product BOOLEAN DEFAULT FALSE, parent_item_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               net_weight REAL DEFAULT 0.0,
               requires_qc BOOLEAN DEFAULT TRUE,
               is_two_component BOOLEAN DEFAULT FALSE
        );""",
        """CREATE TABLE IF NOT EXISTS recipes(
               id SERIAL PRIMARY KEY,
               product_name TEXT NOT NULL,
               version INTEGER DEFAULT 1,
               status TEXT DEFAULT 'ACTIVE',
               properties JSONB,
               parent_product_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               produces_item_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               notes TEXT,
               created_by_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               created_at TIMESTAMPTZ DEFAULT NOW()
        );""",
        """CREATE TABLE IF NOT EXISTS recipe_ingredients(
               id SERIAL PRIMARY KEY,
               recipe_id INTEGER NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
               raw_material_item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
               percentage REAL NOT NULL DEFAULT 0,
               notes TEXT
        );""",
        # stock, trans
        """CREATE TABLE IF NOT EXISTS stock(
               id SERIAL PRIMARY KEY,
               item_id INTEGER REFERENCES items(id) ON DELETE CASCADE,
               location_id INTEGER REFERENCES locations(id) ON DELETE CASCADE,
               qty REAL, batch_no TEXT, expiry_date DATE,
               status TEXT DEFAULT 'AVAILABLE',
               UNIQUE(item_id, location_id, batch_no, expiry_date));""",
        """CREATE TABLE IF NOT EXISTS trans(
               id SERIAL PRIMARY KEY, item_id INTEGER REFERENCES items(id),
               t_type TEXT, t_no TEXT, t_date TIMESTAMPTZ,
               qty REAL, notes TEXT, user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               src_loc INTEGER, dest_loc INTEGER, voids_trans_id INTEGER DEFAULT NULL,
               status TEXT, attach_path TEXT, batch_no TEXT,
               approved_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
               approved_at TIMESTAMPTZ,
               expiry_date DATE);""",
        """CREATE TABLE IF NOT EXISTS trans_files(
               id SERIAL PRIMARY KEY,
               trans_id INTEGER NOT NULL REFERENCES trans(id) ON DELETE CASCADE,
               file_path TEXT NOT NULL,
               uploaded_at TIMESTAMPTZ DEFAULT NOW()
        );""",
        # audit + settings + forms
        """CREATE TABLE IF NOT EXISTS audit(
               id SERIAL PRIMARY KEY, stamp TIMESTAMPTZ,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               action TEXT, details TEXT);""",
        """CREATE TABLE IF NOT EXISTS app_settings(key TEXT PRIMARY KEY, value TEXT);""",
        """CREATE TABLE IF NOT EXISTS form_defs(
               id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL,
               created_at TIMESTAMPTZ DEFAULT NOW(), fields JSONB,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               form_type TEXT DEFAULT 'GENERAL', UNIQUE(name, user_id));""",
        """CREATE TABLE IF NOT EXISTS form_entries(
               id SERIAL PRIMARY KEY, form_id INTEGER NOT NULL REFERENCES form_defs(id) ON DELETE CASCADE,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               ts TIMESTAMPTZ DEFAULT NOW(), data JSONB);""",
        # suppliers
        """CREATE TABLE IF NOT EXISTS suppliers(
               id SERIAL PRIMARY KEY, name TEXT UNIQUE NOT NULL,
               contact_person TEXT, phone TEXT, email TEXT, address TEXT,
               economic_code TEXT, notes TEXT, is_active BOOLEAN DEFAULT TRUE,
               created_at TIMESTAMPTZ DEFAULT NOW());""",
        # assets
        """CREATE TABLE IF NOT EXISTS assets(
               id SERIAL PRIMARY KEY, code TEXT UNIQUE, name TEXT NOT NULL,
               category TEXT, location TEXT, status TEXT DEFAULT '');""",
        """CREATE TABLE IF NOT EXISTS asset_trans(
               id SERIAL PRIMARY KEY,
               asset_id INTEGER NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
               t_type TEXT NOT NULL,
               t_date TIMESTAMPTZ DEFAULT NOW(),
               t_no TEXT,
               notes TEXT,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL
        );""",
        """CREATE TABLE IF NOT EXISTS asset_trans_files(
               id SERIAL PRIMARY KEY,
               asset_trans_id INTEGER NOT NULL REFERENCES asset_trans(id) ON DELETE CASCADE,
               file_path TEXT NOT NULL,
               uploaded_at TIMESTAMPTZ DEFAULT NOW()
        );""",
        # material requests
        """CREATE TABLE IF NOT EXISTS material_requests(
               id SERIAL PRIMARY KEY,
               requester_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               requester_user_id INTEGER,
               item_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               requested_qty REAL NOT NULL DEFAULT 0,
               fulfilled_qty REAL NOT NULL DEFAULT 0,
               status TEXT NOT NULL,
               notes TEXT,
               parent_request_id INTEGER REFERENCES material_requests(id) ON DELETE SET NULL,
               created_at TIMESTAMPTZ DEFAULT NOW()
        );""",
        """CREATE TABLE IF NOT EXISTS material_request_items(
               id SERIAL PRIMARY KEY,
               request_id INTEGER NOT NULL REFERENCES material_requests(id) ON DELETE CASCADE,
               item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
               requested_qty REAL NOT NULL,
               approved_qty REAL DEFAULT 0,
               issued_qty REAL DEFAULT 0,
               notes TEXT
        );""",
        # sequences (حداقلی)
        """CREATE TABLE IF NOT EXISTS sequences(
            name TEXT PRIMARY KEY,
            current BIGINT NOT NULL DEFAULT 0,
            prefix TEXT,
            pad INTEGER NOT NULL DEFAULT 6
        );""",
        # conversion
        """CREATE TABLE IF NOT EXISTS conversion_patterns(
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            src_item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
            dest_item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
            ratio NUMERIC(18,6) NOT NULL DEFAULT 1.0,
            loss_percent NUMERIC(6,3) NOT NULL DEFAULT 0.0,
            notes TEXT,
            active BOOLEAN NOT NULL DEFAULT TRUE,
            created_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );""",
        """CREATE INDEX IF NOT EXISTS ix_convpat_src ON conversion_patterns(src_item_id);""",
        """CREATE INDEX IF NOT EXISTS ix_convpat_dest ON conversion_patterns(dest_item_id);""",
        """CREATE TABLE IF NOT EXISTS conversion_runs(
            id SERIAL PRIMARY KEY,
            pattern_id INTEGER REFERENCES conversion_patterns(id) ON DELETE SET NULL,
            src_trans_id INTEGER REFERENCES trans(id) ON DELETE SET NULL,
            dest_trans_id INTEGER REFERENCES trans(id) ON DELETE SET NULL,
            created_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
            amount_a NUMERIC(18,6) NOT NULL,
            amount_b NUMERIC(18,6) NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );""",
        """CREATE INDEX IF NOT EXISTS ix_convruns_pat ON conversion_runs(pattern_id);""",
        """CREATE INDEX IF NOT EXISTS ix_convruns_src ON conversion_runs(src_trans_id);""",
        """CREATE INDEX IF NOT EXISTS ix_convruns_dest ON conversion_runs(dest_trans_id);""",
    ]

    try:
        with _cx() as (conn, cur):
            print("INFO: (TX 1/3) Initializing base tables...")
            for command in table_creation_commands:
                _exec(conn, cur, command)
            conn.commit()
        print("SUCCESS: Base tables created/verified.")
    except Exception as e:
        print(f"CRITICAL ERROR during table creation: {e}")
        raise

    # 3) مهاجرت‌ها (با لاگ کامل) و ایمن‌سازی sequences/get_next_seq
    migrations = [
        ("ALTER TABLE stock ADD CONSTRAINT qty_must_be_non_negative CHECK (qty >= 0);", "non-negative stock qty"),
        ("ALTER TABLE users DROP COLUMN IF EXISTS department;", "drop obsolete users.department"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'موجود';", "stock.status default fa"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS entry_value REAL;", "stock.entry_value"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS source_po_item_id INTEGER REFERENCES purchase_order_items(id) ON DELETE SET NULL;", "stock.source_po_item_id"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;", "recipes.version"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'ACTIVE';", "recipes.status"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS properties JSONB;", "recipes.properties"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS parent_product_id INTEGER REFERENCES items(id) ON DELETE SET NULL;", "recipes.parent_product_id"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS produces_item_id INTEGER REFERENCES items(id) ON DELETE SET NULL;", "recipes.produces_item_id"),
        ("ALTER TABLE recipes DROP CONSTRAINT IF EXISTS recipes_product_name_key;", "drop old recipe unique"),
        ("DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='recipes_product_name_version_key') THEN ALTER TABLE recipes ADD CONSTRAINT recipes_product_name_version_key UNIQUE (product_name, version); END IF; END $$;", "recipes unique(name,version)"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS part_type TEXT;", "recipes.part_type"),
        ("UPDATE recipes SET part_type = 'MIX' WHERE part_type IS NULL;", "backfill recipes.part_type=MIX"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS yield_percentage REAL;", "recipes.yield_percentage"),
        ("ALTER TABLE items DROP CONSTRAINT IF EXISTS items_name_key;", "drop items unique(name)"),
        # دو ایندکس parent فقط اگر ستون وجود داشته باشد
        ("""
        DO $$
        BEGIN
          IF EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = current_schema()
              AND table_name = 'items'
              AND column_name = 'parent_item_id'
          ) THEN
            CREATE UNIQUE INDEX IF NOT EXISTS ux_items_name_global_when_no_parent
            ON items ( (LOWER(REPLACE(REPLACE(name, E'\u200c',''), ' ', ''))) )
            WHERE parent_item_id IS NULL;

            CREATE UNIQUE INDEX IF NOT EXISTS ux_items_name_per_parent
            ON items ( parent_item_id, (LOWER(REPLACE(REPLACE(name, E'\u200c',''), ' ', ''))) )
            WHERE parent_item_id IS NOT NULL;
          END IF;
        END $$;
        """, "ux items name guarded by column existence"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS brand TEXT;", "assets.brand"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS model TEXT;", "assets.model"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS serial_no TEXT;", "assets.serial_no"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS purchase_date DATE;", "assets.purchase_date"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS warranty_expiry DATE;", "assets.warranty_expiry"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS acquisition_cost REAL;", "assets.acquisition_cost"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS vendor TEXT;", "assets.vendor"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS depreciates BOOLEAN DEFAULT FALSE;", "assets.depreciates"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS depreciation_method TEXT DEFAULT 'STRAIGHT_LINE';", "assets.depreciation_method"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS useful_life_months INTEGER;", "assets.useful_life_months"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS residual_value REAL DEFAULT 0;", "assets.residual_value"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS notes TEXT;", "assets.notes"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS photo_path TEXT;", "assets.photo_path"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS assigned_to_user_id INTEGER REFERENCES users(id) ON DELETE SET NULL;", "assets.assigned_to_user_id"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS cost REAL;", "assets.cost"),
        ("UPDATE assets SET cost = acquisition_cost WHERE cost IS NULL AND acquisition_cost IS NOT NULL;", "backfill assets.cost"),
        ("CREATE INDEX IF NOT EXISTS ix_trans_files_trans ON trans_files(trans_id);", "ix trans_files.trans_id"),
        ("INSERT INTO app_settings(key, value) VALUES ('allow_quarantine_consumption','false') ON CONFLICT (key) DO NOTHING;", "policy quarantine consumption default"),
        ("INSERT INTO sequences(name) VALUES ('TRANS_DOC') ON CONFLICT (name) DO NOTHING;", "seed TRANS_DOC"),
    ]

    try:
        with _cx() as (conn, cur):
            print("INFO: (TX 2/3) Running database migrations...")
            for sql, desc in migrations:
                try:
                    _exec(conn, cur, sql)
                    conn.commit()
                    print(f"SUCCESS: Migration '{desc}' applied.")
                except (psycopg2.errors.DuplicateColumn,
                        psycopg2.errors.DuplicateObject,
                        psycopg2.errors.UndefinedColumn,
                        psycopg2.errors.DuplicateTable) as known_err:
                    conn.rollback()
                    print(f"INFO: Migration '{desc}' already applied or skipped: {known_err}")
                except psycopg2.Error as db_err:
                    conn.rollback()
                    print(f"WARNING: Non-critical migration error on '{desc}': {db_err}")

    except Exception as e:
        print(f"CRITICAL ERROR during migrations (loop): {e}")
        raise

    # 3.1) sequences compatibility + get_next_seq با لاگ کامل و محافظ
    print("INFO: sequences compatibility: start")
    try:
        with _cx() as (conn, cur):
            # وجود جدول sequences؟
            cur.execute("""
                SELECT EXISTS (
                SELECT 1
                FROM information_schema.tables
                WHERE table_schema = current_schema()
                    AND table_name = 'sequences'
                ) AS has_tbl;
            """)
            has_seq_tbl = _fetch_scalar(cur)
            if not has_seq_tbl:
                _exec(conn, cur, """
                    CREATE TABLE sequences(
                    name    TEXT PRIMARY KEY,
                    current BIGINT NOT NULL DEFAULT 0,
                    prefix  TEXT,
                    pad     INTEGER NOT NULL DEFAULT 6,
                    value   BIGINT NOT NULL DEFAULT 0
                    );
                """)
                conn.commit()
                print("INFO: created fresh sequences table.")

            # ستون value اگر نیست
            _exec(conn, cur, "ALTER TABLE sequences ADD COLUMN IF NOT EXISTS value BIGINT;", ignore_codes=("42701",))
            conn.commit()

            # سینک نال‌ها
            _exec(conn, cur, "UPDATE sequences SET value = COALESCE(value, current, 0) WHERE value IS NULL;")
            conn.commit()

            # اگر نال نداریم، NOT NULL کن
            cur.execute("SELECT COUNT(*) AS cnt FROM sequences WHERE value IS NULL;")
            nulls = _fetch_scalar(cur)
            if not nulls:
                _exec(conn, cur, "ALTER TABLE sequences ALTER COLUMN value SET NOT NULL;")
                conn.commit()
            else:
                print(f"WARNING: sequences.value still has {nulls} NULL rows; skipping NOT NULL for safety.")

            # تابع مبتنی بر value
            _exec(conn, cur, """
                CREATE OR REPLACE FUNCTION public.get_next_seq(seq_name text)
                RETURNS integer
                LANGUAGE plpgsql
                AS $$
                DECLARE next_val integer;
                BEGIN
                UPDATE sequences SET value = value + 1
                WHERE name = seq_name
                RETURNING value INTO next_val;

                IF next_val IS NULL THEN
                    INSERT INTO sequences(name, current, prefix, pad, value)
                    VALUES (seq_name, 0, NULL, 6, 1)
                    ON CONFLICT (name) DO NOTHING;

                    UPDATE sequences SET value = value + 1
                    WHERE name = seq_name
                    RETURNING value INTO next_val;
                END IF;

                RETURN next_val;
                END;
                $$;
            """)
            conn.commit()
            print("SUCCESS: sequences compatibility ensured and get_next_seq ready.")
    except Exception:
        import traceback
        print(f"\n=== SEQUENCES BLOCK FAILED ===\n{traceback.format_exc()}\n=== END ===\n")
        raise

    # 4) داده‌های اولیه
    try:
        with _cx() as (conn, cur):
            print("INFO: (TX 3/3) Seeding initial data...")
            db_instance._seed_initial_permissions_and_roles(cur)

            # انبارها و لوکیشن‌های حداقلی
            _exec(conn, cur, "INSERT INTO warehouses(name) VALUES ('Main') ON CONFLICT (name) DO NOTHING;")
            _exec(conn, cur,
                  "INSERT INTO locations(warehouse_id, rack, shelf, bin) "
                  "SELECT id, 'A','1','1' FROM warehouses WHERE name='Main' "
                  "ON CONFLICT DO NOTHING;")
            _exec(conn, cur, "INSERT INTO warehouses(name) VALUES ('Production') ON CONFLICT (name) DO NOTHING;")
            _exec(conn, cur,
                  "INSERT INTO locations(warehouse_id, rack, shelf, bin) "
                  "SELECT id, 'FLOOR','A','1' FROM warehouses WHERE name='Production' "
                  "ON CONFLICT DO NOTHING;")

            # تنظیمات پایه و واحدها
            _exec(conn, cur,
                  "INSERT INTO app_settings(key, value) VALUES ('last_cleared_trans_id', '0') "
                  "ON CONFLICT(key) DO NOTHING;")
            _exec(conn, cur,
                  "INSERT INTO units(name, abbreviation) VALUES "
                  "('عدد','Adad'), ('کیلوگرم','Kg'), ('گرم','g'), ('متر','m'), ('لیتر','L') "
                  "ON CONFLICT (name) DO NOTHING;")

            conn.commit()
        print("SUCCESS: Initial data seeded.")
    except Exception as e:
        print(f"CRITICAL ERROR during data seeding: {e}")
        raise

    print("INFO: Database initialization and migration complete.")
    

                
class DB:
    """PostgreSQL Wrapper با: Min/Max, Expiry, Users, AuditLog"""
# در کلاس DB، کل متد __init__ را با این نسخه جایگزین کنید

    def __init__(self, config: dict):
        """
        نسخه نهایی: در هنگام شروع، یک استخر اتصال (Connection Pool) ایجاد می‌کند.
        """
        if not config:
            raise ValueError("Configuration data is required to initialize the DB.")
        self.config = dict(config)
        self.signals = DBsignals()
        self._pool = None
        self._init_event_method_registry()
        self.compat_select_empty_none = False  # اگر True باشد، SELECT خالی => None برمی‌گردد (رفتار قدیم)

        self._search_path = self._normalize_search_path(self.config.get("search_path"))
        self._search_path_clause = None
        self._last_search_path = None
        self._conn_search_path = weakref.WeakKeyDictionary()
        self._conn_search_path_ids: dict[int, str] = {}
        self._use_conn_id_cache = False
        self._items_category_col: str | None = None
        self._items_category_source: str | None = None
        self._items_category_warned = False
        self._items_unit_col: str | None = None
        self._items_unit_source: str | None = None
        pool_config = dict(self.config)
        pool_config.pop("search_path", None)

        try:
            # ایجاد استخر اتصالات با حداقل 1 و حداکثر 10 اتصال همزمان
            self._pool = psycopg2.pool.SimpleConnectionPool(1, 10, **pool_config)
            print("SUCCESS: Database connection pool created.")
        except Exception as e:
            raise ConnectionError(f"Could not create connection pool. Please check config. Error: {e}")

        self._search_path_clause = self._prepare_search_path_clause(self._search_path)

        self.ensure_audit_log_schema() # <<< این خط را اضافه کنید
        self.ensure_conversion_schema()

    @contextmanager
    def _get_conn(self):
        """
        یک اتصال از استخر گرفته و پس از اتمام کار، آن را باز می‌گرداند.
        این متد جایگزین _conn() قبلی می‌شود.
        """
        if self._pool is None:
            raise ConnectionError("Connection pool is not available.")

        conn = None
        try:
            conn = self._pool.getconn()
            if conn is None:
                raise ConnectionError("Connection pool returned None connection.")
            self._ensure_session_settings(conn)
            yield conn
        finally:
            if conn:
                self._pool.putconn(conn)

    def _ensure_session_settings(self, conn):
        """
        اعمال تنظیمات سشن (فعلاً search_path) با کش داخلی برای هر اتصال.
        """
        target_clause = getattr(self, "_search_path_clause", None)
        if not target_clause:
            target_clause = self._prepare_search_path_clause(self._search_path)
            self._search_path_clause = target_clause

        cached_value = self._get_cached_search_path(conn)
        if cached_value == target_clause:
            self._last_search_path = target_clause
            if DEBUG_DB_SETTINGS:
                print(f"[TRACE:DB:sp] target={target_clause} applied=False conn_id={id(conn)}")
            return target_clause, False

        restore_autocommit = False
        prev_autocommit = getattr(conn, "autocommit", False)

        try:
            if not prev_autocommit:
                conn.autocommit = True
                restore_autocommit = True
            with conn.cursor() as cur:
                cur.execute(f"SET search_path TO {target_clause}")
        except Exception:
            if DEBUG_DB_SETTINGS:
                print(f"[TRACE:DB:sp] target={target_clause} applied=ERROR conn_id={id(conn)}")
            raise
        finally:
            if restore_autocommit:
                conn.autocommit = prev_autocommit

        self._set_cached_search_path(conn, target_clause)
        self._last_search_path = target_clause
        if DEBUG_DB_SETTINGS:
            print(f"[TRACE:DB:sp] target={target_clause} applied=True conn_id={id(conn)}")
        return target_clause, True

    def _normalize_search_path(self, raw) -> str:
        """
        ورودی search_path را به رشتهٔ استاندارد (جداشده با کاما) تبدیل می‌کند.
        """
        if raw is None:
            return "public"
        if isinstance(raw, (list, tuple, set)):
            parts = [str(item).strip() for item in raw if str(item).strip()]
        else:
            parts = [chunk.strip() for chunk in str(raw).split(',') if chunk.strip()]
        if not parts:
            return "public"
        return ', '.join(parts)

    def _prepare_search_path_clause(self, value: str) -> str:
        """مسیر نهایی search_path را با ولیدیشن ساده برمی‌گرداند؛ خطا => بازگشت به public."""
        try:
            clause = self._build_search_path_clause(value)
        except ValueError as exc:
            if DEBUG_DB_SETTINGS:
                print(f"[TRACE:DB:sp] invalid target={value!r} fallback=public reason={exc}")
            clause = 'public'
        return clause

    def _build_search_path_clause(self, value: str) -> str:
        import re
        raw = str(value or '')
        schemas = [chunk.strip() for chunk in raw.split(',') if chunk.strip()]
        if not schemas:
            schemas = ['public']
        pattern = re.compile(r"^[A-Za-z0-9_]+$")
        for schema in schemas:
            if not pattern.fullmatch(schema):
                raise ValueError(f"Invalid schema identifier: {schema}")
        return ', '.join(schemas)

    def _get_cached_search_path(self, conn):
        if not getattr(self, '_use_conn_id_cache', False):
            try:
                return self._conn_search_path.get(conn)
            except TypeError:
                self._use_conn_id_cache = True
        return self._conn_search_path_ids.get(id(conn))

    def _set_cached_search_path(self, conn, value: str):
        if not getattr(self, '_use_conn_id_cache', False):
            try:
                self._conn_search_path[conn] = value
                return
            except TypeError:
                self._use_conn_id_cache = True
        self._conn_search_path_ids[id(conn)] = value

    def _resolve_items_category_column(self, cursor=None) -> str | None:
        """Detects the existing column name storing item categories, with caching and logging."""
        if self._items_category_col is not None:
            return self._items_category_col

        from contextlib import nullcontext
        ctx = nullcontext() if cursor is not None else self.transaction()
        resolved = None
        source = 'schema'

        code_priority = [
            'category',
            'category_fa',
            'category_name',
            'group_name',
            'group',
            'item_category',
            'reporting_group',
        ]

        with ctx as _ctx_cur:
            cur = cursor or _ctx_cur
            try:
                existing = set(self._get_existing_columns('items', cursor=cur))
            except Exception:
                existing = set()

        for candidate in code_priority:
            if candidate in existing:
                resolved = candidate
                source = 'code'
                break

        if resolved is None:
            for candidate in existing:
                lower = candidate.lower()
                if 'category' in lower or 'group' in lower:
                    resolved = candidate
                    source = 'schema-scan'
                    break

        self._items_category_col = resolved
        self._items_category_source = source if resolved else 'none'

        if DEBUG_DB_RESOLVE:
            print(f"[TRACE:DB:items_category] resolved={resolved or 'NONE'} source={self._items_category_source}")

        return resolved

    def _resolve_items_unit_column(self, cursor=None) -> str | None:
        """Determines the column in `items` table representing the unit reference, caching the result."""
        if getattr(self, '_items_unit_col', None) is not None:
            return self._items_unit_col

        from contextlib import nullcontext
        import re as _re

        ctx = nullcontext() if cursor is not None else self.transaction()
        resolved = None
        source = 'schema'
        existing: set[str] = set()
        prefer_candidates = ['unit_id', 'uom_id', 'unitid', 'item_unit_id']
        fallback_candidates = ['unit', 'unit_code', 'unitname', 'unit_name', 'uom', 'uom_code']

        with ctx as _ctx_cur:
            cur = cursor or _ctx_cur
            try:
                existing = set(self._get_existing_columns('items', cursor=cur))
            except Exception:
                existing = set()

        ident_pattern = _re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')

        for candidate in prefer_candidates:
            if candidate in existing and ident_pattern.fullmatch(candidate):
                resolved = candidate
                source = 'code'
                break

        if resolved is None:
            for candidate in fallback_candidates:
                if candidate in existing and ident_pattern.fullmatch(candidate):
                    resolved = candidate
                    source = 'schema-scan'
                    break

        self._items_unit_col = resolved
        self._items_unit_source = source if resolved else 'none'

        if DEBUG_DB_RESOLVE:
            print(f"[TRACE:DB:items_unit] resolved={resolved or 'NONE'} source={self._items_unit_source}")

        return resolved

    def _table_exists(self, table_name: str, cursor=None) -> bool:
        from contextlib import nullcontext
        ctx = nullcontext() if cursor is not None else self.transaction()
        with ctx as _ctx_cur:
            cur = cursor or _ctx_cur
            cur.execute(
                """
                SELECT 1
                FROM information_schema.tables
                WHERE table_schema = ANY (current_schemas(TRUE))
                  AND table_name = %s
                LIMIT 1
                """,
                (table_name,),
            )
            return cur.fetchone() is not None

    def _log_items_category_warning(self):
        if not self._items_category_warned:
            self._items_category_warned = True
            print("WARNING: items category column could not be resolved; returning zero counts.")

    def execute_query(self, query, params=None, fetch_one=False, cursor=None):
        # --- schema compatibility for older/newer BOM table names ---
        try:
            if isinstance(query, str) and "recipe_components" in query:
                if "raw_material_item_id" in query:
                    query = query.replace("recipe_components", "recipe_ingredients")
                elif "component_item_id" in query:
                    query = query.replace("recipe_components", "recipe_items")
        except Exception:
            pass
    
        import re
        import psycopg2
        from psycopg2.extras import DictCursor
        try:
            from psycopg2 import errors as _errors
            from psycopg2 import extensions as _ext
        except Exception:
            _errors = None
            _ext = None

        params = params or []

        def _rows_to_dicts(cur, rows):
            if rows is None:
                return None
            if not rows:
                # سازگاری با برخی کدهای قدیمی
                return None if getattr(self, "compat_select_empty_none", False) and fetch_one else []
            if isinstance(rows[0], dict):
                return rows
            cols = [getattr(d, "name", d[0]) for d in cur.description]
            return [{cols[i]: r[i] for i in range(len(cols))} for r in rows]

        def _run(cur, q, p):
            cur.execute(q, p)
            if cur.description:  # SELECT / RETURNING
                if fetch_one:
                    row = cur.fetchone()
                    if row is None:
                        return None
                    if isinstance(row, dict):
                        return row
                    cols = [getattr(d, "name", d[0]) for d in cur.description]
                    return {cols[i]: row[i] for i in range(len(cols))}
                rows = cur.fetchall()
                return _rows_to_dicts(cur, rows)
            else:
                return getattr(cur, "rowcount", 0)

        def _maybe_retry_on_conflict_without_index(cur, q, p, err):
            """
            فقط وقتی اجرا می‌شود که:
            - متن خطا شامل 'no unique or exclusion constraint matching the ON CONFLICT specification' باشد
            - کوئری از نوع ON CONFLICT ... DO NOTHING باشد (و DO UPDATE نباشد)
            آنگاه: الگوی 'ON CONFLICT ( ... ) DO NOTHING' به 'ON CONFLICT DO NOTHING' تبدیل و یک‌بار تکرار می‌شود.
            """
            msg = (str(err) or "").lower()
            if "no unique or exclusion constraint" not in msg:
                raise err
            # فقط برای DO NOTHING
            low_q = q.lower()
            if "on conflict" not in low_q or "do nothing" not in low_q or "do update" in low_q:
                raise err
            # جایگزینی امن: حذف لیست ستون‌ها داخل پرانتز
            q2 = re.sub(r"on\s+conflict\s*\([^)]*\)\s*do\s*nothing",
                        "ON CONFLICT DO NOTHING",
                        q, flags=re.IGNORECASE)
            try:
                return _run(cur, q2, p)
            except Exception:
                # اگر دوباره خطا خورد، همان خطای اولیه را بده
                raise err

        # اگر کرسر بیرونی داریم، همان را استفاده می‌کنیم (تراکنش با لایه بالاتر)
        if cursor is not None:
            try:
                return _run(cursor, query, params)
            except Exception as e:
                # fallback خاص برای ON CONFLICT بدون ایندکس/قیود — فقط DO NOTHING
                return _maybe_retry_on_conflict_without_index(cursor, query, params, e)

        # بدون کرسر → خودمان کانکشن بگیریم و امن مدیریت کنیم
        with self._get_conn() as conn:
            # 1) پاک‌سازی آغازین در صورت حالت خطا
            try:
                if _ext and hasattr(conn, "get_transaction_status"):
                    if conn.get_transaction_status() == _ext.TRANSACTION_STATUS_INERROR:
                        conn.rollback()
                else:
                    try:
                        conn.rollback()
                    except Exception:
                        pass
            except Exception:
                pass

            # 2) اجرای کوئری با تایم‌اوت محلی و یک‌بار رتری روی خطای aborted
            try:
                with conn.cursor(cursor_factory=DictCursor) as cur:
                    try:
                        cur.execute("SET LOCAL statement_timeout = %s", (15000,))  # 15s
                    except Exception:
                        pass

                    try:
                        res = _run(cur, query, params)
                    except Exception as e:
                        # اگر خطای «بدون قیود یکتا برای ON CONFLICT DO NOTHING» بود، یک‌بار fallback
                        try:
                            res = _maybe_retry_on_conflict_without_index(cur, query, params, e)
                        except Exception as e2:
                            need_retry = False
                            msg = str(e2) if e2 else ""
                            if (_errors and isinstance(e2, _errors.InFailedSqlTransaction)) or ("current transaction is aborted" in msg):
                                need_retry = True
                            if need_retry:
                                try: conn.rollback()
                                except Exception: pass
                                with conn.cursor(cursor_factory=DictCursor) as cur2:
                                    try:
                                        try: cur2.execute("SET LOCAL statement_timeout = %s", (15000,))
                                        except Exception: pass
                                        res = _run(cur2, query, params)
                                    except Exception:
                                        # آخرین تلاش: fallback
                                        res = _maybe_retry_on_conflict_without_index(cur2, query, params, e2)
                            else:
                                raise
            except Exception:
                # rollback نهایی و بالا دادن خطا
                try: conn.rollback()
                except Exception: pass
                raise

            # ⬇⬇⬇ تغییر کلیدیِ امن: چون خودمان کانکشن را مدیریت کرده‌ایم، اینجا commit می‌زنیم.
            try:
                conn.commit()
            except Exception:
                # اگر autocommit فعال باشد یا DB اجازه ندهد، نادیده گرفتن امن است.
                pass

            return res
    # END REWRITE: DB.execute_query
    
    # FIX: EXCLUDE-CONVERSIONS (2025-09-24)
    def _sql_exclude_production_conversions(self) -> str:
        """
        بند فیلتر برای حذفِ «تبدیل‌های تولید» از تراکنش‌های اصلی.
        از همان برچسب‌هایی استفاده می‌کنیم که در execute_conversion ثبت کردیم.
        """
        return " AND NOT (t.t_type IN ('خروج به تبدیل','ورود از تبدیل') OR t.t_no LIKE 'CNV-%') "


    # Transactions: نسخه‌ی امنِ تأمین داده‌ی صفحهٔ «تراکنش‌های اصلی»
    def get_transactions_main(self, limit: int = 1000):
        """
        اگر متد شما اسم دیگری دارد (مثلا list_transactions یا get_transactions)،
        همین بدنه را در همان متد بگذار. فقط مراقب باشید WHERE را دو بار ننویسید.
        """
        with self.transaction() as cur:
            cur.execute(f"""
                SELECT
                    t.id, t.t_no, t.t_date, t.t_type, t.qty, t.batch_no, t.expiry_date,
                    i.name AS item_name,
                    COALESCE(src.name, dst.name, '') AS location_name
                FROM trans t
                JOIN items i       ON i.id = t.item_id
                LEFT JOIN locations src ON src.id = t.src_loc
                LEFT JOIN locations dst ON dst.id = t.dest_loc
                WHERE t.status = 'تایید شده'
                {self._sql_exclude_production_conversions()}
                ORDER BY t.t_date DESC, t.id DESC
                LIMIT %s
            """, (limit,))
            return cur.fetchall() or []

    

            
    # این دو متد جدید را به کلاس DB خود اضافه کنید
    def ensure_audit_log_schema(self):
        """جدول audit_log را در صورت عدم وجود، ایجاد می‌کند."""
        sql = r"""
        CREATE TABLE IF NOT EXISTS audit_log (
            id SERIAL PRIMARY KEY,
            action_key VARCHAR(100) NOT NULL,
            description TEXT,
            user_id INTEGER REFERENCES users(id),
            details JSONB,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );
        CREATE INDEX IF NOT EXISTS idx_audit_log_action_key ON audit_log(action_key);
        CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id);
        """
        try:
            # این متد ممکن است در برخی نسخه‌های قدیمی‌تر DB نباشد، پس از try/except استفاده می‌کنیم
            if hasattr(self, 'execute_sql_block'):
                self.execute_sql_block(sql)
            else:
                with self.transaction() as cur:
                    cur.execute(sql)
        except Exception as e:
            print(f"WARNING: Could not ensure audit_log schema automatically: {e}")

    def ensure_minimum_operational_schema(self):
        """Ensures baseline tables/indexes exist for sourcing and memo features."""
        path_value = getattr(self, "_search_path", "public") or "public"
        created = altered = skipped = 0
        start_ts = time.perf_counter()

        if DEBUG_BOOTSTRAP:
            print("[BOOT:SCHEMA] ensure_minimum_operational_schema start")

        def _summary_line(error_text: str | None = None) -> str:
            base = f"[BOOT:SCHEMA] created={created} altered={altered} skipped={skipped} search_path={path_value}"
            if error_text:
                return f"{base} error={error_text}"
            return base

        try:
            with self.transaction() as cur:
                try:
                    self._ensure_session_settings(cur.connection)
                except Exception:
                    pass

                table_cache = {}

                def _row_value(row):
                    if row is None:
                        return None
                    try:
                        return row[0]
                    except (KeyError, TypeError, IndexError):
                        pass
                    if hasattr(row, "values"):
                        values = list(row.values())
                        return values[0] if values else None
                    try:
                        return next(iter(row))
                    except Exception:
                        return None

                def table_exists(name):
                    if name not in table_cache:
                        cur.execute(
                            """
                            SELECT EXISTS (
                                SELECT 1
                                FROM information_schema.tables
                                WHERE table_name = %s
                                  AND table_schema = ANY (current_schemas(TRUE))
                            )
                            """,
                            (name,),
                        )
                        table_cache[name] = bool(_row_value(cur.fetchone()))
                    return table_cache[name]

                def column_exists(table, column):
                    cur.execute(
                        """
                        SELECT EXISTS (
                            SELECT 1
                            FROM information_schema.columns
                            WHERE table_name = %s
                              AND column_name = %s
                              AND table_schema = ANY (current_schemas(TRUE))
                        )
                        """,
                        (table, column),
                    )
                    return bool(_row_value(cur.fetchone()))

                def index_exists(table, index_name):
                    cur.execute(
                        """
                        SELECT EXISTS (
                            SELECT 1
                            FROM pg_indexes
                            WHERE tablename = %s
                              AND indexname = %s
                              AND schemaname = ANY (current_schemas(TRUE))
                        )
                        """,
                        (table, index_name),
                    )
                    return bool(_row_value(cur.fetchone()))

                def constraint_exists(table, constraint_name):
                    cur.execute(
                        """
                        SELECT EXISTS (
                            SELECT 1
                            FROM information_schema.table_constraints
                            WHERE table_name = %s
                              AND constraint_name = %s
                              AND table_schema = ANY (current_schemas(TRUE))
                        )
                        """,
                        (table, constraint_name),
                    )
                    return bool(_row_value(cur.fetchone()))

                def ensure_table(name, ddl):
                    nonlocal created, skipped
                    if table_exists(name):
                        skipped += 1
                        return
                    cur.execute(ddl)
                    table_cache[name] = True
                    created += 1

                def ensure_index(table, index_name, ddl):
                    nonlocal created, skipped
                    if not table_exists(table):
                        skipped += 1
                        return
                    if index_exists(table, index_name):
                        skipped += 1
                        return
                    cur.execute(ddl)
                    created += 1

                def ensure_column(table, column, definition):
                    nonlocal altered, skipped
                    if not table_exists(table):
                        skipped += 1
                        return
                    if column_exists(table, column):
                        skipped += 1
                        return
                    cur.execute(f"ALTER TABLE {table} ADD COLUMN IF NOT EXISTS {definition}")
                    altered += 1

                def ensure_fk(table, constraint_name, column, target_table, target_column="id", require=True):
                    nonlocal altered, skipped
                    if not require:
                        skipped += 1
                        return
                    if not table_exists(table) or not table_exists(target_table):
                        skipped += 1
                        return
                    if not column_exists(table, column):
                        skipped += 1
                        return
                    if constraint_exists(table, constraint_name):
                        skipped += 1
                        return
                    cur.execute(
                        f"""
                        ALTER TABLE {table}
                        ADD CONSTRAINT {constraint_name}
                        FOREIGN KEY ({column})
                        REFERENCES {target_table}({target_column})
                        DEFERRABLE INITIALLY DEFERRED
                        """
                    )
                    altered += 1

                ensure_table(
                    "purchase_request_groups",
                    """
                    CREATE TABLE IF NOT EXISTS purchase_request_groups (
                        id BIGSERIAL PRIMARY KEY,
                        requester_id BIGINT NULL,
                        original_department_id BIGINT NULL,
                        created_at TIMESTAMPTZ NULL DEFAULT NOW(),
                        approved_by_id BIGINT NULL,
                        approved_at TIMESTAMPTZ NULL,
                        physical_request_no TEXT NULL
                    )
                    """
                )

                ensure_table(
                    "purchase_requests",
                    """
                    CREATE TABLE IF NOT EXISTS purchase_requests (
                        id BIGSERIAL PRIMARY KEY,
                        group_id BIGINT NULL,
                        requester_id BIGINT NULL,
                        original_department_id BIGINT NULL,
                        request_date DATE NULL,
                        created_at TIMESTAMPTZ NULL DEFAULT NOW(),
                        approved_by_id BIGINT NULL,
                        approved_at TIMESTAMPTZ NULL
                    )
                    """
                )

                ensure_table(
                    "internal_memos",
                    """
                    CREATE TABLE IF NOT EXISTS internal_memos (
                        id BIGSERIAL PRIMARY KEY,
                        memo_number TEXT UNIQUE,
                        author_user_id BIGINT NOT NULL,
                        subject TEXT NULL,
                        body TEXT NULL,
                        created_at TIMESTAMPTZ NULL DEFAULT NOW()
                    )
                    """
                )

                ensure_table(
                    "memo_recipients",
                    """
                    CREATE TABLE IF NOT EXISTS memo_recipients (
                        id BIGSERIAL PRIMARY KEY,
                        memo_id BIGINT NOT NULL,
                        recipient_user_id BIGINT NOT NULL,
                        recipient_type TEXT NULL,
                        read_at TIMESTAMPTZ NULL
                    )
                    """
                )

                pd_created_before = created
                pd_altered_before = altered
                pd_skipped_before = skipped

                ensure_table(
                    "production_deliveries",
                    """
                    CREATE TABLE IF NOT EXISTS production_deliveries (
                        id BIGSERIAL PRIMARY KEY,
                        product_item_id BIGINT NULL,
                        product_name TEXT NULL,
                        production_batch_no TEXT NULL,
                        batch_no TEXT NULL,
                        quantity NUMERIC(20,6) NOT NULL DEFAULT 0,
                        status TEXT NOT NULL DEFAULT 'در انتظار تایید انبار',
                        supervisor_user_id BIGINT NULL,
                        created_at TIMESTAMPTZ NULL DEFAULT NOW(),
                        updated_at TIMESTAMPTZ NULL,
                        processed_at TIMESTAMPTZ NULL,
                        expiry_date DATE NULL
                    )
                    """
                )

                for column, definition in (
                    ("product_item_id", "product_item_id BIGINT NULL"),
                    ("product_name", "product_name TEXT NULL"),
                    ("production_batch_no", "production_batch_no TEXT NULL"),
                    ("batch_no", "batch_no TEXT NULL"),
                    ("quantity", "quantity NUMERIC(20,6) NOT NULL DEFAULT 0"),
                    ("qty", "qty NUMERIC(20,6) NULL"),
                    ("status", "status TEXT NOT NULL DEFAULT 'در انتظار تایید انبار'"),
                    ("supervisor_user_id", "supervisor_user_id BIGINT NULL"),
                    ("supervisor_id", "supervisor_id BIGINT NULL"),
                    ("created_by", "created_by BIGINT NULL"),
                    ("created_at", "created_at TIMESTAMPTZ NULL DEFAULT NOW()"),
                    ("updated_at", "updated_at TIMESTAMPTZ NULL"),
                    ("processed_at", "processed_at TIMESTAMPTZ NULL"),
                    ("approved_at", "approved_at TIMESTAMPTZ NULL"),
                    ("rejected_at", "rejected_at TIMESTAMPTZ NULL"),
                    ("approver_user_id", "approver_user_id BIGINT NULL"),
                    ("approver_user", "approver_user TEXT NULL"),
                    ("rejected_by_user_id", "rejected_by_user_id BIGINT NULL"),
                    ("rejection_reason", "rejection_reason TEXT NULL"),
                    ("notes", "notes TEXT NULL"),
                    ("expiry_date", "expiry_date DATE NULL"),
                    ("dest_loc_id", "dest_loc_id BIGINT NULL"),
                    ("t_no", "t_no TEXT NULL"),
                    ("production_order_id", "production_order_id BIGINT NULL"),
                    ("warehouse_id", "warehouse_id BIGINT NULL"),
                    ("dest_warehouse_id", "dest_warehouse_id BIGINT NULL"),
                    ("dest_wh_id", "dest_wh_id BIGINT NULL"),
                    ("user_id", "user_id BIGINT NULL"),
                    ("createdon", "createdon TIMESTAMPTZ NULL"),
                    ("created_date", "created_date TIMESTAMPTZ NULL"),
                    ("ts", "ts TIMESTAMPTZ NULL"),
                ):
                    ensure_column("production_deliveries", column, definition)

                ensure_index("production_deliveries", "idx_pd_status", "CREATE INDEX IF NOT EXISTS idx_pd_status ON production_deliveries(status)")
                ensure_index("production_deliveries", "idx_pd_item_status", "CREATE INDEX IF NOT EXISTS idx_pd_item_status ON production_deliveries(product_item_id, status)")
                ensure_index("production_deliveries", "idx_pd_batch", "CREATE INDEX IF NOT EXISTS idx_pd_batch ON production_deliveries(production_batch_no)")

                users_present_pd = table_exists("users")
                items_present_pd = table_exists("items")
                locations_present_pd = table_exists("locations")
                warehouses_present_pd = table_exists("warehouses")
                prod_orders_present_pd = table_exists("production_orders")

                ensure_fk("production_deliveries", "fk_pd_product_item", "product_item_id", "items", require=items_present_pd)
                ensure_fk("production_deliveries", "fk_pd_supervisor", "supervisor_user_id", "users", require=users_present_pd)
                ensure_fk("production_deliveries", "fk_pd_supervisor_alt", "supervisor_id", "users", require=users_present_pd)
                ensure_fk("production_deliveries", "fk_pd_created_by", "created_by", "users", require=users_present_pd)
                ensure_fk("production_deliveries", "fk_pd_approver", "approver_user_id", "users", require=users_present_pd)
                ensure_fk("production_deliveries", "fk_pd_rejected_by", "rejected_by_user_id", "users", require=users_present_pd)
                ensure_fk("production_deliveries", "fk_pd_user", "user_id", "users", require=users_present_pd)
                ensure_fk("production_deliveries", "fk_pd_dest_loc", "dest_loc_id", "locations", require=locations_present_pd)
                ensure_fk("production_deliveries", "fk_pd_prod_order", "production_order_id", "production_orders", require=prod_orders_present_pd)
                ensure_fk("production_deliveries", "fk_pd_wh", "warehouse_id", "warehouses", require=warehouses_present_pd)
                ensure_fk("production_deliveries", "fk_pd_dest_wh", "dest_warehouse_id", "warehouses", require=warehouses_present_pd)
                ensure_fk("production_deliveries", "fk_pd_dest_wh_alt", "dest_wh_id", "warehouses", require=warehouses_present_pd)

                pd_created = created - pd_created_before
                pd_altered = altered - pd_altered_before
                pd_skipped = skipped - pd_skipped_before
                if DEBUG_DB_RESOLVE:
                    print(f"[TRACE:DB:pd_boot] created={pd_created > 0} altered={pd_altered} skipped={pd_skipped}")

                for table, column, definition in (
                    ("purchase_request_groups", "requester_id", "requester_id BIGINT NULL"),
                    ("purchase_request_groups", "original_department_id", "original_department_id BIGINT NULL"),
                    ("purchase_request_groups", "created_at", "created_at TIMESTAMPTZ NULL DEFAULT NOW()"),
                    ("purchase_request_groups", "approved_by_id", "approved_by_id BIGINT NULL"),
                    ("purchase_request_groups", "approved_at", "approved_at TIMESTAMPTZ NULL"),
                    ("purchase_request_groups", "physical_request_no", "physical_request_no TEXT NULL"),
                    ("purchase_requests", "group_id", "group_id BIGINT NULL"),
                    ("purchase_requests", "requester_id", "requester_id BIGINT NULL"),
                    ("purchase_requests", "original_department_id", "original_department_id BIGINT NULL"),
                    ("purchase_requests", "request_date", "request_date DATE NULL"),
                    ("purchase_requests", "created_at", "created_at TIMESTAMPTZ NULL DEFAULT NOW()"),
                    ("purchase_requests", "approved_by_id", "approved_by_id BIGINT NULL"),
                    ("purchase_requests", "approved_at", "approved_at TIMESTAMPTZ NULL"),
                    ("internal_memos", "memo_number", "memo_number TEXT"),
                    ("internal_memos", "author_user_id", "author_user_id BIGINT NOT NULL"),
                    ("internal_memos", "subject", "subject TEXT NULL"),
                    ("internal_memos", "body", "body TEXT NULL"),
                    ("internal_memos", "created_at", "created_at TIMESTAMPTZ NULL DEFAULT NOW()"),
                    ("memo_recipients", "memo_id", "memo_id BIGINT NOT NULL"),
                    ("memo_recipients", "recipient_user_id", "recipient_user_id BIGINT NOT NULL"),
                    ("memo_recipients", "recipient_type", "recipient_type TEXT NULL"),
                    ("memo_recipients", "read_at", "read_at TIMESTAMPTZ NULL"),
                ):
                    ensure_column(table, column, definition)

                ensure_index("purchase_request_groups", "idx_prg_created_at", "CREATE INDEX IF NOT EXISTS idx_prg_created_at ON purchase_request_groups(created_at)")
                ensure_index("purchase_requests", "idx_pr_group_id", "CREATE INDEX IF NOT EXISTS idx_pr_group_id ON purchase_requests(group_id)")
                ensure_index("purchase_requests", "idx_pr_created_at", "CREATE INDEX IF NOT EXISTS idx_pr_created_at ON purchase_requests(created_at)")
                ensure_index("internal_memos", "idx_im_author", "CREATE INDEX IF NOT EXISTS idx_im_author ON internal_memos(author_user_id)")
                ensure_index("internal_memos", "idx_im_created", "CREATE INDEX IF NOT EXISTS idx_im_created ON internal_memos(created_at)")
                ensure_index("memo_recipients", "idx_mr_memo", "CREATE INDEX IF NOT EXISTS idx_mr_memo ON memo_recipients(memo_id)")
                ensure_index("memo_recipients", "idx_mr_recipient", "CREATE INDEX IF NOT EXISTS idx_mr_recipient ON memo_recipients(recipient_user_id)")

                users_present = table_exists("users")
                departments_present = table_exists("departments")
                prg_present = table_exists("purchase_request_groups")
                internal_memos_present = table_exists("internal_memos")

                ensure_fk("purchase_request_groups", "fk_prg_requester", "requester_id", "users", require=users_present)
                ensure_fk("purchase_request_groups", "fk_prg_approver", "approved_by_id", "users", require=users_present)
                ensure_fk("purchase_request_groups", "fk_prg_department", "original_department_id", "departments", require=departments_present)
                ensure_fk("purchase_requests", "fk_pr_requester", "requester_id", "users", require=users_present)
                ensure_fk("purchase_requests", "fk_pr_approver", "approved_by_id", "users", require=users_present)
                ensure_fk("purchase_requests", "fk_pr_department", "original_department_id", "departments", require=departments_present)
                ensure_fk("purchase_requests", "fk_pr_group", "group_id", "purchase_request_groups", require=prg_present)
                ensure_fk("internal_memos", "fk_internal_memos_author", "author_user_id", "users", require=users_present)
                ensure_fk("memo_recipients", "fk_memo_recipients_memo", "memo_id", "internal_memos", require=internal_memos_present)
                ensure_fk("memo_recipients", "fk_memo_recipients_user", "recipient_user_id", "users", require=users_present)

        except Exception as exc:
            if DEBUG_BOOTSTRAP:
                print(_summary_line(str(exc)))
            raise
        else:
            if DEBUG_BOOTSTRAP:
                print(_summary_line())
        finally:
            if DEBUG_BOOTSTRAP:
                elapsed_ms = (time.perf_counter() - start_ts) * 1000
                print(f"[BOOT:SCHEMA] done in {elapsed_ms:.1f}ms")

    def add_audit_log(self, action: str, description: str, user_id: int, details: dict = None, cur=None):
        """یک رویداد را در جدول تاریخچه سیستم (audit_log) ثبت می‌کند."""
        import json
        details_json = json.dumps(details, ensure_ascii=False) if details else None
        
        sql = """
            INSERT INTO audit_log (action_key, description, user_id, details)
            VALUES (%s, %s, %s, %s)
        """
        params = (action, description, user_id, details_json)
        
        # اگر تراکنش فعال وجود داشت، از همان استفاده می‌کند
        if cur:
            cur.execute(sql, params)
        else:
            with self.transaction() as cur:
                cur.execute(sql, params)
                
    # [FUNC: DB.list_items_minimal] — بازگردانی فهرست درختی با parent_item_id صحیح
    def list_items_minimal(self, exclude_parents: bool = False, include_stock: bool = False) -> list[dict]:
        """
        لیست حداقلی کالاها برای نماهای انتخاب:
        - اگر exclude_parents=True فقط فرزندها (بسته‌بندی‌ها) برگردانده می‌شود.
        - اگر include_stock=True ستون‌های qty/min_level (در صورت موجود بودن) اضافه می‌شود.
        خروجی همیشه کلید 'parent_item_id' خواهد داشت (اگر ستونش موجود باشد).
        """
        item_cols = self._get_existing_columns('items', [])
        has_parent = 'parent_item_id' in item_cols
        base_cols = "id, name, unit_id" + (", parent_item_id" if has_parent else "")

        if include_stock and all(c in item_cols for c in ['qty', 'min_level']):
            base_cols += ", qty, min_level"

        rows = self.execute_query(
            f"SELECT {base_cols} FROM items ORDER BY COALESCE(parent_item_id, id), name", None
        ) or []

        # فیلتر والدها (مادرها) در صورت نیاز
        if exclude_parents and has_parent:
            rows = [r for r in rows if r.get('parent_item_id') not in (None, '', 0)]

        # اطمینان از وجود کلید parent_item_id در همه‌ی ردیف‌ها
        for r in rows:
            if 'parent_item_id' not in r:
                r['parent_item_id'] = None
        return rows

    @contextmanager
    def transaction(self):
        """
        تراکنش ایمن و ساده (هم‌رفتار با نسخهٔ قبلی برنامه):
        - شروع: اگر اتصال واقعاً در حالت خطاست، یک rollback می‌زند.
        - وسط کار: یک timeout محلی می‌گذارد تا UI گیر نکند.
        - پایان: commit؛ در خطا: rollback و بالا دادن خطای اصلی.
        """
        from psycopg2.extras import DictCursor
        try:
            from psycopg2 import extensions as _ext
        except Exception:
            _ext = None

        with self._get_conn() as conn:
            # پاک‌سازی فقط وقتی تراکنشِ درحال‌خطاست
            try:
                if _ext and hasattr(conn, "get_transaction_status"):
                    if conn.get_transaction_status() == _ext.TRANSACTION_STATUS_INERROR:
                        conn.rollback()
                else:
                    # اگر API در دسترس نبود، رول‌بک سبک (بی‌ضرر)
                    try:
                        conn.rollback()
                    except Exception:
                        pass
            except Exception:
                # هر خطایی اینجا نادیده گرفته می‌شود تا جریان اصلی متوقف نشود
                pass

            try:
                with conn.cursor(cursor_factory=DictCursor) as cur:
                    # جلوگیری از هنگ‌های طولانی: تایم‌اوت محلی برای همین تراکنش
                    try:
                        cur.execute("SET LOCAL statement_timeout = %s", (15000,))  # ۱۵ ثانیه
                    except Exception:
                        pass  # روی برخی DBها/تنظیمات ممکن است پشتیبانی نشود

                    yield cur

                conn.commit()
            except Exception:
                try:
                    conn.rollback()
                except Exception:
                    pass
                raise
    # END REWRITE: DB.transaction

    @contextmanager
    def savepoint(self, cursor, name: str):
        """
        استفادهٔ ساده از SAVEPOINT. فقط همان بخش را در صورت خطا برمی‌گرداند
        و تراکنش اصلی سالم می‌ماند.
        """
        try:
            cursor.execute(f"SAVEPOINT {name}")
        except Exception:
            # اگر دیتابیس از قبل aborted بود، به transaction() واگذار می‌شود
            raise
        try:
            yield
            cursor.execute(f"RELEASE SAVEPOINT {name}")
        except Exception:
            try:
                cursor.execute(f"ROLLBACK TO SAVEPOINT {name}")
            except Exception:
                pass
            # خطا را نخوریم؛ اگر «اختیاری» است، لایهٔ بالا تصمیم می‌گیرد
            raise
    # END ADD: DB.savepoint

            
    # کد کامل و نهایی متد از def تا آخرین خط
    def list_reorder_candidates(self, limit: int = 500) -> list[dict]:
        """
        نسخه بازمهندسی شده و بهینه:
        - با فرض وجود ستون‌های min_qty و max_qty در جدول items، لیست کالاهای نیازمند سفارش را با یک کوئری واحد و سریع استخراج می‌کند.
        - تمام جستجوهای دینامیک و کند در information_schema حذف شده‌اند.
        """
        query = """
            WITH item_stock AS (
                SELECT
                    s.item_id,
                    SUM(s.qty) as total_stock
                FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE w.name != 'Production'
                GROUP BY s.item_id
            )
            SELECT
                i.id AS item_id,
                CASE
                    WHEN p.name IS NOT NULL THEN p.name || ' / ' || i.name
                    ELSE i.name
                END AS label,
                i.unit_id,
                COALESCE(s.total_stock, 0) AS stock,
                i.min_qty AS reorder_point,
                (i.min_qty - COALESCE(s.total_stock, 0)) AS deficit,
                COALESCE(i.max_qty - COALESCE(s.total_stock, 0), i.min_qty - COALESCE(s.total_stock, 0)) AS suggested_qty
            FROM items i
            LEFT JOIN items p ON i.parent_item_id = p.id
            LEFT JOIN item_stock s ON i.id = s.item_id
            WHERE i.min_qty > 0
            AND COALESCE(s.total_stock, 0) < i.min_qty
            AND i.is_parent_product = FALSE
            ORDER BY deficit DESC
            LIMIT %s;
        """
        return self.execute_query(query, (limit,)) or []
                                
# در کلاس DB، این متد را جایگزین کنید
    def _conn(self):
        """
        نسخه نهایی و قطعی (V4.0):
        - با استفاده از RealDictCursor تضمین می‌کند که خروجی همیشه به صورت دیکشنری واقعی پایتون باشد.
        """
        try:
            from psycopg2.extras import RealDictCursor

            connection_params = {
                'host': self.config.get("host"),
                'port': self.config.get("port"),
                'dbname': self.config.get("dbname"),
                'user': self.config.get("user"),
                'password': self.config.get("password"),
                'sslmode': self.config.get("sslmode", 'prefer')
            }

            c = psycopg2.connect(**connection_params, 
                                 cursor_factory=RealDictCursor,
                                 connect_timeout=5)
            return c
        except psycopg2.OperationalError as e:
            print(f"خطا در اتصال به دیتابیس PostgreSQL: {e}")
            raise ConnectionError(
                "برنامه قادر به اتصال به دیتابیس نیست.\n"
                "لطفاً از روشن بودن سرویس PostgreSQL و صحت اطلاعات در فایل config.json اطمینان حاصل کنید."
            )
            
        # <<< IMPROVEMENT
    def execute(self, query: str, params=None) -> int:
        """
        اجرای INSERT/UPDATE/DELETE.
        خروجی: تعداد ردیف‌های متاثر.
        """
        with self.transaction() as cur:
            cur.execute(query, params or ())
            return cur.rowcount

    # <<< IMPROVEMENT
    def exists(self, query: str, params=None) -> bool:
        """
        بررسی وجود داده: اگر دست‌کم یک ردیف باشد True برمی‌گرداند.
        """
        with self.transaction() as cur:
            cur.execute(query, params or ())
            return cur.fetchone() is not None

    def _get_existing_columns(self, table_name: str, candidates: list[str] | None = None, cursor=None):
        """Returns a set of existing column names for the given table (public schema).
        If `candidates` provided, returns intersection to safely probe optional columns.
        Works with or without external `cursor`."""
        from contextlib import nullcontext
        ctx = nullcontext() if cursor is not None else self.transaction()
        with ctx as _ctx_cur:
            cur = cursor or _ctx_cur
            cur.execute("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_schema='public' AND table_name=%s
            """, (table_name,))
            rows = cur.fetchall() or []
        cols = { (r['column_name'] if isinstance(r, dict) and 'column_name' in r else r[0]) for r in rows }
        if candidates:
            return {c for c in (candidates or []) if c in cols}
        return cols
    
    # BEGIN REWRITE: DB.finalize_delivery  [REF-TAG: DB.finalize_delivery#2]
    def finalize_delivery(self, delivery_id: int, approver_user_id: int, dest_loc_id: int, t_no: str = None):
        """
        نهایی‌سازی «تحویل از تولید به انبار».
        - انتقال موجودی از Production به مقصد (اتمیک).
        - به‌روزرسانی رکورد production_deliveries.
        - ✅ (جدید) ثبت رکورد تاریخچه در جدول trans برای نمایش در گزارش‌ها.
        """
        with self.transaction() as cur:
            # --- تشخیص ستون‌های جدول production_deliveries
            try:
                pd_cols = set(self._get_existing_columns('production_deliveries', cursor=cur))
            except Exception:
                pd_cols = set()
            batch_expr  = "pd.production_batch_no" if 'production_batch_no' in pd_cols else ("pd.batch_no" if 'batch_no' in pd_cols else "NULL::text")
            qty_expr    = "pd.quantity" if 'quantity' in pd_cols else ("pd.qty" if 'qty' in pd_cols else "0::numeric")
            expiry_expr = "pd.expiry_date" if 'expiry_date' in pd_cols else "NULL::date"
            if 'product_item_id' in pd_cols:
                item_expr  = "pd.product_item_id"
                join_items = ""
            else:
                item_expr  = "COALESCE(i.id, 0)"
                join_items = "LEFT JOIN items i ON i.name = pd.product_name"

            # --- رکورد درخواست (FOR UPDATE)
            select_sql = f"""
                SELECT pd.*,
                    {item_expr}    AS item_id,
                    {batch_expr}   AS batch_no,
                    {qty_expr}     AS qty,
                    {expiry_expr}  AS _expiry
                FROM production_deliveries pd
                {join_items}
                WHERE pd.id = %s
                FOR UPDATE
            """
            cur.execute(select_sql, (delivery_id,))
            row = cur.fetchone()
            if not row:
                raise ValueError("درخواست مورد نظر یافت نشد.")

            status_txt = (row.get('status') or '').strip()
            allowed_statuses = {
                getattr(TransactionStatus, 'PENDING_WAREHOUSE_APPROVAL').value,
                getattr(TransactionStatus, 'PENDING_PRODUCTION_APPROVAL').value
            }
            if status_txt not in allowed_statuses:
                raise ValueError("این ردیف در صف تایید نیست یا قبلاً رسیدگی شده است.")

            item_id  = row.get('item_id')
            batch_no = row.get('batch_no')
            qty      = float(row.get('qty') or 0)
            expiry   = row.get('_expiry')
            if not item_id or qty <= 0:
                raise ValueError("اطلاعات کالا یا مقدار درخواست نامعتبر است.")

            # --- لوکیشن‌ها
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("لوکیشن «Production» تعریف نشده است.")
            if int(dest_loc_id) == int(prod_loc_id):
                raise ValueError("لوکیشن مقصد نمی‌تواند Production باشد.")

            # موجودی Production کافی است؟
            cur.execute("""
                SELECT id, qty FROM stock
                WHERE item_id = %s AND location_id = %s
                AND (batch_no IS NOT DISTINCT FROM %s)
                AND (expiry_date IS NOT DISTINCT FROM %s)
                FOR UPDATE
            """, (item_id, prod_loc_id, batch_no, expiry))
            stock_rows = cur.fetchall() or []
            onhand = float(sum((r.get('qty', 0) if isinstance(r, dict) else r[1]) for r in stock_rows))
            if onhand + 1e-9 < qty:
                raise ValueError(f"موجودی کافی در Production برای این بچ وجود ندارد. موجودی فعلی: {onhand:g}")

            # --- جابه‌جایی موجودی (اتمیک)
            self._upd_stock(cur, item_id=item_id, location_id=prod_loc_id, qty_change=-qty,
                            batch_no=batch_no, expiry_date=expiry, status='موجود', return_stock_id=False)
            self._upd_stock(cur, item_id=item_id, location_id=dest_loc_id, qty_change=qty,
                            batch_no=batch_no, expiry_date=expiry, status='موجود', return_stock_id=False)

            # --- (جدید) ثبت رکورد در جدول trans برای تاریخچه
            try:
                tr_cols = set(self._get_existing_columns('trans', cursor=cur))
            except Exception:
                tr_cols = set()
            has = tr_cols.__contains__

            cols, ph, vals = [], [], []

            # ستون‌های عمومی
            if has('item_id'):    cols.append('item_id');    ph.append('%s'); vals.append(item_id)
            if has('t_type'):     cols.append('t_type');     ph.append('%s'); vals.append('ورود از تولید')
            if has('t_no') and t_no: cols.append('t_no');    ph.append('%s'); vals.append(t_no)
            if has('t_date'):     cols.append('t_date');     ph.append('NOW()')
            if has('qty'):        cols.append('qty');        ph.append('%s'); vals.append(qty)
            if has('user_id'):    cols.append('user_id');    ph.append('%s'); vals.append(approver_user_id)
            if has('status'):     cols.append('status');     ph.append('%s'); vals.append(getattr(TransactionStatus, 'APPROVED').value)
            if has('batch_no') and batch_no is not None:
                cols.append('batch_no'); ph.append('%s'); vals.append(batch_no)
            if has('expiry_date'):
                cols.append('expiry_date'); ph.append('%s'); vals.append(expiry)

            # مبدأ/مقصد: بر حسب ستون‌های موجود
            # src
            if has('src_loc'):
                cols.append('src_loc'); ph.append('%s'); vals.append(prod_loc_id)
            elif has('src_warehouse_id') or has('src_wh_id'):
                cur.execute("SELECT warehouse_id FROM locations WHERE id=%s", (prod_loc_id,))
                src_wid = (cur.fetchone() or {}).get('warehouse_id')
                col = 'src_warehouse_id' if has('src_warehouse_id') else 'src_wh_id'
                cols.append(col); ph.append('%s'); vals.append(src_wid)
            # dest
            if has('dest_loc'):
                cols.append('dest_loc'); ph.append('%s'); vals.append(dest_loc_id)
            elif has('dest_warehouse_id') or has('dest_wh_id'):
                cur.execute("SELECT warehouse_id FROM locations WHERE id=%s", (dest_loc_id,))
                dst_wid = (cur.fetchone() or {}).get('warehouse_id')
                col = 'dest_warehouse_id' if has('dest_warehouse_id') else 'dest_wh_id'
                cols.append(col); ph.append('%s'); vals.append(dst_wid)

            if cols:  # فقط اگر حداقل یک ستون معتبر داریم
                sql = f"INSERT INTO trans ({', '.join(cols)}) VALUES ({', '.join(ph)})"
                cur.execute(sql, tuple(vals))

            # --- به‌روزرسانی رکورد production_deliveries
            sets = ["status = %s"]
            params = [getattr(TransactionStatus, 'APPROVED').value]
            if 'approver_user_id' in pd_cols:
                sets.append("approver_user_id = %s"); params.append(approver_user_id)
            if 'approved_at' in pd_cols:
                sets.append("approved_at = NOW()")
            if 'dest_loc_id' in pd_cols:
                sets.append("dest_loc_id = %s"); params.append(dest_loc_id)
            if t_no and 't_no' in pd_cols:
                sets.append("t_no = %s"); params.append(t_no)
            if 'updated_at' in pd_cols:
                sets.append("updated_at = NOW()")
            params.append(delivery_id)
            cur.execute(f"UPDATE production_deliveries SET {', '.join(sets)} WHERE id = %s", tuple(params))
            
            try:
                self.mark_notification_resolved('APPROVE_DELIVERY', int(delivery_id))
            except Exception:
                pass
            try:
                if hasattr(self, 'signals'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass

            # --- لاگ
            try:
                self._log_atomic(cur, approver_user_id, 'APPROVE_PRODUCTION_DELIVERY',
                                f"delivery_id:{delivery_id}, item_id:{item_id}, batch:{batch_no}, qty:{qty}, dest:{dest_loc_id}")
            except Exception:
                pass

            return True
    # END REWRITE: DB.finalize_delivery

        
    # BEGIN REWRITE: DB._ceo_urgency_for_prs
    def _ceo_urgency_for_prs(self, pr_ids, cursor):
        """
        برای مجموعه‌ای از PR، فوریتِ تاییدشده توسط مدیرعامل را از جدول‌های رایج برمی‌گرداند.
        خروجی: {pr_id: urgency_text}
        """
        if not pr_ids:
            return {}
        out = {}

        # 1) اگر در خودِ purchase_requests ستونی برای فوریت مدیرعامل باشد
        pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cursor))
        for col in ("urgency_ceo","ceo_urgency","final_urgency","urgency_override","approved_urgency","ceo_priority","priority_ceo"):
            if col in pr_cols:
                placeholders = ", ".join(["%s"] * len(pr_ids))
                q = f"SELECT id, {col} FROM purchase_requests WHERE id IN ({placeholders})"
                cursor.execute(q, tuple(pr_ids))
                rows = cursor.fetchall() or []
                for r in rows:
                    pid, val = r[0], (r[1] or "")
                    val = val.strip() if isinstance(val, str) else val
                    if val:
                        out[int(pid)] = val
                if out:
                    return out
                break  # ستون هست ولی همه خالی بودند؛ می‌رویم سراغ جدول‌های بعدی

        # 2) جدول‌های رایج تأیید/رویداد
        candidate_tables = [
            "pr_approvals", "purchase_request_approvals", "approvals",
            "pr_status_history", "workflow_logs", "pr_workflow", "purchase_request_workflow"
        ]
        for tbl in candidate_tables:
            cols = set(self._get_existing_columns(tbl, cursor=cursor))
            if not cols:
                continue

            pr_fk = None
            for c in ("pr_id","purchase_request_id","request_id","doc_id","object_id","entity_id"):
                if c in cols:
                    pr_fk = c; break
            if not pr_fk:
                continue

            role_col = None
            for c in ("role","actor_role","approved_by_role","position","level_name","actor_title"):
                if c in cols:
                    role_col = c; break

            urg_col = None
            for c in ("urgency","new_urgency","final_urgency","approved_urgency","priority","priority_new"):
                if c in cols:
                    urg_col = c; break
            if not urg_col:
                continue

            ts_col = None
            for c in ("updated_at","created_at","approved_at","event_time","ts","time"):
                if c in cols:
                    ts_col = c; break

            role_filter = "TRUE"
            if role_col:
                role_filter = f"(LOWER({role_col}) LIKE '%%ceo%%' OR {role_col} LIKE '%%مدیرعامل%%')"

            placeholders = ", ".join(["%s"] * len(pr_ids))
            if ts_col:
                q = f"""
                    SELECT DISTINCT ON ({pr_fk}) {pr_fk} AS pid, {urg_col} AS urg
                    FROM {tbl}
                    WHERE {pr_fk} IN ({placeholders}) AND {role_filter}
                    ORDER BY {pr_fk}, {ts_col} DESC NULLS LAST
                """
            else:
                q = f"""
                    SELECT {pr_fk} AS pid, {urg_col} AS urg
                    FROM {tbl}
                    WHERE {pr_fk} IN ({placeholders}) AND {role_filter}
                """
            cursor.execute(q, tuple(pr_ids))
            rows = cursor.fetchall() or []
            for pid, urg in rows:
                urg = (urg or "").strip() if isinstance(urg, str) else urg
                if pid is not None and urg:
                    out[int(pid)] = urg

            if out:
                return out

        return {}
    # END REWRITE: DB._ceo_urgency_for_prs

    
    def resolve_item_code_column(self, cursor=None) -> str | None:
        """
        بهترین ستون کُد/شناسهٔ کالا را از جدول items تشخیص می‌دهد.
        اولویت: sku → code → item_code → barcode → part_code
        """
        candidates = ['sku', 'code', 'item_code', 'barcode', 'part_code']
        cols = set(self._get_existing_columns('items', cursor=cursor))
        for c in candidates:
            if c in cols:
                return c
        return None
    

            
    def ensure_pr_status_index(self) -> None:
        """Drop broken legacy index and (re)create a correct one on the real PR status column."""
        col = self._get_pr_status_column()
        with self.transaction() as cur:
            cur.execute("""
            DO $$
            BEGIN
                IF EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'ix_pr_stat') THEN
                    EXECUTE 'DROP INDEX IF EXISTS ix_pr_stat';
                END IF;
            END $$;
            """)
            cur.execute(f"CREATE INDEX IF NOT EXISTS ix_pr_status ON purchase_requests({col})")
            
    
    # BEGIN REWRITE: DB.is_physical_request_no_taken
    def is_physical_request_no_taken(self, physical_no: str, cursor=None) -> bool:
        """True اگر شمارهٔ فیزیکی گروه قبلاً ثبت شده باشد؛ بدون نشت اتصال."""
        if not physical_no:
            return False
        if cursor is not None:
            cursor.execute(
                "SELECT 1 FROM purchase_request_groups WHERE physical_request_no = %s LIMIT 1",
                (physical_no,)
            )
            return cursor.fetchone() is not None
        # مدیریت‌شده
        rows = self.execute_query(
            "SELECT 1 FROM purchase_request_groups WHERE physical_request_no = %s LIMIT 1",
            (physical_no,)
        )
        return bool(rows)
    # END REWRITE: DB.is_physical_request_no_taken
    
    # BEGIN REWRITE: DB._resolve_original_dept_id
    def _resolve_original_dept_id(self, original_dept_id: int | None, requester_id: int, cursor=None) -> int | None:
        """
        اگر original_dept_id از UI آمد، همان را (پس از نرمال‌سازی) برگردان.
        در غیر این صورت از users.department_id برای requester بخوان.
        حالت‌های «۰/خالی/رشتهٔ تهی» نامعتبر محسوب می‌شوند.
        """
        # 1) نرمال‌سازی ورودی از UI
        try:
            v = original_dept_id
            if v in (None, "", " ", "0", 0):
                v = None
            else:
                v = int(v)
        except Exception:
            v = None
        if v is not None:
            return v

        # 2) fallback: پروفایل کاربر
        cur = cursor  # در همهٔ فراخوانی‌های فعلی cursor پاس داده می‌شود
        try:
            cur.execute("SELECT department_id FROM users WHERE id=%s", (int(requester_id),))
            row = cur.fetchone()
            dep = row[0] if row and (isinstance(row, (list, tuple)) or isinstance(row, dict)) else None
            if dep in (None, "", " ", "0", 0):
                return None
            return int(dep)
        except Exception:
            return None
    # END REWRITE: DB._resolve_original_dept_id
    
    # BEGIN REWRITE: DB._reset_aborted_tx
    def _reset_aborted_tx(self):
        """
        تلاش برای خارج کردن اتصال مشکل‌دار از پول:
        - یک اتصال می‌گیریم، rollback می‌کنیم و با close=True به پول برمی‌گردانیم
        تا پول آن را از چرخه خارج و اتصال تازه بسازد.
        """
        try:
            if getattr(self, "_pool", None):
                conn = self._pool.getconn()
                try:
                    try:
                        conn.rollback()
                    except Exception:
                        pass
                finally:
                    # close=True یعنی این کانکشن از پول خارج و بسته شود
                    self._pool.putconn(conn, close=True)
        except Exception:
            pass
    # END REWRITE: DB._reset_aborted_tx

    
    

    
    # BEGIN REWRITE: DB._user_name_expr
    def _user_name_expr(self, alias: str = 'u', cursor=None) -> str:
        """
        عبارت امن برای نمایش نام کاربر.
        عمداً 'name' را استفاده نمی‌کنیم تا خطای u.name رخ ندهد.
        اولویت: full_name → username → email.
        """
        cols = set()
        try:
            if cursor:
                cursor.execute("""
                    SELECT column_name FROM information_schema.columns
                    WHERE table_schema='public' AND table_name='users'
                """)
                cols = {r[0] for r in (cursor.fetchall() or [])}
        except Exception:
            pass

        order = [c for c in ('full_name', 'username', 'email') if c in cols] or ['username']
        return "COALESCE(" + ", ".join([f"{alias}.{c}" for c in order] + ["'-'"]) + ")"
    # END REWRITE: DB._user_name_expr
    
    def _quote_winner_predicate(self, alias: str = 'w', cursor=None) -> str:
        """
        شرط SQL برای «برنده بودن» کوئوت با توجه به ستون‌های موجود در supplier_quotes.
        """
        cols = set(self._get_existing_columns('supplier_quotes', cursor=cursor))
        if 'is_winner' in cols:
            return f"COALESCE({alias}.is_winner, FALSE) = TRUE"
        if 'is_selected' in cols:
            return f"COALESCE({alias}.is_selected, FALSE) = TRUE"
        if 'selected' in cols:
            return f"COALESCE({alias}.selected, FALSE) = TRUE"
        if 'winner' in cols:
            return f"COALESCE({alias}.winner, 0) = 1"
        # اگر هیچ ستونی برای برنده نداریم، عملاً هیچ کوئوتی «برنده» تلقی نشود.
        return "1=0"
    
    def migrate_legacy_supplier_quotes_winner(self) -> None:
        """
        افزودن ستون is_winner (در صورت نبود) و مهاجرت از ستون‌های قدیمی.
        """
        with self.transaction() as cur:
            cols = set(self._get_existing_columns('supplier_quotes', cursor=cur))
            if 'is_winner' not in cols:
                cur.execute("ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS is_winner BOOLEAN")
                # بک‌فیل از ستون‌های قدیمی
                if 'is_selected' in cols:
                    cur.execute("UPDATE supplier_quotes SET is_winner = COALESCE(is_selected,FALSE) WHERE is_winner IS NULL")
                elif 'selected' in cols:
                    cur.execute("UPDATE supplier_quotes SET is_winner = COALESCE(selected,FALSE) WHERE is_winner IS NULL")
                elif 'winner' in cols:
                    cur.execute("UPDATE supplier_quotes SET is_winner = (winner = 1) WHERE is_winner IS NULL")
                # پیش‌فرض false برای باقی‌مانده‌ها
                cur.execute("UPDATE supplier_quotes SET is_winner = COALESCE(is_winner,FALSE)")
                # ایندکس برنده‌ها (ممکن است pr_id هنوز ایجاد شده باشد ولی مقداردهی نشده؛ مشکلی ندارد)
                try:
                    cur.execute("CREATE INDEX IF NOT EXISTS ix_supplier_quotes_winner ON supplier_quotes(pr_id, is_winner)")
                except Exception:
                    pass

    
        # [FUNC: DB.get_parent_column] — نام ستون والد را برمی‌گرداند (parent_item_id | parent_id | None)
    def get_parent_column(self) -> str | None:
        cols = self._get_existing_columns('items')
        if 'parent_item_id' in cols: return 'parent_item_id'
        if 'parent_id' in cols: return 'parent_id'
        return None

    # [FUNC: DB.search_items_by_sku_prefix] — پیشنهاد زنده‌ی SKU با پیشونددهی صحیح alias
    def search_items_by_sku_prefix(self, prefix: str, limit: int = 15) -> list[dict]:
        """
        جست‌وجوی آیتم‌هایی که کدشان با prefix شروع می‌شود.
        فقط «child»ها و نیز آیتم‌های مستقلِ بدون‌فرزند برگردانده می‌شوند.
        خروجی: [{id, unit_id, code, full_name}]
        """
        prefix = (prefix or "").strip()
        if len(prefix) < 1:
            return []

        code_cols = self._get_existing_columns('items', ['sku', 'code', 'item_code', 'barcode', 'part_code'])
        if not code_cols:
            return []

        pcol = self.get_parent_column()
        # ✅ مهم: تمام ارجاعات ستونی را با alias جدول i. پیشوند می‌دهیم تا ابهام رفع شود
        code_cols_i = [f"i.{c}" for c in code_cols]
        coalesce_i = "COALESCE(" + ",".join(code_cols_i) + ")"
        where_like = ' OR '.join([f"i.{c} ILIKE %s" for c in code_cols])
        params = tuple([prefix + '%'] * len(code_cols)) + (limit,)

        if pcol:
            sql = f"""
                WITH parents AS (
                    SELECT DISTINCT {pcol} AS pid FROM items WHERE {pcol} IS NOT NULL
                )
                SELECT i.id,
                    i.unit_id,
                    {coalesce_i} AS code,
                    CASE WHEN i.{pcol} IS NOT NULL THEN (p.name || ' / ' || i.name) ELSE i.name END AS full_name,
                    i.{pcol} AS parent_id
                FROM items i
                LEFT JOIN items p ON p.id = i.{pcol}
                WHERE ({where_like})
                AND (i.{pcol} IS NOT NULL OR i.id NOT IN (SELECT pid FROM parents))
                ORDER BY full_name
                LIMIT %s
            """
        else:
            sql = f"""
                SELECT i.id, i.unit_id, {coalesce_i} AS code, i.name AS full_name, NULL::INTEGER AS parent_id
                FROM items i
                WHERE ({where_like})
                ORDER BY full_name
                LIMIT %s
            """

        rows = self.execute_query(sql, params) or []
        out: list[dict] = []
        for r in rows:
            code_val = (r.get('code') or "")
            if code_val == "":
                continue
            out.append({
                "id": int(r['id']),
                "unit_id": r.get('unit_id'),
                "code": str(code_val),
                "full_name": r.get('full_name') or ""
            })
        return out

    def _get_pr_status_column(self) -> str:
        """ستون وضعیت PR را به‌صورت سازگار با `_status_col_pr` برمی‌گرداند."""
        # همهٔ کدها از این به بعد یک منبع حقیقت دارند
        return self._status_col_pr()
                                                
    def stats(self):
        """آمار کلی انبار را بر اساس موجودی واقعی در جدول stock محاسبه می‌کند."""
        with self.transaction() as cur:
            has_items = self._table_exists('items', cursor=cur)
            has_stock = self._table_exists('stock', cursor=cur)
            if not has_items or not has_stock:
                return 0, []

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur)) if has_items else set()
            except Exception:
                item_cols = set()

            category_col = None
            for cand in ('category', 'category_name', 'reporting_group', 'group_name', 'item_category'):
                if cand in item_cols:
                    category_col = cand
                    break
            if not category_col:
                return 0, []

            q1 = 'SELECT COUNT(*) as cnt FROM items'
            count_res = self.execute_query(q1, cursor=cur)
            cnt = count_res[0]['cnt'] if count_res else 0

            import re as _re
            if not _re.fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", category_col):
                return cnt, []

            q2 = f"""
                SELECT i.{category_col} AS category, SUM(s.qty) AS total_qty
                FROM stock s
                JOIN items i ON s.item_id = i.id
                GROUP BY i.{category_col}
                ORDER BY i.{category_col}
            """
            cat_res = self.execute_query(q2, cursor=cur) or []

        return cnt, cat_res
        
# در کلاس DB، این متد را نیز با نسخه جدید جایگزین کنید
    def get_item_by_name(self, item_name: str):
        """یک کالا را بر اساس نام دقیق آن جستجو کرده و اطلاعاتش را برمی‌گرداند."""
        # حالا فراخوانی به درستی انجام می‌شود
        return self.execute_query("SELECT * FROM items WHERE name = %s", (item_name,), fetch_one=True)
    

    
    # BEGIN ADD: DB._append_pr_history
    def _append_pr_history(self, pr_id: int, action: str, by_user_id: int, note: str = "", cursor=None) -> None:
        """ثبت تاریخچهٔ اقدامات PR (در pr_history اگر هست، وگرنه ضمیمه به notes)."""
        from contextlib import nullcontext as _nc
        with _nc(cursor) as cur_in:
            if cur_in is None:
                ctx = self.transaction(); cur = ctx.__enter__()
            else:
                cur = cur_in; ctx = None
            try:
                # آیا جدول pr_history هست؟
                try:
                    cur.execute("SELECT to_regclass('public.pr_history')")
                    has_hist = bool((cur.fetchone() or [None])[0])
                except Exception:
                    has_hist = False

                if has_hist:
                    cols = set(self._get_existing_columns("pr_history", cursor=cur))
                    c_pr = "purchase_request_id" if "purchase_request_id" in cols else ("pr_id" if "pr_id" in cols else None)
                    c_act = "action" if "action" in cols else None
                    c_by  = "by_user_id" if "by_user_id" in cols else ("actor_id" if "actor_id" in cols else None)
                    c_note= "note" if "note" in cols else ("notes" if "notes" in cols else None)
                    c_at  = "created_at" if "created_at" in cols else None
                    if c_pr and c_act and c_by:
                        parts, vals = [c_pr, c_act, c_by], [int(pr_id), str(action), int(by_user_id)]
                        if c_note: parts.append(c_note); vals.append((note or "")[:500])
                        if c_at:   parts.append(c_at);   vals.append(None)  # DEFAULT NOW()
                        sql = f"INSERT INTO pr_history({', '.join(parts)}) VALUES({', '.join(['%s']*len(parts))})"
                        cur.execute(sql, vals)
                        return

                # fallback: اضافه‌کردن به notes در purchase_requests
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
                notes_col = "notes" if "notes" in pr_cols else ("note" if "note" in pr_cols else None)
                if notes_col:
                    cur.execute(f"SELECT COALESCE({notes_col}, '') FROM purchase_requests WHERE id=%s", (pr_id,))
                    prev = (cur.fetchone() or [""])[0] or ""
                    line = f"[{action}] by #{by_user_id}"
                    if note:
                        line += f": {note}"
                    merged = (prev + ("\n" if prev else "") + line)[:1000]
                    cur.execute(f"UPDATE purchase_requests SET {notes_col}=%s WHERE id=%s", (merged, pr_id))
            finally:
                if ctx is not None:
                    ctx.__exit__(None, None, None)
    # END ADD: DB._append_pr_history
    

    
    # BEGIN ADD: DB.count_pr_attachments
    def count_pr_attachments(self, pr_id: int) -> int:
        """
        تعداد پیوست‌های یک PR را از رایج‌ترین اسکیماها برمی‌گرداند.
        اولویت: purchase_request_attachments -> pr_attachments -> attachments(...).
        اگر ستونی برای متن/JSON پیوست‌ها در خود PR باشد، تعداد آیتم‌ها را تخمین می‌زند.
        """
        try:
            with self.transaction() as cur:
                # 1) purchase_request_attachments
                cols = set(self._get_existing_columns("purchase_request_attachments", cursor=cur))
                if cols and ("pr_id" in cols):
                    q = "SELECT COUNT(*) FROM purchase_request_attachments WHERE pr_id=%s"
                    cur.execute(q, (int(pr_id),))
                    return int(cur.fetchone()[0] or 0)

                # 2) pr_attachments
                cols = set(self._get_existing_columns("pr_attachments", cursor=cur))
                if cols and ("pr_id" in cols):
                    cur.execute("SELECT COUNT(*) FROM pr_attachments WHERE pr_id=%s", (int(pr_id),))
                    return int(cur.fetchone()[0] or 0)

                # 3) attachments عمومی با نشانهٔ entity/type
                cols = set(self._get_existing_columns("attachments", cursor=cur))
                if cols and ({"pr_id","request_id","object_id","entity_id"} & cols):
                    fk = "pr_id" if "pr_id" in cols else ("request_id" if "request_id" in cols else ("object_id" if "object_id" in cols else "entity_id"))
                    where_extra = ""
                    for mark in ("entity","entity_type","model","ref_table","doc_type","object_type"):
                        if mark in cols:
                            where_extra = f" AND (LOWER({mark}) LIKE '%%purchase_request%%' OR {mark}='PR')"
                            break
                    cur.execute(f"SELECT COUNT(*) FROM attachments WHERE {fk}=%s{where_extra}", (int(pr_id),))
                    return int(cur.fetchone()[0] or 0)

                # 4) فیلدهای متنی در خود purchase_requests
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
                for c in ("attachments_json","attachments","files_json","files","file_list","attachment","attachment_list","pr_files"):
                    if c in pr_cols:
                        cur.execute(f"SELECT {c} FROM purchase_requests WHERE id=%s", (int(pr_id),))
                        raw = cur.fetchone()
                        raw = raw[0] if raw else None
                        if not raw:
                            return 0
                        try:
                            import json
                            v = json.loads(raw) if isinstance(raw, (str, bytes, bytearray)) else raw
                            if isinstance(v, list):
                                return len(v)
                            if isinstance(v, dict) and "items" in v and isinstance(v["items"], list):
                                return len(v["items"])
                        except Exception:
                            s = str(raw)
                            for sep in ["\n","; ", ";", ", ", ","]:
                                if sep in s:
                                    return len([p for p in s.split(sep) if p.strip()])
                            return 1 if s.strip() else 0
        except Exception:
            return 0
    # END ADD: DB.count_pr_attachments

    
    
    def get_open_purchase_orders(self) -> list[dict]:
        """
        POهای باز برای صفحهٔ دریافت.
        خروجی: [{po_id, order_no, supplier_name, status, item_count, total_amount}, ...]
        """
        q = """
            SELECT po.id AS po_id,
                COALESCE(po.order_no,'')                AS order_no,
                COALESCE(s.name,'')                     AS supplier_name,
                COALESCE(po.status,'باز')               AS status,
                COUNT(poi.id)                           AS item_count,
                COALESCE(SUM(COALESCE(poi.line_total, poi.unit_price * poi.ordered_qty)),0) AS total_amount
            FROM purchase_orders po
            JOIN suppliers s          ON s.id = po.supplier_id
            LEFT JOIN purchase_order_items poi ON poi.po_id = po.id
            WHERE COALESCE(po.status,'باز') IN ('باز','بخشی دریافت شد')
            GROUP BY po.id, po.order_no, s.name, po.status
            ORDER BY po.id DESC
        """
        return self.execute_query(q) or []

    
    def ensure_purchasing_schema(self) -> None:
        """Idempotent creation/upgrade of purchasing core schema + hot indexes."""
        sql = r"""
        DO $$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='purchase_requests') THEN
                EXECUTE 'CREATE TABLE purchase_requests(
                    id SERIAL PRIMARY KEY,
                    item_id INTEGER NOT NULL REFERENCES items(id),
                    requested_qty REAL NOT NULL,
                    requester_id INTEGER NOT NULL REFERENCES users(id),
                    original_department_id INTEGER REFERENCES departments(id),
                    urgency TEXT,
                    urgency_set_by_id INTEGER REFERENCES users(id),
                    status TEXT NOT NULL,
                    notes TEXT,
                    request_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    processed_by_id INTEGER REFERENCES users(id),
                    processed_date TIMESTAMPTZ,
                    selected_quote_id INTEGER,
                    group_id INTEGER REFERENCES purchase_request_groups(id)
                )';
            END IF;

            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='supplier_quotes') THEN
                EXECUTE 'CREATE TABLE supplier_quotes(
                    id SERIAL PRIMARY KEY,
                    purchase_request_id INTEGER NOT NULL REFERENCES purchase_requests(id) ON DELETE CASCADE,
                    supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
                    unit_price REAL NOT NULL,
                    currency TEXT,
                    lead_time_days INTEGER,
                    min_order_qty REAL,
                    is_winner BOOLEAN DEFAULT FALSE,
                    notes TEXT,
                    quote_document_path TEXT,
                    created_by_id INTEGER REFERENCES users(id),
                    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                )';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_sq_req ON supplier_quotes(purchase_request_id)';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_sq_supplier ON supplier_quotes(supplier_id)';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_sq_winner ON supplier_quotes(is_winner)';
            END IF;

            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='purchase_orders') THEN
                EXECUTE 'CREATE TABLE purchase_orders(
                    id SERIAL PRIMARY KEY,
                    po_number TEXT UNIQUE,
                    supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
                    buyer_id INTEGER REFERENCES users(id),
                    status TEXT NOT NULL DEFAULT ''پیش‌نویس'',
                    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    approved_by INTEGER REFERENCES users(id),
                    approved_at TIMESTAMPTZ,
                    total_amount REAL
                )';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_po_supplier ON purchase_orders(supplier_id)';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_po_status ON purchase_orders(status)';
            END IF;

            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='purchase_order_items') THEN
                EXECUTE 'CREATE TABLE purchase_order_items(
                    id SERIAL PRIMARY KEY,
                    po_id INTEGER NOT NULL REFERENCES purchase_orders(id) ON DELETE CASCADE,
                    item_id INTEGER NOT NULL REFERENCES items(id),
                    qty REAL NOT NULL,
                    unit_price REAL,
                    pr_id INTEGER REFERENCES purchase_requests(id),
                    notes TEXT
                )';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_poi_po ON purchase_order_items(po_id)';
                EXECUTE 'CREATE INDEX IF NOT EXISTS ix_poi_item ON purchase_order_items(item_id)';
            END IF;
        END $$;
        """
        self.execute_sql_block(sql)
        self.ensure_pr_status_index()
        

            
    def bootstrap_purchasing_runtime(self) -> None:
        """
        آماده‌سازی اسکیما + مهاجرت‌های سازگاری (PostgreSQL) به‌صورت idempotent.
        """
        with self.transaction() as cur:
            # suppliers
            cur.execute("""
                CREATE TABLE IF NOT EXISTS suppliers (
                    id SERIAL PRIMARY KEY,
                    name TEXT UNIQUE NOT NULL,
                    phone TEXT,
                    email TEXT,
                    is_active BOOLEAN DEFAULT TRUE
                )
            """)
            # supplier_quotes (با ستون‌های جدید؛ در اسکیماهای قدیمی بعضی ستون‌ها بعداً افزوده/مهاجرت می‌شوند)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS supplier_quotes (
                    id SERIAL PRIMARY KEY,
                    pr_id INTEGER,
                    supplier_id INTEGER NOT NULL,
                    unit_price NUMERIC(18,2) NOT NULL,
                    currency VARCHAR(8) DEFAULT 'IRR',
                    lead_time_days INTEGER,
                    min_order_qty NUMERIC(18,3),
                    is_winner BOOLEAN,
                    notes TEXT
                )
            """)
            cur.execute("CREATE INDEX IF NOT EXISTS ix_supplier_quotes_pr ON supplier_quotes(pr_id)")
            # purchase_orders
            cur.execute("""
                CREATE TABLE IF NOT EXISTS purchase_orders (
                    id SERIAL PRIMARY KEY,
                    supplier_id INTEGER NOT NULL,
                    order_no TEXT,
                    status TEXT DEFAULT 'باز',
                    created_by INTEGER,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                )
            """)
            cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS uq_purchase_orders_order_no ON purchase_orders(order_no)")
            # purchase_order_items
            cur.execute("""
                CREATE TABLE IF NOT EXISTS purchase_order_items (
                    id SERIAL PRIMARY KEY,
                    po_id INTEGER NOT NULL,
                    pr_id INTEGER,
                    item_id INTEGER,
                    ordered_qty NUMERIC(18,3),
                    unit_price NUMERIC(18,2),
                    line_total NUMERIC(18,2),
                    received_qty NUMERIC(18,3) DEFAULT 0
                )
            """)
            cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS uq_poi_pr ON purchase_order_items(pr_id)")
            cur.execute("CREATE INDEX IF NOT EXISTS ix_poi_po ON purchase_order_items(po_id)")

        # 1) ستون‌های کمکی PR و ایندکس وضعیت
        try: self.ensure_pr_request_extensions()
        except Exception: pass
        try: self.ensure_pr_status_index()
        except Exception: pass
        # 2) مهاجرت ستون‌های legacy مربوط به pr_id
        try: self.migrate_legacy_purchasing_schema()
        except Exception: pass
        # 3) مهاجرت ستون برنده در supplier_quotes
        try: self.migrate_legacy_supplier_quotes_winner()
        except Exception: pass

        
    def ensure_pr_request_extensions(self) -> None:
        """
        ستون‌های کمکی PR را در صورت نبود اضافه می‌کند (PostgreSQL).
        شامل فیلدهای مسیر «تایید مدیر واحد».
        """
        with self.transaction() as cur:
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS urgency TEXT")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS notes TEXT")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS selected_quote_id INTEGER")
            # ارجاع کارپرداز
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS agent_assignee_id INTEGER")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS agent_assigned_at TIMESTAMPTZ")
            # تایید مدیر واحد
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS manager_approver_id INTEGER")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS manager_submitted_at TIMESTAMPTZ")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS manager_decision TEXT")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS manager_decided_at TIMESTAMPTZ")
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS manager_note TEXT")
            # ستون وضعیت اگر بعضی دیتابیس‌ها فقط state دارند
            cur.execute("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS status TEXT")

    def _status_col_pr(self, cursor=None) -> str:
        cols = set(self._get_existing_columns('purchase_requests', cursor=cursor))
        return 'state' if 'state' in cols else 'status'
    
    
    # BEGIN ADD: DB._dept_col_pr
    def _dept_col_pr(self, cursor=None) -> str:
        """ستون واحد سازمانی PR را از بین original_department_id/department_id/requester_department_id تشخیص می‌دهد."""
        cols = set(self._get_existing_columns('purchase_requests', cursor=cursor))
        for c in ('original_department_id', 'department_id', 'requester_department_id'):
            if c in cols:
                return c
        return 'department_id'
    # END ADD: DB._dept_col_pr
    
    # BEGIN REWRITE: DB._display_status
    def _display_status(self, raw: str) -> str:
        """نگاشت سادهٔ وضعیت برای نمایش یکنواخت (صرفاً نمایشی)."""
        m = (raw or '').strip()
        return {
            'Issued': 'باز',
            'Open': 'باز',
            'Closed': 'بسته',
            'Cancelled': 'لغو',
            'سفارش صادر شد': 'سفارش صادر شد',
            'سفارش خرید صادر شد': 'سفارش صادر شد',
            'تامین‌کننده انتخاب شد': 'تامین‌کننده انتخاب شد',
            'در انتظار تایید مدیر واحد': 'در انتظار تایید مدیر واحد',
            'در انتظار تایید بازرگانی': 'در انتظار تایید بازرگانی',
            'رد شده': 'رد شده',
        }.get(m, m)
    # END REWRITE: DB._display_status
    
        # BEGIN ADD: DB._transit_pr_status
    def _transit_pr_status(self, pr_id: int, to_status: str, allow_from: list[str] | None = None, cursor=None) -> bool:
        """جابه‌جایی امن وضعیت PR. اگر allow_from داده شود، فقط از همان‌ها جابه‌جا می‌شود."""
        import contextlib
        need_close = cursor is None
        with (self.transaction() if need_close else contextlib.nullcontext()) as cur:
            cur = cur if need_close else cursor
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            col = 'state' if 'state' in pr_cols else ('status' if 'status' in pr_cols else None)
            if not col:
                return False
            cur.execute(f"SELECT {col} FROM purchase_requests WHERE id=%s", (pr_id,))
            row = cur.fetchone(); now = (row[0] if row else None)
            if allow_from and (now not in allow_from):
                return False
            cur.execute(f"UPDATE purchase_requests SET {col}=%s WHERE id=%s", (to_status, pr_id))
            return cur.rowcount == 1
    # END ADD: DB._transit_pr_status

    
    # BEGIN ADD: DB._display_status
    def _display_status(self, raw) -> str:
        """نمایش سادهٔ وضعیت برای UI؛ اگر مقدار ناشناخته بود همان raw برگردد."""
        if raw is None:
            return ''
        try:
            return str(raw)
        except Exception:
            return ''
    # END ADD: DB._display_status

    def _resolve_manager_for_user(self, requester_user_id: int, cursor=None) -> int | None:
        """
        مدیر واحدِ درخواست‌دهنده را تشخیص می‌دهد:
        departments.manager_user_id  →  users.manager_id  →  None
        """
        with (self.transaction() if cursor is None else nullcontext()) as cur_ctx:
            cur = cursor or cur_ctx
            # 1) از طریق دپارتمان
            try:
                cur.execute("""
                    SELECT d.manager_user_id
                    FROM users u
                    JOIN departments d ON d.id = u.department_id
                    WHERE u.id = %s
                """, (requester_user_id,))
                r = cur.fetchone()
                if r:
                    mgr = r[0] if not isinstance(r, dict) else r.get('manager_user_id')
                    if mgr: return int(mgr)
            except Exception:
                pass
            # 2) users.manager_id
            try:
                cols = set(self._get_existing_columns('users', cursor=cur))
                if 'manager_id' in cols:
                    cur.execute("SELECT manager_id FROM users WHERE id = %s", (requester_user_id,))
                    r = cur.fetchone()
                    if r:
                        mgr = r[0] if not isinstance(r, dict) else r.get('manager_id')
                        if mgr: return int(mgr)
            except Exception:
                pass
        return None
    
    
    # BEGIN ADD: DB._resolve_ceo_manager
    def _resolve_ceo_manager(self, cursor=None):
        """اگر جدول کاربران/نقش‌ها موجود بود، شناسهٔ مدیرعامل را برمی‌گرداند؛ در غیر این‌صورت None."""
        try:
            cur = cursor or self.get_cursor()
            cur.execute("SELECT id FROM users WHERE role IN ('CEO','ceo','مدیرعامل') ORDER BY id LIMIT 1")
            row = cur.fetchone()
            return int(row['id'] if isinstance(row, dict) else row[0]) if row else None
        except Exception:
            return None
    # END ADD: DB._resolve_ceo_manager
    
    # BEGIN REWRITE: DB.submit_pr_for_unit_manager
    def submit_pr_for_unit_manager(self, pr_id: int, requester_user_id: int) -> bool:
        """
        ارسال PR برای تایید مدیر واحد (کاملاً مستقل از workflow) + تضمین دیده‌شدن در کارتابل مدیر واحد.
        - تعیین مدیر بر اساس «واحد مقصدِ PR» (original_department_id/...)، نه واحدِ درخواست‌دهنده.
        - ست‌کردن وضعیت «در انتظار تایید مدیر واحد» برای PRهای تازه/خنثی.
        - ساخت/تثبیت رکورد Pending در manager_approvals با assigned_manager_id درست (idempotent).
        """
        if not pr_id or not requester_user_id:
            return False

        try:
            ST_AW_MGR = getattr(TransactionStatus, 'PR_AWAITING_MANAGER').value
        except Exception:
            ST_AW_MGR = 'در انتظار تایید مدیر واحد'

        with self.transaction() as cur:
            # --- کشف ستون‌ها
            pr_cols  = set(self._get_existing_columns('purchase_requests', cursor=cur)) or set()
            dept_cols= set(self._get_existing_columns('departments', cursor=cur)) or set()
            ma_cols  = set()
            try:
                cur.execute("SELECT to_regclass('public.manager_approvals')")
                if (cur.fetchone() or [None])[0]:
                    ma_cols = set(self._get_existing_columns('manager_approvals', cursor=cur)) or set()
            except Exception:
                ma_cols = set()

            status_col = 'status' if 'status' in pr_cols else ('state' if 'state' in pr_cols else None)
            dept_col   = next((c for c in ('original_department_id','department_id','requester_department_id','dept_id') if c in pr_cols), None)
            has_mgr_fk = 'manager_approver_id' in pr_cols
            has_dept_mgr = 'manager_user_id' in dept_cols

            # --- خواندن requester و واحد مقصد
            requester_id = int(requester_user_id)
            pr_dept_id = None
            try:
                sel_cols = ['requester_id'] + ([dept_col] if dept_col else [])
                cur.execute(f"SELECT {', '.join(sel_cols)} FROM purchase_requests WHERE id=%s", (int(pr_id),))
                row = cur.fetchone()
                if row:
                    if isinstance(row, dict):
                        requester_id = int(row.get('requester_id') or requester_id)
                        pr_dept_id = int(row.get(dept_col)) if (dept_col and row.get(dept_col)) else None
                    else:
                        requester_id = int(row[0] or requester_id)
                        if dept_col:
                            pr_dept_id = int(row[1]) if row[1] is not None else None
            except Exception:
                pass

            # --- تعیین مدیر بر اساس واحد مقصد؛ در صورت نبود، از روی خود کاربر
            manager_id = None
            if pr_dept_id and has_dept_mgr:
                try:
                    cur.execute("SELECT manager_user_id FROM departments WHERE id=%s", (int(pr_dept_id),))
                    r = cur.fetchone()
                    manager_id = (r[0] if (r and not isinstance(r, dict)) else (r.get('manager_user_id') if r else None)) or None
                    if manager_id is not None:
                        manager_id = int(manager_id)
                except Exception:
                    manager_id = None
            if not manager_id:
                try:
                    manager_id = self._resolve_manager_for_user(requester_id, cursor=cur)
                except Exception:
                    manager_id = None

            # --- ست‌کردن وضعیت و مدیر در خود PR (ایمن/بدون تغییر رفتار بیرونی)
            set_parts, params = [], []
            if status_col:
                # فقط اگر وضعیت خنثی/جدید است، به «در انتظار تایید مدیر واحد» تغییر بده
                set_parts.append(f"{status_col} = COALESCE(NULLIF({status_col}, ''), %s)")
                params.append(ST_AW_MGR)
            if has_mgr_fk and manager_id:
                set_parts.append("manager_approver_id = COALESCE(manager_approver_id, %s)")
                params.append(int(manager_id))
            # ثبت زمان ارسال برای مدیر (اگر ستون‌ها موجود باشند)
            for c in ('manager_submitted_at','submitted_to_manager_at'):
                if c in pr_cols:
                    set_parts.append(f"{c} = COALESCE({c}, NOW())")
            for c in ('manager_submitted_by','submitted_to_manager_by'):
                if c in pr_cols:
                    set_parts.append(f"{c} = COALESCE({c}, %s)")
                    params.append(int(requester_id))

            if set_parts:
                params.append(int(pr_id))
                cur.execute(f"UPDATE purchase_requests SET {', '.join(set_parts)} WHERE id=%s", tuple(params))

            # --- تضمین رکورد Pending در صف با assigned_manager_id درست (idempotent)
            has_wf   = 'workflow' in ma_cols
            has_st   = 'status'   in ma_cols
            has_assn = 'assigned_manager_id' in ma_cols
            has_req  = 'requester_id' in ma_cols
            has_cby  = 'created_by_id' in ma_cols
            if has_wf and has_st:
                # درج اگر نبود
                cols, vals, qparams = ['purchase_request_id','workflow','status'], ['%s','%s','%s'], [int(pr_id),'DEPT_MANAGER','Pending']
                if has_req: cols.append('requester_id');     vals.append('%s'); qparams.append(int(requester_id))
                if has_cby: cols.append('created_by_id');    vals.append('%s'); qparams.append(int(requester_id))
                if has_assn: cols.append('assigned_manager_id'); vals.append('%s'); qparams.append(int(manager_id) if manager_id else None)

                cur.execute(
                    f"""
                    INSERT INTO manager_approvals({', '.join(cols)})
                    SELECT {', '.join(vals)}
                    WHERE NOT EXISTS (
                        SELECT 1 FROM manager_approvals
                        WHERE purchase_request_id=%s AND workflow='DEPT_MANAGER' AND status='Pending'
                    )
                    """,
                    tuple(qparams + [int(pr_id)])
                )

                # اگر هست ولی گیرنده اشتباه/تهی است، اصلاحش کن
                if has_assn and manager_id:
                    cur.execute(
                        """
                        UPDATE manager_approvals
                        SET assigned_manager_id = %s
                        WHERE purchase_request_id=%s AND workflow='DEPT_MANAGER' AND status='Pending'
                        AND (assigned_manager_id IS NULL OR assigned_manager_id <> %s)
                        """,
                        (int(manager_id), int(pr_id), int(manager_id))
                    )

        # سیگنال‌های سبک UI
        try:
            if hasattr(self, 'signals'):
                self.signals.dataChanged.emit('PURCHASING_LISTS_CHANGED')
                self.signals.dataChanged.emit('MY_REQUESTS_TRACKING_CHANGED')
                self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        except Exception:
            pass

        return True
    # END REWRITE: DB.submit_pr_for_unit_manager
        
# BEGIN ADD<DB.ensure_new_pr_visible_for_manager>
    def ensure_new_pr_visible_for_manager(self, pr_id: int) -> bool:
        """
        اگر وضعیت PR خالی/NULL باشد، آن را روی «در انتظار تایید مدیر واحد» می‌گذارد.
        خروجی: True اگر چیزی تغییر کرده باشد.
        """
        if not pr_id:
            return False

        # مقدار وضعیت هدف (اول از Enum، بعد فارسی)
        try:
            st_mgr = getattr(TransactionStatus, 'PR_AWAITING_MANAGER').value
        except Exception:
            st_mgr = 'در انتظار تایید مدیر واحد'

        with self.transaction() as cur:
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur)) or set()
            status_col = 'status' if 'status' in pr_cols else ('state' if 'state' in pr_cols else None)
            if not status_col:
                return False

            # فقط وقتی خالی است ست کن (idempotent)
            cur.execute(
                f"UPDATE purchase_requests "
                f"SET {status_col}=%s "
                f"WHERE id=%s AND COALESCE({status_col}, '') IN ('','PR_CREATED','NEW','CREATED')",
                (st_mgr, int(pr_id))
            )
            return bool(cur.rowcount or 0)
# END ADD<DB.ensure_new_pr_visible_for_manager>

    # BEGIN REWRITE: DB.list_prs_pending_unit_manager
    def list_prs_pending_unit_manager(self, manager_user_id: int, limit: int = 100, offset: int = 0):
        """
        PRهای «در انتظار تایید مدیر واحد» برای همان مدیر + حالت نیابت (Delegation).
        خروجی: list[dict] با id, group_id, started_at
        - اگر ستون manager_approver_id موجود باشد → فیلتر روی خودِ مدیر و delegator (درصورت وجود).
        - در غیر اینصورت → فیلتر بر اساس واحد سازمانی مدیر.
        - اگر هیچ نگاشت مدیری/واحدی یافت نشود، نتیجه خالی برمی‌گردد (پیام در UI).
        """
        def _dbg(*a):
            try:
                if getattr(self, "_DEBUG_TASKS", True):
                    print("[DBG:LUPM]", *a)
            except Exception:
                pass

        try:
            manager_user_id = int(manager_user_id)
        except Exception:
            _dbg("bad manager_user_id:", manager_user_id)
            return []

        try:
            with self.transaction() as cur:
                # کشف ستون‌های لازم
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur)) or set()
                c_status = "status" if "status" in pr_cols else ("state" if "state" in pr_cols else None)
                c_group  = "group_id" if "group_id" in pr_cols else None
                c_dept   = next((c for c in ("original_department_id", "department_id", "requester_department_id", "dept_id") if c in pr_cols), None)
                has_mgr_col = "manager_approver_id" in pr_cols
                started_expr = "request_date" if "request_date" in pr_cols else "NULL"

                try:
                    AW_MGR = getattr(TransactionStatus, "PR_AWAITING_MANAGER").value
                except Exception:
                    AW_MGR = "در انتظار تایید مدیر واحد"

                if not c_status:
                    _dbg("no status/state column on PR.")
                    return []

                where = [f"COALESCE({c_status}, '') = %s"]
                params = [AW_MGR]

                if has_mgr_col:
                    # پشتیبانی نیابت: اگر مدیر فعلی delegate باشد، delegator را هم لحاظ کن
                    delegator_id = self._resolve_approval_delegate_of(manager_user_id, 'PURCHASE_REQUEST_APPROVAL')
                    mgr_ids = [manager_user_id] + ([int(delegator_id)] if isinstance(delegator_id, int) else [])
                    if len(mgr_ids) == 1:
                        where.append("manager_approver_id = %s")
                        params.append(mgr_ids[0])
                    else:
                        where.append("manager_approver_id IN (%s, %s)")
                        params.extend(mgr_ids[:2])  # فقط یک delegator فعال را پشتیبانی می‌کنیم
                else:
                    # مسیر واحد سازمانی
                    dept_id = None
                    try:
                        dept_id = self._resolve_department_id(manager_user_id, cursor=cur)
                    except Exception:
                        dept_id = None
                    if c_dept and dept_id:
                        where.append(f"{c_dept} = %s")
                        params.append(int(dept_id))
                    else:
                        # هیچ نگاشت مدیری/واحدی موجود نیست → نتیجه خالی و پیام در UI
                        _dbg("no manager mapping or department for user:", manager_user_id)
                        return []

                grp_expr = f"COALESCE({c_group}, id) AS group_id" if c_group else "id AS group_id"
                sql = (
                    f"SELECT id, {grp_expr}, {started_expr} AS started_at "
                    f"FROM purchase_requests "
                    f"WHERE {' AND '.join(where)} "
                    f"ORDER BY id DESC LIMIT %s OFFSET %s"
                )
                params.extend([int(limit), int(offset)])

                cur.execute(sql, params)
                rows = cur.fetchall() or []
                # تبدیل امن به dict
                try:
                    colnames = [d.name for d in cur.description]
                    rows = [{colnames[i]: r[i] for i in range(len(colnames))} for r in rows]
                except Exception:
                    pass

                _dbg("rows:", len(rows))
                return rows
        except Exception as e:
            _dbg("FATAL:", e)
            return []
    # END REWRITE: DB.list_prs_pending_unit_manager
    
    # BEGIN ADD: DB.has_unit_manager_mapping
    def has_unit_manager_mapping(self, manager_user_id: int) -> bool:
        """
        آیا این کاربر به‌عنوان «مدیر واحد» جایی شناخته می‌شود؟
        برای پیام UI: اگر False و لیست PRها خالی بود ⇒ «مدیر واحد تعریف نشده».
        منطق: وجود در جدول واحدها (preferred) یا در PRها به‌عنوان manager_approver_id.
        """
        try:
            uid = int(manager_user_id)
        except Exception:
            return False

        try:
            with self.transaction() as cur:
                # 1) چک روی جدول دپارتمان‌ها (اولویت)
                dept_cols = set(self._get_existing_columns("departments", cursor=cur)) or set()
                c_mgr = next((c for c in ("manager_user_id", "unit_manager_id", "head_user_id") if c in dept_cols), None)
                if c_mgr:
                    cur.execute(f"SELECT 1 FROM departments WHERE {c_mgr} = %s LIMIT 1", (uid,))
                    if cur.fetchone():
                        return True

                # 2) چک روی خود PRها اگر ستون manager_approver_id داریم
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur)) or set()
                if "manager_approver_id" in pr_cols:
                    cur.execute("SELECT 1 FROM purchase_requests WHERE manager_approver_id = %s LIMIT 1", (uid,))
                    if cur.fetchone():
                        return True
                return False
        except Exception:
            # امن: به سمت False برگرد تا UI پیام راهنما بده
            return False
    # END ADD: DB.has_unit_manager_mapping

        

    

# BEGIN ADD<DB.list_user_personal_kanban_tasks>
    def list_user_personal_kanban_tasks(self, user_id: int, include_done: bool = False) -> list[dict]:
        """
        کارهای «شخصیِ کاربر» برای کانبان — بدون هیچ اتصال به PR/Workflow.
        اگر جدول وجود نداشته باشد، خروجی خالی است.
        """
        if not user_id:
            return []
        try:
            with self.transaction() as cur:
                cur.execute("SELECT to_regclass('public.kanban_tasks')")
                if not (cur.fetchone() or [None])[0]:
                    return []  # منبع شخصی هنوز ساخته نشده

                where_done = "" if include_done else "AND COALESCE(status,'TODO') <> 'DONE'"
                sql = f"""
                    SELECT id, title, COALESCE(description,'') AS description,
                           COALESCE(status,'TODO') AS status, COALESCE(priority,'NORMAL') AS priority,
                           COALESCE(due_date::text,'') AS due_date
                      FROM kanban_tasks
                     WHERE user_id=%s {where_done}
                     ORDER BY CASE COALESCE(priority,'NORMAL')
                                WHEN 'URGENT' THEN 0
                                WHEN 'HIGH'   THEN 1
                                WHEN 'NORMAL' THEN 2
                                ELSE 3
                              END,
                              id DESC
                """
                rows = self.execute_query(sql, (int(user_id),), fetch_all=True, cursor=cur) or []
                return [dict(r) if isinstance(r, dict) else {
                    "id": r[0], "title": r[1], "description": r[2],
                    "status": r[3], "priority": r[4], "due_date": r[5]
                } for r in rows]
        except Exception:
            return []
# END ADD<DB.list_user_personal_kanban_tasks>

            
    # این متد را در کلاس DB به طور کامل جایگزین کنید
    def list_pr_group_headers_for_ceo(self, manager_id: int) -> list[dict]:
        """
        نسخه نهایی و سازگار (V3.1):
        - کوئری برای ارجاع به ستون تاریخ صحیح (pg.created_at) اصلاح شده است.
        - تمام قابلیت‌های پیچیده کد اصلی کاربر حفظ شده است.
        """
        # تضمین وجود اسکیماهای لازم
        self.ensure_purchasing_schema()

        has_group = self._table_has_column('purchase_requests', 'group_id')
        uname = self._user_name_expr('u')
        reason_code_expr = "CASE WHEN pr.reason_code IS NOT NULL THEN pr.reason_code ELSE (SELECT m[1] FROM regexp_matches(COALESCE(pr.notes,''), '\\[REASON:([A-Z_]+)\\]') AS m LIMIT 1) END"
        grp_key_expr = "COALESCE(pr.group_id, pr.id)"
        form_no_expr = "COALESCE(pg.physical_request_no, '')" if has_group else "''"

        # کوئری اصلی با تغییر در بخش تاریخ
        query = f"""
            WITH pending_prs AS (
                SELECT pr.id, pr.group_id
                FROM purchase_requests pr
                WHERE pr.status = %s
            )
            SELECT
                pr.group_id as grp_key,
                (pr.group_id IS NULL) AS is_single,
                {form_no_expr} AS form_no,
                MAX({uname}) AS requester_name,
                COALESCE(MAX(d.name), MAX(d2.name), '-') AS dept_name,
                COUNT(pr.id) AS items_count,
                SUM(pr.requested_qty) AS total_qty,
                MAX(COALESCE(pr.urgency_suggested, pr.urgency, '')) AS urgency_max,
                STRING_AGG(DISTINCT COALESCE({reason_code_expr}, ''), ',') AS reasons,
                MIN(pg.created_at) AS created_at -- <<< اصلاح کلیدی: استفاده از تاریخ ایجاد گروه
            FROM purchase_requests pr
            JOIN pending_prs pp ON pp.id = pr.id
            LEFT JOIN users u ON u.id = pr.requester_id
            LEFT JOIN departments d2 ON d2.id = u.department_id
            {'LEFT JOIN purchase_request_groups pg ON pg.id = pr.group_id' if has_group else ''}
            {'LEFT JOIN departments d ON d.id = pg.original_department_id' if has_group else ''}
            GROUP BY pr.group_id, pg.physical_request_no
            ORDER BY MIN(pg.created_at) ASC;
        """

        params = (TransactionStatus.PR_AWAITING_CEO.value,)
        return self.execute_query(query, params) or []
        
    # این متد را در کلاس DB به طور کامل جایگزین کنید
    def list_pr_group_items_for_ceo(self, group_key: int) -> list[dict]:
        """
        نسخه نهایی و کامل (V5): تمام اقلام یک گروه را با تمام جزئیات برای میزکار مدیرعامل برمی‌گرداند.
        """
        sql = """
            SELECT
                pr.id, -- pr_id is the primary key for the item row
                i.name AS item_name,
                p.name AS parent_name,
                i.sku,
                pr.requested_qty,
                un.name AS unit_name,
                COALESCE(pr.urgency_suggested, pr.urgency, 'عادی') as urgency_suggested,
                pr.specs,
                pr.notes,
                COALESCE(att.attachments_count, 0) as attachments_count
            FROM purchase_requests pr
            JOIN items i ON pr.item_id = i.id
            LEFT JOIN items p ON i.parent_item_id = p.id
            LEFT JOIN units un ON un.id = COALESCE(pr.requested_unit_id, i.unit_id)
            LEFT JOIN (
                SELECT pr_id, COUNT(*) AS attachments_count
                FROM purchase_request_attachments
                GROUP BY pr_id
            ) att ON att.pr_id = pr.id
            WHERE pr.group_id = %s AND pr.status = %s
            ORDER BY pr.id;
        """
        params = (group_key, TransactionStatus.PR_AWAITING_CEO.value)
        return self.execute_query(sql, params) or []
            

    def decide_ceo_approvals_bulk(self, *args, **kwargs) -> dict:
        """
        تصمیم‌های مدیرعامل به‌صورت گروهی — مستقل از workflow.

        ورودی‌های پذیرفته‌شده (هر کدوم باشه کار می‌کنه):
        - decisions=[{pr_id, approve, new_qty?, final_urgency?/urgency?, rejection_note?}, ...]
        - pr_ids=[...]  + approve=True/False  (+ اختیاری: new_qty, final_urgency/urgency, rejection_note)
        - group_id=...  (+ approve=True/False)  → pr_ids از گروه خوانده می‌شود.

        خروجی: {ok: True, approved: nA, rejected: nR, affected: nA+nR, pr_ids:[...]}
        *امضای انعطاف‌پذیر با *args, **kwargs برای سازگاری با صداهای قدیمی.
        """
        # --- تایید کننده
        approver_id = int(kwargs.get("approver_id") or kwargs.get("user_id") or 0)
        if not approver_id:
            raise ValueError("approver_id نامعتبر است.")

        # --- کمک: نگاشت وضعیت‌ها با fallback فارسی
        def _enum(name: str, fallback: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return fallback

        ST_READY_SRC    = _enum('READY_FOR_SOURCING',  'آماده برای استعلام')
        ST_REJECTED_CEO = _enum('PR_CEO_REJECTED',     'رد شده توسط مدیرعامل')

        # --- ۱) ورودی‌ها
        decisions = kwargs.get("decisions")
        pr_ids = list(kwargs.get("pr_ids") or kwargs.get("ids") or [])
        group_id = kwargs.get("group_id")
        default_approve = kwargs.get("approve")

        # اگر فقط group_id داریم، pr_ids را از گروه بخوانیم (با transaction، نه connection)
        if group_id and not pr_ids and (not decisions):
            try:
                with self.transaction() as cur:
                    cols = set(self._get_existing_columns("purchase_requests", cursor=cur)) or set()
                    c_gid = "group_id" if "group_id" in cols else ("request_group_id" if "request_group_id" in cols else None)
                    if c_gid:
                        cur.execute(f"SELECT id FROM purchase_requests WHERE {c_gid}=%s ORDER BY id ASC", (int(group_id),))
                        rows = cur.fetchall() or []
                        # به dict/tuple هر دو سازگار
                        pr_ids = [int(r[0] if not isinstance(r, dict) else r.get("id")) for r in rows if (r or 0)]
            except Exception:
                pr_ids = []

        # decisions را بسازیم اگر فقط pr_ids داده شده
        if decisions is None:
            decisions = []
            if pr_ids:
                for pid in pr_ids:
                    decisions.append({
                        "pr_id": int(pid),
                        "approve": bool(default_approve) if default_approve is not None else True,
                        "new_qty": kwargs.get("new_qty"),
                        "final_urgency": kwargs.get("final_urgency") or kwargs.get("urgency"),
                        "rejection_note": kwargs.get("rejection_note"),
                    })
            else:
                # تلاش برای استخراج از args (سازگاری با فراخوانی‌های قدیمی احتمالی)
                for a in args:
                    if isinstance(a, list):
                        decisions = a
                        break

        # ولیدیشن حداقلی
        safe_decisions = []
        for d in (decisions or []):
            try:
                pid = int(d.get("pr_id"))
            except Exception:
                continue
            if not pid:
                continue
            safe_decisions.append({
                "pr_id": pid,
                "approve": bool(d.get("approve")),
                "new_qty": d.get("new_qty"),
                "final_urgency": d.get("final_urgency") or d.get("urgency"),
                "rejection_note": (d.get("rejection_note") or "").strip()[:500] if d.get("rejection_note") else None,
            })
        if not safe_decisions:
            return {"ok": True, "approved": 0, "rejected": 0, "affected": 0, "pr_ids": []}

        # --- ۲) کشف ستون‌ها و اعمال تصمیم‌ها به‌صورت اتمیک
        approved_cnt = rejected_cnt = 0
        out_pr_ids = []

        with self.transaction() as cur:
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur)) or set()
            status_col   = 'state' if 'state' in pr_cols else ('status' if 'status' in pr_cols else None)
            approval_col = 'approval_status' if 'approval_status' in pr_cols else None
            qty_col      = 'requested_qty' if 'requested_qty' in pr_cols else None
            urg_col      = 'final_urgency' if 'final_urgency' in pr_cols else ('urgency' if 'urgency' in pr_cols else None)
            rej_col      = 'rejection_reason' if 'rejection_reason' in pr_cols else ('reject_reason' if 'reject_reason' in pr_cols else None)
            appr_at_col  = 'ceo_decided_at' if 'ceo_decided_at' in pr_cols else ('approved_at' if 'approved_at' in pr_cols else None)
            appr_by_col  = 'ceo_decided_by' if 'ceo_decided_by' in pr_cols else ('approved_by_id' if 'approved_by_id' in pr_cols else None)

            if not status_col:
                raise RuntimeError("ستون وضعیت در purchase_requests پیدا نشد.")

            # حلقه‌ی تصمیم‌ها
            for d in safe_decisions:
                pid = int(d["pr_id"]); approve = bool(d["approve"])
                new_qty = d.get("new_qty")
                final_urgency = d.get("final_urgency")
                rejection_note = d.get("rejection_note")

                # قفل رکورد برای ایمنی هم‌زمانی
                cur.execute("SELECT id FROM purchase_requests WHERE id=%s FOR UPDATE", (pid,))
                row = cur.fetchone()
                if not row:
                    continue

                # ساخت UPDATE داینامیک
                sets, params = [], []
                target_status = ST_READY_SRC if approve else ST_REJECTED_CEO
                sets.append(f"{status_col}=%s"); params.append(target_status)

                if approval_col:
                    sets.append(f"{approval_col}=%s"); params.append('APPROVED' if approve else 'REJECTED')

                if approve and (new_qty is not None) and (qty_col is not None):
                    try:
                        qv = float(new_qty)
                        if qv > 0:
                            sets.append(f"{qty_col}=%s"); params.append(qv)
                    except Exception:
                        pass

                if final_urgency and urg_col:
                    sets.append(f"{urg_col}=%s"); params.append(str(final_urgency).strip())

                if (not approve) and rejection_note and rej_col:
                    sets.append(f"{rej_col}=%s"); params.append(rejection_note)

                if appr_at_col:
                    sets.append(f"{appr_at_col}=NOW()")
                if appr_by_col:
                    sets.append(f"{appr_by_col}=%s"); params.append(int(approver_id))

                params.append(pid)
                cur.execute(
                    f"UPDATE purchase_requests SET {', '.join(sets)} WHERE id=%s",
                    tuple(params)
                )
                out_pr_ids.append(pid)
                if approve: approved_cnt += 1
                else:       rejected_cnt += 1

                # تاریخچه اختیاری در pr_approvals (اگر وجود داشته باشد)
                try:
                    cur.execute("SELECT to_regclass('public.pr_approvals')")
                    reg = cur.fetchone()
                    ok_table = (reg and (reg[0] if not isinstance(reg, dict) else list(reg.values())[0]))
                    if ok_table:
                        pa_cols = set(self._get_existing_columns('pr_approvals', cursor=cur))
                        c_pr  = 'purchase_request_id' if 'purchase_request_id' in pa_cols else ('pr_id' if 'pr_id' in pa_cols else None)
                        c_wf  = 'workflow' if 'workflow' in pa_cols else None
                        c_st  = 'status' if 'status' in pa_cols else ('state' if 'state' in pa_cols else None)
                        c_by  = 'decided_by_id' if 'decided_by_id' in pa_cols else ('approver_id' if 'approver_id' in pa_cols else None)
                        c_at  = 'decided_at' if 'decided_at' in pa_cols else None
                        c_note= 'note' if 'note' in pa_cols else None
                        if c_pr and c_wf and c_st:
                            cols = [c_pr, c_wf, c_st]
                            vals = [pid, 'CEO', ('APPROVED' if approve else 'REJECTED')]
                            if c_by:   cols.append(c_by);  vals.append(int(approver_id))
                            # decided_at را اگر ستون دارد، با NOW() ست می‌کنیم
                            if c_at:   cols.append(c_at)
                            if (not approve) and rejection_note and c_note:
                                cols.append(c_note); vals.append(rejection_note)

                            placeholders = []
                            vi = 0
                            for c in cols:
                                if c == c_at:
                                    placeholders.append("NOW()")
                                else:
                                    placeholders.append("%s"); vi += 1
                            cur.execute(
                                f"INSERT INTO pr_approvals ({', '.join(cols)}) VALUES ({', '.join(placeholders)})",
                                tuple(vals)
                            )
                except Exception:
                    pass

                # رویداد timeline اختیاری
                try:
                    tl_cols = set(self._get_existing_columns('request_timeline', cursor=cur))
                    if {'purchase_request_id','event','created_at'}.issubset(tl_cols):
                        ev = 'تایید مدیرعامل' if approve else 'رد مدیرعامل'
                        note = None if approve else (rejection_note or None)
                        # اگر ستون actor_id هست، پرش می‌کنیم
                        if 'actor_id' in tl_cols and 'notes' in tl_cols:
                            cur.execute(
                                "INSERT INTO request_timeline (purchase_request_id, event, created_at, actor_id, notes) VALUES (%s, %s, NOW(), %s, %s)",
                                (pid, ev, int(approver_id), note)
                            )
                        elif 'actor_id' in tl_cols:
                            cur.execute(
                                "INSERT INTO request_timeline (purchase_request_id, event, created_at, actor_id) VALUES (%s, %s, NOW(), %s)",
                                (pid, ev, int(approver_id))
                            )
                        else:
                            cur.execute(
                                "INSERT INTO request_timeline (purchase_request_id, event, created_at) VALUES (%s, %s, NOW())",
                                (pid, ev)
                            )
                except Exception:
                    pass

        # سیگنال‌های سبک UI (مثل قبل)
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("PURCHASING_LISTS_CHANGED")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
        except Exception:
            pass

        return {
            "ok": True,
            "approved": approved_cnt,
            "rejected": rejected_cnt,
            "affected": approved_cnt + rejected_cnt,
            "pr_ids": out_pr_ids
        }
                
    # این متد را در کلاس DB به طور کامل جایگزین کنید
    def get_pr_group_details_for_approval(self, group_id: int) -> dict:
        """
        نسخه نهایی (V2.1):
        - باگ مربوط به اتصال (JOIN) جدول واحدها برطرف شده است.
        - تمام اطلاعات لازم برای دیالوگ تایید مدیر واحد را به درستی واکشی می‌کند.
        """
        header = self.execute_query(
            """
            SELECT pg.id, pg.physical_request_no, d.name as dept_name, u.username as requester_name
            FROM purchase_request_groups pg
            JOIN users u ON pg.requester_id = u.id
            JOIN departments d ON pg.original_department_id = d.id
            WHERE pg.id = %s
            """, (group_id,), fetch_one=True
        )

        # کوئری اصلی برای واکشی تمام جزئیات اقلام
        items_query = """
            SELECT 
                pr.id, 
                i.name as item_name, 
                pr.requested_qty, 
                un.name as unit_name, 
                pr.urgency_suggested,
                pr.specs,
                pr.notes,
                COALESCE(att.attachments_count, 0) as attachments_count
            FROM purchase_requests pr
            JOIN items i ON pr.item_id = i.id
            LEFT JOIN units un ON un.id = COALESCE(pr.requested_unit_id, i.unit_id) -- <<< اصلاح کلیدی اینجاست
            LEFT JOIN (
                SELECT pr_id, COUNT(*) AS attachments_count
                FROM purchase_request_attachments
                GROUP BY pr_id
            ) att ON att.pr_id = pr.id
            WHERE pr.group_id = %s ORDER BY pr.id
        """
        items = self.execute_query(items_query, (group_id,))

        return {'header': dict(header) if header else {}, 'items': [dict(i) for i in items] if items else []}

    def approve_pr_group_by_dept_head(self, group_id: int, approver_id: int):
        """وضعیت تمام اقلام یک گروه را به 'در انتظار تایید مدیرعامل' تغییر می‌دهد."""
        with self.transaction() as cur:
            # ابتدا ID تمام PR های مرتبط را پیدا می‌کنیم
            pr_records = self.execute_query("SELECT id FROM purchase_requests WHERE group_id = %s AND status = %s", (group_id, TransactionStatus.PR_AWAITING_MANAGER.value), cursor=cur)
            if not pr_records:
                raise ValueError("هیچ درخواست معتبری برای تایید در این گروه یافت نشد.")
            
            pr_ids = [rec['id'] for rec in pr_records]
            
            # وضعیت همه را یکجا آپدیت می‌کنیم
            self.execute_query(
                "UPDATE purchase_requests SET status = %s WHERE id = ANY(%s)",
                (TransactionStatus.PR_AWAITING_CEO.value, pr_ids),
                cursor=cur
            )
            
            # لاگ اقدام
            self.add_audit_log('PR_GROUP_MANAGER_APPROVED', f"مدیر واحد فرم درخواست خرید گروه #{group_id} را تایید کرد.", approver_id, {'group_id': group_id}, cur)

    # BEGIN REWRITE: DB.reject_pr_group_by_dept_head
    def reject_pr_group_by_dept_head(self, group_id: int, approver_id: int, reason: str):
        """وضعیت تمام اقلام یک گروه را به «رد شده توسط مدیر واحد» تغییر می‌دهد (اتمیک و سازگار عقب‌رو)."""
        with self.transaction() as cur:
            # 1) کشف امن نام ستون وضعیت
            try:
                status_col = self._status_col_pr(cursor=cur)
            except Exception:
                status_col = 'status'

            # 2) مقداردهی امن Enum ها (اگر نبودند، متن پیش‌فرض)
            def _val(name: str, default: str) -> str:
                try:
                    return getattr(TransactionStatus, name).value
                except Exception:
                    return default
            st_pending_mgr = _val('PR_AWAITING_MANAGER', 'تایید مدیر واحد')
            st_rejected_mgr = _val('PR_REJECTED_BY_DEPT_MANAGER', 'رد مدیر واحد')

            # 3) بروزرسانی وضعیت و افزودن یادداشت
            note = f"[دلیل رد مدیر واحد]: {reason}" if reason else ""
            self.execute_query(
                f"UPDATE purchase_requests SET {status_col} = %s, notes = COALESCE(notes, '') || %s WHERE group_id = %s AND {status_col} = %s",
                (st_rejected_mgr, note, group_id, st_pending_mgr),
                cursor=cur
            )

            # 4) ثبت لاگ اقدام
            self.add_audit_log('PR_GROUP_MANAGER_REJECTED', f"مدیر واحد گروه {group_id} را رد کرد.", approver_id, {'group_id': group_id, 'reason': reason}, cur)
    # END REWRITE: DB.reject_pr_group_by_dept_head

    # BEGIN REWRITE: DB.approve_pr
    def approve_pr(self, pr_id: int, approver_id: int, note: str = None) -> dict:
        """
        تایید «مدیر واحد» روی یک PR.
        - وضعیت PR → «در انتظار تایید مدیرعامل»
        - بستن همهٔ Pendingهای مرتبط در manager_approvals برای همین PR (workflow='DEPT_MANAGER')
        - ثبت تاریخچه (در صورت وجود pr_approvals)
        - ارسال سیگنال‌های UI
        خروجی: dict ساده برای لاگ/دیباگ
        """
        # Enum ایمن با fallback فارسی
        def _enum(name: str, fallback: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return fallback

        ST_WAIT_CEO = _enum("PR_AWAITING_CEO", "در انتظار تایید مدیرعامل")

        with self.transaction() as cur:
            # 1) تغییر وضعیت PR
            pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
            pr_status = "status" if "status" in pr_cols else ("state" if "state" in pr_cols else None)
            pr_mgr_id = "manager_approver_id" if "manager_approver_id" in pr_cols else None
            if not pr_status:
                raise RuntimeError("ستون وضعیت در purchase_requests یافت نشد.")

            cur.execute("SELECT id FROM purchase_requests WHERE id=%s FOR UPDATE", (int(pr_id),))
            if not cur.fetchone():
                return {"ok": False, "msg": "PR not found", "pr_id": pr_id}

            sets, params = [f"{pr_status}=%s"], [ST_WAIT_CEO]
            if pr_mgr_id:
                sets.append(f"{pr_mgr_id}=%s"); params.append(int(approver_id))
            params.append(int(pr_id))
            cur.execute(f"UPDATE purchase_requests SET {', '.join(sets)} WHERE id=%s", tuple(params))

            # 2) بستن Pending در manager_approvals
            updated_ma = 0
            try:
                cur.execute("SELECT to_regclass('public.manager_approvals')")
                if (cur.fetchone() or [None])[0]:
                    ma_cols = set(self._get_existing_columns("manager_approvals", cursor=cur))
                    ma_pr   = "purchase_request_id" if "purchase_request_id" in ma_cols else ("pr_id" if "pr_id" in ma_cols else None)
                    ma_st   = "status" if "status" in ma_cols else ("state" if "state" in ma_cols else None)
                    ma_wf   = "workflow" if "workflow" in ma_cols else None
                    ma_asg  = "assigned_manager_id" if "assigned_manager_id" in ma_cols else None
                    ma_by   = "decided_by_id" if "decided_by_id" in ma_cols else ("approver_id" if "approver_id" in ma_cols else None)
                    ma_at   = "decided_at" if "decided_at" in ma_cols else None
                    ma_note = "note" if "note" in ma_cols else None

                    if ma_pr and ma_st:
                        upd_sets, upd_params = [f"{ma_st}=%s"], ["Approved"]
                        if ma_by:  upd_sets.append(f"{ma_by}=%s");  upd_params.append(int(approver_id))
                        if ma_at:  upd_sets.append(f"{ma_at}=NOW()")
                        if note and ma_note:
                            upd_sets.append(f"{ma_note}=COALESCE({ma_note}, %s)"); upd_params.append(note[:500])

                        where, wparams = [f"{ma_pr}=%s", f"{ma_st}='Pending'"], [int(pr_id)]
                        if ma_wf:
                            where.append(f"({ma_wf}='DEPT_MANAGER' OR {ma_wf} IS NULL)")
                        if ma_asg:
                            where.append(f"({ma_asg}=%s OR {ma_asg} IS NULL)"); wparams.append(int(approver_id))

                        cur.execute(
                            f"UPDATE manager_approvals SET {', '.join(upd_sets)} WHERE " + " AND ".join(where),
                            tuple(upd_params + wparams)
                        )
                        updated_ma = cur.rowcount or 0
            except Exception as e:
                print(f"[DBG:approve_pr] skip manager_approvals update: {e}")

            # 3) تاریخچه اختیاری
            try:
                cur.execute("SELECT to_regclass('public.pr_approvals')")
                if (cur.fetchone() or [None])[0]:
                    pa_cols = set(self._get_existing_columns('pr_approvals', cursor=cur))
                    c_pr  = 'purchase_request_id' if 'purchase_request_id' in pa_cols else ('pr_id' if 'pr_id' in pa_cols else None)
                    c_wf  = 'workflow' if 'workflow' in pa_cols else None
                    c_st  = 'status'   if 'status'   in pa_cols else ('state' if 'state' in pa_cols else None)
                    c_by  = 'decided_by_id' if 'decided_by_id' in pa_cols else ('approver_id' if 'approver_id' in pa_cols else None)
                    c_at  = 'decided_at' if 'decided_at' in pa_cols else None
                    c_note= 'note' if 'note' in pa_cols else None
                    if c_pr and c_wf and c_st:
                        cols, vals = [c_pr, c_wf, c_st], [int(pr_id), 'DEPT_MANAGER', 'APPROVED']
                        if c_by:   cols.append(c_by);  vals.append(int(approver_id))
                        if c_at:   cols.append(c_at);  vals.append(None)  # NOW() سمت DB
                        if note and c_note: cols.append(c_note); vals.append(note[:500])
                        cur.execute(
                            f"INSERT INTO pr_approvals ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(vals))})",
                            tuple(vals)
                        )
            except Exception:
                pass

        # 4) سیگنال‌ها
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
                self.signals.dataChanged.emit("PURCHASING_LISTS_CHANGED")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
                self.signals.dataChanged.emit("TASKS_CHANGED")
        except Exception:
            pass

        print(f"[DBG:approve_pr] pr_id={pr_id} ma_updated={updated_ma}")
        return {"ok": True, "pr_id": int(pr_id), "ma_updated": int(updated_ma)}
    # END REWRITE: DB.approve_pr

    # BEGIN REWRITE: DB.reject_pr
    def reject_pr(self, pr_id: int, approver_id: int, reason: str = None) -> dict:
        """
        رد «مدیر واحد» روی یک PR.
        - وضعیت PR → «رد شده»
        - بستن همهٔ Pendingهای مرتبط در manager_approvals برای همین PR (workflow='DEPT_MANAGER')
        - ثبت تاریخچه (در صورت وجود pr_approvals)
        - ارسال سیگنال‌های UI
        """
        def _enum(name: str, fallback: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return fallback

        ST_REJECTED = _enum("REJECTED", "رد شده")

        with self.transaction() as cur:
            # 1) تغییر وضعیت PR
            pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
            pr_status = "status" if "status" in pr_cols else ("state" if "state" in pr_cols else None)
            if not pr_status:
                raise RuntimeError("ستون وضعیت در purchase_requests یافت نشد.")
            cur.execute("SELECT id FROM purchase_requests WHERE id=%s FOR UPDATE", (int(pr_id),))
            if not cur.fetchone():
                return {"ok": False, "msg": "PR not found", "pr_id": pr_id}
            cur.execute(f"UPDATE purchase_requests SET {pr_status}=%s WHERE id=%s", (ST_REJECTED, int(pr_id)))

            # 2) بستن Pending در manager_approvals
            updated_ma = 0
            try:
                cur.execute("SELECT to_regclass('public.manager_approvals')")
                if (cur.fetchone() or [None])[0]:
                    ma_cols = set(self._get_existing_columns("manager_approvals", cursor=cur))
                    ma_pr   = "purchase_request_id" if "purchase_request_id" in ma_cols else ("pr_id" if "pr_id" in ma_cols else None)
                    ma_st   = "status" if "status" in ma_cols else ("state" if "state" in ma_cols else None)
                    ma_wf   = "workflow" if "workflow" in ma_cols else None
                    ma_asg  = "assigned_manager_id" if "assigned_manager_id" in ma_cols else None
                    ma_by   = "decided_by_id" if "decided_by_id" in ma_cols else ("approver_id" if "approver_id" in ma_cols else None)
                    ma_at   = "decided_at" if "decided_at" in ma_cols else None
                    ma_note = "note" if "note" in ma_cols else None

                    if ma_pr and ma_st:
                        sets, params = [f"{ma_st}=%s"], ["Rejected"]
                        if ma_by:  sets.append(f"{ma_by}=%s");  params.append(int(approver_id))
                        if ma_at:  sets.append(f"{ma_at}=NOW()")
                        if reason and ma_note:
                            sets.append(f"{ma_note}=COALESCE({ma_note}, %s)"); params.append(reason[:500])

                        where, wparams = [f"{ma_pr}=%s", f"{ma_st}='Pending'"], [int(pr_id)]
                        if ma_wf:
                            where.append(f"({ma_wf}='DEPT_MANAGER' OR {ma_wf} IS NULL)")
                        if ma_asg:
                            where.append(f"({ma_asg}=%s OR {ma_asg} IS NULL)"); wparams.append(int(approver_id))

                        cur.execute(
                            f"UPDATE manager_approvals SET {', '.join(sets)} WHERE " + " AND ".join(where),
                            tuple(params + wparams)
                        )
                        updated_ma = cur.rowcount or 0
            except Exception as e:
                print(f"[DBG:reject_pr] skip manager_approvals update: {e}")

            # 3) تاریخچه اختیاری
            try:
                cur.execute("SELECT to_regclass('public.pr_approvals')")
                if (cur.fetchone() or [None])[0]:
                    pa_cols = set(self._get_existing_columns('pr_approvals', cursor=cur))
                    c_pr  = 'purchase_request_id' if 'purchase_request_id' in pa_cols else ('pr_id' if 'pr_id' in pa_cols else None)
                    c_wf  = 'workflow' if 'workflow' in pa_cols else None
                    c_st  = 'status'   if 'status'   in pa_cols else ('state' if 'state' in pa_cols else None)
                    c_by  = 'decided_by_id' if 'decided_by_id' in pa_cols else ('approver_id' if 'approver_id' in pa_cols else None)
                    c_at  = 'decided_at' if 'decided_at' in pa_cols else None
                    c_note= 'note' if 'note' in pa_cols else None
                    if c_pr and c_wf and c_st:
                        cols, vals = [c_pr, c_wf, c_st], [int(pr_id), 'DEPT_MANAGER', 'REJECTED']
                        if c_by:   cols.append(c_by);  vals.append(int(approver_id))
                        if c_at:   cols.append(c_at);  vals.append(None)  # NOW() سمت DB
                        if reason and c_note: cols.append(c_note); vals.append(reason[:500])
                        cur.execute(
                            f"INSERT INTO pr_approvals ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(vals))})",
                            tuple(vals)
                        )
            except Exception:
                pass

        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
                self.signals.dataChanged.emit("PURCHASING_LISTS_CHANGED")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
                self.signals.dataChanged.emit("TASKS_CHANGED")
        except Exception:
            pass

        print(f"[DBG:reject_pr] pr_id={pr_id} ma_updated={updated_ma}")
        return {"ok": True, "pr_id": int(pr_id), "ma_updated": int(updated_ma)}
    # END REWRITE: DB.reject_pr

    def withdraw_pr(self, pr_id: int, requester_id: int, reason: str = "") -> None:
        """انصراف درخواست‌دهنده؛ فقط اگر هنوز در صف مدیر واحد Pending باشد."""
        with self.transaction() as cur:
            # اگر جدول صف مدیر هست، Pending را لغو کن
            try:
                cur.execute("SELECT to_regclass('public.manager_approvals')")
                has = bool((cur.fetchone() or [None])[0])
            except Exception:
                has = False
            if has:
                ma_cols = set(self._get_existing_columns("manager_approvals", cursor=cur))
                c_pr = "purchase_request_id" if "purchase_request_id" in ma_cols else "pr_id"
                c_st = "status" if "status" in ma_cols else "state"
                cur.execute(f"UPDATE manager_approvals SET {c_st}='Withdrawn' WHERE {c_pr}=%s AND {c_st}='Pending'", (pr_id,))
            # وضعیت PR ← «لغو توسط درخواست‌دهنده»
            pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
            status_col = self._status_col_pr(cursor=cur) if hasattr(self, "_status_col_pr") else ("status" if "status" in pr_cols else "state")
            cur.execute(f"UPDATE purchase_requests SET {status_col}=%s WHERE id=%s", ("لغو توسط درخواست‌دهنده", pr_id))
            self._append_pr_history(pr_id, "WITHDRAWN_BY_REQUESTER", requester_id, reason, cursor=cur)
    # END ADD: DB.approve_pr / DB.reject_pr / DB.withdraw_pr
    
    def reopen_purchase_request(self, pr_id: int, user_id: int | None = None) -> None:
        """بازگشایی PR به وضعیت 'در انتظار تایید بازرگانی' (PostgreSQL)."""
        with self.transaction() as cur:
            cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            status_col = 'state' if 'state' in cols else 'status'
            from psycopg2 import sql as _sql
            cur.execute(_sql.SQL("UPDATE purchase_requests SET {c}=%s WHERE id=%s").format(
                c=_sql.Identifier(status_col)), ('در انتظار تایید بازرگانی', pr_id))
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, user_id, 'PR_REOPENED', f"PR#{pr_id} -> 'در انتظار تایید بازرگانی'")
            except Exception:
                pass
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass
        
    def cancel_purchase_order(self, po_id: int, canceller_id: int | None = None) -> None:
        """لغو PO فقط در صورت نبود دریافت ثبت‌شده (PostgreSQL)."""
        with self.transaction() as cur:
            cur.execute("SELECT to_regclass('public.receipts') IS NOT NULL AND to_regclass('public.receipt_items') IS NOT NULL")
            has_receipts = bool((cur.fetchone() or [False])[0])
            if has_receipts:
                r = self.execute_query("SELECT 1 FROM receipts WHERE po_id=%s LIMIT 1", (po_id,), fetch_one=True, cursor=cur)
                if r: raise RuntimeError("این PO دریافت دارد؛ لغو ممکن نیست.")
            else:
                r2 = self.execute_query(
                    "SELECT 1 FROM purchase_order_items WHERE po_id=%s AND COALESCE(received_qty,0)>0 LIMIT 1",
                    (po_id,), fetch_one=True, cursor=cur)
                if r2: raise RuntimeError("برای برخی آیتم‌ها دریافت ثبت شده است؛ لغو ممکن نیست.")

            cur.execute("UPDATE purchase_orders SET status='لغو شد' WHERE id=%s", (po_id,))
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, canceller_id, 'PO_CANCELED', f"PO#{po_id} canceled")
            except Exception:
                pass
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass
        
    # BEGIN REWRITE: DB.get_purchasing_kpis
    def get_purchasing_kpis(self) -> dict:
        """KPIهای کلیدی چرخه خرید (ایمن نسبت به نام ستون‌ها)."""
        with self.transaction() as cur:
            pr_cols  = set(self._get_existing_columns('purchase_requests', cursor=cur))
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            sq_cols  = set(self._get_existing_columns('supplier_quotes', cursor=cur))

            status_col = 'state' if 'state' in pr_cols else 'status'
            poi_pr_col = 'pr_id' if 'pr_id' in poi_cols else (
                'purchase_request_id' if 'purchase_request_id' in poi_cols else (
                'request_id' if 'request_id' in poi_cols else None))
            sq_pr_col  = 'pr_id' if 'pr_id' in sq_cols else (
                'purchase_request_id' if 'purchase_request_id' in sq_cols else (
                'request_id' if 'request_id' in sq_cols else None))
            winner_pred = self._quote_winner_predicate(alias='w', cursor=cur)

            # 1) PRهای قابل اقدام (وارد PO نشده‌اند)
            actionable_sql = f"""
                SELECT COUNT(1) AS c
                FROM purchase_requests pr
                WHERE COALESCE(pr.{status_col},'') IN ('در انتظار تایید بازرگانی','تامین‌کننده انتخاب شد','تایید شده توسط مدیرعامل','AWAITING_COMMERCE','READY_FOR_SOURCING')
                {("AND NOT EXISTS (SELECT 1 FROM purchase_order_items poi WHERE poi."+poi_pr_col+"=pr.id)") if poi_pr_col else ""}
            """
            actionable = self.execute_query(actionable_sql, fetch_one=True, cursor=cur) or {'c': 0}

            # 2) PRهای آماده سفارش (winner دارند و هنوز وارد PO نشده‌اند)
            ready_sql = f"""
                SELECT COUNT(1) AS c
                FROM purchase_requests pr
                JOIN supplier_quotes w ON w.{sq_pr_col}=pr.id AND {winner_pred}
                {("LEFT JOIN purchase_order_items poi ON poi."+poi_pr_col+"=pr.id") if poi_pr_col else ""}
                WHERE {("poi."+poi_pr_col+" IS NULL") if poi_pr_col else "TRUE"}
            """
            ready = self.execute_query(ready_sql, fetch_one=True, cursor=cur) or {'c': 0}

            open_pos    = self.execute_query(
                "SELECT COUNT(1) AS c FROM purchase_orders WHERE COALESCE(status,'باز') IN ('باز','بخشی دریافت شد')",
                fetch_one=True, cursor=cur) or {'c': 0}
            partial_pos = self.execute_query(
                "SELECT COUNT(1) AS c FROM purchase_orders WHERE COALESCE(status,'باز')='بخشی دریافت شد'",
                fetch_one=True, cursor=cur) or {'c': 0}

            def _v(x): return int(x['c'] if isinstance(x, dict) and 'c' in x else (x[0] if x else 0))
            return {
                'actionable_prs': _v(actionable),
                'ready_for_ordering': _v(ready),
                'open_pos': _v(open_pos),
                'partial_pos': _v(partial_pos),
            }
    # END REWRITE: DB.get_purchasing_kpis
        
    def list_receipts_for_po(self, po_id: int) -> list[dict]:
        """لیست رسیدهای یک PO (PostgreSQL)."""
        has = self.execute_query(
            "SELECT to_regclass('public.receipts') IS NOT NULL AND to_regclass('public.receipt_items') IS NOT NULL",
            fetch_one=True
        )
        if not has or not (has[0] if not isinstance(has, dict) else list(has.values())[0]):
            return []
        q = """
            SELECT r.id AS receipt_id, r.receipt_no, r.received_at, r.receiver_id,
                ri.po_item_id, ri.received_qty
            FROM receipts r
            JOIN receipt_items ri ON ri.receipt_id = r.id
            WHERE r.po_id = %s
            ORDER BY r.id DESC, ri.po_item_id
        """
        return self.execute_query(q, (po_id,)) or []
    
    def create_or_get_supplier(self, name: str, phone: str = "", email: str = "", is_active: int = 1) -> int:
        """ایجاد/بازیابی تامین‌کننده با نام یکتا (PostgreSQL)."""
        if not name or not str(name).strip():
            raise ValueError("نام تامین‌کننده الزامی است.")
        self.ensure_quote_schema()
        name = str(name).strip()
        with self.transaction() as cur:
            cur.execute(
                """INSERT INTO suppliers(name, phone, email, is_active)
                VALUES (%s,%s,%s,%s)
                ON CONFLICT (name) DO UPDATE SET
                    phone = EXCLUDED.phone,
                    email = EXCLUDED.email,
                    is_active = EXCLUDED.is_active
                RETURNING id""",
                (name, (phone or "").strip()[:64], (email or "").strip()[:128], bool(is_active))
            )
            sup_id = (cur.fetchone() or [None])[0]
            if not sup_id:
                cur.execute("SELECT id FROM suppliers WHERE name=%s", (name,))
                sup_id = (cur.fetchone() or [0])[0]
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, None, 'SUPPLIER_UPSERTED', f"SUP#{sup_id} '{name}'")
            except Exception:
                pass
        try:
            if hasattr(self, "signals"): self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass
        return int(sup_id)
    
    def update_supplier_quote(self, quote_id: int, unit_price: float | None = None, currency: str | None = None,
                            lead_time_days: int | None = None, min_order_qty: float | None = None,
                            notes: str | None = None, editor_user_id: int | None = None) -> None:
        """بروزرسانی فیلدهای یک کوئوت (PostgreSQL)."""
        self.ensure_quote_schema()
        sets, args = [], []
        if unit_price is not None:
            if float(unit_price) <= 0: raise ValueError("قیمت نامعتبر است.")
            sets.append("unit_price = %s"); args.append(float(unit_price))
        if currency is not None:
            sets.append("currency = %s"); args.append((currency or "IRR")[:8])
        if lead_time_days is not None:
            sets.append("lead_time_days = %s"); args.append(int(lead_time_days))
        if min_order_qty is not None:
            sets.append("min_order_qty = %s"); args.append(float(min_order_qty))
        if notes is not None:
            sets.append("notes = %s"); args.append((notes or "").strip()[:500])
        if not sets: return
        args.append(quote_id)
        with self.transaction() as cur:
            cur.execute(f"UPDATE supplier_quotes SET {', '.join(sets)} WHERE id = %s", tuple(args))
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, editor_user_id, 'QUOTE_UPDATED', f"QUOTE#{quote_id}")
            except Exception:
                pass
        try:
            if hasattr(self, "signals"): self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass
        
    def delete_supplier_quote(self, quote_id: int, user_id: int | None = None) -> None:
        """حذف کوئوت در صورت عدم استفاده و غیرِبرنده بودن (PostgreSQL)."""
        self.ensure_quote_schema()
        row = self.execute_query("SELECT id, pr_id, is_winner FROM supplier_quotes WHERE id=%s",
                                (quote_id,), fetch_one=True)
        if not row: return
        pr_id = int(row['pr_id'] if isinstance(row, dict) else row[1])
        is_winner = bool(row['is_winner'] if isinstance(row, dict) else row[2])
        if is_winner:
            raise RuntimeError("این کوئوت برنده است؛ ابتدا برنده‌بودن را لغو کنید.")
        used = self.execute_query("SELECT 1 FROM purchase_order_items WHERE pr_id=%s LIMIT 1",
                                (pr_id,), fetch_one=True)
        if used:
            raise RuntimeError("برای این PR آیتم سفارش وجود دارد؛ حذف کوئوت مجاز نیست.")
        with self.transaction() as cur:
            cur.execute("DELETE FROM supplier_quotes WHERE id=%s", (quote_id,))
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, user_id, 'QUOTE_DELETED', f"QUOTE#{quote_id} PR#{pr_id}")
            except Exception:
                pass
        try:
            if hasattr(self, "signals"): self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass
        
    def get_receivable_items(self) -> list[dict]:
        """
        همه آیتم‌های PO که هنوز باقی‌مانده دارند (remaining > 0) را می‌آورد.
        خروجی مناسب برای دریافت گروهی.
        """
        q = """
            WITH recv AS (
                SELECT ri.po_item_id, SUM(ri.received_qty) AS s
                FROM receipt_items ri
                JOIN receipts r ON r.id = ri.receipt_id
                GROUP BY ri.po_item_id
            )
            SELECT po.id AS po_id, po.order_no, COALESCE(po.status,'باز') AS status,
                poi.id AS po_item_id, poi.item_id, i.name AS item_name,
                poi.ordered_qty,
                COALESCE(poi.received_qty,0) + COALESCE(recv.s,0) AS received_qty,
                GREATEST(poi.ordered_qty - (COALESCE(poi.received_qty,0) + COALESCE(recv.s,0)), 0) AS remaining_qty
            FROM purchase_orders po
            JOIN purchase_order_items poi ON poi.po_id = po.id
            LEFT JOIN recv ON recv.po_item_id = poi.id
            LEFT JOIN items i ON i.id = poi.item_id
            WHERE COALESCE(po.status,'باز') IN ('باز','بخشی دریافت شد')
            AND GREATEST(poi.ordered_qty - (COALESCE(poi.received_qty,0) + COALESCE(recv.s,0)), 0) > 0
            ORDER BY po.id DESC, poi.id
        """
        return self.execute_query(q) or []
    
    # BEGIN REWRITE: DB.integrity_check_purchasing
    def integrity_check_purchasing(self) -> dict:
        """
        چک‌های سلامت سبک حوزه خرید (ایمن نسبت به نام ستون‌ها).
        برمی‌گرداند: {'pr_in_po_without_winner': N, 'winner_pr_wrong_status': N, 'empty_po_headers': N, 'over_received_items': N}
        """
        with self.transaction() as cur:
            pr_cols  = set(self._get_existing_columns('purchase_requests', cursor=cur))
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            sq_cols  = set(self._get_existing_columns('supplier_quotes', cursor=cur))

            status_col = 'state' if 'state' in pr_cols else 'status'
            poi_pr_col = 'pr_id' if 'pr_id' in poi_cols else (
                'purchase_request_id' if 'purchase_request_id' in poi_cols else (
                'request_id' if 'request_id' in poi_cols else None))
            sq_pr_col  = 'pr_id' if 'pr_id' in sq_cols else (
                'purchase_request_id' if 'purchase_request_id' in sq_cols else (
                'request_id' if 'request_id' in sq_cols else None))
            winner_pred = self._quote_winner_predicate(alias='w', cursor=cur)

            # 1) PRهایی که در PO آمده‌اند ولی winner ندارند
            c1 = self.execute_query(f"""
                SELECT COUNT(1) AS c
                FROM purchase_order_items poi
                LEFT JOIN supplier_quotes w ON w.{sq_pr_col} = poi.{poi_pr_col} AND {winner_pred}
                WHERE w.id IS NULL
            """, fetch_one=True, cursor=cur) or {'c': 0}

            # 2) PRهای winnerدار اما وضعیت ناسازگار
            c2 = self.execute_query(f"""
                SELECT COUNT(1) AS c
                FROM purchase_requests pr
                JOIN supplier_quotes w ON w.{sq_pr_col} = pr.id AND {winner_pred}
                WHERE COALESCE(pr.{status_col},'') NOT IN ('تامین‌کننده انتخاب شد','تایید شده توسط مدیرعامل','AWAITING_COMMERCE','READY_FOR_SOURCING','سفارش خرید صادر شد')
            """, fetch_one=True, cursor=cur) or {'c': 0}

            # 3) POهایی که آیتم ندارند (header یتیم)
            c3 = self.execute_query("""
                SELECT COUNT(1) AS c
                FROM purchase_orders po
                LEFT JOIN purchase_order_items poi ON poi.purchase_order_id = po.id
                WHERE poi.id IS NULL
            """, fetch_one=True, cursor=cur) or {'c': 0}

            # 4) آیتم‌های دریافت‌شده بیش از سفارش (اگر ستون‌ها باشد)
            c4 = self.execute_query("""
                SELECT COUNT(1) AS c
                FROM purchase_order_items poi
                JOIN receipt_items ri ON ri.po_item_id = poi.id
                WHERE COALESCE(ri.qty,0) > COALESCE(poi.qty,0)
            """, fetch_one=True, cursor=cur) or {'c': 0}

            def _v(x): return int(x['c'] if isinstance(x, dict) and 'c' in x else (x[0] if x else 0))
            return {
                'pr_in_po_without_winner': _v(c1),
                'winner_pr_wrong_status': _v(c2),
                'empty_po_headers': _v(c3),
                'over_received_items': _v(c4),
            }
    # END REWRITE: DB.integrity_check_purchasing

    def reject_purchase_request(self, pr_id: int, reason: str = "", user_id: int | None = None) -> None:
        """رد درخواست خرید و پاکسازی برنده‌ها (PostgreSQL)."""
        with self.transaction() as cur:
            cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            status_col = 'state' if 'state' in cols else 'status'
            from psycopg2 import sql as _sql
            cur.execute(_sql.SQL("UPDATE purchase_requests SET {c}='رد شد' WHERE id=%s").format(
                c=_sql.Identifier(status_col)), (pr_id,))
            cur.execute("UPDATE supplier_quotes SET is_winner=false WHERE pr_id=%s", (pr_id,))
            if 'selected_quote_id' in cols:
                cur.execute("UPDATE purchase_requests SET selected_quote_id=NULL WHERE id=%s", (pr_id,))
            try:
                if hasattr(self, "_log_atomic"):
                    msg = f"PR#{pr_id} rejected. {(('reason='+reason[:120]) if reason else '')}"
                    self._log_atomic(cur, user_id, 'PR_REJECTED', msg)
            except Exception:
                pass
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass

    # BEGIN REWRITE: DB.list_pr_groups_for_sourcing
    def list_pr_groups_for_sourcing(self, limit: int = 500, dept_id: int | None = None) -> list[dict]:
        """
        لیست فرم‌های خرید برای تب «بازرگانی/استعلام».
        خروجی: grp_key, physical_request_no, requester_name, dept_name, items_count, last_created,
                approver_name, approved_at
        - شمارهٔ فرم متنی و بدون تضاد نوع
        - بازیابی نام/زمان تأیید از ستون‌های گروه؛ اگر نبود، از آخرین PR همان فرم (LATERAL) می‌گیریم.
        - چاپ SQL و traceback
        """
        from psycopg2 import sql as _sql
        import traceback

        def _cols(t, cur):
            try:
                return set(self._get_existing_columns(t, cursor=cur))
            except Exception:
                return set()

        def _user_name_expr(alias: str, cur):
            try:
                return self._user_name_expr(alias, cur)
            except Exception:
                return (
                    f"COALESCE(NULLIF(TRIM({alias}.full_name),''),"
                    f"NULLIF(TRIM({alias}.first_name||' '||{alias}.last_name),''),"
                    f"NULLIF(TRIM({alias}.username),''),'')"
                )

        out = []
        with self.transaction() as cur:
            try:
                prc = _cols("purchase_requests", cur)
                pgc = _cols("purchase_request_groups", cur)
                uc  = _cols("users", cur)
                dc  = _cols("departments", cur)

                # ستون‌های گروه/PR
                c_pg_id   = "id"
                phys_cands = ("physical_request_no","physical_no","request_physical_no","form_no","form_number","pr_no","request_no","display_no")
                c_pg_phys = next((c for c in phys_cands if c in pgc), None)
                c_pr_phys = next((c for c in phys_cands if c in prc), None)

                c_pr_gid  = "group_id" if "group_id" in prc else ("request_group_id" if "request_group_id" in prc else None)
                c_pr_cdt  = "request_date" if "request_date" in prc else ("created_at" if "created_at" in prc else None)
                c_pg_cdt  = "created_at" if "created_at" in pgc else ("created_on" if "created_on" in pgc else None)

                c_pg_req  = "requester_id" if "requester_id" in pgc else ("created_by_id" if "created_by_id" in pgc else None)
                c_pr_req  = "requester_id" if "requester_id" in prc else ("user_id" if "user_id" in prc else None)

                c_pg_dept = "original_department_id" if "original_department_id" in pgc else ("department_id" if "department_id" in pgc else None)
                c_pr_dept = "original_department_id" if "original_department_id" in prc else ("department_id" if "department_id" in prc else None)

                # تأییدکننده/زمان تأیید
                c_pg_appr   = next((c for c in ("approved_by_id","approver_id","ceo_approver_id") if c in pgc), None)
                c_pg_apprat = next((c for c in ("approved_at","approval_at","ceo_approved_at","approved_on") if c in pgc), None)
                c_pr_appr   = next((c for c in ("approved_by_id","approver_id","ceo_approver_id") if c in prc), None)
                c_pr_apprat = next((c for c in ("approved_at","approval_at","ceo_approved_at","approved_on") if c in prc), None)

                req_name_expr  = _user_name_expr("u", cur) if uc else "''"
                dept_name_expr = "d.name" if "name" in dc else "''"
                appr_name_expr = _user_name_expr("ua", cur) if uc else "''"

                # فیلتر واحد
                where_parts = [_sql.SQL("TRUE")]
                params = []
                if dept_id is not None:
                    where_parts.append(
                        _sql.SQL("COALESCE(pr.{pr_dept}, pg.{pg_dept}) = %s").format(
                            pr_dept=_sql.Identifier(c_pr_dept or "department_id"),
                            pg_dept=_sql.Identifier(c_pg_dept or (c_pr_dept or "department_id"))
                        )
                    )
                    params.append(int(dept_id))

                # شمارهٔ فرم به متن
                pg_phys_txt = _sql.SQL("pg.{c}::text").format(c=_sql.Identifier(c_pg_phys)) if c_pg_phys else _sql.SQL("NULL")
                pr_phys_txt = _sql.SQL("pr.{c}::text").format(c=_sql.Identifier(c_pr_phys)) if c_pr_phys else _sql.SQL("NULL")
                phys_display = _sql.SQL("MAX(COALESCE({a}, {b}, pg.{id}::text))").format(a=pg_phys_txt, b=pr_phys_txt, id=_sql.Identifier(c_pg_id))

                # زیرکوئری LATERAL برای گرفتن آخرین تایید از PR در صورت نبود ستون گروه
                lateral_parts = []
                if not (c_pg_appr and c_pg_apprat) and (c_pr_appr and c_pr_apprat and c_pr_gid):
                    lateral_parts.append(_sql.SQL("""
                        LEFT JOIN LATERAL (
                            SELECT pr2.{appr} AS appr_id, pr2.{apprat} AS appr_at
                            FROM purchase_requests pr2
                            WHERE pr2.{gid} = pg.{pgid} AND pr2.{appr} IS NOT NULL
                            ORDER BY pr2.{apprat} DESC NULLS LAST
                            LIMIT 1
                        ) lastpr ON TRUE
                    """).format(
                        appr=_sql.Identifier(c_pr_appr),
                        apprat=_sql.Identifier(c_pr_apprat),
                        gid=_sql.Identifier(c_pr_gid),
                        pgid=_sql.Identifier(c_pg_id)
                    ))

                # انتخاب نام/زمان تایید
                appr_id_select = _sql.SQL("pg.{a}").format(a=_sql.Identifier(c_pg_appr)) if c_pg_appr else (_sql.SQL("lastpr.appr_id") if lateral_parts else _sql.SQL("NULL"))
                appr_at_select = _sql.SQL("pg.{a}").format(a=_sql.Identifier(c_pg_apprat)) if c_pg_apprat else (_sql.SQL("lastpr.appr_at") if lateral_parts else _sql.SQL("NULL"))

                # JOIN های اصلی
                joins = [
                    _sql.SQL("LEFT JOIN purchase_request_groups pg ON pg.id = pr.{gid}").format(gid=_sql.Identifier(c_pr_gid or "group_id")),
                    _sql.SQL("LEFT JOIN users u ON u.id = COALESCE(pg.{pg_req}, pr.{pr_req})").format(
                        pg_req=_sql.Identifier(c_pg_req or (c_pr_req or "requester_id")),
                        pr_req=_sql.Identifier(c_pr_req or "requester_id")
                    ),
                    _sql.SQL("LEFT JOIN departments d ON d.id = COALESCE(pg.{pg_dept}, pr.{pr_dept})").format(
                        pg_dept=_sql.Identifier(c_pg_dept or (c_pr_dept or "original_department_id")),
                        pr_dept=_sql.Identifier(c_pr_dept or "original_department_id")
                    )
                ]
                if lateral_parts:
                    joins.append(lateral_parts[0])
                    joins.append(_sql.SQL("LEFT JOIN users ua ON ua.id = lastpr.appr_id"))
                else:
                    joins.append(_sql.SQL("LEFT JOIN users ua ON ua.id = {appr_id}").format(appr_id=appr_id_select))

                q = _sql.SQL("""
                    SELECT
                        pg.{pgid} AS grp_key,
                        {phys_display} AS physical_request_no,
                        {req_name} AS requester_name,
                        COALESCE({dept_name}, '') AS dept_name,
                        COUNT(pr.id) AS items_count,
                        MAX(COALESCE(pr.{pr_cdt}, pg.{pg_cdt})) AS last_created,
                        {appr_name} AS approver_name,
                        {appr_at}   AS approved_at
                    FROM purchase_requests pr
                    {joins}
                    WHERE {where_all}
                    GROUP BY pg.{pgid}, {req_name}, {dept_name}, {appr_name}, {appr_at}
                    ORDER BY MAX(COALESCE(pr.{pr_cdt}, pg.{pg_cdt})) DESC
                    LIMIT %s
                """).format(
                    pgid=_sql.Identifier(c_pg_id),
                    phys_display=phys_display,
                    req_name=_sql.SQL(req_name_expr),
                    dept_name=_sql.SQL(dept_name_expr),
                    pr_cdt=_sql.Identifier(c_pr_cdt or "id"),
                    pg_cdt=_sql.Identifier(c_pg_cdt or "id"),
                    appr_name=_sql.SQL(appr_name_expr),
                    appr_at=appr_at_select,
                    joins=_sql.SQL("\n").join(joins),
                    where_all=_sql.SQL(" AND ").join(where_parts)
                )

                params.append(int(limit))
                try:
                    print("\n[SQL:list_pr_groups_for_sourcing]\n", cur.mogrify(q, params).decode("utf-8","ignore"), "\n")
                except Exception:
                    pass

                cur.execute(q, params)
                rows = cur.fetchall() or []
                cols = [d.name if hasattr(d, "name") else d[0] for d in cur.description]
                for r in rows:
                    rec = dict(zip(cols, r))
                    out.append({
                        "grp_key": int(rec.get("grp_key")) if rec.get("grp_key") is not None else None,
                        "physical_request_no": rec.get("physical_request_no") or "",
                        "requester_name": rec.get("requester_name") or "",
                        "dept_name": rec.get("dept_name") or "",
                        "items_count": int(rec.get("items_count") or 0),
                        "last_created": rec.get("last_created"),
                        "approver_name": rec.get("approver_name") or "",
                        "approved_at": rec.get("approved_at"),
                    })
            except Exception as e:
                print("[ERR:list_pr_groups_for_sourcing]", e)
                print(traceback.format_exc())
                raise
        return out
    # END REWRITE: DB.list_pr_groups_for_sourcing
    
    # داخل کلاس DB
    def _safe(self, sql_txt: str, params=None, tag: str = None):
        try:
            if tag:
                print(f"[SQL:{tag}]\n{sql_txt.strip()}\n")
            with self._conn() as cn:
                with cn.cursor(cursor_factory=DictCursor) as cur:
                    cur.execute(sql_txt, params or [])
                    if cur.description:
                        return [dict(r) for r in cur.fetchall()]
                    return []
        except Exception as e:
            print(f"[ERR{':' + tag if tag else ''}] {e}\n{traceback.format_exc()}")
            raise

    def _table_exists(self, table_name: str, cur=None, **kw) -> bool:
        """Checks if a table exists in the current search_path, honoring optional cursors."""
        using_param = 'cur' if cur is not None else 'none'
        if cur is None:
            cur = kw.get('cursor')
            if cur is not None:
                using_param = 'cursor'

        sql = "SELECT 1 FROM information_schema.tables WHERE table_schema = ANY (current_schemas(TRUE)) AND table_name = %s LIMIT 1"

        exists = False
        if cur is not None:
            cur.execute(sql, (table_name,))
            exists = cur.fetchone() is not None
        else:
            rows = self._safe(sql, (table_name,), tag='table_exists')
            exists = bool(rows)

        if DEBUG_DB_RESOLVE:
            print(f"[TRACE:DB:_table_exists] using_param={using_param} table={table_name} exists={int(bool(exists))}")

        return bool(exists)

    def _column_exists(self, table_name: str, col_name: str) -> bool:
        q = """SELECT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema='public' AND table_name=%s AND column_name=%s)"""
        r = self._safe(q, (table_name, col_name), tag="column_exists")
        return bool(r and list(r[0].values())[0])

            
    # BEGIN REWRITE: DB.list_pr_items_for_sourcing
    def list_pr_items_for_sourcing(self, group_key: int):
        """
        اقلام فرم برای صفحه‌ی بازرگانی (sourcing).
        - فقط خواندن؛ بدون دست‌کاری داده.
        - هیچ فیلتر تایید/وضعیت روی سطرهای PR اعمال نمی‌شود؛
        فرض این است که «فهرست فرم‌ها» قبلاً مسیر تایید را پوشش می‌دهد.
        """
        try:
            gid = int(group_key)
        except Exception:
            print(f"[WARN:list_pr_items_for_sourcing] bad group_key={group_key!r}")
            return []

        sql = """
            SELECT
                pr.id,
                CASE
                    WHEN i."name" IS NOT NULL
                        THEN COALESCE(p."name" || ' / ', '') || i."name"
                    ELSE i."name"
                END AS item_name,
                pr."requested_qty"                                   AS requested_qty,
                COALESCE(pr."urgency", pr."urgency_suggested", '')   AS final_urgency,
                COALESCE(NULLIF(TRIM(pr."specs")::text, ''), '')     AS specs,
                COALESCE(NULLIF(TRIM(pr."notes")::text, ''), '')     AS notes,
                (
                    SELECT COUNT(1)
                    FROM "purchase_request_attachments" a
                    WHERE a."pr_id" = pr.id
                )                                                    AS attachments_count
            FROM purchase_requests pr
            LEFT JOIN items i ON i.id = pr."item_id"
            LEFT JOIN items p ON p.id = i."parent_item_id"
            WHERE pr."group_id" = %s
            ORDER BY pr.id
        """
        rows = self._safe(sql, (gid,), tag="list_pr_items_for_sourcing")
        print(f"[DBG:list_pr_items_for_sourcing] returned_rows={len(rows)}")
        return rows
    # END REWRITE: DB.list_pr_items_for_sourcing
    
    
    def list_my_pr_groups_overview(self, user_id: int, limit: int = 200, offset: int = 0) -> list[dict]:
        """
        خلاصه‌ی فرم‌های PR کاربر (گروه‌محور) برای «پیگیری درخواست‌های من».
        خروجی: [{group_id, physical_no, items_count, dept_name, requester_name,
                stage_label, next_actor, created_at, created_at_fmt}]
        فقط ۱ ردیف به‌ازای هر فرم (group_id) برمی‌گرداند؛ اقلام در جزئیات فرم لود می‌شوند.
        """
        if not user_id:
            return []

        import datetime as _dt

        def _pick(cols: set, *names):
            for n in names:
                if n in cols:
                    return n
            return None

        out: list[dict] = []
        with self.transaction() as cur:
            # تشخیص ستون‌ها برای سازگاری با اسکیماهای مختلف
            pr_cols  = set(self._get_existing_columns("purchase_requests", cursor=cur))
            pg_cols  = set(self._get_existing_columns("purchase_request_groups", cursor=cur))
            usr_cols = set(self._get_existing_columns("users", cursor=cur))
            dep_cols = set(self._get_existing_columns("departments", cursor=cur))

            # ستون‌های کلیدی PR
            c_pr_gid   = _pick(pr_cols, "group_id", "request_group_id")
            c_pr_req   = _pick(pr_cols, "requester_id", "user_id", "created_by_id")
            c_pr_stat  = _pick(pr_cols, "status", "state", "approval_status")
            c_pr_cdt   = _pick(pr_cols, "request_date", "created_at", "created_on", "created_date", "date")
            c_pr_phys  = _pick(pr_cols, "physical_request_no", "physical_no", "group_physical_no", "pr_no", "form_no", "request_no")
            c_pr_urg   = _pick(pr_cols, "final_urgency", "urgency", "priority")

            # ستون‌های گروه
            c_pg_id    = _pick(pg_cols, "id")
            c_pg_phys  = _pick(pg_cols, "physical_request_no", "physical_no", "form_no", "group_no", "pr_no", "request_no")
            c_pg_req   = _pick(pg_cols, "requester_id", "created_by_id")
            c_pg_dept  = _pick(pg_cols, "original_department_id", "department_id")
            c_pg_cdt   = _pick(pg_cols, "created_at", "created_on", "created_date")

            # نام کاربر
            name_expr = "'-'"
            if usr_cols:
                name_expr = "COALESCE(u.full_name, u.name, u.username, u.email, '-')"

            # اتصال به users و departments (ستون‌آگاه)
            join_user = "LEFT JOIN users u ON u.id = COALESCE(pg.{pg_req}, pr.{pr_req})".format(
                pg_req=c_pg_req or "requester_id", pr_req=c_pr_req or "requester_id"
            ) if usr_cols else ""

            dept_expr_parts = []
            if c_pg_dept: dept_expr_parts.append(f"pg.{c_pg_dept}")
            if _pick(pr_cols, "original_department_id", "department_id"):
                dept_expr_parts.append("COALESCE(pr.original_department_id, pr.department_id)")
            dep_join = ""
            if dep_cols and dept_expr_parts:
                dep_join = f"LEFT JOIN departments d ON d.id = COALESCE({', '.join(dept_expr_parts)})"

            # عبارت شماره فیزیکی فرم (گروه مقدم است؛ بعد PR)
            phys_parts = []
            if c_pg_phys: phys_parts.append(f"pg.{c_pg_phys}::text")
            if c_pr_phys: phys_parts.append(f"MIN(pr.{c_pr_phys}::text)")
            phys_expr = "COALESCE(" + ", ".join(phys_parts + ["'---'"]) + ")"

            # عبارت تاریخ ایجاد (بدون MIN(None))
            created_parts = []
            if c_pg_cdt: created_parts.append(f"pg.{c_pg_cdt}")
            if c_pr_cdt: created_parts.append(f"MIN(pr.{c_pr_cdt})")
            created_expr = "COALESCE(" + (", ".join(created_parts) if created_parts else "NULL") + ", NOW())"

            # وضعیت‌ها برای تعیین مرحله/بازیگر بعدی
            ST_AW_MGR = 'در انتظار تایید مدیر واحد'
            ST_AW_CEO = 'در انتظار تایید مدیرعامل'
            COMMERCE_BUCKET = "('ارجاع به کارپرداز','در حال استعلام','آماده اقدام بازرگانی','تایید مدیرعامل','در حال خرید','آماده ورود به انبار')"

            # اتصال به جدول گروه
            if not (c_pg_id and c_pr_gid and c_pr_stat and c_pr_req):
                return []

            sql = f"""
                SELECT
                    pg.{c_pg_id}                                 AS group_id,
                    {phys_expr}                                  AS physical_no,
                    COUNT(pr.id)                                 AS items_count,
                    COALESCE(d.name, '')                         AS dept_name,
                    {name_expr}                                  AS requester_name,
                    -- شمارش مرحله‌ها
                    SUM(CASE WHEN pr.{c_pr_stat} = %s THEN 1 ELSE 0 END) AS cnt_mgr,
                    SUM(CASE WHEN pr.{c_pr_stat} = %s THEN 1 ELSE 0 END) AS cnt_ceo,
                    SUM(CASE WHEN pr.{c_pr_stat} IN {COMMERCE_BUCKET} THEN 1 ELSE 0 END) AS cnt_commerce,
                    SUM(CASE WHEN pr.{c_pr_stat} IN ('انبار شده','بسته','تکمیل') THEN 1 ELSE 0 END) AS cnt_done,
                    {created_expr}                               AS created_at
                FROM purchase_request_groups pg
                LEFT JOIN purchase_requests pr ON pr.{c_pr_gid} = pg.{c_pg_id}
                {join_user}
                {dep_join}
                WHERE COALESCE({('pg.'+c_pg_req) if c_pg_req else 'NULL'}, pr.{c_pr_req}) = %s
                GROUP BY pg.{c_pg_id}, d.name, {name_expr}
                ORDER BY created_at DESC NULLS LAST, pg.{c_pg_id} DESC
                LIMIT %s OFFSET %s
            """
            cur.execute(sql, (ST_AW_MGR, ST_AW_CEO, int(user_id), int(limit), int(offset)))
            rows = cur.fetchall() or []
            cols = [d.name for d in cur.description]

            for r in rows:
                rec = {cols[i]: r[i] for i in range(len(cols))}
                cnt_mgr = int(rec.get("cnt_mgr") or 0)
                cnt_ceo = int(rec.get("cnt_ceo") or 0)
                cnt_com = int(rec.get("cnt_commerce") or 0)
                cnt_done= int(rec.get("cnt_done") or 0)
                items   = int(rec.get("items_count") or 0)

                if cnt_mgr > 0:
                    next_actor = "مدیر واحد"; stage = "در انتظار تایید مدیر واحد"
                elif cnt_ceo > 0:
                    next_actor = "مدیرعامل"; stage = "در انتظار تایید مدیرعامل"
                elif cnt_com > 0:
                    next_actor = "بازرگانی"; stage = "در حال اقدام بازرگانی"
                elif items > 0 and cnt_done == items:
                    next_actor = "—"; stage = "تکمیل شده"
                else:
                    next_actor = "—"; stage = "—"

                ct = rec.get("created_at")
                ct_fmt = ""
                if isinstance(ct, (_dt.datetime, _dt.date)):
                    try:
                        ct_fmt = ct.strftime("%Y-%m-%d %H:%M") if hasattr(ct, "strftime") else str(ct)
                    except Exception:
                        ct_fmt = str(ct or "")

                out.append({
                    "group_id": rec.get("group_id"),
                    "physical_no": (rec.get("physical_no") or "---"),
                    "items_count": items,
                    "dept_name": rec.get("dept_name") or "",
                    "requester_name": rec.get("requester_name") or "-",
                    "stage_label": stage,
                    "next_actor": next_actor,
                    "created_at": ct,
                    "created_at_fmt": ct_fmt
                })

        return out

    
    def assign_pr_to_agent(self, pr_id: int, agent_user_id: int) -> bool:
        """
        ارجاع PR به کارپرداز (PostgreSQL).
        فقط وقتی مجاز است که PR وارد PO نشده و برنده‌ای هم ست نشده باشد.
        """
        if not pr_id or not agent_user_id:
            return False
        with self.transaction() as cur:
            # وجود PR
            row = self.execute_query("SELECT id FROM purchase_requests WHERE id=%s", (pr_id,), fetch_one=True, cursor=cur)
            if not row: return False
            # در PO نباشد
            used = self.execute_query("SELECT 1 FROM purchase_order_items WHERE pr_id=%s LIMIT 1", (pr_id,), fetch_one=True, cursor=cur)
            if used: return False
            # برنده نداشته باشد
            win = self.execute_query("SELECT 1 FROM supplier_quotes WHERE pr_id=%s AND is_winner=TRUE LIMIT 1",
                                    (pr_id,), fetch_one=True, cursor=cur)
            if win: return False

            cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            status_col = 'state' if 'state' in cols else 'status'
            from psycopg2 import sql as _sql
            # ارجاع + وضعیت
            cur.execute(_sql.SQL("""
                UPDATE purchase_requests
                SET agent_assignee_id=%s,
                    agent_assigned_at=COALESCE(agent_assigned_at, NOW()),
                    {c}='ارجاع به کارپرداز'
                WHERE id=%s
            """).format(c=_sql.Identifier(status_col)), (agent_user_id, pr_id))
            ok = (cur.rowcount or 0) > 0
            try:
                if ok and hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, agent_user_id, 'PR_ASSIGNED_TO_AGENT', f"PR#{pr_id}")
            except Exception: pass
        try:
            if ok and hasattr(self, "signals"): self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception: pass
        return bool(ok)

    # BEGIN REWRITE: DB.list_prs_for_agent
    def list_prs_for_agent(self) -> list[dict]:
        """
        لیست PRهای ارجاع‌شده به کارپرداز (Agent).
        - بدون وابستگی به u.name؛ از _user_name_expr استفاده می‌شود.
        - ستون واحد/مشخصات اگر در items نبودند، به‌صورت امن خالی می‌آیند.
        """
        with self.transaction() as cur:
            it_cols = set(self._get_existing_columns('items', cursor=cur))
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            u_cols  = set(self._get_existing_columns('users', cursor=cur))
            d_cols  = set(self._get_existing_columns('departments', cursor=cur))

            unit_expr  = "i.unit_name" if 'unit_name' in it_cols else "''"
            specs_expr = "i.specs" if 'specs' in it_cols else "''"

            try:
                req_name_expr = self._user_name_expr('u', cursor=cur)
            except Exception:
                # فالبک اگر helper نباشد
                req_name_expr = "COALESCE(u.full_name, u.username, u.email, '-')"

            # منبع دپارتمان: اول از PR، بعد از user
            dep_candidates = []
            if 'original_department_id' in pr_cols: dep_candidates.append("pr.original_department_id")
            if 'department_id' in pr_cols:          dep_candidates.append("pr.department_id")
            if 'department_id' in u_cols:           dep_candidates.append("u.department_id")
            dep_id_expr = ("COALESCE(" + ", ".join(dep_candidates) + ")") if dep_candidates else "NULL"
            dept_join = f"LEFT JOIN departments d ON d.id = {dep_id_expr}" if d_cols else "LEFT JOIN departments d ON 1=0"

            # فیلدهای مقدار/یادداشت ممکن است تفاوت نام داشته باشند
            qty_expr   = "COALESCE(pr.requested_qty, pr.quantity, pr.qty)" if any(c in pr_cols for c in ('requested_qty','quantity','qty')) else "NULL"
            notes_expr = "COALESCE(pr.notes, pr.note, '')"

            sql = f"""
                SELECT
                    COALESCE(i.name,'')        AS item_name,
                    {qty_expr}                  AS requested_qty,
                    COALESCE({unit_expr},'')    AS unit_name,
                    COALESCE({specs_expr},'')   AS specs,
                    {notes_expr}                AS notes,
                    {req_name_expr}             AS requester_name,
                    COALESCE(d.name,'')         AS dept_name
                FROM purchase_requests pr
                LEFT JOIN items i ON i.id = pr.item_id
                LEFT JOIN users u ON u.id = pr.requester_id
                {dept_join}
                WHERE pr.agent_assignee_id IS NOT NULL
                ORDER BY pr.agent_assigned_at DESC NULLS LAST, pr.id DESC
            """
            cur.execute(sql)
            rows = cur.fetchall() or []
            out = []
            for r in rows:
                item_name, requested_qty, unit_name, specs, notes, requester_name, dept_name = r
                out.append({
                    "item_name": item_name or "",
                    "requested_qty": float(requested_qty) if requested_qty is not None else None,
                    "unit_name": unit_name or "",
                    "specs": specs or "",
                    "notes": notes or "",
                    "requester_name": requester_name or "-",
                    "dept_name": dept_name or "",
                })
            return out
    # END REWRITE: DB.list_prs_for_agent
    
    # BEGIN ADD: DB.ensure_pr_attachments_schema
    def ensure_pr_attachments_schema(self):
        """
        تضمین ساختار پیوست‌های PR (idempotent). هیچ وابستگی یا اسکیمای جدید خارج از مسیر موجود اضافه نمی‌کند.
        جدول هدف: purchase_request_attachments
        ستون‌ها: id, pr_id, line_id (اختیاری), filename, file_data (BYTEA), size_bytes, uploaded_at
        """
        sql = r"""
        DO $$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='purchase_request_attachments') THEN
                CREATE TABLE purchase_request_attachments (
                    id SERIAL PRIMARY KEY,
                    pr_id INTEGER REFERENCES purchase_requests(id) ON DELETE CASCADE,
                    line_id INTEGER NULL,
                    filename TEXT NOT NULL,
                    file_data BYTEA NOT NULL,
                    size_bytes INTEGER,
                    uploaded_at TIMESTAMPTZ DEFAULT NOW()
                );
                CREATE INDEX IF NOT EXISTS idx_pra_pr ON purchase_request_attachments(pr_id);
                CREATE INDEX IF NOT EXISTS idx_pra_line ON purchase_request_attachments(line_id);
            ELSE
                -- مهاجرت‌های سبک و سازگار با عقب‌رو
                IF NOT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_name='purchase_request_attachments' AND column_name='file_data'
                ) THEN
                    ALTER TABLE purchase_request_attachments ADD COLUMN file_data BYTEA;
                END IF;
                IF NOT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_name='purchase_request_attachments' AND column_name='line_id'
                ) THEN
                    ALTER TABLE purchase_request_attachments ADD COLUMN line_id INTEGER NULL;
                END IF;
                IF NOT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_name='purchase_request_attachments' AND column_name='size_bytes'
                ) THEN
                    ALTER TABLE purchase_request_attachments ADD COLUMN size_bytes INTEGER;
                END IF;
                IF NOT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_name='purchase_request_attachments' AND column_name='uploaded_at'
                ) THEN
                    ALTER TABLE purchase_request_attachments ADD COLUMN uploaded_at TIMESTAMPTZ DEFAULT NOW();
                END IF;
                CREATE INDEX IF NOT EXISTS idx_pra_pr ON purchase_request_attachments(pr_id);
                CREATE INDEX IF NOT EXISTS idx_pra_line ON purchase_request_attachments(line_id);
            END IF;
        END $$;
        """
        try:
            if hasattr(self, "execute_sql_block"):
                self.execute_sql_block(sql)
            else:
                with self.transaction() as cur:
                    cur.execute(sql)
        except Exception:
            # سازگار با محیط‌هایی که دسترسی به DO $$ ندارند
            with self.transaction() as cur:
                cur.execute("SELECT to_regclass('public.purchase_request_attachments')")
                has = bool((cur.fetchone() or [None])[0])
                if not has:
                    cur.execute("""
                        CREATE TABLE purchase_request_attachments (
                            id SERIAL PRIMARY KEY,
                            pr_id INTEGER REFERENCES purchase_requests(id) ON DELETE CASCADE,
                            line_id INTEGER NULL,
                            filename TEXT NOT NULL,
                            file_data BYTEA NOT NULL,
                            size_bytes INTEGER,
                            uploaded_at TIMESTAMPTZ DEFAULT NOW()
                        )""")
                    cur.execute("CREATE INDEX IF NOT EXISTS idx_pra_pr ON purchase_request_attachments(pr_id)")
                    cur.execute("CREATE INDEX IF NOT EXISTS idx_pra_line ON purchase_request_attachments(line_id)")
    # END ADD: DB.ensure_pr_attachments_schema
    
    # BEGIN REWRITE: DB.fetch_pr_attachment
    def fetch_pr_attachment(self, attachment_id: int | None = None,
                            pr_id: int | None = None,
                            filename: str | None = None,
                            cursor=None):
        """
        خروجی یکی از این‌هاست:
        {'filename': str, 'data': bytes}  یا  {'filename': str, 'path': str}  یا  {'filename': str, 'url': str}
        یا None اگر چیزی پیدا نشود.
        """
        tables   = ["purchase_request_attachments", "pr_attachments", "attachments", "purchase_request_files"]
        data_cols = ["file_data", "data", "blob", "content"]
        path_cols = ["file_path", "path", "fs_path", "local_path"]
        url_cols  = ["url", "uri", "link", "href"]
        name_cols = ["filename", "name", "file_name"]

        def _select_any(cur, t: str, where_sql: str, params: tuple):
            cols = set(self._get_existing_columns(t, cursor=cur) or [])
            if not cols:
                return None
            sel = [c for c in (name_cols + data_cols + path_cols + url_cols) if c in cols]
            if not sel:
                return None
            cur.execute(f"SELECT {', '.join(sel)} FROM {t} {where_sql} ORDER BY id DESC LIMIT 1", params)
            row = cur.fetchone()
            if not row:
                return None
            rec = {sel[i]: row[i] for i in range(len(sel))}
            fn = rec.get("filename") or rec.get("name") or rec.get("file_name") or (filename or "file")

            # bytes
            for c in data_cols:
                v = rec.get(c)
                if isinstance(v, (bytes, bytearray, memoryview)):
                    return {"filename": fn, "data": bytes(v)}
            # path
            for c in path_cols:
                v = rec.get(c)
                if v:
                    return {"filename": fn, "path": str(v)}
            # url
            for c in url_cols:
                v = rec.get(c)
                if v:
                    return {"filename": fn, "url": str(v)}
            return {"filename": fn}

        with self.transaction() as cur:
            # با id
            if attachment_id:
                for t in tables:
                    try:
                        hit = _select_any(cur, t, "WHERE id=%s", (int(attachment_id),))
                        if hit: return hit
                    except Exception:
                        continue
            # با (pr_id, filename)
            if pr_id and filename:
                for t in tables:
                    try:
                        cols = set(self._get_existing_columns(t, cursor=cur) or [])
                        if not cols: continue
                        pr_col = next((c for c in ("purchase_request_id","pr_id","request_id","object_id","entity_id") if c in cols), None)
                        nm_col = next((c for c in name_cols if c in cols), None)
                        if not (pr_col and nm_col): continue
                        where_extra = ""
                        for mark in ("entity","entity_type","model","ref_table","doc_type","object_type"):
                            if mark in cols:
                                where_extra = f" AND (LOWER({mark}) LIKE '%%purchase_request%%' OR {mark}='PR')"
                                break
                        hit = _select_any(cur, t, f"WHERE {pr_col}=%s AND {nm_col}=%s{where_extra}", (int(pr_id), filename))
                        if hit: return hit
                    except Exception:
                        continue
        return None
    # END REWRITE: DB.fetch_pr_attachment

    def get_pr_attachment_data(self, attachment_id: int) -> dict | None:
        """نام و محتوای باینری یک پیوست مشخص را برمی‌گرداند."""
        return self.execute_query(
            "SELECT filename, file_data FROM purchase_request_attachments WHERE id = %s",
            (attachment_id,), fetch_one=True
        )
        
    def get_pr_ids_ready_for_supplier(self, supplier_id: int) -> list[int]:
        """PRهایی که winner آن‌ها همین تامین‌کننده است و هنوز در PO نیامده‌اند (PostgreSQL)."""
        q = """
            SELECT pr.id
            FROM purchase_requests pr
            JOIN supplier_quotes w ON w.pr_id = pr.id AND w.is_winner = true
            WHERE w.supplier_id = %s
            AND COALESCE(pr.status, pr.state, '') IN ('تامین‌کننده انتخاب شد','تایید شده توسط مدیرعامل')
            AND NOT EXISTS (SELECT 1 FROM purchase_order_items poi WHERE poi.pr_id = pr.id)
            ORDER BY pr.id
        """
        rows = self.execute_query(q, (supplier_id,)) or []
        out: list[int] = []
        for r in rows:
            out.append(int(r['id'] if isinstance(r, dict) else r[0]))
        return out

    # [FUNC: DB.find_item_by_sku] — پذیرش فقط child یا آیتمِ مستقل (بدون فرزند)
    def find_item_by_sku(self, s: str) -> dict | None:
        """SKU/کد → رکورد آیتم. اگر مادرِ دارای فرزند باشد، is_parent=True برمی‌گرداند."""
        s = (s or "").strip()
        if not s:
            return None

        code_cols = self._get_existing_columns('items', ['sku', 'code', 'item_code', 'barcode', 'part_code'])
        if not code_cols:
            return None

        pcol = self.get_parent_column()
        where = ' OR '.join([f"{c}=%s" for c in code_cols])
        params = tuple([s] * len(code_cols))
        row = self.execute_query(
            f"SELECT id, name, unit_id, {pcol or 'NULL'} AS parent_id FROM items WHERE {where} LIMIT 1",
            params, fetch_one=True
        )
        if not row:
            return None

        # مادر؟ فقط وقتی «واقعاً» مادر است که فرزند داشته باشد
        if not row.get('parent_id'):
            if pcol:
                has_child = self.execute_query(
                    f"SELECT 1 FROM items WHERE {pcol}=%s LIMIT 1", (row['id'],), fetch_one=True
                )
                if has_child:  # مادرِ واقعی ⇒ انتخاب‌ناپذیر
                    row['is_parent'] = True
                    return row
            # آیتمِ مستقل (بدون فرزند)
            row['is_parent'] = False
            return row

        # child
        row['is_parent'] = False
        return row
    
    
    def get_sku_for_item(self, item_id: int) -> str | None:
        """از میان ستون‌های رایج (sku, code, item_code, barcode) اولین مقدار غیرتهی را برمی‌گرداند."""
        cols = self._get_existing_columns('items', ['sku', 'code', 'item_code', 'barcode'])
        if not cols:
            return None
        # ساخت SELECT پویا مثل: SELECT COALESCE(sku,code,item_code,barcode) AS sku ...
        coalesce = "COALESCE(" + ",".join(cols) + ")"
        row = self.execute_query(
            f"SELECT {coalesce} AS sku FROM items WHERE id=%s",
            (item_id,),
            fetch_one=True
        )
        val = row.get('sku') if row else None
        return str(val).strip() if val else None
    
    def get_item_sku(self, item_id: int):
        """
        برگرداندن SKU برای آیتم (مادر/پک).
        اگر پیدا نشود، None.
        """
        row = self.execute_query(
            "SELECT sku FROM items WHERE id = %s LIMIT 1",
            (int(item_id),), fetch_one=True
        )
        return (row or {}).get('sku')

    
    # BEGIN ADD: DB._insert_pr_group_safe
    def _insert_pr_group_safe(self, cursor, *, requester_id: int,
                            original_dept_id: int | None,
                            physical_no: str | None,
                            note_group: str | None) -> int:
        """
        درج گروه PR به‌صورت ستون‌ـآگاه.
        فقط ستون‌هایی که واقعاً در purchase_request_groups وجود دارند درج می‌شوند.
        هر نام ناشناسی مثل request_note / request_no نادیده گرفته می‌شود.
        """
        cols_existing = set(self._get_existing_columns("purchase_request_groups", cursor=cursor))

        grp_cols, grp_vals = [], []

        if "requester_id" in cols_existing:
            grp_cols.append("requester_id"); grp_vals.append(requester_id)

        # واحد
        if "original_department_id" in cols_existing:
            grp_cols.append("original_department_id"); grp_vals.append(original_dept_id)
        elif "department_id" in cols_existing:
            grp_cols.append("department_id"); grp_vals.append(original_dept_id)

        # شماره فیزیکی (هر کدام موجود باشد)
        for cand in ("physical_request_no", "physical_no", "request_physical_no"):
            if cand in cols_existing:
                grp_cols.append(cand); grp_vals.append((physical_no or "").strip() or None)
                break

        # نوت گروه (افراد معمولاً ستونش را "notes" می‌گذارند)
        if (note_group or "").strip() and "notes" in cols_existing:
            grp_cols.append("notes"); grp_vals.append((note_group or "").strip())

        if not grp_cols:
            raise RuntimeError("purchase_request_groups: هیچ ستون معتبری برای درج پیدا نشد.")

        cursor.execute(
            f"INSERT INTO purchase_request_groups({', '.join(grp_cols)}) "
            f"VALUES({', '.join(['%s']*len(grp_cols))}) RETURNING id",
            grp_vals
        )
        gid_row = cursor.fetchone()
        return int((gid_row[0] if isinstance(gid_row, (list, tuple)) else gid_row["id"]))
    # END ADD: DB._insert_pr_group_safe

    # BEGIN REWRITE: DB.create_purchase_request_multi
    def create_purchase_request_multi(
        self,
        items: list[dict],
        requester_id: int,
        original_dept_id: int | None = None,
        group_physical_no: str | None = None,
        request_note: str | None = None,
        **kwargs
    ) -> dict:
        """
        ایجاد گروه PR + ردیف‌ها؛
        نکته‌ی کلیدی: وضعیت اولیه‌ی هر PR = «در انتظار تایید مدیر واحد» تا در کارتابل مدیر واحد ظاهر شود.
        پیوست‌ها بعد از Commit و در تراکنش جدا درج می‌شوند (برای جلوگیری از abort).
        در پایان، «ارسال خودکار به مدیر واحد» نیز انجام می‌شود.
        """
        if not items or not isinstance(items, list):
            raise ValueError("لیست اقلام برای ایجاد درخواست خرید خالی یا نامعتبر است.")

        # اسکیمای خرید (idempotent)
        self.ensure_purchasing_schema()

        # تعیین وضعیت‌های متنی به‌صورت امن (enum → fallback فارسی)
        def _enum(name: str, default: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return default
        ST_INIT_MANAGER = _enum('PR_AWAITING_MANAGER', 'در انتظار تایید مدیر واحد')

        # تلاش برای پر کردن واحد سازمانی از پروفایل (در صورت خالی بودن)
        if original_dept_id in (None, "", 0, "0"):
            try:
                resolved = self._resolve_original_dept_id(requester_id)
                if resolved:
                    original_dept_id = resolved
            except Exception:
                pass

        pr_ids: list[int] = []
        group_id: int | None = None

        # ---- مرحله ۱: ثبت گروه و ردیف‌های PR در یک تراکنش تمیز
        with self.transaction() as cur:
            # ایجاد گروه (اختیاری/ستون‌آگاه)
            try:
                group_id = self._insert_pr_group_safe(
                    cursor=cur,
                    requester_id=int(requester_id),
                    original_dept_id=int(original_dept_id) if original_dept_id else None,
                    physical_no=(group_physical_no or "").strip() or None,
                    note_group=(request_note or "").strip()
                )
            except Exception:
                group_id = None  # اگر جدول گروه نداریم، ادامه می‌دهیم.

            # ستون‌های موجود جدول PR
            cols = set(self._get_existing_columns("purchase_requests", cursor=cur))

            def pick(*names):
                for n in names:
                    if n in cols:
                        return n
                return None

            col_item       = pick("item_id", "product_id")
            col_qty        = pick("requested_qty", "quantity", "qty")
            col_unit       = pick("requested_unit_id", "unit_id")
            col_specs      = pick("specs", "specifications", "tech_specs")
            col_note       = pick("note", "notes", "description")
            col_req        = pick("requester_id", "user_id", "created_by_id")
            col_dept       = pick("original_department_id", "department_id")
            col_group      = pick("group_id", "request_group_id")
            col_status     = pick("status", "state")
            col_approval   = pick("approval_status")
            col_urg_user   = pick("urgency_suggested", "urgency", "priority", "importance")

            # اگر ستون «واحد سازمانی» داریم ولی مقدارش تعیین نشده، ادامه نده (سیاست: پیام و توقف)
            if col_dept and (original_dept_id in (None, "", 0, "0")):
                raise ValueError("واحد سازمانی مشخص نیست. لطفاً واحد درخواست‌دهنده را تعیین کنید.")

            if not (col_item and col_qty and col_req):
                raise RuntimeError("جدول purchase_requests ستون‌های حداقلیِ لازم را ندارد.")

            # آماده‌سازی اقلام معتبر + جمع‌آوری پیوست‌ها برای مرحلهٔ ۲
            deferred_attachments: list[tuple[int, list]] = []

            for it in items:
                try:
                    item_id = int(it.get("item_id"))
                    qty     = float(it.get("qty"))
                except Exception:
                    continue
                if not item_id or qty <= 0:
                    continue

                cols_ins, vals_ins = [], []

                # ستون‌های حداقلی
                cols_ins += [col_item, col_qty, col_req]
                vals_ins += [item_id, qty, int(requester_id)]

                if col_unit and it.get("requested_unit_id"):
                    vals_ins += [int(it.get("requested_unit_id"))]; cols_ins += [col_unit]
                if col_specs and (it.get("specs") or "").strip():
                    vals_ins += [(it.get("specs") or "").strip()]; cols_ins += [col_specs]
                if col_note:
                    vals_ins += [(it.get("note") or "").strip()]; cols_ins += [col_note]
                if col_dept and original_dept_id:
                    vals_ins += [int(original_dept_id)]; cols_ins += [col_dept]
                if col_group and group_id:
                    vals_ins += [int(group_id)]; cols_ins += [col_group]

                # فوریت کاربر (عیناً همان مقدار انتخاب‌شده) — اگر ستون مقصد داشتیم
                if col_urg_user:
                    urg_raw = (it.get("urgency") or it.get("urgency_suggested") or "").strip()
                    if urg_raw:
                        vals_ins += [urg_raw]; cols_ins += [col_urg_user]

                # وضعیت اولیه صحیح برای کارتابل مدیر واحد
                if col_status:
                    vals_ins += [ST_INIT_MANAGER]; cols_ins += [col_status]
                if col_approval:
                    vals_ins += ['PENDING']; cols_ins += [col_approval]

                placeholders = ", ".join(["%s"] * len(vals_ins))
                cur.execute(
                    f"INSERT INTO purchase_requests({', '.join(cols_ins)}) "
                    f"VALUES({placeholders}) RETURNING id",
                    vals_ins
                )
                new_id = int(cur.fetchone()[0])
                pr_ids.append(new_id)

                # پیوست‌های این ردیف را برای مرحلهٔ ۲ نگه می‌داریم
                attachments = self._normalize_attachments_payload(it.get("attachments") or [])
                if attachments:
                    deferred_attachments.append((new_id, attachments))

        # ---- مرحله ۲: درج پیوست‌ها پس از Commit (تراکنش جدا + SAVEPOINT + DO NOTHING)
        if pr_ids:
            with self.transaction() as cur:
                cur.execute("""
                    SELECT table_name FROM information_schema.tables
                    WHERE table_schema='public'
                    AND table_name IN ('purchase_request_attachments','pr_attachments','request_attachments')
                """)
                row = cur.fetchone()
                att_table = row[0] if row and row[0] else "purchase_request_attachments"
                try:
                    if att_table == "purchase_request_attachments":
                        self.ensure_pr_attachments_schema()
                except Exception:
                    pass

                att_cols = set(self._get_existing_columns(att_table, cursor=cur))
                pr_fk   = "purchase_request_id" if "purchase_request_id" in att_cols else ("pr_id" if "pr_id" in att_cols else "request_id")
                fn_col  = "filename" if "filename" in att_cols else ("name" if "name" in att_cols else None)
                data_col= "file_data" if "file_data" in att_cols else ("data" if "data" in att_cols else ("content" if "content" in att_cols else None))
                size_col= "size_bytes" if "size_bytes" in att_cols else ("size" if "size" in att_cols else None)

                if pr_fk and fn_col and data_col:
                    for pr_id, files in deferred_attachments:
                        used = 0
                        for f in files:
                            raw = f.get("data") or b""
                            if not isinstance(raw, (bytes, bytearray)):
                                continue
                            used += len(raw)
                            if used > 10 * 1024 * 1024:
                                break
                            cols_ins = [pr_fk, fn_col, data_col]
                            vals_ins = [int(pr_id), str(f.get("filename") or ""), psycopg2.Binary(bytes(raw))]
                            if size_col:
                                cols_ins += [size_col]; vals_ins += [int(f.get("size_bytes") or len(raw))]
                            try:
                                cur.execute("SAVEPOINT sp_att")
                                cur.execute(
                                    f"INSERT INTO {att_table}({', '.join(cols_ins)}) "
                                    f"VALUES({', '.join(['%s']*len(vals_ins))}) "
                                    f"ON CONFLICT DO NOTHING",
                                    vals_ins
                                )
                                cur.execute("RELEASE SAVEPOINT sp_att")
                            except Exception:
                                try:
                                    cur.execute("ROLLBACK TO SAVEPOINT sp_att")
                                    cur.execute("RELEASE SAVEPOINT sp_att")
                                except Exception:
                                    pass

        # ---- مرحله ۳: ارسال خودکار برای تایید مدیر واحد (workflow-free) ----
        for _pid in (pr_ids or []):
            try:
                self.ensure_new_pr_visible_for_manager(int(_pid))
            except Exception:
                pass
            try:
                self.submit_pr_for_unit_manager(int(_pid), int(requester_id))
            except Exception:
                pass

        # اعلان‌های سبک برای تازه‌سازی UI
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("PURCHASING_LISTS_CHANGED")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
        except Exception:
            pass

        return {"group_id": group_id, "pr_ids": pr_ids, "duplicate": False}
    # END REWRITE: DB.create_purchase_request_multi
    
    # BEGIN ADD: DB._normalize_attachments_payload
    def _normalize_attachments_payload(self, attachments):
        """
        ورودی پیوست‌ها را به لیست دیکشنری استاندارد تبدیل می‌کند:
        [{"filename": str, "data": bytes, "size_bytes": int?}, ...]
        تاپل‌ها مثل (name, bytes) هم پشتیبانی می‌شوند.
        """
        norm = []
        for a in (attachments or []):
            if isinstance(a, dict):
                fn = (a.get("filename") or a.get("name") or "").strip()
                raw = a.get("file_data") or a.get("data") or a.get("content") or b""
                sz  = a.get("size_bytes") or a.get("size") or None
                try:
                    sz = int(sz) if sz is not None else (len(raw) if isinstance(raw, (bytes, bytearray)) else None)
                except Exception:
                    sz = None
                norm.append({"filename": fn, "data": raw or b"", "size_bytes": sz})
            elif isinstance(a, (list, tuple)) and len(a) >= 2:
                fn = (a[0] if a[0] is not None else "")
                raw = a[1]
                sz  = len(raw) if isinstance(raw, (bytes, bytearray)) else None
                norm.append({"filename": str(fn), "data": raw or b"", "size_bytes": sz})
            # سایر انواع نادیده گرفته می‌شوند
        return norm
    # END ADD: DB._normalize_attachments_payload

        
    def ensure_manager_approvals_schema(self) -> None:
        self.execute_query("""
        CREATE TABLE IF NOT EXISTS manager_approvals (
            id SERIAL PRIMARY KEY,
            purchase_request_id   INTEGER NOT NULL REFERENCES purchase_requests(id) ON DELETE CASCADE,
            requester_id          INTEGER NULL REFERENCES users(id),
            created_by_id         INTEGER NULL REFERENCES users(id),
            assigned_manager_id   INTEGER NULL REFERENCES users(id),
            workflow              TEXT    NOT NULL DEFAULT 'CEO',
            status                TEXT    NOT NULL DEFAULT 'Pending',
            approver_id           INTEGER NULL REFERENCES users(id),
            note                  TEXT NULL,
            created_at            TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            decided_at            TIMESTAMPTZ NULL,
            decided_by_id         INTEGER NULL REFERENCES users(id)
        );
        CREATE INDEX IF NOT EXISTS ix_mgr_appr_work_status_mgr
            ON manager_approvals (workflow, status, assigned_manager_id);
        """, None)

    # [FUNC: DB.create_ceo_approvals_for_prs] — درج گروهی + سیگنال رفرش
    def create_ceo_approvals_for_prs(self, pr_ids: list[int], assigned_manager_id: int | None = None) -> int:
        """برای هر PR یک رکورد Pending در workflow='CEO' ایجاد می‌کند (بدون تکرار). خروجی: تعداد ردیف‌های درج‌شده."""
        if not pr_ids:
            return 0
        self.ensure_manager_approvals_schema()
        q = """
        INSERT INTO manager_approvals (purchase_request_id, workflow, status, assigned_manager_id)
        SELECT pr.id, 'CEO', 'Pending', %s
        FROM purchase_requests pr
        WHERE pr.id = ANY(%s)
        AND NOT EXISTS (
            SELECT 1 FROM manager_approvals ma
            WHERE ma.purchase_request_id = pr.id
                AND ma.workflow = 'CEO'
                AND ma.status = 'Pending'
        )
        """
        with self.transaction() as cur:
            cur.execute(q, (assigned_manager_id, pr_ids))
            try:
                inserted = cur.rowcount or 0
            except Exception:
                inserted = 0

        # بعد از کامیـت، سیگنال رفرش برای داشبوردها
        try:
            self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass

        return inserted
        
        
    # BEGIN REWRITE: DB.ensure_commerce_perf_indexes
    def ensure_commerce_perf_indexes(self) -> None:
        """
        نقطهٔ واحد ساخت ایندکس‌های کارایی چرخهٔ خرید.
        تضمین می‌کند اول اسکیمای Quotes امن باشد (وجود ستون pr_id)،
        بعد فقط در صورت وجود ستون، ایندکس‌های مرتبط ساخته شوند.
        """
        try:
            # تا حد ممکن قبل از هر ایندکس، اسکیمای Quotes را ایمن کن
            if hasattr(self, "ensure_quote_schema"):
                self.ensure_quote_schema()
        except Exception:
            # اگر متد موجود نبود/خطا داد، بعداً با چک ستون ادامه می‌دهیم
            pass

        with self.transaction() as cur:
            # آیا جدول supplier_quotes وجود دارد؟
            has_sq = False
            try:
                cur.execute("SELECT to_regclass('public.supplier_quotes')")
                has_sq = bool((cur.fetchone() or [None])[0])
            except Exception:
                has_sq = False

            # اگر جدول هست، فقط وقتی ستون pr_id هست، ایندکس‌هایش را بساز
            if has_sq:
                try:
                    cols = set(self._get_existing_columns('supplier_quotes', cursor=cur))
                except Exception:
                    cols = set()
                if 'pr_id' in cols:
                    try:
                        cur.execute("CREATE INDEX IF NOT EXISTS ix_supplier_quotes_pr ON supplier_quotes(pr_id)")
                    except Exception:
                        pass
                    try:
                        cur.execute("CREATE INDEX IF NOT EXISTS ix_supplier_quotes_winner ON supplier_quotes(pr_id, is_winner)")
                    except Exception:
                        pass

            # ایندکس‌های POI (ایمن)
            try:
                cur.execute("SELECT to_regclass('public.purchase_order_items')")
                has_poi = bool((cur.fetchone() or [None])[0])
            except Exception:
                has_poi = False
            if has_poi:
                try:
                    cur.execute("CREATE INDEX IF NOT EXISTS ix_poi_po ON purchase_order_items(po_id)")
                except Exception:
                    pass

        # وضعیت PR (همیشه safe است)
        try:
            self.ensure_pr_status_index()
        except Exception:
            pass
    # END REWRITE: DB.ensure_commerce_perf_indexes
        
    def ensure_pr_approval_schema(self) -> None:
        """ستون‌های approval و ایندکس‌ها را برای purchase_requests تضمین می‌کند (Postgres/SQLite-friendly)."""
        # تلاش برای افزودن ستون‌ها (اگر پشتیبانی از IF NOT EXISTS نباشد، مسیر fallback را امتحان کن)
        alter_cmds = [
            "ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS approval_status TEXT",
            "ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS approved_by_id INTEGER",
            "ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS approved_at TIMESTAMPTZ",
            "ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS approval_note TEXT",
            "ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS approval_delegate_of INTEGER"
        ]
        for sql in alter_cmds:
            try:
                self.execute_query(sql)
            except Exception:
                # Fallback برای دیتابیس‌هایی که IF NOT EXISTS ندارند (مثل برخی نسخه‌های SQLite)
                if "IF NOT EXISTS" in sql:
                    try:
                        self.execute_query(sql.replace(" IF NOT EXISTS", ""))
                    except Exception:
                        pass  # ستون احتمالاً وجود دارد
                else:
                    pass

        # ایندکس‌ها (در هر دو موتور معمولاً پشتیبانی می‌شود)
        try:
            self.execute_query("CREATE INDEX IF NOT EXISTS ix_pr_approval_status ON purchase_requests(approval_status)")
        except Exception:
            pass
        try:
            self.execute_query("CREATE INDEX IF NOT EXISTS ix_pr_approved_by ON purchase_requests(approved_by_id)")
        except Exception:
            pass

        # مقداردهی پیش‌فرض برای ردیف‌های قدیمی
        try:
            self.execute_query(
                "UPDATE purchase_requests SET approval_status = COALESCE(approval_status, %s)",
                ('PENDING',)
            )
        except Exception:
            # برخی درایورها جایگزین %s ندارند؛ یک بار بدون پارامتر هم امتحان کن
            try:
                self.execute_query("UPDATE purchase_requests SET approval_status = COALESCE(approval_status, 'PENDING')")
            except Exception:
                pass
            
    def _resolve_column(self, table: str, preferred: str, alternatives: list[str] | tuple[str, ...] = (), cursor=None) -> str:
        """
        تشخیص نام ستون موجود در جدول. اگر preferred نبود، از alternatives یکی را برمی‌گرداند.
        در صورت عدم وجود هیچ‌کدام، ValueError می‌اندازد.
        """
        cols = set(self._get_existing_columns(table, cursor=cursor))
        if preferred in cols:
            return preferred
        for c in (alternatives or []):
            if c in cols:
                return c
        raise ValueError(f"None of the columns exist on {table}: {preferred} or {list(alternatives)}")

    def migrate_legacy_purchasing_schema(self) -> None:
        """
        هم‌ترازی اسکیماهای قدیمی با استاندارد جدید:
        - افزودن pr_id به supplier_quotes/purchase_order_items در صورت نبود
        - کپی‌کردن مقادیر از ستون‌های قدیمی (request_id / purchase_request_id / prid)
        """
        with self.transaction() as cur:
            # supplier_quotes
            sq_cols = set(self._get_existing_columns('supplier_quotes', cursor=cur))
            if sq_cols:
                if 'pr_id' not in sq_cols:
                    # پیدا کردن ستون قدیمی
                    src = None
                    for alt in ('request_id', 'purchase_request_id', 'prid'):
                        if alt in sq_cols:
                            src = alt; break
                    # اگر هیچ‌کدام نبود، فقط ستون را بسازیم (بعداً برنامه مقداردهی می‌کند)
                    cur.execute("ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS pr_id INTEGER")
                    if src:
                        cur.execute(f"UPDATE supplier_quotes SET pr_id = {src} WHERE pr_id IS NULL")
                    # ایندکس‌های ضروری
                    cur.execute("CREATE INDEX IF NOT EXISTS ix_supplier_quotes_pr ON supplier_quotes(pr_id)")
                    cur.execute("CREATE INDEX IF NOT EXISTS ix_supplier_quotes_winner ON supplier_quotes(pr_id, is_winner)")

            # purchase_order_items
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            if poi_cols:
                if 'pr_id' not in poi_cols:
                    src = None
                    for alt in ('request_id', 'purchase_request_id', 'prid'):
                        if alt in poi_cols:
                            src = alt; break
                    cur.execute("ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS pr_id INTEGER")
                    if src:
                        cur.execute(f"UPDATE purchase_order_items SET pr_id = {src} WHERE pr_id IS NULL")
                # گارد یکتا پس از اطمینان از وجود pr_id
                try:
                    cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS uq_poi_pr ON purchase_order_items(pr_id)")
                except Exception:
                    pass
                cur.execute("CREATE INDEX IF NOT EXISTS ix_poi_po ON purchase_order_items(po_id)")

            

    # [FUNC: DB._set_pr_status_if_exists] — ست‌کردن وضعیت کاری PR در صورت وجود ستون
    def _set_pr_status_if_exists(self, pr_ids: list[int], status_value: str) -> None:
        """اگر ستون status در purchase_requests وجود داشت، مقدارش را تنظیم می‌کند."""
        if not pr_ids: return
        try:
            cols = self._get_existing_columns('purchase_requests', ['status'])
        except Exception:
            cols = set()
        if 'status' in cols:
            ph = ','.join(['%s'] * len(pr_ids))
            self.execute_query(
                f"UPDATE purchase_requests SET status=%s WHERE id IN ({ph})",
                (status_value, *pr_ids)
            )

    # BEGIN REWRITE<DB.decide_manager_approval>
    def decide_manager_approval(self, *args, **kwargs) -> None:
        """
        سازگاری رو به عقب: تایید/رد یک تیکت با امضاهای متفاوت، روی متد گروهی (bulk) سوار می‌شود.
        رفتار بیرونی تغییری نکرده؛ فقط نگاشت ورودی‌ها به امضای جدید bulk انجام می‌شود.
        """
        # --- استخراج پارامترها از امضاهای قدیمی/متنوع ---
        appr_id = kwargs.get('appr_id')
        approver_id = (kwargs.get('approver_id') or kwargs.get('user_id') or
                    kwargs.get('manager_id') or kwargs.get('decider_id') or
                    kwargs.get('approved_by_id'))
        approve = kwargs.get('approve')
        note = kwargs.get('note', '')

        # پوزیشنال‌ها (حفظ سازگاری با ترتیب‌های قدیمی)
        if appr_id is None and len(args) >= 1:
            try: appr_id = int(args[0])
            except Exception: pass

        if approver_id is None:
            # (appr_id, approver_id, approve, note) | (appr_id, approve, approver_id, note)
            if len(args) >= 2 and not isinstance(args[1], bool):
                try: approver_id = int(args[1])
                except Exception: pass
            if approver_id is None and len(args) >= 3 and not isinstance(args[2], bool):
                try: approver_id = int(args[2])
                except Exception: pass

        if approve is None:
            if len(args) >= 2 and isinstance(args[1], bool):
                approve = args[1]
            elif len(args) >= 3 and isinstance(args[2], bool):
                approve = args[2]

        if not note and len(args) >= 4 and isinstance(args[3], str):
            note = args[3]

        if appr_id is None or approver_id is None or approve is None:
            raise TypeError("decide_manager_approval(appr_id, approver_id, approve, note='') — پارامترهای لازم ناقص است.")

        # --- نگاشت به امضای جدید متد Bulk ---
        # نکته: برای سازگاری، از دیکشنری استاندارد استفاده می‌کنیم.
        decision_item = {
            "approval_id": int(appr_id),
            "decision": "APPROVE" if bool(approve) else "REJECT",
            "comment": (note or "").strip(),
        }
        # فراخوانی امنِ نسخهٔ جدید Bulk
        self.decide_manager_approvals_bulk(
            decisions=[decision_item],
            decided_by_user_id=int(approver_id),
        )
    # END REWRITE<DB.decide_manager_approval>

    # BEGIN ADD: DB._resolve_approval_delegate_of
    def _resolve_approval_delegate_of(self, user_id: int, delegation_key: str, cursor=None):
        """
        delegatorِ این کاربر را برای یک کلید نیابت (مثلاً 'PURCHASE_REQUEST_APPROVAL') برمی‌گرداند.
        اگر نیابت فعال/معتبر نبود ⇒ None.
        جدول پیشنهادی: approval_delegations(delegate_user_id, delegator_user_id, delegation_key, starts_at, ends_at, is_revoked)
        """
        q = """
            SELECT d.delegator_user_id
            FROM approval_delegations d
            WHERE d.delegate_user_id = %s
            AND d.delegation_key    = %s
            AND (d.starts_at IS NULL OR d.starts_at <= NOW())
            AND (d.ends_at   IS NULL OR d.ends_at   >= NOW())
            AND COALESCE(d.is_revoked, FALSE) = FALSE
            ORDER BY d.id DESC
            LIMIT 1
        """
        try:
            if cursor:
                cursor.execute(q, (int(user_id), str(delegation_key)))
                row = cursor.fetchone()
            else:
                row = self.execute_query(q, (int(user_id), str(delegation_key)), fetch_one=True)
            if not row:
                return None
            # row می‌تواند dict یا tuple باشد
            if isinstance(row, dict):
                return int(row.get("delegator_user_id")) if row.get("delegator_user_id") is not None else None
            return int(row[0]) if row[0] is not None else None
        except Exception:
            # اگر جدول/ایندکس وجود نداشت هم امن برگردیم
            return None
    # END ADD: DB._resolve_approval_delegate_of

    # [FUNC: DB.list_purchase_requests_for_approval] — لیست PRها بر اساس وضعیت‌های مدنظر
    def list_purchase_requests_for_approval(self, statuses: list[str] = None) -> list[dict]:
        """لیست PRها را برای مرکز تأمین برمی‌گرداند؛ پیش‌فرض PENDING/SUBMITTED."""
        self.ensure_purchasing_schema(); self.ensure_pr_approval_schema()
        statuses = statuses or ['PENDING', 'SUBMITTED', 'در انتظار']
        ph = ','.join(['%s'] * len(statuses))
        return self.execute_query(
            f"""
            SELECT pr.id,
                i.name AS item_name,
                pr.requested_qty,
                COALESCE(pr.approval_status,'PENDING') AS approval_status,
                u.username AS requester_name,
                pr.request_date
            FROM purchase_requests pr
            LEFT JOIN items i ON i.id = pr.item_id
            LEFT JOIN users u ON u.id = pr.requester_id
            WHERE COALESCE(pr.approval_status,'PENDING') IN ({ph})
            ORDER BY pr.request_date DESC, pr.id DESC
            """,
            tuple(statuses)
        ) or []

    # [FUNC: DB.submit_prs_for_approval] — تغییر وضعیت به SUBMITTED
    def submit_prs_for_approval(self, pr_ids: list[int], user_id: int, note: str = '') -> int:
        """PRها را به وضعیت «SUBMITTED» می‌برد؛ تعداد ردیف‌های تغییر یافته را برمی‌گرداند."""
        if not pr_ids: return 0
        self.ensure_pr_approval_schema()
        ph = ','.join(['%s'] * len(pr_ids))
        return self.execute_query(
            f"""
            UPDATE purchase_requests
            SET approval_status = 'SUBMITTED',
                approval_note   = %s
            WHERE id IN ({ph})
            AND COALESCE(approval_status,'PENDING') <> 'APPROVED'
            """,
            (note, *pr_ids)
        ) or 0

    # [FUNC: DB.approve_purchase_requests] — تأیید کردن PRها
    def approve_purchase_requests(self, pr_ids: list[int], approver_id: int, note: str = '') -> int:
        """PRها را تأیید می‌کند؛ تعداد ردیف‌های تغییر یافته را برمی‌گرداند."""
        if not pr_ids: return 0
        self.ensure_pr_approval_schema()
        delegate_of = self._resolve_approval_delegate_of(approver_id, 'PURCHASE_REQUEST_APPROVAL')
        ph = ','.join(['%s'] * len(pr_ids))
        return self.execute_query(
            f"""
            UPDATE purchase_requests
            SET approval_status    = 'APPROVED',
                approved_by_id     = %s,
                approved_at        = NOW(),
                approval_note      = %s,
                approval_delegate_of = %s
            WHERE id IN ({ph})
            """,
            (approver_id, note, delegate_of, *pr_ids)
        ) or 0

    # [FUNC: DB.reject_purchase_requests] — رد کردن PRها
    def reject_purchase_requests(self, pr_ids: list[int], approver_id: int, note: str) -> int:
        """PRها را رد می‌کند و یادداشت را ذخیره می‌نماید."""
        if not pr_ids: return 0
        self.ensure_pr_approval_schema()
        delegate_of = self._resolve_approval_delegate_of(approver_id, 'PURCHASE_REQUEST_APPROVAL')
        ph = ','.join(['%s'] * len(pr_ids))
        return self.execute_query(
            f"""
            UPDATE purchase_requests
            SET approval_status    = 'REJECTED',
                approved_by_id     = %s,
                approved_at        = NOW(),
                approval_note      = %s,
                approval_delegate_of = %s
            WHERE id IN ({ph})
            """,
            (approver_id, note or 'رد توسط مسئول تأیید', delegate_of, *pr_ids)
        ) or 0

    
    
    def reject_material_request(self, request_id: int, user_id: int, reason: str):
        """یک درخواست مواد اولیه را به صورت اتمیک رد کرده و دلیل آن را ثبت می‌کند."""
        with self.transaction() as cur:
            notes = f"درخواست توسط انباردار رد شد. دلیل: {reason}"
            query = """
                UPDATE material_requests 
                SET status=%s, processed_by_user_id=%s, processed_at=NOW(), notes=%s 
                WHERE id=%s
            """
            params = (TransactionStatus.REJECTED.value, user_id, notes, request_id)
            self.execute_query(query, params, cursor=cur)
                                                        
                                    
                                
        
                
    def process_purchase_request(self, pr_id: int, actor_id: int, approve: bool, reason: str = "") -> None:
        """اقدام روی PR در بازرگانی؛ آپدیت امن بدون ارجاع به ستون‌های ناموجود."""
        # 1) تعیین نام ستون وضعیت (status|state)
        status_col = 'status'
        try:
            status_col = self._get_pr_status_column()  # اگر پچ v2.9 را داری
        except Exception:
            pass

        # 2) مقدار وضعیت هدف
        try:
            status_ok  = getattr(TransactionStatus, 'PR_AWAITING_MANAGER_APPROVAL').value
        except Exception:
            status_ok  = 'در انتظار تایید مدیر'
        try:
            status_rej = getattr(TransactionStatus, 'PR_REJECTED_BY_COMMERCE').value
        except Exception:
            status_rej = 'رد شده توسط بازرگانی'

        new_status = status_ok if approve else status_rej

        # 3) کشف ستون‌های موجود در purchase_requests
        existing = set()
        try:
            existing = self._get_existing_columns('purchase_requests', ['processed_by_id', 'processed_date', 'notes'])
        except Exception:
            # اگر کمک‌متد در دسترس نبود، ادامه می‌دهیم (بدون ستون‌های اختیاری)
            existing = set()

        # 4) ساخت SET به‌صورت داینامیک (فقط ستون‌های موجود)
        set_parts: list[str] = [f"{status_col} = %s"]
        params: list[object] = [new_status]

        if 'processed_by_id' in existing:
            set_parts.append("processed_by_id = %s")
            params.append(actor_id)
        if 'processed_date' in existing:
            set_parts.append("processed_date = NOW()")  # بدون پارامتر
        if (not approve) and reason and ('notes' in existing):
            # افزودن یک یادداشت کوتاه به notes (پیوست به انتها)
            set_parts.append("notes = COALESCE(notes,'') || CASE WHEN notes IS NULL OR notes = '' THEN '' ELSE E'\n' END || %s")
            params.append(f"رد با دلیل: {reason}")

        q = f"UPDATE purchase_requests SET {', '.join(set_parts)} WHERE id = %s"
        params.append(pr_id)

        # 5) اجرای امن در تراکنش
        with self.transaction() as cur:
            cur.execute(q, tuple(params))
            # لاگ اختیاری
            try:
                action = 'FORWARD_TO_MANAGER' if approve else 'REJECT_BY_COMMERCE'
                self._log_atomic(cur, actor_id, action, f'PR {pr_id}')
            except Exception:
                pass
            
    # BEGIN REWRITE: DB.ensure_manager_approval_schema  (idempotent + safe)
    def ensure_manager_approval_schema(self) -> None:
        """
        جدول/ایندکس‌های manager_approvals + بک‌فیل ایمن برای تیکت‌های «مدیر واحد».
        - فقط وقتی PR واقعاً در وضعیت «در انتظار تایید مدیر واحد» باشد، Pending می‌سازیم.
        - برای هر (purchase_request_id, workflow) فقط یک Pending مجاز است.
        - Pending های مانده برای PRهایی که دیگر منتظر مدیر واحد نیستند، پاکسازی می‌شوند.
        """

        # کمک: کشف نام ستون وضعیت PR
        def _pr_status_col(cur):
            cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            return 'status' if 'status' in cols else ('state' if 'state' in cols else None)

        # کمک: Enum ایمن با fallback فارسی
        def _enum(name, fa):
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return fa

        ST_WAIT_MGR = _enum('PR_AWAITING_MANAGER', 'در انتظار تایید مدیر واحد')
        # چند معادل رایج برای پوشش دیتابیس‌های قدیمی
        WAIT_MGR_ALIASES = {ST_WAIT_MGR, 'در انتظار تایید مدیریت', 'در انتظار تایید مدیر واحد'}

        with self.transaction() as cur:
            # 1) ایجاد جدول در صورت نبود
            cur.execute("""
            DO $$
            BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname='manager_approvals' AND relkind='r') THEN
                CREATE TABLE manager_approvals (
                id SERIAL PRIMARY KEY,
                purchase_request_id INTEGER NOT NULL REFERENCES purchase_requests(id) ON DELETE CASCADE,
                requester_id        INTEGER REFERENCES users(id),
                created_by_id       INTEGER REFERENCES users(id),
                assigned_manager_id INTEGER REFERENCES users(id),
                workflow            TEXT    NOT NULL DEFAULT 'DEPT_MANAGER',
                status              TEXT    NOT NULL DEFAULT 'Pending',     -- Pending/Approved/Rejected/...
                note                TEXT,
                created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                decided_at          TIMESTAMPTZ,
                decided_by_id       INTEGER REFERENCES users(id)
                );
            END IF;
            END $$;
            """)

            # 2) ستون‌های جاافتاده (سازگاری با اسکیماهای قدیمی)
            try:
                cols = set(self._get_existing_columns('manager_approvals', cursor=cur))
                if 'workflow'            not in cols: cur.execute("ALTER TABLE manager_approvals ADD COLUMN IF NOT EXISTS workflow TEXT NOT NULL DEFAULT 'DEPT_MANAGER'")
                if 'decided_by_id'       not in cols and 'decided_by' in cols:
                    cur.execute("ALTER TABLE manager_approvals RENAME COLUMN decided_by TO decided_by_id")
                for c in ('requester_id','created_by_id','assigned_manager_id','status','note','created_at','decided_at','decided_by_id'):
                    cur.execute(f"ALTER TABLE manager_approvals ADD COLUMN IF NOT EXISTS {c} { 'TIMESTAMPTZ NOT NULL DEFAULT NOW()' if c=='created_at' else 'TEXT' if c in ('status','workflow','note') else 'INTEGER' }")
            except Exception:
                pass

            # 3) ایندکس‌ها (از جمله ایندکس یکتای جزئی فقط برای Pending)
            for sql in (
                "CREATE INDEX IF NOT EXISTS ix_ma_status   ON manager_approvals(status)",
                "CREATE INDEX IF NOT EXISTS ix_ma_manager  ON manager_approvals(assigned_manager_id)",
                "CREATE INDEX IF NOT EXISTS ix_ma_pr       ON manager_approvals(purchase_request_id)",
                "CREATE INDEX IF NOT EXISTS ix_ma_wf       ON manager_approvals(workflow)",
                # فقط یک Pending برای هر PR/Workflow
                "CREATE UNIQUE INDEX IF NOT EXISTS ux_ma_pr_wf_pending ON manager_approvals(purchase_request_id, workflow) WHERE status = 'Pending'"
            ):
                try: cur.execute(sql)
                except Exception: pass

            # 4) بک‌فیل ایمن فقط برای PRهایی که واقعاً منتظر مدیر واحد هستند
            pr_status_col = _pr_status_col(cur)  # status یا state
            if pr_status_col:
                placeholders = ", ".join(["%s"] * len(WAIT_MGR_ALIASES))
                cur.execute(f"""
                    INSERT INTO manager_approvals
                    (purchase_request_id, requester_id, created_by_id, assigned_manager_id, workflow, status, note)
                    SELECT
                    pr.id,
                    pr.requester_id,
                    pr.requester_id,
                    COALESCE(pr.manager_approver_id, d.manager_user_id),
                    'DEPT_MANAGER',
                    'Pending',
                    'Backfill(safe): awaiting unit manager'
                    FROM purchase_requests pr
                    LEFT JOIN departments d ON d.id = pr.original_department_id
                    WHERE COALESCE(pr.{pr_status_col}, '') IN ({placeholders})
                    AND NOT EXISTS (
                        SELECT 1 FROM manager_approvals ma
                        WHERE ma.purchase_request_id = pr.id
                        AND ma.workflow = 'DEPT_MANAGER'
                        AND ma.status = 'Pending'
                    );
                """, tuple(WAIT_MGR_ALIASES))

                # 5) پاکسازی Pendingهای بی‌اعتبار (PR دیگر منتظر مدیر واحد نیست)
                cur.execute(f"""
                    DELETE FROM manager_approvals ma
                    USING purchase_requests pr
                    WHERE ma.purchase_request_id = pr.id
                    AND ma.workflow = 'DEPT_MANAGER'
                    AND ma.status = 'Pending'
                    AND COALESCE(pr.{pr_status_col}, '') NOT IN ({placeholders});
                """, tuple(WAIT_MGR_ALIASES))

        # (اختیاری) سیگنال برای تازه‌سازی UI
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("TASKS_CHANGED")
        except Exception:
            pass
    # END REWRITE: DB.ensure_manager_approval_schema
        
    # BEGIN REWRITE: DB.get_pr_group_snapshot
    def get_pr_group_snapshot(self, pr_id: int) -> dict | None:
        """
        خلاصهٔ یک فرم (بر اساس pr_idِ یکی از ردیف‌ها):
        {'group_id','physical_request_no','items':[{'pr_id','item_name','qty','unit','specs','notes','attachments_count'}]}
        ستون‌آگاه و سازگار با اسکیماهای مختلف.
        """
        from psycopg2 import sql as _sql

        with self.transaction() as cur:
            # 1) group_id از خود PR
            cur.execute("SELECT group_id FROM purchase_requests WHERE id=%s", (int(pr_id),))
            r = cur.fetchone()
            if not r or not r[0]:
                return None
            gid = int(r[0])

            # 2) شمارهٔ فیزیکی گروه (اگر ستونش باشد)
            phys = None
            try:
                pg_cols = set(self._get_existing_columns("purchase_request_groups", cursor=cur))
                if pg_cols and ("physical_request_no" in pg_cols):
                    cur.execute("SELECT physical_request_no FROM purchase_request_groups WHERE id=%s", (gid,))
                    rr = cur.fetchone()
                    phys = rr[0] if rr else None
            except Exception:
                pass

            # 3) کشف ستون‌ها
            pr_cols    = set(self._get_existing_columns("purchase_requests", cursor=cur))
            items_cols = set(self._get_existing_columns("items", cursor=cur))
            units_cols = set(self._get_existing_columns("units", cursor=cur))

            qty_col   = "requested_qty" if "requested_qty" in pr_cols else ("quantity" if "quantity" in pr_cols else "qty")
            specs_col = "specs" if "specs" in pr_cols else None
            notes_col = "notes" if "notes" in pr_cols else ("note" if "note" in pr_cols else None)
            item_fk   = "item_id" if "item_id" in pr_cols else None
            req_unit_fk = "requested_unit_id" if "requested_unit_id" in pr_cols else None

            # اسم کالا در items
            item_name_col = None
            for c in ("name", "title", "item_name", "description", "desc", "sku_name", "label"):
                if c in items_cols:
                    item_name_col = c
                    break

            # اسم واحد
            unit_name_col = None
            for c in ("name", "title"):
                if c in units_cols:
                    unit_name_col = c
                    break

            # بیان‌های انتخاب
            item_name_expr = _sql.SQL("i.{}").format(_sql.Identifier(item_name_col)) if (item_name_col and item_fk) else _sql.SQL("NULL::text")
            unit_name_expr = _sql.SQL("un.{}").format(_sql.Identifier(unit_name_col)) if unit_name_col else _sql.SQL("NULL::text")
            specs_expr = _sql.SQL("COALESCE(pr.{}, '')").format(_sql.Identifier(specs_col)) if specs_col else _sql.SQL("''")
            notes_expr = _sql.SQL("COALESCE(pr.{}, '')").format(_sql.Identifier(notes_col)) if notes_col else _sql.SQL("''")
            qty_expr   = _sql.SQL("COALESCE(pr.{}, 0)").format(_sql.Identifier(qty_col))

            # ⚠️ اینجا همه را به str تبدیل می‌کنیم تا join کار کند
            select_parts = [
                _sql.SQL("pr.id AS pr_id").as_string(cur),
                item_name_expr.as_string(cur) + " AS item_name",
                qty_expr.as_string(cur)       + " AS qty",
                unit_name_expr.as_string(cur) + " AS unit",
                specs_expr.as_string(cur)     + " AS specs",
                notes_expr.as_string(cur)     + " AS notes",
            ]
            select_sql = ',\n                    '.join(select_parts)

            # Joinها
            join_items = _sql.SQL("LEFT JOIN items i ON i.id = pr.{}").format(_sql.Identifier(item_fk)) if item_fk else _sql.SQL("")
            item_unit_fk = "unit_id" if "unit_id" in items_cols else None
            if req_unit_fk:
                join_units = _sql.SQL("LEFT JOIN units un ON un.id = pr.{}").format(_sql.Identifier(req_unit_fk))
            elif item_unit_fk and item_fk:
                join_units = _sql.SQL("LEFT JOIN units un ON un.id = i.{}").format(_sql.Identifier(item_unit_fk))
            else:
                join_units = _sql.SQL("")

            q = _sql.SQL("""
                SELECT {sel}
                FROM purchase_requests pr
                {join_i}
                {join_u}
                WHERE pr.group_id = %s
                ORDER BY pr.id
            """).format(sel=_sql.SQL(select_sql), join_i=join_items, join_u=join_units)

            cur.execute(q, (gid,))
            rows = cur.fetchall() or []

            # 5) مونتاژ خروجی + تعداد پیوست هر ردیف
            items = []
            for row in rows:
                prid = int(row[0])
                items.append({
                    "pr_id": prid,
                    "item_name": row[1] or "",
                    "qty": row[2],
                    "unit": row[3] or "",
                    "specs": row[4] or "",
                    "notes": row[5] or "",
                    "attachments_count": int(self.count_pr_attachments(prid)),
                })

            return {"group_id": gid, "physical_request_no": phys, "items": items}
    # END REWRITE: DB.get_pr_group_snapshot

        
    # BEGIN REWRITE: DB.get_pr_attachments
    def get_pr_attachments(self, pr_id):
        """
        فهرست پیوست‌های یک PR از جدول‌های رایج؛ اگر نبود، از ستون متنیِ خود PR.
        اندازهٔ فایل از ستون‌های رایج: size_bytes / size / length.
        """
        try:
            with self.transaction() as cur:
                candidate_tables = [
                    ("purchase_request_attachments", ("pr_id","purchase_request_id","request_id")),
                    ("pr_attachments",              ("pr_id","purchase_request_id","request_id")),
                    ("purchase_request_files",      ("purchase_request_id","pr_id","request_id")),
                    ("request_attachments",         ("request_id","pr_id","purchase_request_id")),
                    ("attachments",                 ("pr_id","purchase_request_id","request_id","object_id","entity_id")),
                ]
                for tbl, fk_cands in candidate_tables:
                    cols = set(self._get_existing_columns(tbl, cursor=cur))
                    if not cols: 
                        continue
                    fk = next((c for c in fk_cands if c in cols), None)
                    if not fk:
                        continue
                    where_extra = ""
                    for mark in ("entity","entity_type","model","ref_table","doc_type","object_type"):
                        if mark in cols:
                            where_extra = f"AND (LOWER({mark}) LIKE '%%purchase_request%%' OR {mark}='PR')"
                            break
                    ts = "uploaded_at" if "uploaded_at" in cols else ("created_at" if "created_at" in cols else None)
                    order_by = f"ORDER BY {ts} DESC NULLS LAST" if ts else ""

                    # نام/اندازه
                    name_col = "filename" if "filename" in cols else ("name" if "name" in cols else None)
                    size_col = "size_bytes" if "size_bytes" in cols else ("size" if "size" in cols else ("length" if "length" in cols else None))

                    q = f"""
                        SELECT {('id' if 'id' in cols else 'NULL')} AS id,
                            {fk} AS pr_id,
                            { (name_col if name_col else "'-'") } AS filename,
                            { (size_col if size_col else 'NULL') } AS size,
                            { (ts if ts else 'NULL') } AS uploaded_at
                        FROM {tbl}
                        WHERE {fk} = %s {where_extra}
                        {order_by}
                    """
                    cur.execute(q, (int(pr_id),))
                    rows = cur.fetchall() or []
                    out = []
                    for r in rows:
                        rid, _, fn, sz, dt = r[0], r[1], r[2], (r[3] if len(r) > 3 else None), (r[4] if len(r) > 4 else None)
                        out.append({"id": (int(rid) if isinstance(rid, (int,)) else None), "filename": fn, "size": sz, "uploaded_at": dt})
                    return out

                # fallback: ستون متنی/JSON در خود purchase_requests
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
                att_text_col = next((c for c in ("attachments_json","attachments","files_json","files","file_list","attachment","attachment_list","pr_files") if c in pr_cols), None)
                if not att_text_col:
                    return []
                from psycopg2 import sql as _sql
                q = _sql.SQL("SELECT {c} FROM purchase_requests WHERE id=%s").format(c=_sql.Identifier(att_text_col))
                cur.execute(q, (int(pr_id),))
                raw = cur.fetchone(); raw = raw[0] if raw else None
                if raw in (None,"",b""): return []
                import json
                items = []
                try:
                    v = json.loads(raw) if isinstance(raw, (str, bytes, bytearray)) else raw
                    if isinstance(v, list): items = v
                except Exception:
                    s = str(raw)
                    for sep in ["\n","; ", ";", ", ", ","]:
                        if sep in s:
                            items = [p.strip() for p in s.split(sep) if p.strip()]
                            break
                    if not items and s.strip(): items = [s.strip()]
                out = []
                for it in items:
                    if isinstance(it, dict):
                        fn = it.get("filename") or it.get("name") or it.get("file") or "-"
                        sz = it.get("size") or it.get("length")
                        dt = it.get("uploaded_at") or it.get("date")
                    else:
                        fn = str(it); sz = None; dt = None
                    out.append({"id": None, "filename": fn, "size": sz, "uploaded_at": dt})
                return out
        except Exception:
            return []
    # END REWRITE: DB.get_pr_attachments
    
    # BEGIN ADD: DB.make_pr_deeplink
    def make_pr_deeplink(self, pr_id: int) -> str:
        """
        یک پیوند داخلی سبک برای ارجاع به PR می‌سازد.
        اگر الگو/تنظیم خاصی وجود نداشت، متن «PR:<id>» را برمی‌گرداند.
        """
        try:
            # اگر در تنظیمات داخلی، الگوی پیوند تعریف شده باشد از آن استفاده کن
            base = getattr(self, "internal_link_base", None) or ""
            if base:
                # مثال: base = "app://purchase-request/"
                return f"{base}{int(pr_id)}"
            # برگشت ساده و بدون وابستگی
            return f"PR:{int(pr_id)}"
        except Exception:
            return f"PR:{pr_id}"
    # END ADD: DB.make_pr_deeplink
    
    # BEGIN ADD: DB._coalesce_physical_no_expr
    def _coalesce_physical_no_expr(self, cursor, pr_cols: set) -> tuple[str, str]:
        """
        برگرداندن (expr, left_pg) برای «شمارهٔ فیزیکی»:
        - expr: COALESCE(NULLIF(TRIM(...))) از بین ستون‌های موجود در purchase_request_groups و purchase_requests
        - left_pg: اگر جدول گروه موجود باشد و group_id هم در PR باشد ⇒ LEFT JOIN لازم؛ وگرنه رشتهٔ خالی
        """
        # آیا جدول گروه موجود است؟
        try:
            cursor.execute("SELECT to_regclass('public.purchase_request_groups')")
            pg_exists = bool((cursor.fetchone() or [None])[0])
        except Exception:
            pg_exists = False

        pg_cols = set()
        if pg_exists:
            try:
                pg_cols = set(self._get_existing_columns("purchase_request_groups", cursor=cursor) or [])
            except Exception:
                pg_cols = set()

        # نام‌های محتمل ستون‌ها
        candidates_group = (
            "physical_request_no", "physical_no", "physical_no_text",
            "request_no", "req_no",
            "form_no", "form_number",
            "paper_no", "paper_number",
            "document_no", "doc_no",
            "serial_no", "serial",
            "tracking_no",
            "group_no", "group_code",
            "code", "code_no", "no", "number"
        )
        candidates_pr = (
            "physical_request_no", "physical_no", "physical_no_text",
            "request_no", "req_no",
            "form_no", "form_number",
            "paper_no", "paper_number",
            "document_no", "doc_no",
            "serial_no", "serial",
            "tracking_no",
            "group_physical_no", "group_code",
            "code", "code_no", "no", "number"
        )

        parts = []
        if pg_exists and "group_id" in pr_cols:
            for c in candidates_group:
                if c in pg_cols:
                    parts.append(f"NULLIF(TRIM(pg.{c}::text),'')")
        for c in candidates_pr:
            if c in pr_cols:
                parts.append(f"NULLIF(TRIM(pr.{c}::text),'')")

        expr = ("COALESCE(" + ", ".join(parts) + ")") if parts else "NULL"
        left_pg = "LEFT JOIN purchase_request_groups pg ON pg.id = pr.group_id" if (pg_exists and "group_id" in pr_cols) else ""
        return expr, left_pg
    # END ADD: DB._coalesce_physical_no_expr
    
    # BEGIN ADD: DB._where_pending_manager
    def _where_pending_manager(self, cursor, pr_cols: set, ma_cols: set) -> tuple[str, list, str, list]:
        """
        برگرداندن چهارگانهٔ شرط‌ها و پارامترها:
        - ma_extra_sql: شرط‌های تکمیلی روی جدول manager_approvals (Pending واقعی)
        - ma_params: پارامترهای ma_extra_sql
        - pr_status_sql: شرط وضعیت خود PR (یکی از حالت‌های «در انتظار تایید مدیر واحد»)
        - pr_params: پارامترهای pr_status_sql
        اگر ستونی موجود نباشد، بخش مربوطه خالی برمی‌گردد.
        """
        # معادل‌های Pending برای approvals
        approval_pending_aliases = ('Pending', 'در انتظار', 'درانتظار', 'در_انتظار')
        # معادل‌های «در انتظار تایید مدیر واحد» برای خود PR
        pr_wait_mgr_aliases = ('در انتظار تایید مدیر واحد', 'PendingManager', 'AWAITING_MANAGER')

        # approvals:
        ma_extra = []
        ma_params = []
        if "status" in ma_cols:
            ma_extra.append(f"(ma.status IN ({', '.join(['%s']*len(approval_pending_aliases))}))")
            ma_params.extend(list(approval_pending_aliases))
        if "is_active" in ma_cols:
            ma_extra.append("COALESCE(ma.is_active, TRUE) = TRUE")
        if "is_done" in ma_cols:
            ma_extra.append("COALESCE(ma.is_done, FALSE) = FALSE")
        if "is_canceled" in ma_cols:
            ma_extra.append("COALESCE(ma.is_canceled, FALSE) = FALSE")
        if "decision_at" in ma_cols:
            ma_extra.append("ma.decision_at IS NULL")
        if "resolved_at" in ma_cols:
            ma_extra.append("ma.resolved_at IS NULL")
        ma_extra_sql = (" AND " + " AND ".join(ma_extra)) if ma_extra else ""

        # وضعیت خود PR (نام ستون پویا)
        pr_status_col = None
        for c in ("status", "state", "stage", "workflow_status", "workflow_state"):
            if c in pr_cols:
                pr_status_col = c
                break
        pr_status_sql, pr_params = "", []
        if pr_status_col:
            pr_status_sql = f" AND COALESCE(pr.{pr_status_col}, '') IN ({', '.join(['%s']*len(pr_wait_mgr_aliases))})"
            pr_params = list(pr_wait_mgr_aliases)

        return ma_extra_sql, ma_params, pr_status_sql, pr_params
    # END ADD: DB._where_pending_manager

    # BEGIN REWRITE: DB.list_pending_manager_approvals
    def list_pending_manager_approvals(self, user_id: int, limit: int = 200, offset: int = 0):
        """
        لیست PRهای منتظر تایید «مدیر واحد» برای داشبورد.
        شرط نمایش = (manager_approvals واقعاً Pending) AND (وضعیت خود PR «در انتظار تایید مدیر واحد»)
        شمارهٔ فیزیکی از هر ستون موجود به‌صورت پویا استخراج می‌شود.
        خروجی: list[dict] با کلیدهای: id, group_id, started_at, physical_no, approval_id
        """
        import datetime as _dt

        def _fmt_ts(v):
            try:
                if isinstance(v, _dt.datetime): return v.strftime("%Y-%m-%d %H:%M")
                if isinstance(v, _dt.date): return v.strftime("%Y-%m-%d 00:00")
                s = str(v or "").strip().replace("T"," ")
                if "+" in s: s = s.split("+",1)[0]
                if "." in s: s = s.split(".",1)[0]
                if len(s) == 10: return f"{s} 00:00"
                return s[:16] if len(s) >= 16 else s
            except Exception:
                return str(v or "")

        rows = []
        try:
            with self.transaction() as cur:
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur) or [])
                # ستون‌های انتخابی
                sel_group   = "COALESCE(pr.group_id, pr.id)" if "group_id" in pr_cols else "pr.id"
                sel_started = "pr.request_date" if "request_date" in pr_cols else "NOW()"
                # عبارت شماره فیزیکی + LEFT JOIN گروه (در صورت وجود)
                phys_expr, left_pg = self._coalesce_physical_no_expr(cur, pr_cols)
                # ستون‌های approvals (اگر جدولش هست)
                ma_cols = set(self._get_existing_columns("manager_approvals", cursor=cur) or [])
                ma_exists = bool(ma_cols)
                # شرط‌های Pending
                ma_extra_sql, ma_params, pr_status_sql, pr_params = self._where_pending_manager(cur, pr_cols, ma_cols)

                # مسیر اصلی: approvals + وضعیت PR
                if ma_exists:
                    params = [int(user_id), int(user_id)] + ma_params + pr_params + [int(limit), int(offset)]
                    query = f"""
                        SELECT
                            ma.id AS approval_id,
                            pr.id AS id,
                            {sel_group}   AS group_id,
                            {sel_started} AS started_at,
                            {phys_expr}   AS physical_no
                        FROM manager_approvals ma
                        JOIN purchase_requests pr ON pr.id = ma.purchase_request_id
                        {left_pg}
                        WHERE
                            (ma.assigned_manager_id = %s OR (
                                ma.assigned_manager_id IS NULL AND pr.original_department_id IN (
                                    SELECT id FROM departments WHERE manager_user_id = %s
                                )
                            ))
                            {ma_extra_sql}
                            {pr_status_sql}
                        ORDER BY ma.id DESC
                        LIMIT %s OFFSET %s
                    """
                    cur.execute(query, tuple(params))
                    fetched = cur.fetchall() or []
                    if fetched:
                        colnames = [d.name for d in cur.description]
                        for rec in fetched:
                            r = dict(zip(colnames, rec))
                            r["started_at"] = _fmt_ts(r.get("started_at"))
                            if not r.get("physical_no"):
                                r["physical_no"] = None
                            rows.append(r)

                # فالبک: اگر approvals نبود یا نتیجه خالی و ستون وضعیت PR داریم
                if not rows and pr_status_sql:
                    # pr_status_sql خودش شامل placeholders و ما پارامترها را داریم
                    params = pr_params + [int(user_id), int(user_id), int(limit), int(offset)]
                    query = f"""
                        SELECT
                            NULL::integer AS approval_id,
                            pr.id AS id,
                            {sel_group}   AS group_id,
                            {sel_started} AS started_at,
                            {phys_expr}   AS physical_no
                        FROM purchase_requests pr
                        {left_pg}
                        WHERE 1=1
                        {pr_status_sql}
                        AND (pr.manager_approver_id = %s OR pr.original_department_id IN (SELECT id FROM departments WHERE manager_user_id = %s))
                        ORDER BY pr.id DESC
                        LIMIT %s OFFSET %s
                    """
                    cur.execute(query, tuple(params))
                    fetched = cur.fetchall() or []
                    if fetched:
                        colnames = [d.name for d in cur.description]
                        for rec in fetched:
                            r = dict(zip(colnames, rec))
                            r["started_at"] = _fmt_ts(r.get("started_at"))
                            if not r.get("physical_no"):
                                r["physical_no"] = None
                            rows.append(r)

        except Exception as e:
            print(f"[DBG:LPM] ERROR(list_pending_manager_approvals): {e}")

        return rows
    # END REWRITE: DB.list_pending_manager_approvals
    
        # BEGIN ADD: DB._where_pending_ceo
    def _where_pending_ceo(self, cursor, pr_cols: set, ma_cols: set) -> tuple[str, list, str, list]:
        """
        شرط‌های Pending مخصوص «مدیرعامل»:
        - ma_extra_sql, ma_params: شرط‌های جدول manager_approvals برای workflow=CEO و Pending واقعی
        - pr_status_sql, pr_params: شرط وضعیت خود PR در حالت «در انتظار تایید مدیرعامل»
        """
        # معادل‌های Pending
        ma_pending_aliases = ('Pending', 'در انتظار', 'درانتظار', 'در_انتظار')
        # معادل‌های وضعیت انتظار مدیرعامل
        pr_ceo_wait_aliases = ('در انتظار تایید مدیرعامل', 'PendingCEO', 'AWAITING_CEO')

        # approvals (manager_approvals)
        ma_extra, ma_params = [], []
        if "workflow" in ma_cols:
            ma_extra.append("ma.workflow = 'CEO'")
        if "status" in ma_cols:
            ma_extra.append(f"(ma.status IN ({', '.join(['%s']*len(ma_pending_aliases))}))")
            ma_params.extend(list(ma_pending_aliases))
        if "is_active" in ma_cols:   ma_extra.append("COALESCE(ma.is_active, TRUE) = TRUE")
        if "is_done" in ma_cols:     ma_extra.append("COALESCE(ma.is_done, FALSE) = FALSE")
        if "is_canceled" in ma_cols: ma_extra.append("COALESCE(ma.is_canceled, FALSE) = FALSE")
        if "decision_at" in ma_cols: ma_extra.append("ma.decision_at IS NULL")
        if "resolved_at" in ma_cols: ma_extra.append("ma.resolved_at IS NULL")
        ma_extra_sql = (" AND " + " AND ".join(ma_extra)) if ma_extra else ""

        # وضعیت خود PR
        pr_status_col = None
        for c in ("status", "state", "stage", "workflow_status", "workflow_state"):
            if c in pr_cols:
                pr_status_col = c; break
        pr_status_sql, pr_params = "", []
        if pr_status_col:
            pr_status_sql = f" AND COALESCE(pr.{pr_status_col}, '') IN ({', '.join(['%s']*len(pr_ceo_wait_aliases))})"
            pr_params = list(pr_ceo_wait_aliases)

        return ma_extra_sql, ma_params, pr_status_sql, pr_params
    # END ADD: DB._where_pending_ceo

    
    # BEGIN ADD: DB.list_pending_ceo_items
    def list_pending_ceo_items(self, user_id: int, only_mine: bool = True, limit: int = 500, offset: int = 0) -> list[dict]:
        """
        لیست آیتم‌های منتظر «تأیید مدیرعامل» (آیتم‌محور، مستقل از workflow؛ سازگار با UI مدیرعامل).
        خروجی هر ردیف: {appr_id, pr_id, item_name, requested_qty, unit_name, requester_name, urgency, attachments_count, specs}
        """
        rows = []
        try:
            with self.transaction() as cur:
                pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur) or [])
                ma_cols = set(self._get_existing_columns("manager_approvals", cursor=cur) or [])

                # شرط‌های Pending مخصوص CEO
                ma_extra_sql, ma_params, pr_status_sql, pr_params = self._where_pending_ceo(cur, pr_cols, ma_cols)

                # ستون‌های نام‌ها (ایمن)
                requester_name_expr = "COALESCE(pr.requester_name, u.full_name, u.display_name, u.name, u.username, '')"
                item_join  = "LEFT JOIN items i ON i.id = pr.item_id"
                unit_join  = "LEFT JOIN units un ON un.id = COALESCE(pr.requested_unit_id, i.unit_id)"
                user_join  = "LEFT JOIN users u ON u.id = pr.requester_id"

                # ضمیمه‌ها
                att_join = """
                    LEFT JOIN (
                        SELECT pr_id, COUNT(*) AS attachments_count
                        FROM purchase_request_attachments
                        GROUP BY pr_id
                    ) att ON att.pr_id = pr.id
                """

                # فیلتر ارجاع‌شده به من (یا همه)
                mine_sql = " AND (ma.assigned_manager_id = %s)" if only_mine else " AND (ma.assigned_manager_id = %s OR ma.assigned_manager_id IS NULL)"
                params = [int(user_id)] + ma_params + pr_params + [int(limit), int(offset)]

                query = f"""
                    SELECT
                        ma.id AS appr_id,
                        pr.id AS pr_id,
                        COALESCE(i.name, '') AS item_name,
                        pr.requested_qty,
                        COALESCE(un.name, '') AS unit_name,
                        {requester_name_expr} AS requester_name,
                        COALESCE(pr.urgency_suggested, pr.urgency, 'عادی') AS urgency,
                        COALESCE(att.attachments_count, 0) AS attachments_count,
                        COALESCE(pr.specs, '') AS specs
                    FROM manager_approvals ma
                    JOIN purchase_requests pr ON pr.id = ma.purchase_request_id
                    {item_join}
                    {unit_join}
                    {user_join}
                    {att_join}
                    WHERE 1=1
                    {ma_extra_sql}
                    {pr_status_sql}
                    {mine_sql}
                    ORDER BY pr.id DESC
                    LIMIT %s OFFSET %s
                """
                # پارامترها به‌ترتیب: user_id (برای mine_sql) + ma_params + pr_params + limit/offset
                # ولی چون mine_sql بعد از pr_status_sql آمده، باید user_id را بعد از pr_params بدهیم:
                params = ma_params + pr_params + [int(user_id)] + [int(limit), int(offset)]
                cur.execute(query, tuple(params))
                fetched = cur.fetchall() or []
                if fetched:
                    colnames = [d.name for d in cur.description]
                    for rec in fetched:
                        rows.append(dict(zip(colnames, rec)))

        except Exception as e:
            print(f"[DBG:CEO] ERROR(list_pending_ceo_items): {e}")

        return rows
    # END ADD: DB.list_pending_ceo_items

# BEGIN REWRITE<DB.ensure_prs_sent_to_commerce>
    def ensure_prs_sent_to_commerce(self, pr_ids, user_id: int, cursor=None):
        """
        PRها را برای بازرگانی آماده می‌کند (idempotent) — بدون ساخت رکورد در manager_approvals.
        فقط وضعیت PR به «در انتظار تایید بازرگانی» می‌رود و سیگنال UI زده می‌شود.
        خروجی: تعداد رکوردهایی که واقعاً آپدیت شدند.
        """
        # نرمال‌سازی ورودی
        norm_ids: list[int] = []
        if isinstance(pr_ids, (list, tuple, set)):
            for x in pr_ids:
                try:
                    norm_ids.append(int(x))
                except Exception:
                    continue
        else:
            try:
                norm_ids = [int(pr_ids)]
            except Exception:
                norm_ids = []
        if not norm_ids:
            return 0

        try:
            st_await_commerce = getattr(TransactionStatus, 'PR_AWAITING_COMMERCE').value
        except Exception:
            st_await_commerce = 'در انتظار تایید بازرگانی'

        def _work(cur) -> int:
            changed = 0
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            status_col = 'status' if 'status' in pr_cols else ('state' if 'state' in pr_cols else None)
            if not status_col:
                return 0

            cur.execute(
                f"UPDATE purchase_requests SET {status_col}=%s "
                f"WHERE id = ANY(%s) AND COALESCE({status_col}, '') <> %s",
                (st_await_commerce, norm_ids, st_await_commerce)
            )
            changed += (cur.rowcount or 0)

            try:
                if hasattr(self, 'signals'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
                    self.signals.dataChanged.emit('PURCHASING_LISTS_CHANGED')
            except Exception:
                pass

            return changed

        if cursor is not None:
            return _work(cursor)
        with self.transaction() as cur:
            return _work(cur)
# END REWRITE<DB.ensure_prs_sent_to_commerce>

    
    # [FUNC: DB.set_pr_urgency_bulk] — ست گروهی فوریت برای PRها (بدون تغییر وضعیت)
    def set_pr_urgency_bulk(self, pr_ids: list[int], urgency: str, approver_id: int) -> int:
        """
        فوریت نهایی PRها را تنظیم می‌کند. وضعیت PR را دست نمی‌زند.
        خروجی: تعداد ردیف‌های به‌روزشده.
        """
        if not pr_ids or not urgency:
            return 0
        # نگاشتِ کدهای مجاز؛ برای جلوگیری از مقدار غیرمجاز
        valid = {'NOW', 'U1', 'U2', 'U3', 'NORMAL'}
        if urgency not in valid:
            raise ValueError("Invalid urgency code")

        q = f"UPDATE purchase_requests SET urgency = %s, urgency_set_by_id = %s WHERE id = ANY(%s)"
        with self.transaction() as cur:
            cur.execute(q, (urgency, approver_id, pr_ids))
            return cur.rowcount or 0
        
    def _close_pending_manager_approvals(self, pr_id: int, *, approve: bool, decided_by: int = None, note: str = None, workflow: str = 'DEPT_MANAGER', cursor=None) -> int:
        """
        همهٔ ردیف‌های Pending مربوط به یک PR را در جدول manager_approvals از Pending خارج می‌کند.
        هم ستون status و هم state را (هر کدام وجود داشته باشد) پوشش می‌دهد.
        دو مرحله: 1) با قید workflow، 2) درصورت 0 ردیف، بدون قید workflow.
        خروجی: تعداد ردیف‌های به‌روزشده.
        """
        from contextlib import nullcontext
        ctx = nullcontext(cursor) if cursor is not None else self.transaction()
        cur = ctx.__enter__()
        try:
            # وجود جدول؟
            try:
                cur.execute("SELECT to_regclass('public.manager_approvals')")
                if not (cur.fetchone() or [None])[0]:
                    return 0
            except Exception:
                return 0

            ma_cols = set(self._get_existing_columns('manager_approvals', cursor=cur)) or set()
            ma_pr   = 'purchase_request_id' if 'purchase_request_id' in ma_cols else ('pr_id' if 'pr_id' in ma_cols else None)
            ma_wf   = 'workflow' if 'workflow' in ma_cols else None
            ma_st   = 'status' if 'status' in ma_cols else None
            ma_state= 'state' if 'state' in ma_cols else None  # بعضی DBها از state استفاده کرده‌اند
            ma_asg  = 'assigned_manager_id' if 'assigned_manager_id' in ma_cols else None
            ma_by   = 'decided_by_id' if 'decided_by_id' in ma_cols else ('approver_id' if 'approver_id' in ma_cols else None)
            ma_at   = 'decided_at' if 'decided_at' in ma_cols else None
            ma_note = 'note' if 'note' in ma_cols else None
            if not (ma_pr and (ma_st or ma_state)):
                return 0

            new_val = 'Approved' if approve else 'Rejected'
            set_fragments = []
            set_params = []

            if ma_st:
                set_fragments.append(f"{ma_st}=%s")
                set_params.append(new_val)
            if ma_state:
                set_fragments.append(f"{ma_state}=%s")
                set_params.append(new_val)
            if ma_by and decided_by:
                set_fragments.append(f"{ma_by}=%s")
                set_params.append(int(decided_by))
            if ma_at:
                set_fragments.append(f"{ma_at}=NOW()")
            if ma_note and (note or "").strip():
                set_fragments.append(f"{ma_note}=%s")
                set_params.append(note.strip()[:500])

            # شرط Pending (هر کدام از دو ستون وضعیت که هست)
            pending_conds = []
            pend_params = []
            if ma_st:
                pending_conds.append(f"{ma_st}=%s")
                pend_params.append('Pending')
            if ma_state:
                pending_conds.append(f"{ma_state}=%s")
                pend_params.append('Pending')
            pending_where = ("(" + " OR ".join(pending_conds) + ")") if pending_conds else "TRUE"

            # مرحله 1: با workflow (اگر ستونش هست)
            where = [f"{ma_pr}=%s", pending_where]
            params = [int(pr_id)] + pend_params
            if ma_wf and workflow:
                where.append(f"{ma_wf}=%s")
                params.append(str(workflow))

            cur.execute(
                f"UPDATE manager_approvals SET {', '.join(set_fragments)} WHERE " + " AND ".join(where),
                tuple(set_params + params)
            )
            updated = cur.rowcount or 0

            # مرحله 2: اگر چیزی آپدیت نشد، بدون قید workflow
            if updated == 0:
                where2 = [f"{ma_pr}=%s", pending_where]
                params2 = [int(pr_id)] + pend_params
                cur.execute(
                    f"UPDATE manager_approvals SET {', '.join(set_fragments)} WHERE " + " AND ".join(where2),
                    tuple(set_params + params2)
                )
                updated = cur.rowcount or 0

            try:
                print(f"[DBG:CLOSE_MA] pr_id={pr_id} approve={approve} updated={updated}")
            except Exception:
                pass
            return int(updated)
        finally:
            ctx.__exit__(None, None, None)

            
    def decide_manager_approvals_bulk(self, decisions=None, approve=None, user_id=None, **kwargs) -> dict:
        """
        تصمیم مدیر واحد روی PRها (بدون اتکا به موتور workflow).
        - وضعیت PR را جلو می‌برد.
        - «همهٔ» Pendingهای همان PR را در manager_approvals می‌بندد (status/state).
        - سیگنال‌های UI ارسال می‌شود.
        """
        try:
            uid = int(user_id or kwargs.get("approver_id") or kwargs.get("actor_id") or 0)
        except Exception:
            uid = 0
        if not uid:
            raise ValueError("user_id/approver_id نامعتبر است.")

        if decisions is None:
            pr_ids = list(kwargs.get("pr_ids") or [])
            dec = bool(approve) if approve is not None else True
            note = kwargs.get("note") or kwargs.get("reason") or None
            decisions = [{"pr_id": int(pid), "approve": dec, "note": note} for pid in pr_ids]

        # ورودی امن
        safe = []
        for d in (decisions or []):
            pid = int(d.get("pr_id") or 0) if str(d.get("pr_id") or "").strip().isdigit() else 0
            aid = d.get("approval_id") or d.get("appr_id")
            try:
                aid = int(aid) if aid is not None else None
            except Exception:
                aid = None
            ok   = bool(d.get("approve") if d.get("approve") is not None else (approve if approve is not None else True))
            note = (d.get("note") or "").strip()[:500] if d.get("note") else None
            if pid or aid:
                safe.append({"pr_id": pid, "approval_id": aid, "approve": ok, "note": note})
        if not safe:
            return {"ok": True, "affected": 0, "approved": 0, "rejected": 0, "pr_ids": []}

        # Enum ایمن
        def _enum(name: str, fb: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return fb
        ST_WAIT_CEO   = _enum("PR_AWAITING_CEO", "در انتظار تایید مدیرعامل")
        ST_REJ_BY_MGR = _enum("REJECTED", "رد شده")

        approved_cnt = rejected_cnt = 0
        out_pr_ids = []

        with self.transaction() as cur:
            pr_cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
            pr_status = "status" if "status" in pr_cols else ("state" if "state" in pr_cols else None)
            pr_mgr_id = "manager_approver_id" if "manager_approver_id" in pr_cols else None
            if not pr_status:
                raise RuntimeError("ستون وضعیت در purchase_requests یافت نشد.")

            # اگر approval_id آمد، pr_id را استخراج کنیم
            def _pid_from_approval(aid: int) -> int:
                try:
                    cur.execute("SELECT to_regclass('public.manager_approvals')")
                    if not (cur.fetchone() or [None])[0]:
                        return 0
                    ma_cols = set(self._get_existing_columns("manager_approvals", cursor=cur)) or set()
                    ma_id = 'id' if 'id' in ma_cols else None
                    ma_pr = 'purchase_request_id' if 'purchase_request_id' in ma_cols else ('pr_id' if 'pr_id' in ma_cols else None)
                    if not (ma_id and ma_pr):
                        return 0
                    cur.execute(f"SELECT {ma_pr} FROM manager_approvals WHERE {ma_id}=%s", (int(aid),))
                    r = cur.fetchone()
                    return int(r[0]) if r and r[0] is not None else 0
                except Exception:
                    return 0

            for d in safe:
                pid = int(d["pr_id"]) if d["pr_id"] else _pid_from_approval(d["approval_id"]) if d["approval_id"] else 0
                if not pid:
                    continue

                is_approve = bool(d["approve"])
                note = d.get("note")

                # قفل و بروزرسانی PR
                cur.execute("SELECT id FROM purchase_requests WHERE id=%s FOR UPDATE", (pid,))
                if not cur.fetchone():
                    continue

                new_status = ST_WAIT_CEO if is_approve else ST_REJ_BY_MGR
                sets, params = [f"{pr_status}=%s"], [new_status]
                if pr_mgr_id and is_approve:
                    sets.append(f"{pr_mgr_id}=%s"); params.append(int(uid))
                params.append(pid)
                cur.execute(f"UPDATE purchase_requests SET {', '.join(sets)} WHERE id=%s", tuple(params))

                # بستن همه Pendingها (status/state) برای این PR
                updated = self._close_pending_manager_approvals(
                    pid, approve=is_approve, decided_by=uid, note=note, workflow='DEPT_MANAGER', cursor=cur
                )
                try:
                    print(f"[DBG:DMAB] pr_id={pid} closed_pending={updated}")
                except Exception:
                    pass

                out_pr_ids.append(pid)
                if is_approve: approved_cnt += 1
                else:          rejected_cnt += 1

                # تاریخچه اختیاری
                try:
                    cur.execute("SELECT to_regclass('public.pr_approvals')")
                    if cur.fetchone()[0]:
                        pa_cols = set(self._get_existing_columns('pr_approvals', cursor=cur))
                        c_pr  = 'purchase_request_id' if 'purchase_request_id' in pa_cols else ('pr_id' if 'pr_id' in pa_cols else None)
                        c_wf  = 'workflow' if 'workflow' in pa_cols else None
                        c_st  = 'status' if 'status' in pa_cols else ('state' if 'state' in pa_cols else None)
                        c_by  = 'decided_by_id' if 'decided_by_id' in pa_cols else ('approver_id' if 'approver_id' in pa_cols else None)
                        c_at  = 'decided_at' if 'decided_at' in pa_cols else None
                        c_note= 'note' if 'note' in pa_cols else None
                        if c_pr and c_wf and c_st:
                            cols = [c_pr, c_wf, c_st]; vals = [pid, 'DEPT_MANAGER', ('APPROVED' if is_approve else 'REJECTED')]
                            if c_by: cols.append(c_by); vals.append(uid)
                            if c_at: cols.append(c_at); vals.append(None)  # NOW() سمت DB
                            if note and c_note: cols.append(c_note); vals.append(note[:500])
                            cur.execute(
                                f"INSERT INTO pr_approvals ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(vals))})",
                                tuple(vals)
                            )
                except Exception:
                    pass

        # سیگنال‌ها
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
                self.signals.dataChanged.emit("PURCHASING_LISTS_CHANGED")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
                self.signals.dataChanged.emit("TASKS_CHANGED")
        except Exception:
            pass

        return {"ok": True, "affected": approved_cnt + rejected_cnt, "approved": approved_cnt, "rejected": rejected_cnt, "pr_ids": out_pr_ids}
    
        # BEGIN ADD: DB._update_pr_status
    def _update_pr_status(self, pr_id: int, target: str, cursor=None) -> None:
        """
        به‌روزرسانی امن وضعیت PR با کشف نام ستون؛ بدون تغییر Schema.
        target می‌تواند یکی از ارزش‌های Enum شما باشد (مثلاً TransactionStatus.PR_AWAITING_COMMERCE)
        یا متن ساده ('REJECTED' ...).
        """
        # نگاشت Enum → متن
        try:
            if hasattr(target, "value"):
                target_val = target.value
            else:
                target_val = str(target)
        except Exception:
            target_val = str(target)

        from contextlib import nullcontext
        with nullcontext(cursor) as cur_in:
            if cur_in is None:
                ctx = self.transaction(); cur = ctx.__enter__()
            else:
                cur = cur_in; ctx = None
            try:
                cols = set(self._get_existing_columns("purchase_requests", cursor=cur))
                status_col = (
                    self._status_col_pr(cursor=cur) if hasattr(self, "_status_col_pr")
                    else ('status' if 'status' in cols else ('state' if 'state' in cols else None))
                )
                if not status_col:
                    return
                cur.execute(f"UPDATE purchase_requests SET {status_col}=%s WHERE id=%s", (target_val, pr_id))
            finally:
                if cur_in is None:
                    ctx.__exit__(None, None, None)
    # END ADD: DB._update_pr_status
    
    # BEGIN ADD: DB._pr_has_pending_for
    def _pr_has_pending_for(self, pr_id: int, workflow: str, cursor=None) -> bool:
        """
        آیا برای این PR در workflow مشخص، Pending باز داریم؟
        برای جلوگیری از ساخت تکراری Pending بازرگانی.
        """
        from contextlib import nullcontext
        wf = (workflow or "").upper()
        with nullcontext(cursor) as cur_in:
            if cur_in is None:
                ctx = self.transaction(); cur = ctx.__enter__()
            else:
                cur = cur_in; ctx = None
            try:
                cur.execute("SELECT to_regclass('public.pr_approvals')")
                tbl = "pr_approvals" if (cur.fetchone() or [None])[0] else None
                if not tbl:
                    return False
                cols = set(self._get_existing_columns(tbl, cursor=cur))
                c_pr   = "purchase_request_id" if "purchase_request_id" in cols else ("pr_id" if "pr_id" in cols else None)
                c_wf   = "workflow" if "workflow" in cols else None
                c_stat = "status" if "status" in cols else ("state" if "state" in cols else None)
                if not all([c_pr, c_wf, c_stat]):
                    return False
                cur.execute(
                    f"SELECT 1 FROM {tbl} WHERE {c_pr}=%s AND UPPER({c_wf})=%s AND UPPER({c_stat}) IN ('PENDING','AWAITING','WAITING') LIMIT 1",
                    (pr_id, wf)
                )
                return bool(cur.fetchone())
            finally:
                if cur_in is None:
                    ctx.__exit__(None, None, None)
    # END ADD: DB._pr_has_pending_for

    def assign_manager_approval_to(self, appr_id: int, manager_id: int) -> None:
        """تخصیص یک تیکت به یک مدیر مشخص."""
        with self.transaction() as cur:
            cur.execute("UPDATE manager_approvals SET assigned_manager_id=%s WHERE id=%s", (manager_id, appr_id))
            try:
                self._log_atomic(cur, manager_id, 'ASSIGN_MANAGER_APPROVAL', f'appr {appr_id} → manager {manager_id}')
            except Exception:
                pass

    
    def ensure_suppliers_schema(self) -> None:
        """ایجاد جدول suppliers اگر وجود ندارد (idempotent)."""
        sql = r"""
        DO $$
        BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables WHERE table_name='suppliers'
        ) THEN
            EXECUTE 'CREATE TABLE suppliers (
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            phone TEXT,
            email TEXT,
            address TEXT,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            )';
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_suppliers_name ON suppliers(name)';
        END IF;
        END $$;"""
        self.execute_sql_block(sql)

    def create_supplier_safe(self, name: str, phone: str = "", email: str = "", address: str = "") -> int:
        """تأمین‌کننده می‌سازد یا اگر همنام بود، id موجود را برمی‌گرداند."""
        name = (name or "").strip()
        if not name:
            raise ValueError("نام تأمین‌کننده الزامی است.")

        self.ensure_suppliers_schema()
        with self.transaction() as cur:
            try:
                row = self.execute_query(
                    "INSERT INTO suppliers (name, phone, email, address) VALUES (%s, %s, %s, %s) RETURNING id",
                    (name, phone, email, address), fetch_one=True, cursor=cur
                )
                sup_id = row["id"]
            except Exception:
                # اگر با همین نام قبلاً وجود دارد
                r = self.execute_query(
                    "SELECT id FROM suppliers WHERE name = %s",
                    (name,), fetch_one=True, cursor=cur
                )
                if not r:
                    raise
                sup_id = r["id"]
            # لاگ اختیاری
            try:
                self._log_atomic(cur, None, 'CREATE_SUPPLIER_SAFE', f'supplier {sup_id} - {name}')
            except Exception:
                pass
        return sup_id
    
    # BEGIN REWRITE: DB.ensure_supplier_quotes_schema
    def ensure_supplier_quotes_schema(self) -> None:
        """ایجاد/به‌روزرسانی کامل اسکیمای تامین‌کننده و کوئوت (ایمن و چندباره‌اجرا)."""
        sql = r"""
        DO $$
        BEGIN
            -- جدول تامین‌کنندگان
            IF NOT EXISTS (
                SELECT 1 FROM information_schema.tables WHERE table_name='suppliers'
            ) THEN
                EXECUTE 'CREATE TABLE suppliers(
                    id SERIAL PRIMARY KEY,
                    name TEXT UNIQUE NOT NULL,
                    phone TEXT, email TEXT, is_active BOOLEAN DEFAULT TRUE
                )';
            END IF;

            -- جدول پیشنهاد قیمت‌ها (با ستون‌های سازگار)
            IF NOT EXISTS (
                SELECT 1 FROM information_schema.tables WHERE table_name='supplier_quotes'
            ) THEN
                EXECUTE 'CREATE TABLE supplier_quotes (
                    id SERIAL PRIMARY KEY,
                    purchase_request_id INTEGER NOT NULL REFERENCES purchase_requests(id) ON DELETE CASCADE,
                    pr_id INTEGER, -- سازگاری با نسخه‌های قدیمی
                    supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
                    unit_price NUMERIC NOT NULL,
                    currency VARCHAR(8) DEFAULT ''IRR'',
                    lead_time_days INTEGER,
                    min_order_qty NUMERIC,
                    is_winner BOOLEAN NOT NULL DEFAULT FALSE,
                    notes TEXT,
                    created_by_id INTEGER REFERENCES users(id),
                    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                )';
            END IF;

            -- ستون‌ها (اگر نبود اضافه شود)
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS pr_id INTEGER';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS purchase_request_id INTEGER';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS supplier_id INTEGER';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS unit_price NUMERIC';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS currency VARCHAR(8)';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS lead_time_days INTEGER';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS min_order_qty NUMERIC';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS is_winner BOOLEAN';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS notes TEXT';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS created_by_id INTEGER';
            EXECUTE 'ALTER TABLE supplier_quotes ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ';

            -- ایندکس‌ها
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_supplier_quotes_req ON supplier_quotes(purchase_request_id)';
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_supplier_quotes_req_compat ON supplier_quotes(pr_id)';
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_supplier_quotes_supplier ON supplier_quotes(supplier_id)';
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_supplier_quotes_winner ON supplier_quotes(is_winner)';
        END $$;"""
        self.execute_sql_block(sql)
    # END REWRITE: DB.ensure_supplier_quotes_schema
        
    # BEGIN REWRITE: DB.ensure_quote_schema
    def ensure_quote_schema(self) -> None:
        """
        مرجع واحد برای آماده‌سازی اسکیمای تامین‌کننده و کوئوت.
        اگر قبلاً اجرا شده باشد، تکرارش بی‌خطر است.
        """
        # جدول تامین‌کننده
        self.ensure_suppliers_schema()
        # جدول/ستون‌ها/ایندکس‌های کوئوت (نسخهٔ واحد)
        self.ensure_supplier_quotes_schema()
    # END REWRITE: DB.ensure_quote_schema     
        
        
    # BEGIN REWRITE: DB.create_purchase_order_for_supplier
    def create_purchase_order_for_supplier(self, pr_id: int, supplier_id: int | None = None, creator_id: int | None = None) -> int:
        """
        صدور PO برای یک PR بر اساس کوئوتِ برنده، بدون وابستگی به workflow.
        - اگر supplier_id داده نشود، از روی کوئوتِ برنده استخراج می‌شود.
        - اگر داده شود، با کوئوت برنده تطبیق داده می‌شود.
        - در پایان: PR => ORDERED و «پیگیری درخواست‌های من» آپدیت می‌شود.
        خروجی: po_id
        """
        def _enum(name: str, default: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return default

        ST_READY_ORDER   = _enum('READY_FOR_ORDERING', 'آماده برای سفارش')
        ST_ORDERED       = _enum('PR_ORDERED', 'سفارش شد')
        PO_STATUS_OPEN   = _enum('PO_OPEN', 'باز')
        PO_STATUS_ISSUED = _enum('PO_ISSUED', 'صادر شد')

        with self.transaction() as cur:
            # --- 1) قفل و اعتبارسنجی PR
            cur.execute("SELECT * FROM purchase_requests WHERE id=%s FOR UPDATE", (pr_id,))
            pr = cur.fetchone()
            if not pr:
                raise ValueError("PR پیدا نشد.")

            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            status_col = 'state' if 'state' in pr_cols else ('status' if 'status' in pr_cols else None)
            approval_col = 'approval_status' if 'approval_status' in pr_cols else None
            has_updated_at = 'updated_at' in pr_cols

            # باید کوئوتِ برنده مشخص باشد
            sel_qid = pr.get('selected_quote_id') if isinstance(pr, dict) else pr[pr_cols.index('selected_quote_id')] if 'selected_quote_id' in pr_cols else None
            if not sel_qid:
                raise RuntimeError("برای این PR هنوز کوئوتِ برنده تعیین نشده است.")

            # اگر وضعیت PR هنوز آماده سفارش نیست، آن را تحمل می‌کنیم اما هشدار سبک می‌دهیم
            try:
                current_status = pr.get(status_col) if (status_col and isinstance(pr, dict)) else None
                if current_status and current_status not in (ST_READY_ORDER, 'READY_FOR_ORDERING', 'آماده برای سفارش'):
                    pass
            except Exception:
                pass

            # --- 2) دریافت کوئوتِ برنده و استخراج تامین‌کننده/قیمت
            cur.execute("SELECT id, pr_id, supplier_id, unit_price, price, quoted_price FROM supplier_quotes WHERE id=%s", (sel_qid,))
            qrow = cur.fetchone()
            if not qrow:
                raise RuntimeError("کوئوتِ برنده پیدا نشد.")
            q = qrow if isinstance(qrow, dict) else {}
            q_supplier_id = (q.get('supplier_id') if q else qrow[2])
            unit_price = (
                (q.get('unit_price') if q else qrow[3]) or
                (q.get('price') if q else qrow[4]) or
                (q.get('quoted_price') if q else qrow[5]) or
                0
            )

            # تعیین تامین‌کننده نهایی
            final_supplier_id = supplier_id or q_supplier_id
            if not final_supplier_id:
                raise RuntimeError("تأمین‌کننده مشخص نیست.")
            if supplier_id and supplier_id != q_supplier_id:
                raise RuntimeError("تأمین‌کنندهٔ ورودی با تامین‌کنندهٔ کوئوتِ برنده هم‌خوان نیست.")

            # چک فعال‌بودن تامین‌کننده در صورت وجود ستون
            try:
                sup_cols = set(self._get_existing_columns('suppliers', cursor=cur))
                if 'is_active' in sup_cols:
                    row = self.execute_query("SELECT is_active FROM suppliers WHERE id=%s", (final_supplier_id,), fetch_one=True, cursor=cur)
                    is_active = (row.get('is_active') if isinstance(row, dict) else (row[0] if row else True))
                    if is_active is False:
                        raise RuntimeError("این تأمین‌کننده غیرفعال است.")
            except Exception:
                pass

            # --- 3) جلوگیری از صدور تکراری PO برای همین PR
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            poi_pr_col = 'pr_id' if 'pr_id' in poi_cols else ('purchase_request_id' if 'purchase_request_id' in poi_cols else None)
            if poi_pr_col:
                cur.execute(f"""
                    SELECT po.id
                    FROM purchase_order_items poi
                    JOIN purchase_orders po ON po.id = poi.po_id
                    WHERE poi.{poi_pr_col}=%s
                    LIMIT 1
                """, (pr_id,))
                existed = cur.fetchone()
                if existed:
                    # PR قبلاً PO خورده؛ شناسهٔ همان PO را برمی‌گردانیم
                    po_id = existed['id'] if isinstance(existed, dict) else existed[0]
                    # اما وضعیت PR را برای یک‌دستی به ORDERED همسو می‌کنیم
                    if status_col:
                        cur.execute(f"UPDATE purchase_requests SET {status_col}=%s WHERE id=%s", (ST_ORDERED, pr_id))
                    if has_updated_at:
                        cur.execute("UPDATE purchase_requests SET updated_at=NOW() WHERE id=%s", (pr_id,))
                    try:
                        tl_cols = set(self._get_existing_columns('request_timeline', cursor=cur))
                        if {'purchase_request_id','event','created_at'}.issubset(tl_cols):
                            cur.execute("""
                                INSERT INTO request_timeline (purchase_request_id, event, created_at, actor_id)
                                VALUES (%s, %s, NOW(), %s)
                            """, (pr_id, "هم‌راستاسازی وضعیت با PO موجود", creator_id))
                    except Exception:
                        pass
                    return po_id

            # --- 4) ساخت PO
            po_cols = set(self._get_existing_columns('purchase_orders', cursor=cur))
            # ستون‌های در دسترس
            cols, vals, params = [], [], []
            if 'supplier_id' in po_cols:
                cols.append('supplier_id'); vals.append('%s'); params.append(final_supplier_id)
            if 'created_by' in po_cols:
                cols.append('created_by'); vals.append('%s'); params.append(creator_id)
            if 'created_at' in po_cols:
                cols.append('created_at'); vals.append('NOW()')
            if 'status' in po_cols:
                cols.append('status'); vals.append('%s'); params.append(PO_STATUS_ISSUED)
            if 'title' in po_cols:
                cols.append('title'); vals.append('%s'); params.append(f"PO for PR #{pr_id}")
            if 'pr_id' in po_cols:
                cols.append('pr_id'); vals.append('%s'); params.append(pr_id)

            if not cols:
                raise RuntimeError("ساخت PO ممکن نیست: هیچ ستونی از جدول purchase_orders در دسترس نیست.")

            cur.execute(f"INSERT INTO purchase_orders ({', '.join(cols)}) VALUES ({', '.join(vals)}) RETURNING id")
            po_id_row = cur.fetchone()
            po_id = po_id_row['id'] if isinstance(po_id_row, dict) else po_id_row[0]

            # --- 5) ساخت آیتم‌های PO
            # داده‌های حداقلی از PR برای ساخت آیتم
            item_id = pr.get('item_id') if isinstance(pr, dict) else pr[pr_cols.index('item_id')] if 'item_id' in pr_cols else None
            req_qty = pr.get('requested_qty') if isinstance(pr, dict) else pr[pr_cols.index('requested_qty')] if 'requested_qty' in pr_cols else 1

            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            poi_fields, poi_vals, poi_params = [], [], []
            if 'po_id' in poi_cols:
                poi_fields.append('po_id'); poi_vals.append('%s'); poi_params.append(po_id)
            if 'item_id' in poi_cols and item_id is not None:
                poi_fields.append('item_id'); poi_vals.append('%s'); poi_params.append(item_id)
            if 'quantity' in poi_cols:
                poi_fields.append('quantity'); poi_vals.append('%s'); poi_params.append(req_qty or 1)
            if 'unit_price' in poi_cols:
                poi_fields.append('unit_price'); poi_vals.append('%s'); poi_params.append(unit_price or 0)
            # ارجاع به PR برای ردیابی
            if 'pr_id' in poi_cols:
                poi_fields.append('pr_id'); poi_vals.append('%s'); poi_params.append(pr_id)
            elif 'purchase_request_id' in poi_cols:
                poi_fields.append('purchase_request_id'); poi_vals.append('%s'); poi_params.append(pr_id)

            if poi_fields:
                cur.execute(f"INSERT INTO purchase_order_items ({', '.join(poi_fields)}) VALUES ({', '.join(poi_vals)})", tuple(poi_params))

            # --- 6) به‌روزرسانی وضعیت PR به «ORDERED»
            sets, par = [], []
            if status_col:
                sets.append(f"{status_col}=%s"); par.append(ST_ORDERED)
            if approval_col and (pr.get(approval_col) if isinstance(pr, dict) else None) is None:
                pass
            if has_updated_at:
                sets.append("updated_at=NOW()")
            if sets:
                par.append(pr_id)
                cur.execute(f"UPDATE purchase_requests SET {', '.join(sets)} WHERE id=%s", tuple(par))

            # --- 7) تایم‌لاین و سیگنال‌ها
            try:
                tl_cols = set(self._get_existing_columns('request_timeline', cursor=cur))
                if {'purchase_request_id','event','created_at'}.issubset(tl_cols):
                    cur.execute("""
                        INSERT INTO request_timeline (purchase_request_id, event, created_at, actor_id)
                        VALUES (%s, %s, NOW(), %s)
                    """, (pr_id, "صدور سفارش (PO)", creator_id))
            except Exception:
                pass

        # سیگنال‌های سبک برای تازه‌سازی UI/پیگیری
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("PURCHASING_ORDERED")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
        except Exception:
            pass

        return po_id
    # END REWRITE: DB.create_purchase_order_for_supplier

            
    # BEGIN ADD: DB.has_open_po_for_item & DB.assert_no_open_po_for_item
    def has_open_po_for_item(self, item_id: int) -> bool:
        """
        آیا برای این کالا سفارش خرید باز وجود دارد؟
        تعریف «باز»: وضعیت سفارش در حالت‌های بسته/لغو/دریافت-کامل نباشد.
        با هر دو طرح ستون po_id / purchase_order_id کار می‌کند.
        """
        close_set = {'Closed', 'Cancelled', 'Received', 'Rejected', 'بسته', 'لغو شده', 'لغو', 'دریافت کامل شد'}
        with self.transaction() as cur:
            # تعیین ستون join
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            join_expr = "COALESCE(poi.po_id, poi.purchase_order_id)" if {'po_id','purchase_order_id'} & poi_cols else "poi.po_id"
            q = f"""
                SELECT 1
                FROM purchase_order_items poi
                JOIN purchase_orders p ON p.id = {join_expr}
                WHERE poi.item_id = %s
                AND COALESCE(NULLIF(TRIM(p.status), ''), 'باز') NOT IN %s
                LIMIT 1
            """
            cur.execute(q, (int(item_id), tuple(close_set)))
            return bool(cur.fetchone())

    def assert_no_open_po_for_item(self, item_id: int):
        """اگر برای کالا PO باز موجود باشد، خطا می‌اندازد؛ برای استفاده در مسیرهای حساس."""
        if self.has_open_po_for_item(item_id):
            raise ValueError("برای این کالا یک سفارش خریدِ باز وجود دارد؛ دوباره اضافه نکنید.")
    # END ADD: DB.has_open_po_for_item & DB.assert_no_open_po_for_item

                
    def ensure_purchase_orders_schema(self) -> None:
        """ایجاد/تکمیل جداول PO؛ سازگار با اسکیمای قدیمی و بدون خطای کوتیشن."""
        sql = r"""
        DO $$
        BEGIN
        -- هدر سفارش خرید
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables WHERE table_name='purchase_orders'
        ) THEN
            EXECUTE 'CREATE TABLE purchase_orders (
            id SERIAL PRIMARY KEY,
            supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
            order_no TEXT,
            po_number TEXT,
            status TEXT NOT NULL DEFAULT ''Issued'',
            total_amount NUMERIC,
            currency TEXT DEFAULT ''IRR'',
            notes TEXT,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            created_by_id INTEGER REFERENCES users(id),
            issue_date TIMESTAMPTZ NOT NULL DEFAULT NOW()
            )';
        END IF;

        -- اطمینان از وجود ستون‌ها (ایمن)
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS po_number TEXT';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS order_no TEXT';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS status TEXT';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS total_amount NUMERIC';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS currency TEXT';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS notes TEXT';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS created_by_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS supplier_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_orders ADD COLUMN IF NOT EXISTS issue_date TIMESTAMPTZ';
        -- پیش‌فرض‌های ملایم
        EXECUTE 'ALTER TABLE purchase_orders ALTER COLUMN issue_date SET DEFAULT NOW()';
        EXECUTE 'ALTER TABLE purchase_orders ALTER COLUMN status SET DEFAULT ''Issued''';

        -- آیتم‌های سفارش خرید
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables WHERE table_name='purchase_order_items'
        ) THEN
            EXECUTE 'CREATE TABLE purchase_order_items (
            id SERIAL PRIMARY KEY,
            po_id INTEGER,
            purchase_order_id INTEGER,
            purchase_request_id INTEGER,
            quote_id INTEGER,
            item_id INTEGER,
            qty NUMERIC,
            unit_price NUMERIC,
            amount NUMERIC
            )';
        END IF;

        -- اطمینان از وجود ستون‌های آیتم‌ها
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS po_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS purchase_order_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS purchase_request_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS quote_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS item_id INTEGER';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS qty NUMERIC';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS unit_price NUMERIC';
        EXECUTE 'ALTER TABLE purchase_order_items ADD COLUMN IF NOT EXISTS amount NUMERIC';

        -- ایندکس‌ها
        EXECUTE 'CREATE INDEX IF NOT EXISTS ix_po_supplier ON purchase_orders(supplier_id)';
        IF EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name='purchase_order_items' AND column_name='po_id'
        ) THEN
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_poi_po ON purchase_order_items(po_id)';
        ELSIF EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name='purchase_order_items' AND column_name='purchase_order_id'
        ) THEN
            EXECUTE 'CREATE INDEX IF NOT EXISTS ix_poi_po ON purchase_order_items(purchase_order_id)';
        END IF;
        END $$;"""
        self.execute_sql_block(sql)
        
    
    def get_purchase_order_detail(self, po_id: int) -> dict:
        """هدر + اقلام یک PO را برمی‌گرداند (سازگار با نام‌های مختلف ستون‌ها)."""
        self.ensure_purchase_orders_schema(); self.ensure_supplier_quotes_schema()
        # کشف ستون‌های هدر
        try:
            po_cols = self._get_existing_columns('purchase_orders', ['po_number','order_no','issue_date','created_at','total_amount','currency','supplier_id','notes'])
        except Exception:
            po_cols = {'po_number','order_no','issue_date','created_at','total_amount','currency','supplier_id','notes'}
        po_no_expr = 'p.po_number' if 'po_number' in po_cols else ('p.order_no' if 'order_no' in po_cols else 'p.id::text')
        if 'po_number' in po_cols and 'order_no' in po_cols:
            po_no_expr = 'COALESCE(p.po_number, p.order_no)'
        issue_expr = 'p.issue_date' if 'issue_date' in po_cols else ('p.created_at' if 'created_at' in po_cols else 'NOW()')
        total_expr = 'p.total_amount' if 'total_amount' in po_cols else 'NULL::NUMERIC'
        curr_expr  = 'p.currency' if 'currency' in po_cols else "'IRR'"

        header = self.execute_query(
            f"""
            SELECT p.id, {po_no_expr} AS po_no, p.supplier_id, s.name AS supplier_name,
                {total_expr} AS total_amount, {curr_expr} AS currency, {issue_expr} AS issue_date,
                p.notes
            FROM purchase_orders p
            LEFT JOIN suppliers s ON s.id = p.supplier_id
            WHERE p.id = %s
            """, (po_id,), fetch_one=True
        ) or {}

        # کشف ستون‌های آیتم‌ها
        try:
            poi_cols = self._get_existing_columns('purchase_order_items', ['po_id','purchase_order_id','purchase_request_id','quote_id','item_id','qty','quantity','unit_price','price','unitprice','amount','line_total'])
        except Exception:
            poi_cols = {'po_id','purchase_request_id','quote_id','item_id','qty','unit_price','amount'}

        qty_expr   = 'i.qty' if 'qty' in poi_cols else ('i.quantity' if 'quantity' in poi_cols else 'NULL::NUMERIC')
        price_expr = 'i.unit_price' if 'unit_price' in poi_cols else ('i.price' if 'price' in poi_cols else ('i.unitprice' if 'unitprice' in poi_cols else 'NULL::NUMERIC'))
        amt_expr   = 'i.amount' if 'amount' in poi_cols else ('i.line_total' if 'line_total' in poi_cols else f'({qty_expr})*({price_expr})')

        po_ref = 'i.po_id' if 'po_id' in poi_cols else 'i.purchase_order_id'

        items = self.execute_query(
            f"""
            SELECT i.id AS line_id, pr.id AS pr_id, it.name AS item_name,
                {qty_expr} AS qty, {price_expr} AS unit_price, {amt_expr} AS amount
            FROM purchase_order_items i
            LEFT JOIN purchase_requests pr ON pr.id = i.purchase_request_id
            LEFT JOIN items it ON it.id = COALESCE(i.item_id, pr.item_id)
            WHERE {po_ref} = %s
            ORDER BY i.id
            """,
            (po_id,)
        ) or []

        return {"header": header, "items": items}
        
    def add_supplier_quote(self, pr_id: int, supplier_id: int, unit_price: float,
                        currency: str = "IRR", lead_time_days: int | None = None,
                        min_order_qty: float | None = None, notes: str = "",
                        user_id: int | None = None) -> int:
        """افزودن کوئوت تامین‌کننده برای یک PR (PostgreSQL)."""
        self.ensure_quote_schema()
        if unit_price is None or float(unit_price) <= 0:
            raise ValueError("قیمت معتبر نیست.")
        if not self.execute_query("SELECT 1 FROM purchase_requests WHERE id=%s", (pr_id,), fetch_one=True):
            raise ValueError("PR نامعتبر است.")
        if not self.execute_query("SELECT 1 FROM suppliers WHERE id=%s", (supplier_id,), fetch_one=True):
            raise ValueError("تامین‌کننده نامعتبر است.")

        with self.transaction() as cur:
            cur.execute(
                """INSERT INTO supplier_quotes
                    (pr_id, supplier_id, unit_price, currency, lead_time_days, min_order_qty, notes, is_winner)
                VALUES (%s,%s,%s,%s,%s,%s,%s,false)
                RETURNING id""",
                (pr_id, supplier_id, float(unit_price), (currency or "IRR")[:8],
                lead_time_days, min_order_qty, (notes or "").strip()[:500])
            )
            qid = (cur.fetchone() or [0])[0]
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, user_id, 'QUOTE_ADDED',
                                    f"PR#{pr_id} SUP#{supplier_id} price={unit_price} {currency}")
            except Exception:
                pass
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception:
            pass
        return int(qid)

    def list_quotes_for_pr(self, pr_id: int) -> list[dict]:
        """فهرست پیشنهادها برای یک PR (سازگار با ستون‌های اختیاری)."""
        # اطمینان از به‌روز بودن schema
        try:
            self.ensure_supplier_quotes_schema()
        except Exception:
            pass

        try:
            cols = self._get_existing_columns('supplier_quotes', ['is_selected', 'created_at'])
        except Exception:
            cols = {'is_selected', 'created_at'}  # فرض خوش‌بینانه

        is_sel_expr = 'sq.is_selected AS is_selected' if 'is_selected' in cols else 'FALSE AS is_selected'
        created_expr = 'sq.created_at AS created_at' if 'created_at' in cols else 'NOW() AS created_at'

        q = f"""
            SELECT sq.id, sq.purchase_request_id, sq.supplier_id,
                s.name AS supplier_name,
                sq.unit_price, sq.lead_time_days, sq.notes,
                {is_sel_expr}, {created_expr}
            FROM supplier_quotes sq
            JOIN suppliers s ON s.id = sq.supplier_id
            WHERE sq.purchase_request_id = %s
        """
        # مرتب‌سازی: اگر ستون is_selected باشد، اولویت با منتخب‌ها
        if 'is_selected' in cols:
            q += " ORDER BY is_selected DESC, sq.unit_price ASC, sq.id DESC"
        else:
            q += " ORDER BY sq.unit_price ASC, sq.id DESC"

        return self.execute_query(q, (pr_id,))

    # BEGIN REWRITE: DB.select_quote_winner
    def select_quote_winner(self, pr_id: int, quote_id: int, approver_id: int | None = None) -> None:
        """
        انتخاب برندهٔ استعلام برای یک PR و آماده‌سازی آن برای سفارش.
        - سایر کوئوت‌های همان PR لغو برنده می‌شوند؛ فقط یکی برنده می‌ماند.
        - selected_quote_id (اگر ستون باشد) تنظیم می‌شود.
        - وضعیت PR به «آمادهٔ سفارش» تغییر داده می‌شود.
        """
        def _enum(name: str, default: str) -> str:
            try:
                return getattr(TransactionStatus, name).value
            except Exception:
                return default

        ST_READY_ORDER = _enum('READY_FOR_ORDERING', 'آماده برای سفارش')

        with self.transaction() as cur:
            # سازگارسازی نام ستون‌ها
            sq_cols = set(self._get_existing_columns('supplier_quotes', cursor=cur))
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            if not sq_cols or not pr_cols:
                raise RuntimeError("جداول اصلی supplier_quotes یا purchase_requests در دسترس نیستند.")

            has_selected_quote = 'selected_quote_id' in pr_cols
            status_col = 'state' if 'state' in pr_cols else ('status' if 'status' in pr_cols else None)

            # راستی‌آزمایی نسبت quote ↔ pr
            sq_pr_col = 'pr_id' if 'pr_id' in sq_cols else ('purchase_request_id' if 'purchase_request_id' in sq_cols else None)
            if not sq_pr_col:
                raise RuntimeError("در کُد موجود نیست: ستون pr_id/purchase_request_id در supplier_quotes")
            cur.execute(f"SELECT 1 FROM supplier_quotes WHERE id=%s AND {sq_pr_col}=%s", (int(quote_id), int(pr_id)))
            if not cur.fetchone():
                raise RuntimeError("کوئوت انتخاب‌شده متعلق به این PR نیست.")

            # شرط «برنده بودن» سازگار با اسکیمای فعلی
            try:
                winner_pred = self._quote_winner_predicate(alias='w', cursor=cur)
            except Exception:
                winner_pred = "w.is_winner = TRUE"

            # 1) همهٔ برنده‌ها را برای همین PR false کن
            cur.execute(f"UPDATE supplier_quotes SET is_winner=FALSE WHERE {sq_pr_col}=%s", (int(pr_id),))
            # 2) این کوئوت را برنده کن
            cur.execute("UPDATE supplier_quotes SET is_winner=TRUE WHERE id=%s", (int(quote_id),))

            # 3) به‌روزرسانی PR: وضعیت «آمادهٔ سفارش» + selected_quote_id + updated_at (اگر هست)
            if has_selected_quote:
                cur.execute("UPDATE purchase_requests SET selected_quote_id=%s WHERE id=%s", (int(quote_id), int(pr_id)))
            if status_col:
                cur.execute(f"UPDATE purchase_requests SET {status_col}=%s WHERE id=%s", (ST_READY_ORDER, int(pr_id)))
            if 'updated_at' in pr_cols:
                cur.execute("UPDATE purchase_requests SET updated_at=NOW() WHERE id=%s", (int(pr_id),))

            # 4) ثبت اختیاری در تایم‌لاین (اگر جدول موجود باشد)
            try:
                tl_cols = set(self._get_existing_columns('request_timeline', cursor=cur))
                if {'purchase_request_id','event','created_at'}.issubset(tl_cols):
                    cur.execute("""
                        INSERT INTO request_timeline (purchase_request_id, event, created_at, actor_id, notes)
                        VALUES (%s, %s, NOW(), %s, %s)
                    """, (int(pr_id), "انتخاب تامین‌کننده و آمادهٔ سفارش", int(approver_id or 0) or None, f'Quote #{int(quote_id)}'))
            except Exception:
                pass

        # 5) نوتیف سبک (اگر سیستم سیگنال دارد)
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("PURCHASING_READY_FOR_ORDERING")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
        except Exception:
            pass
    # END REWRITE: DB.select_quote_winner
            
    # BEGIN REWRITE: DB.get_requests_ready_for_ordering
    def get_requests_ready_for_ordering(self) -> list[dict]:
        """
        PRهای آمادهٔ سفارش (winner دارند، هنوز وارد PO نشده‌اند) — ایمن نسبت به نام ستون‌ها و currency.
        خروجی: [{pr_id, item_name, quote_id, supplier_id, supplier_name, requested_qty, unit_price, currency, lead_time_days}]
        """
        out: list[dict] = []
        with self.transaction() as cur:
            sq_cols  = set(self._get_existing_columns('supplier_quotes', cursor=cur))
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))
            pr_cols  = set(self._get_existing_columns('purchase_requests', cursor=cur))
            it_cols  = set(self._get_existing_columns('items', cursor=cur))
            sup_cols = set(self._get_existing_columns('suppliers', cursor=cur))

            if not (sq_cols and pr_cols):
                return out

            # کمک‌ها
            def pick(cols, *names):
                for n in names:
                    if n in cols:
                        return n
                return None

            # نگاشت ستون‌ها
            sq_pr_col  = pick(sq_cols, 'pr_id', 'purchase_request_id', 'request_id')
            poi_pr_col = pick(poi_cols, 'pr_id', 'purchase_request_id', 'request_id')
            unit_price_col = pick(sq_cols, 'unit_price', 'price', 'price_unit')
            currency_col   = pick(sq_cols, 'currency')
            lead_col       = pick(sq_cols, 'lead_time_days')
            winner_col     = pick(sq_cols, 'is_winner')
            item_name_col  = pick(it_cols, 'name', 'title')
            supp_name_col  = pick(sup_cols, 'name')
            qty_col        = pick(pr_cols, 'requested_qty', 'quantity', 'qty')

            # شرط «برنده بودن»
            try:
                winner_pred = self._quote_winner_predicate(alias='w', cursor=cur)
            except Exception:
                winner_pred = f"w.{winner_col} = TRUE" if winner_col else "TRUE"

            # بیان فیلدها
            currency_expr = f"w.{currency_col}" if currency_col else "'IRR'"
            lead_expr     = f"COALESCE(w.{lead_col},0)" if lead_col else "0"
            item_name_expr= f"COALESCE(i.{item_name_col},'')" if item_name_col else "''"
            supp_name_expr= f"COALESCE(s.{supp_name_col},'')" if supp_name_col else "''"

            # ضد تکرار PO (اگر جدول اقلام PO داریم)
            not_in_poi = f"NOT EXISTS (SELECT 1 FROM purchase_order_items poi WHERE poi.{poi_pr_col} = pr.id)" if poi_pr_col else "TRUE"

            sql = f"""
                SELECT pr.id AS pr_id,
                    {item_name_expr}        AS item_name,
                    w.id                    AS quote_id,
                    w.supplier_id           AS supplier_id,
                    {supp_name_expr}        AS supplier_name,
                    pr.{qty_col or 'requested_qty'} AS requested_qty,
                    {('w.' + unit_price_col) if unit_price_col else 'NULL'} AS unit_price,
                    COALESCE({currency_expr}, 'IRR') AS currency,
                    {lead_expr}             AS lead_time_days
                FROM purchase_requests pr
                JOIN supplier_quotes w
                ON w.{sq_pr_col} = pr.id AND {winner_pred}
                LEFT JOIN items i     ON i.id = pr.item_id
                LEFT JOIN suppliers s ON s.id = w.supplier_id
                WHERE {not_in_poi}
                ORDER BY supplier_name NULLS LAST, item_name NULLS LAST, pr.id
            """
            cur.execute(sql)
            colnames = [d.name for d in cur.description]
            for r in cur.fetchall() or []:
                out.append({colnames[i]: r[i] for i in range(len(colnames))})

        return out
    # END REWRITE: DB.get_requests_ready_for_ordering
    

    def list_suppliers_simple(self, q: str | None = None) -> list[dict]:
        """لیست مختصر تامین‌کننده‌ها (id, name)؛ با فیلتر اختیاری نام."""
        self.ensure_suppliers_schema()
        if q and q.strip():
            return self.execute_query(
                "SELECT id, name FROM suppliers WHERE name ILIKE %s ORDER BY name",
                (f"%{q.strip()}%",)
            ) or []
        return self.execute_query("SELECT id, name FROM suppliers ORDER BY name") or []
                                
# در کلاس DB، این متد را با نسخه کامل و اصلاح شده زیر جایگزین کنید
    def get_fifo_pick_plan(self, item_id: int, qty_needed: float, warehouse_name: str, cursor=None) -> list:
        """
        نسخه 2.1 (اصلاح شده):
        - شناسه کالا (item_id) را نیز در خروجی پلن برداشت قرار می‌دهد تا باگ KeyError برطرف شود.
        """
        query = """
            SELECT
                s.id as stock_id, s.qty, s.batch_no, s.expiry_date, s.location_id
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0.001 AND w.name = %s
            ORDER BY s.id ASC;
        """
        available_batches = self.execute_query(query, (item_id, warehouse_name), cursor=cursor)

        def get_readable_names():
            item_name_rec = self.execute_query("SELECT name FROM items WHERE id = %s", (item_id,), fetch_one=True, cursor=cursor)
            item_name = item_name_rec['name'] if item_name_rec else f"کالای ناشناخته (ID={item_id})"
            return item_name, warehouse_name

        if not available_batches:
            item_name, fa_warehouse_name = get_readable_names()
            raise ValueError(f"موجودی کافی برای کالای «{item_name}» در انبار «{fa_warehouse_name}» یافت نشد.")

        total_available = sum(b['qty'] for b in available_batches)
        if total_available < qty_needed:
            item_name, fa_warehouse_name = get_readable_names()
            raise ValueError(f"موجودی کل برای کالای «{item_name}» در انبار «{fa_warehouse_name}» کافی نیست.\nنیاز: {qty_needed}\nموجود: {total_available}")

        picks = []
        remaining_needed = qty_needed
        for batch in available_batches:
            if remaining_needed <= 0: break
            
            pick_qty = min(batch['qty'], remaining_needed)
            
            picks.append({
                'item_id': item_id,  # <<< --- اصلاح کلیدی و نهایی اینجاست ---
                'stock_id': batch['stock_id'], 'location_id': batch['location_id'],
                'batch_no': batch['batch_no'], 'expiry_date': batch['expiry_date'],
                'pick_qty': pick_qty
            })
            
            remaining_needed -= pick_qty
            
        return picks
        
                        
                
    def get_items_by_category(self, category_name: str):
        """لیست کالاهای یک دسته با واحد صحیح."""
        return self.execute_query(
            """
            SELECT i.id, i.name, COALESCE(u.name,'') AS unit
            FROM items i
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE i.category = %s
            ORDER BY i.name
            """,
            (category_name,)
        )
    

    def get_next_packed_batch_no(self, sku_prefix: str) -> str:
        """برای یک SKU مشخص، بچ نامبر بسته‌بندی بعدی را تولید می‌کند."""
        now_jalali = jd.datetime.now()
        year_short = str(now_jalali.year)[-2:]
        month_str = f"{now_jalali.month:02d}"
        
        # بچ نامبر نهایی به این شکل خواهد بود: PACK-SKU-YYMM-NNN
        search_pattern = f"PACK-{sku_prefix}-{year_short}{month_str}-%"
        
        # ما در جدول stock دنبال بچ نامبرهای قبلی می‌گردیم
        query = "SELECT MAX(batch_no) as last_batch FROM stock WHERE batch_no LIKE %s"
        last_batch_rec = self.execute_query(query, (search_pattern,), fetch_one=True)
        
        last_batch = last_batch_rec.get('last_batch') if last_batch_rec else None
        
        next_serial = 1
        if last_batch:
            try:
                last_serial_str = last_batch.split('-')[-1]
                next_serial = int(last_serial_str) + 1
            except (IndexError, ValueError):
                next_serial = 1
                
        return f"PACK-{sku_prefix}-{year_short}{month_str}-{next_serial:03d}"
                
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def add_lab_delivery_trans(self, item_id: int, qty: float, batch_no: str, expiry_date: dt.date, notes: str, user_id: int):
        """
        یک تراکنش خروج به آزمایشگاه ثبت کرده و موجودی را از انبار تولید کسر می‌کند.
        این عملیات اتمیک و امن است.
        """
        prod_loc_id = self.get_production_floor_location()
        if not prod_loc_id:
            raise ValueError("انبار 'کف کارگاه' (Production) در سیستم تعریف نشده است.")

        with self.transaction() as cur:
            # گام ۱: کسر موجودی از انبار تولید
            self._upd_stock(cur, item_id, prod_loc_id, -abs(qty), batch_no, expiry_date)

            # گام ۲: ثبت تراکنش خروج به آزمایشگاه
            cur.execute(
                """INSERT INTO trans (item_id, t_type, qty, notes, user_id, src_loc, status, batch_no, expiry_date, t_date, t_no)
                   VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s) RETURNING id""",
                (
                    item_id,
                    TransactionType.EXIT_TO_LAB.value, # <-- اصلاح کلیدی: استفاده از Enum
                    qty,
                    notes,
                    user_id,
                    prod_loc_id,
                    TransactionStatus.APPROVED.value,
                    batch_no,
                    expiry_date,
                    f"LAB-{item_id}-{int(dt.datetime.now().timestamp())}"
                )
            )
            trans_id = cur.fetchone()['id']
            
            # گام ۳: ثبت لاگ حسابرسی
            log_details = f"Sent to lab: trans_id:{trans_id}, item_id:{item_id}, qty:{qty}, batch:{batch_no}"
            self._log_atomic(cur, user_id, 'LAB_DELIVERY', log_details)
            
            return trans_id
                
# در کلاس DB، این متد را با نسخه جدید و امن جایگزین کنید
    def get_next_bulk_batch_no(self, part_type: str) -> str:
        """
        نسخه ۲.۰ (امن و اتمیک):
        با استفاده از یک جدول سکانس در دیتابیس، بچ نامبر بعدی را به صورت کاملاً امن
        و بدون ریسک تکرار (Race Condition) تولید می‌کند.
        """
        if part_type.upper() not in ['R', 'H', 'P']:
            raise ValueError("نوع پارت برای بچ نامبر باید 'R', 'H' یا 'P' باشد.")

        prefix = part_type.upper()
        now_jalali = jd.datetime.now()
        year_short = str(now_jalali.year)[-2:]
        month_str = f"{now_jalali.month:02d}"
        
        # نام سکانس بر اساس پیشوند، سال و ماه ساخته می‌شود تا هر ماه از ۱ شروع شود
        sequence_name = f"batch_{prefix}_{year_short}{month_str}"

        try:
            with self.transaction() as cur:
                # ابتدا بررسی می‌کنیم که آیا سکانس برای این ماه وجود دارد یا خیر
                cur.execute("SELECT 1 FROM sequences WHERE name = %s", (sequence_name,))
                if cur.fetchone() is None:
                    # اگر وجود نداشت، آن را ایجاد می‌کنیم
                    cur.execute("INSERT INTO sequences (name, value) VALUES (%s, 0)", (sequence_name,))

                # حالا شماره بعدی را به صورت اتمیک از دیتابیس درخواست می‌کنیم
                result = self.execute_query(
                    "SELECT get_next_seq(%s) as next_val",
                    (sequence_name,),
                    fetch_one=True,
                    cursor=cur
                )
                next_serial = result['next_val']

            return f"{prefix}-{year_short}{month_str}-{next_serial:03d}"
            
        except Exception as e:
            # در صورت بروز هرگونه خطا، یک پیام واضح برای تحلیل مشکل برمی‌گردانیم
            raise RuntimeError(f"خطا در هنگام تولید شماره بچ از سکانس دیتابیس: {e}")
        
                        
    def get_all_units(self):
            """لیست تمام واحدهای اندازه‌گیری تعریف شده را برمی‌گرداند."""
            return self.execute_query("SELECT id, name, abbreviation FROM units ORDER BY name")

# در کلاس DB، این متد را جایگزین کنید

    def delete_unit(self, unit_id: int):
        """یک واحد را به صورت اتمیک حذف می‌کند، به شرطی که توسط هیچ کالایی استفاده نشده باشد."""
        with self.transaction() as cur:
            # ابتدا چک می‌کنیم که آیا این واحد در حال استفاده است یا خیر
            in_use = self.execute_query(
                "SELECT 1 FROM items WHERE unit_id = %s LIMIT 1",
                (unit_id,),
                cursor=cur,
                fetch_one=True
            )
            if in_use:
                raise ValueError("این واحد توسط یک یا چند کالا در حال استفاده است و قابل حذف نیست.")
            
            # اگر استفاده نشده بود، حذف کن
            self.execute_query("DELETE FROM units WHERE id = %s", (unit_id,), cursor=cur)
                                                    
# این متد جدید را به کلاس DB اضافه کنید
    def void_asset_transaction(self, trans_id_to_void: int, user_id: int):
        """یک تراکنش دارایی را باطل کرده و وضعیت دارایی را به حالت قبل برمی‌گرداند."""
        with self.transaction() as cur:
            # گام ۱: تراکنش اصلی را برای ابطال پیدا کن
            cur.execute("SELECT * FROM asset_trans WHERE id = %s FOR UPDATE", (trans_id_to_void,))
            orig_trans = cur.fetchone()

            if not orig_trans: raise ValueError("تراکنش مورد نظر یافت نشد.")
            if orig_trans['status'] == 'باطل شده': raise ValueError("این تراکنش قبلاً باطل شده است.")
            
            asset_id = orig_trans['asset_id']
            
            # گام ۲: پیدا کردن آخرین وضعیت دارایی قبل از این تراکنش
            cur.execute(
                "SELECT t_type FROM asset_trans WHERE asset_id = %s AND id < %s ORDER BY id DESC LIMIT 1",
                (asset_id, trans_id_to_void)
            )
            prev_trans = cur.fetchone()

            previous_status = 'در انبار' # حالت پیش‌فرض اگر هیچ تراکنش قبلی نباشد
            if prev_trans:
                if prev_trans['t_type'] in ["خروج (تعمیرات)", "خروج (پروژه)"]:
                    previous_status = prev_trans['t_type']
                elif prev_trans['t_type'] == "بازگشت به انبار":
                    previous_status = "در انبار"
                elif prev_trans['t_type'] == "اسقاط":
                    previous_status = "اسقاط شده"

            # گام ۳: آپدیت وضعیت خود دارایی به حالت قبلی
            cur.execute("UPDATE assets SET status = %s WHERE id = %s", (previous_status, asset_id))

            # گام ۴: ثبت تراکنش ابطال
            void_note = f"ابطال تراکنش شماره {trans_id_to_void} ({orig_trans['t_type']})"
            cur.execute(
                """INSERT INTO asset_trans (asset_id, t_type, t_no, t_date, notes, user_id, status, voids_trans_id)
                   VALUES (%s, %s, %s, %s, %s, %s, %s, %s)""",
                (asset_id, f"ابطال {orig_trans['t_type']}", orig_trans['t_no'], datetime.now(), void_note, user_id, 'تایید شده', trans_id_to_void)
            )

            # گام ۵: علامت‌گذاری تراکنش اصلی به عنوان "باطل شده"
            cur.execute("UPDATE asset_trans SET status = 'باطل شده' WHERE id = %s", (trans_id_to_void,))

            self._log_atomic(cur, user_id, 'VOID_ASSET_TRANS', f"Voided asset_trans_id: {trans_id_to_void}")
            
            
                                    
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def _seed_initial_permissions_and_roles(self, cur):
        """
        نسخه نهایی و جامع (بازطراحی شده):
        - تمام دسترسی‌های ممکن در سیستم را به صورت گروه‌بندی شده و شفاف تعریف می‌کند.
        - دسترسی‌های جدید برای ماژول‌های فروش و کنترل کیفیت را شامل می‌شود.
        """
        permissions = [
            # --- دسترسی‌های مشاهده صفحات اصلی ---
            ('page:view:dashboard', 'مشاهده داشبورد'),
            ('page:view:items', 'مشاهده کالاها و دارایی‌ها'),
            ('page:view:transactions', 'مشاهده تراکنش‌ها'),
            ('page:view:purchasing', 'مشاهده ماژول بازرگانی'),
            ('page:view:qa', 'مشاهده ماژول تضمین کیفیت (QA)'),
            ('page:view:qc', 'مشاهده ماژول کنترل کیفیت (QC)'),
            ('page:view:sales', 'مشاهده ماژول فروش'),
            ('page:view:production', 'مشاهده مدیریت تولید'),
            ('page:view:inventory', 'مشاهده انبارگردانی'),
            ('page:view:forms', 'مشاهده فرم‌های عمومی'),
            ('page:view:settings', 'مشاهده تنظیمات'),

            # --- دسترسی‌های ماژول کالاها و دارایی‌ها ---
            ('items:create', 'ایجاد کالای جدید'),
            ('items:edit', 'ویرایش کالا'),
            ('items:delete', 'حذف کالا'),
            ('items:view_cost', 'مشاهده ارزش ریالی'),
            ('items:recalc_minmax', 'محاسبه حد سفارش'),
            ('assets:create', 'تعریف دارایی'),
            ('assets:edit', 'ویرایش دارایی'),
            ('assets:delete', 'حذف دارایی'),
            ('assets:transact', 'ثبت تراکنش دارایی'),

            # --- دسترسی‌های ماژول تراکنش‌ها و انبار ---
            ('transactions:create_entry', 'ثبت تراکنش ورود'),
            ('transactions:create_exit', 'ثبت تراکنش خروج'),
            ('transactions:create_other', 'ثبت سایر تراکنش‌ها (ضایعات، برگشت)'),
            ('transactions:transfer', 'انجام انتقال داخلی بین انبارها'),
            ('transactions:void', 'ابطال تراکنش‌های تایید شده'),
            ('transactions:cancel_pending', 'لغو تراکنش‌های در انتظار'),
            ('warehouse:approve_void', 'تایید نهایی ابطال (مدیر انبار)'),
            ('warehouse:fulfill_request', 'رسیدگی به درخواست مواد اولیه/داخلی'),
            ('warehouse:approve_delivery', 'تایید دریافت محصول از تولید'),
            ('warehouse:approve_return', 'تایید برگشت مواد از تولید'),

            # --- دسترسی‌های ماژول بازرگانی ---
            ('purchasing:manage_suppliers', 'مدیریت تامین‌کنندگان'),
            ('purchasing:create_request', 'ایجاد درخواست خرید'),
            ('purchasing:manage_quotes', 'مدیریت استعلام‌ها و پیشنهاد قیمت'),
            ('purchasing:create_po', 'ایجاد سفارش خرید (PO)'),
            ('purchasing:receive_po', 'ثبت رسید سفارش خرید'),

            # --- دسترسی‌های ماژول فروش (جدید) ---
            ('sales:create_order', 'ثبت سفارش فروش جدید'),
            ('sales:manage_customers', 'مدیریت مشتریان'),
            ('sales:start_proforma_process', 'شروع فرآیند پیش‌فاکتور'),
            ('sales:export_pdf', 'دریافت خروجی PDF پیش‌فاکتور'),
            ('sales:inquire_qc', 'استعلام سوابق کیفی بچ‌ها'),

            # --- دسترسی‌های ماژول تضمین کیفیت (QA) ---
            ('qa:manage_forms', 'طراحی و مدیریت فرم‌های QA'),
            ('qa:manage_org_chart', 'مدیریت چارت سازمانی'),

            # --- دسترسی‌های ماژول کنترل کیفیت (QC) (جدید) ---
            ('qc:manage_quarantine', 'تایید یا رد کیفی کالاهای ورودی'),
            ('qc:resolve_nonconforming', 'تعیین تکلیف کالاهای نامنطبق (مرجوعی/ضایعات)'),
            ('qc:view_history', 'مشاهده و جستجو در بایگانی گزارش‌های کیفی'),

            # --- دسترسی‌های ماژول تولید ---
            ('production:manage_recipes', 'مدیریت فرمول‌های ساخت (BOM)'),
            ('production:report', 'ثبت گزارش تولید (محصول فله)'),
            ('production:packing', 'انجام عملیات بسته‌بندی (محصول نهایی)'),
            ('production:request_materials', 'ثبت درخواست مواد از انبار'),
            ('production:approve_transfer', 'تایید دریافت مواد اولیه از انبار'),
            ('production:void_production', 'ابطال بچ تولید یا عملیات بسته‌بندی'),
            ('production:confidentiality:manage', 'مدیریت محرمانگی فرمول‌ها'),              # ← اضافه جدید
            ('production:financial_report', 'گزارش مالی تولید (BOM)'),                     # ← اضافه جدید

            # --- دسترسی‌های ماژول انبارگردانی ---
            ('inventory:start_count', 'شروع انبارگردانی جدید'),
            ('inventory:perform_count', 'انجام شمارش و ثبت مقادیر'),
            ('inventory:review_count', 'بازبینی مغایرت‌ها و تایید نهایی'),

            # --- دسترسی‌های ماژول تنظیمات ---
            ('settings:manage_users', 'مدیریت کاربران و نقش‌ها'),
            ('settings:manage_locations', 'مدیریت انبارها و لوکیشن‌ها'),
            ('settings:manage_units', 'مدیریت واحدهای شمارش'),
            ('settings:manage_app', 'تغییر تنظیمات کلی برنامه'),
            ('settings:backup_restore', 'پشتیبان‌گیری و بازیابی اطلاعات'),
            ('settings:factory_reset', 'ریست کامل برنامه (بسیار خطرناک)'),
        ]
        
        cur.executemany("INSERT INTO permissions (code, description) VALUES (%s, %s) ON CONFLICT (code) DO NOTHING", permissions)
        cur.execute("INSERT INTO roles (name, dashboard_type) VALUES ('Admin', 'ADMIN') ON CONFLICT (name) DO NOTHING")
        cur.execute("SELECT id FROM roles WHERE name = 'Admin'")
        admin_role_id_rec = cur.fetchone()
        if admin_role_id_rec:
            admin_role_id = admin_role_id_rec['id']
            cur.execute("SELECT id FROM permissions")
            all_perm_ids = [p['id'] for p in cur.fetchall()]
            perms_to_insert = [(admin_role_id, perm_id) for perm_id in all_perm_ids]
            if perms_to_insert:
                cur.execute("DELETE FROM role_permissions WHERE role_id = %s", (admin_role_id,))
                cur.executemany("INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s) ON CONFLICT DO NOTHING", perms_to_insert)
        
        admin_pass_hash = hash_password('admin')
        cur.execute("INSERT INTO users(username, passhash, role_id) VALUES (%s, %s, %s) ON CONFLICT (username) DO NOTHING", 
                    ('admin', admin_pass_hash, admin_role_id if admin_role_id_rec else None))
        
    def _get_permission_label(self, code: str) -> str:
        """
        برچسب فارسی استاندارد برای کُدهای شناخته‌شده.
        """
        c = (code or "").strip().lower()
        labels = {
            'page:view:production': 'مشاهده مدیریت تولید',
            'production:confidentiality:manage': 'مدیریت محرمانگی فرمول‌ها',
            'production:financial_report': 'گزارش مالی تولید (BOM)',
            # کُد نهایی واحد برای دیدن BOM/فرمول
            'production:formula:view': 'مشاهدهٔ کامل BOM و جزئیات فرمول',

            # --- دسترسی‌های ریز مربوط به «سایر عملیات» در تولید ---
            'production:ops:deliver': 'تحویل محصول بسته‌بندی شده به انبار',
            'production:ops:return':  'برگشت مواد اولیه به انبار',
        }
        return labels.get(c, f'دسترسی: {c}')

    def _canonicalize_permission_code(self, code: str) -> str:
        """
        تمام نام‌های پراکنده/قدیمی مرتبط با «دیدن کامل BOM/فرمول» را
        به کُد نهایی 'production:formula:view' تبدیل می‌کند.
        غیر از آن، دست‌نخورده برمی‌گرداند.
        """
        c = (code or '').strip().lower()
        if not c:
            return c

        alias_map = {
            'production:formulaview':        'production:formula:view',
            'production:view_bom_full':      'production:formula:view',
            'production:bom_full:view':      'production:formula:view',
            'production:formula:full_view':  'production:formula:view',
            'production:formula_full_view':  'production:formula:view',
            'production:formula:view_full':  'production:formula:view',
            'production:bomfull:view':       'production:formula:view',
        }
        if c in alias_map:
            return alias_map[c]

        # پوشش شکل‌های مشابه با خط تیره/زیرخط/نقطه
        import re
        patt = r'^production:(?:bom|formula)[:_\-\.]?(?:full|full_)?[_\-\.]?view$'
        if re.match(patt, c):
            return 'production:formula:view'

        return c

    def ensure_permission_exists(self, code, description=None):
        """
        ثبت/اصلاح permission با کانُنیکال‌سازی نام.
        اگر توضیح خام/خالی باشد، فارسی استاندارد ست می‌شود.
        برای نشکستن رفتار، پیش‌فرض فقط به Admin داده می‌شود.
        """
        try:
            if not code or ':' not in str(code):
                return None
            base = str(code).strip().lower()
            canon = self._canonicalize_permission_code(base)
            final_desc = description or self._get_permission_label(canon)

            with self.transaction() as cur:
                cur.execute(
                    "INSERT INTO permissions (code, description) VALUES (%s, %s) "
                    "ON CONFLICT (code) DO NOTHING",
                    (canon, final_desc)
                )
                cur.execute("SELECT id, description FROM permissions WHERE code = %s", (canon,))
                row = cur.fetchone()
                if not row:
                    return None
                pid = row['id']
                have = (row.get('description') or '').strip()
                low = have.lower()
                if (not have) or (low == canon) or low.startswith('دسترسی:') or low.startswith('permission:') or low.startswith('access:'):
                    if final_desc and final_desc != have:
                        try:
                            cur.execute("UPDATE permissions SET description = %s WHERE id = %s", (final_desc, pid))
                        except Exception:
                            pass

                # دادن خودکار به Admin
                cur.execute("SELECT id FROM roles WHERE name = 'Admin'")
                r = cur.fetchone()
                if r:
                    cur.execute(
                        "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s) "
                        "ON CONFLICT DO NOTHING",
                        (r['id'], pid)
                    )
                return pid
        except Exception as e:
            print('WARN ensure_permission_exists:', e)
            return None

    def normalize_permission_aliases(self):
        """
        تمام permissionsی که با الگو/نام‌های قدیمی «دیدن BOM/فرمول» ذخیره شده‌اند
        به 'production:formula:view' ادغام می‌شوند:
        - role_permissions منتقل می‌شود
        - رکوردهای قدیمی از permissions حذف می‌شود
        - برچسب فارسی رکورد نهایی تثبیت می‌شود
        """
        try:
            canonical = 'production:formula:view'
            canonical_label = self._get_permission_label(canonical)

            with self.transaction() as cur:
                # تضمین وجود رکورد نهایی
                cur.execute(
                    "INSERT INTO permissions (code, description) VALUES (%s, %s) "
                    "ON CONFLICT (code) DO NOTHING",
                    (canonical, canonical_label)
                )
                cur.execute("SELECT id FROM permissions WHERE code = %s", (canonical,))
                row = cur.fetchone()
                if not row:
                    return {'migrated': 0, 'deleted': 0}
                canonical_id = row['id']

                # پیمایش همه و ادغام موارد معادل
                rows = self.execute_query("SELECT id, code FROM permissions")
                migrated = 0
                deleted = 0
                for r in rows:
                    pid, code = r['id'], (r['code'] or '').strip().lower()
                    canon = self._canonicalize_permission_code(code)
                    if canon == canonical and code != canonical:
                        # انتقال نقش‌ها
                        cur.execute("SELECT role_id FROM role_permissions WHERE permission_id = %s", (pid,))
                        roles = [x['role_id'] for x in cur.fetchall()]
                        if roles:
                            cur.executemany(
                                "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s) "
                                "ON CONFLICT DO NOTHING",
                                [(rid, canonical_id) for rid in roles]
                            )
                            cur.execute("DELETE FROM role_permissions WHERE permission_id = %s", (pid,))
                        cur.execute("DELETE FROM permissions WHERE id = %s", (pid,))
                        migrated += 1
                        deleted += 1

                # پاکسازی نهایی: اگر چند رکورد با همان برچسب فارسی باقی مانده باشد
                cur.execute("""
                    SELECT id, code FROM permissions
                    WHERE LOWER(description) = LOWER(%s) AND code <> %s
                """, (canonical_label, canonical))
                dups = cur.fetchall() or []
                for d in dups:
                    dup_id, dup_code = d['id'], d['code']
                    cur.execute("SELECT role_id FROM role_permissions WHERE permission_id = %s", (dup_id,))
                    roles = [x['role_id'] for x in cur.fetchall()]
                    if roles:
                        cur.executemany(
                            "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s) "
                            "ON CONFLICT DO NOTHING",
                            [(rid, canonical_id) for rid in roles]
                        )
                        cur.execute("DELETE FROM role_permissions WHERE permission_id = %s", (dup_id,))
                    cur.execute("DELETE FROM permissions WHERE id = %s", (dup_id,))
                    deleted += 1

                cur.execute("UPDATE permissions SET description = %s WHERE id = %s",
                            (canonical_label, canonical_id))

            print(f'INFO normalize_permission_aliases: migrated={migrated}, deleted={deleted}')
            return {'migrated': migrated, 'deleted': deleted}
        except Exception as e:
            print('WARN normalize_permission_aliases failed:', e)
            return {'migrated': 0, 'deleted': 0}

    def sync_permissions_with_source(self):
        """
        اسکن رشته‌های permission داخل فایل، کانُنیکال‌سازی همه، درجِ موارد جدید،
        و آپدیت برچسب فارسی برای کُدهای شناخته‌شده.
        """
        try:
            import os, re
            file_path = os.path.abspath(__file__)
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as fh:
                src = fh.read()

            raw = set(re.findall(r"[\'\"]([A-Za-z]+(?::[A-Za-z0-9_]+)+)[\'\"]", src))
            candidates = sorted({self._canonicalize_permission_code(s.lower()) for s in raw})

            rows = self.execute_query("SELECT code FROM permissions")
            existing = {r['code'] for r in rows}

            missing = [c for c in candidates if c not in existing]
            if missing:
                with self.transaction() as cur:
                    for code in missing:
                        cur.execute(
                            "INSERT INTO permissions (code, description) VALUES (%s, %s) "
                            "ON CONFLICT (code) DO NOTHING",
                            (code, self._get_permission_label(code))
                        )
                    # دادن به Admin برای موارد تازه
                    cur.execute("SELECT id FROM roles WHERE name = 'Admin'")
                    r = cur.fetchone()
                    admin_id = r['id'] if r else None
                    if admin_id:
                        cur.execute("SELECT id, code FROM permissions WHERE code = ANY(%s)", (missing,))
                        id_map = {row['code']: row['id'] for row in cur.fetchall()}
                        pairs = [(admin_id, id_map[c]) for c in missing if c in id_map]
                        if pairs:
                            cur.executemany(
                                "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s) "
                                "ON CONFLICT DO NOTHING",
                                pairs
                            )
            print(f'INFO permission sync: found={len(candidates)} inserted={len(missing)}')
            return {'found': len(candidates), 'inserted': len(missing)}
        except Exception as e:
            print('WARN sync_permissions_with_source failed:', e)
            return {'found': 0, 'inserted': 0}

        
    def _get_allowed_permission_prefixes(self):
        """
        پیشوندهای مجاز را به‌صورت خودکار از جدول permissions استخراج می‌کند.
        مثال خروجی: {'items:', 'assets:', 'transactions:', 'production:', 'page:view:', ...}
        اگر دیتابیس خالی بود یا خطا شد، یک لیست حداقلی برمی‌گرداند.
        """
        try:
            rows = self.execute_query("SELECT code FROM permissions")
            prefixes = set()
            for r in rows:
                code = (r['code'] or '').strip().lower()
                if not code or ':' not in code:
                    continue
                parts = code.split(':')
                # کدهای نوع page:view:<module>
                if parts[0] == 'page' and len(parts) >= 2 and parts[1] == 'view':
                    prefixes.add('page:view:')
                # کدهای معمولی مثل items:edit
                if len(parts) >= 2 and parts[0]:
                    prefixes.add(parts[0] + ':')
            # اگر چیزی درنیامد، حداقل پیش‌فرض امن
            if not prefixes:
                prefixes = {
                    'page:view:', 'items:', 'assets:', 'transactions:', 'warehouse:',
                    'purchasing:', 'sales:', 'qa:', 'qc:', 'production:', 'inventory:', 'settings:', 'forms:'
                }
            return tuple(sorted(prefixes))
        except Exception as e:
            print('WARN _get_allowed_permission_prefixes:', e)
            return (
                'page:view:', 'items:', 'assets:', 'transactions:', 'warehouse:',
                'purchasing:', 'sales:', 'qa:', 'qc:', 'production:', 'inventory:', 'settings:', 'forms:'
            )

                    
                        
                                                                                                                                                        
    # FIX: PROD-LOC-CANONICAL (2025-09-24) — helper to build JOIN without exploding on l.is_default
    def _join_default_location_sql(self, cursor=None) -> str:
        """
        اگر ستون is_default در locations وجود داشت، شرطش را اضافه می‌کنیم؛
        وگرنه JOIN ساده انجام می‌دهیم تا خطای «column l.is_default does not exist» نخورد.
        """
        try:
            cols = set(self._get_existing_columns('locations', cursor=cursor) or [])
        except Exception:
            # fallback بدون introspection
            cols = set()
        if 'is_default' in cols:
            return "JOIN locations l ON l.warehouse_id = w.id AND COALESCE(l.is_default, TRUE) = TRUE"
        return "JOIN locations l ON l.warehouse_id = w.id"


    # FIX: PROD-LOC-CANONICAL (2025-09-24) — safe default location resolution
    def get_warehouse_default_location(self, warehouse_name: str):
        """
        ID لوکیشن پیش‌فرض یک انبار را برمی‌گرداند، بدون اتکا به ستون‌هایی که شاید وجود نداشته باشند.
        راهبرد:
        1) اگر warehouses.default_location_id وجود دارد و مقدار دارد → همان
        2) در غیر این‌صورت، اولین لوکیشن همان انبار (ORDER BY l.id)
        """
        with self.transaction() as cur:
            # حالت 1: ستون default_location_id اگر باشد
            try:
                cols_w = set(self._get_existing_columns('warehouses', cursor=cur) or [])
            except Exception:
                cols_w = set()
            if 'default_location_id' in cols_w:
                cur.execute("""
                    SELECT w.default_location_id AS loc_id
                    FROM warehouses w
                    WHERE LOWER(w.name) = LOWER(%s) AND w.default_location_id IS NOT NULL
                    LIMIT 1
                """, (warehouse_name,))
                r = cur.fetchone()
                if r and r.get('loc_id'):
                    return int(r['loc_id'])

            # حالت 2: JOIN با locations بدون تکیه به l.is_default
            join_sql = self._join_default_location_sql(cursor=cur)
            cur.execute(f"""
                SELECT l.id AS loc_id
                FROM warehouses w
                {join_sql}
                WHERE LOWER(w.name) = LOWER(%s)
                ORDER BY l.id
                LIMIT 1
            """, (warehouse_name,))
            r2 = cur.fetchone()
            return int(r2['loc_id']) if r2 and r2.get('loc_id') else None
    

    def get_stock_for_warehouse(self, warehouse_name: str):
        """موجودی همهٔ کالاها در یک انبار مشخص به‌همراه واحد و شناسهٔ والد."""
        query = """
            SELECT 
                i.id          AS item_id,
                i.name,
                i.category,
                i.parent_item_id,
                COALESCE(u.name,'') AS unit,
                i.min_qty,
                s.batch_no,
                SUM(s.qty)   AS total_qty,
                MIN(s.expiry_date) AS expiry_date
            FROM stock s
            JOIN items i       ON i.id = s.item_id
            LEFT JOIN units u  ON u.id = i.unit_id
            JOIN locations l   ON l.id = s.location_id
            JOIN warehouses w  ON w.id = l.warehouse_id
            WHERE w.name = %s
            GROUP BY i.id, i.name, i.category, i.parent_item_id, u.name, i.min_qty, s.batch_no
            ORDER BY i.name
        """
        return self.execute_query(query, (warehouse_name,))
        
# === BEGIN PATCH: DB methods for 'returns from production' ===

    # === BEGIN PATCH: DB.get_pending_returns_from_production (V6 — trans-based, defensive) ===
    def get_pending_returns_from_production(self):
        """
        برمی‌گرداند: لیست درخواست‌های «برگشت از تولید» که هنوز تایید/رد نشده‌اند.
        خروجی کلیدها: id, item_name, unit_name, qty, batch_no, requested_at, requester, reason
        """
        with self.transaction() as cur:
            # وجود جدول trans
            cur.execute("SELECT to_regclass('trans') AS r")
            if not (cur.fetchone() or {}).get('r'):
                return []

            # کشف ستون‌ها
            tcols = set(self._get_existing_columns('trans', cursor=cur))
            idc     = 'id'
            itemc   = 'item_id' if 'item_id' in tcols else None
            qtyc    = 'qty' if 'qty' in tcols else ('quantity' if 'quantity' in tcols else None)
            typec   = 't_type' if 't_type' in tcols else ('type' if 'type' in tcols else None)
            statusc = 'status' if 'status' in tcols else None
            batchc  = 'batch_no' if 'batch_no' in tcols else ('batch' if 'batch' in tcols else None)
            expc    = 'expiry_date' if 'expiry_date' in tcols else ('exp_date' if 'exp_date' in tcols else None)
            datec   = next((c for c in ('t_date','created_at','created_on','date') if c in tcols), None)
            userc   = next((c for c in ('user_id','created_by','requested_by') if c in tcols), None)
            notesc  = next((c for c in ('notes','note','reason') if c in tcols), None)

            if not (itemc and qtyc and typec):
                return []

            # users/items/units
            def _reg(name):
                cur.execute("SELECT to_regclass(%s) AS r", (name,))
                return (cur.fetchone() or {}).get('r')

            has_items = bool(_reg('items'))
            has_units = bool(_reg('units'))
            has_users = bool(_reg('users'))
            users_cols = set(self._get_existing_columns('users', cursor=cur)) if has_users else set()
            name_cands = [c for c in ('username','full_name','display_name','name','email') if c in users_cols]

            requester_expr = ("COALESCE(" + ", ".join([f"uu.{c}" for c in name_cands]) + ")") if (has_users and userc and name_cands) else "''"
            join_users = f"LEFT JOIN users uu ON uu.id = t.{userc}" if (has_users and userc) else ""
            import re as _re

            unit_col = None
            if has_items and has_units:
                try:
                    unit_col = self._resolve_items_unit_column(cursor=cur)
                except Exception:
                    unit_col = None
                if unit_col:
                    ident_pattern = _re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")
                    if not ident_pattern.fullmatch(unit_col):
                        unit_col = None

            if has_items:
                item_name_expr = "i.name"
                join_items = f"JOIN items i ON i.id = t.{itemc}"
                if has_units and unit_col:
                    join_units = f"LEFT JOIN units u ON u.id = i.{unit_col}"
                    unit_name_expr = "COALESCE(u.name,'')"
                else:
                    unit_name_expr = "''"
                    join_units = ""
            else:
                item_name_expr = f"CAST(t.{itemc} AS text)"
                unit_name_expr = "''"
                join_items = join_units = ""

            batch_expr = f"t.{batchc}" if batchc else "NULL::text"
            date_expr  = f"t.{datec}" if datec else "NULL::timestamp"
            reason_expr= f"COALESCE(t.{notesc},'')" if notesc else "''"

            # فیلتر نوع و وضعیت
            types_fa = ('برگشت از تولید','برگشت مواد به انبار','برگشتی از تولید')
            types_en = ('return from production','return_from_production','return to warehouse from production')
            st_open_fa = ('در انتظار تایید انبار','در انتظار تایید','در انتظار')
            st_open_en = ('pending warehouse approval','pending_warehouse_approval','pending','awaiting')

            where_parts = [
                f"(t.{typec} = ANY(%s) OR lower(t.{typec}) = ANY(%s) "
                f"OR (t.{typec} ILIKE %s AND t.{typec} ILIKE %s) "
                f"OR (lower(t.{typec}) LIKE %s AND lower(t.{typec}) LIKE %s))",
                f"COALESCE(t.{qtyc},0) <> 0"
            ]
            params = [list(types_fa), [s.lower() for s in types_en], '%برگشت%','%تولید%','%return%','%prod%']

            if statusc:
                where_parts.append(f"(t.{statusc} IS NULL OR t.{statusc} = ANY(%s) OR lower(t.{statusc}) = ANY(%s))")
                params += [list(st_open_fa), [s.lower() for s in st_open_en]]

            sql = f"""
                SELECT
                    t.{idc} AS id,
                    {item_name_expr} AS item_name,
                    {unit_name_expr} AS unit_name,
                    COALESCE(t.{qtyc},0) AS qty,
                    {batch_expr} AS batch_no,
                    {date_expr}  AS requested_at,
                    {requester_expr} AS requester,
                    {reason_expr} AS reason
                FROM trans t
                {join_items}
                {join_units}
                {join_users}
                WHERE {' AND '.join(['(' + p + ')' for p in where_parts])}
                ORDER BY t.{idc} DESC
                LIMIT 500;
            """
            cur.execute(sql, tuple(params))
            result_rows = [dict(r) for r in (cur.fetchall() or [])]
            if DEBUG_DB_RESOLVE:
                unit_label = unit_col or 'NONE'
                print(f"[TRACE:DB:pending_returns] rows={len(result_rows)} unit_col={unit_label}")
            return result_rows
    # === END PATCH ===

    def approve_material_return(self, return_id: int, user_id: int, target_location_id: int):
        """
        تایید برگشت از تولید بر پایهٔ جدول trans (اتمیک و idempotent):
        - رکورد trans را FOR UPDATE می‌گیرد.
        - فقط اگر status «در انتظار تایید انبار» باشد عمل می‌کند.
        - از انبار مبدا تولید (src_loc_id) کم می‌کند و به مقصد اضافه می‌کند.
        - همان سطر trans را «انجام شد» می‌کند و from/to را می‌نویسد اگر ستونشان باشد.
        """
        with self.transaction() as cur:
            # 1) رکورد trans را قفل کن
            cur.execute("SELECT * FROM trans WHERE id=%s FOR UPDATE", (return_id,))
            t = cur.fetchone()
            if not t:
                raise ValueError("درخواست برگشت پیدا نشد.")

            # نوع و وضعیت
            t_type   = (t.get('t_type') or t.get('type') or '').strip()
            t_status = (t.get('status') or '').strip()

            # اگر قبلاً پردازش شده، idempotent برگرد
            if t_status and t_status != 'در انتظار تایید انبار':
                return

            is_return_from_prod = (
                t_type == 'برگشت از تولید' or
                ('برگشت' in t_type and 'تولید' in t_type) or
                ('return' in t_type.lower() and 'prod' in t_type.lower())
            )
            if not is_return_from_prod:
                raise ValueError("نوع تراکنش معتبر نیست (برگشت از تولید).")

            # 2) داده‌های لازم
            item_id  = int(t['item_id'])
            qty      = float(t['qty'] or 0.0)
            if qty <= 0:
                raise ValueError("مقدار برگشت نامعتبر است.")

            batch_no = t.get('batch_no') or t.get('batch')
            exp_dt   = t.get('expiry_date') or t.get('exp_date')

            # مبدا: اگر خود سطر trans از قبل from_location داشته باشد همان را بگیر، وگرنه کف تولید
            trans_cols = set(self._get_existing_columns('trans', cursor=cur))
            src_loc_id = None
            if 'from_location_id' in trans_cols:
                src_loc_id = t.get('from_location_id')
            if not src_loc_id:
                src_loc_id = self.get_production_floor_location()
            if not src_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # 3) کم از تولید (cross-expiry + عبور از وضعیت)
            self._upd_stock(
                cur,
                item_id=item_id,
                location_id=src_loc_id,
                qty_change=-abs(qty),
                batch_no=batch_no,
                expiry_date=exp_dt,            # اگر None باشد هم مشکلی نیست
                status=None,
                ignore_status_check=True,
                allow_cross_expiry_decrement=True
            )

            # 4) اضافه به مقصد
            self._upd_stock(
                cur,
                item_id=item_id,
                location_id=target_location_id,
                qty_change=abs(qty),
                batch_no=batch_no,
                expiry_date=exp_dt,
                status='تایید شده'
            )

            # 5) بستن سطر trans و نوشتن from/to در صورت وجود ستون
            sets, params = ["status=%s"], ['انجام شد']
            if 'processed_at' in trans_cols:
                sets.append("processed_at=NOW()")
            if 'processed_by' in trans_cols:
                sets.append("processed_by=%s"); params.append(user_id)
            if 'from_location_id' in trans_cols:
                sets.append("from_location_id=%s"); params.append(src_loc_id)
            if 'to_location_id' in trans_cols:
                sets.append("to_location_id=%s"); params.append(target_location_id)

            params.append(return_id)
            cur.execute(f"UPDATE trans SET {', '.join(sets)} WHERE id=%s", tuple(params))
            
            # داخل کلاس DB، در انتهای approve_material_return(...)
            try:
                self.mark_notification_resolved('APPROVE_RETURN', int(return_id))
            except Exception:
                pass
            try:
                if hasattr(self, 'signals'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass


            # 6) لاگ
            if hasattr(self, "_log_atomic"):
                self._log_atomic(cur, user_id, 'APPROVE_MATERIAL_RETURN',
                                f"trans#{return_id} item={item_id} qty={qty} batch={batch_no} "
                                f"from={src_loc_id} -> to={target_location_id}")
                
            


    def reject_material_return(self, return_id: int, user_id: int, reason: str = None):
        """
        رد برگشت از تولید بر پایه trans (بدون تغییر موجودی).
        """
        with self.transaction() as cur:
            cur.execute("SELECT * FROM trans WHERE id=%s FOR UPDATE", (return_id,))
            t = cur.fetchone()
            if not t:
                raise ValueError("درخواست برگشت پیدا نشد.")
            t_status = (t.get('status') or '').strip()
            if t_status and t_status != 'در انتظار تایید انبار':
                return  # idempotent

            tcols = set(self._get_existing_columns('trans', cursor=cur))
            sets, params = ["status=%s"], ['رد شده']
            if 'processed_at' in tcols: sets.append("processed_at=NOW()")
            if 'processed_by' in tcols: sets.append("processed_by=%s"); params.append(user_id)
            if 'notes' in tcols and (reason or ''):
                sets.append("notes=COALESCE(notes,'') || %s"); params.append("\nReject: " + reason)
            params.append(return_id)
            cur.execute(f"UPDATE trans SET {', '.join(sets)} WHERE id=%s", tuple(params))

            if hasattr(self, "_log_atomic"):
                self._log_atomic(cur, user_id, 'REJECT_MATERIAL_RETURN',
                                f"trans#{return_id} REJECTED ({reason or ''})")
                
    # ------------------- [DB class] Helpers for notifications -------------------
    # اضافه به داخل کلاس DB


    def _dbg(self, msg: str):
        # اگر فلگ سراسری یا اتریبیوت داخل DB روشن بود، لاگ بزن
        if getattr(self, 'DEBUG_NOTIF', False) or globals().get('DEBUG_NOTIF', False):
            print(msg)

    def _notif_key(self, action_key, action_data) -> str:
        return f"{action_key}:{action_data if action_data is not None else ''}"

    def _load_notif_set(self, key_name: str) -> set:
        raw = self.get_setting(key_name, "[]") or "[]"
        try:
            data = json.loads(raw)
            return set(data) if isinstance(data, list) else set()
        except Exception:
            return set()

    def _save_notif_set(self, key_name: str, s: set):
        try:
            self.set_setting(key_name, json.dumps(sorted(list(s))))
            self._dbg(f"[TRACE:NOTIF:store] upserted={len(s)} flags_set={key_name}")
        except Exception as e:
            self._dbg(f"[TRACE:NOTIF:store] error: {e}")

    def mark_notification_dismissed(self, action_key: str, action_data):
        key = self._notif_key(action_key, action_data)
        dismissed = self._load_notif_set("notif_dismissed_keys")
        if key not in dismissed:
            dismissed.add(key)
            self._save_notif_set("notif_dismissed_keys", dismissed)
        reads = self._load_notif_set("notif_read_keys")
        if key in reads:
            reads.remove(key)
            self._save_notif_set("notif_read_keys", reads)

    def mark_notification_read(self, action_key: str, action_data):
        key = self._notif_key(action_key, action_data)
        reads = self._load_notif_set("notif_read_keys")
        if key not in reads:
            reads.add(key)
            self._save_notif_set("notif_read_keys", reads)

    def mark_notification_resolved(self, action_key: str, action_data):
        key = self._notif_key(action_key, action_data)
        resolved = self._load_notif_set("notif_resolved_keys")
        if key not in resolved:
            resolved.add(key)
            self._save_notif_set("notif_resolved_keys", resolved)
        dismissed = self._load_notif_set("notif_dismissed_keys")
        if key in dismissed:
            dismissed.remove(key)
            self._save_notif_set("notif_dismissed_keys", dismissed)
            self._dbg(f"[TRACE:NOTIF:gc] id={key} reason=resolved removed=true")
        reads = self._load_notif_set("notif_read_keys")
        if key in reads:
            reads.remove(key)
            self._save_notif_set("notif_read_keys", reads)
            self._dbg(f"[TRACE:NOTIF:gc] id={key} reason=resolved removed=true")

    def _is_notif_suppressed(self, action_key: str, action_data) -> bool:
        k = self._notif_key(action_key, action_data)
        return (k in self._load_notif_set("notif_resolved_keys")) or (k in self._load_notif_set("notif_dismissed_keys"))
    # ==========================================================

                                                        
# در کلاس DB، این متد را با نسخه استاندارد زیر جایگزین کنید

    def get_setting(self, key: str, default: str = None):
        """یک مقدار را از جدول تنظیمات می‌خواند."""
        query = "SELECT value FROM app_settings WHERE key = %s"
        res = self.execute_query(query, (key,), fetch_one=True)
        return res['value'] if res else default
    
    
    def set_setting(self, key: str, value: str):
            """
            نسخه دیباگ نهایی برای تست جداگانه دستورات UPDATE و INSERT.
            """
            with self.transaction() as cur:
                # گام ۱: ابتدا تلاش می‌کنیم ردیف موجود را UPDATE کنیم
                print(f"DEBUG: Attempting to UPDATE key '{key}' to value '{value}'")
                cur.execute("UPDATE app_settings SET value = %s WHERE key = %s", (str(value), key))
                
                # گام ۲: بررسی می‌کنیم که آیا ردیفی آپدیت شد یا خیر
                if cur.rowcount > 0:
                    print(f"DEBUG: UPDATE successful. {cur.rowcount} row(s) affected.")
                else:
                    # گام ۳: اگر هیچ ردیفی آپدیت نشد، یعنی کلید وجود نداشته، پس آن را INSERT می‌کنیم
                    print(f"DEBUG: UPDATE affected 0 rows. Key '{key}' not found or no permission. Attempting to INSERT.")
                    try:
                        cur.execute(
                            "INSERT INTO app_settings (key, value) VALUES (%s, %s)",
                            (key, str(value))
                        )
                        print(f"DEBUG: INSERT successful for key '{key}'.")
                    except Exception as e:
                        print(f"DEBUG: INSERT failed for key '{key}'. Error: {e}")

    # BEGIN REWRITE: DB.add_file
    def add_file(self, trans_id: int, path: str):
        """افزودن فایل پیوست برای تراکنش، با تشخیص خودکار نام ستون مسیر فایل."""
        from psycopg2 import sql as _sql
        with self.transaction() as cur:
            try:
                cols = set(self._get_existing_columns('trans_files', cursor=cur))
            except Exception:
                cols = {'path'}  # fallback

            path_col = next((c for c in ('file_path', 'path', 'filepath') if c in cols), 'path')
            stmt = _sql.SQL("INSERT INTO trans_files(trans_id, {c}) VALUES (%s,%s)").format(
                c=_sql.Identifier(path_col)
            )
            cur.execute(stmt, (trans_id, path))
    # END REWRITE: DB.add_file

    # BEGIN REWRITE: DB.list_files
    def list_files(self, trans_id: int):
        """لیست فایل‌های پیوست یک تراکنش را (ایمن نسبت به نام ستون) برمی‌گرداند."""
        # ستون مسیر فایل را از جدول trans_files تشخیص می‌دهیم
        try:
            cols = set(self._get_existing_columns('trans_files'))
        except Exception:
            cols = {'path'}  # اگر تابع کمکی در دسترس نبود، پیش‌فرض

        path_col = next((c for c in ('file_path', 'path', 'filepath') if c in cols), 'path')
        query = f"SELECT id, {path_col} AS path FROM trans_files WHERE trans_id=%s"
        return self.execute_query(query, (trans_id,))
    # END REWRITE: DB.list_files

    def delete_file(self, file_id: int):
        """یک فایل پیوست را با استفاده از رویه استاندارد حذف می‌کند."""
        with self.transaction() as cur:
            cur.execute("DELETE FROM trans_files WHERE id=%s", (file_id,))
            
    def _log(self, user_id: int, act: str, det: str):
        """
        وقایع را با استفاده از user_id عددی و در یک تراکنش امن و مستقل ثبت می‌کند.
        """
        # استفاده از ابزار استاندارد برای ثبت یک لاگ به صورت اتمیک
        with self.transaction() as cur:
            cur.execute('INSERT INTO audit(stamp, user_id, action, details) VALUES (%s, %s, %s, %s)',
                        (datetime.now(dt.timezone.utc), user_id, act, det))
        
    # در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def verify(self, u, p):
        """
        کاربر را تایید می‌کند. اگر هش قدیمی بود، آن را به صورت خودکار به فرمت جدید ارتقا می‌دهد.
        """
        from passlib.exc import UnknownHashError

        with self.transaction() as cur:
            # گام ۱: کاربر را فقط بر اساس نام کاربری پیدا کن
            cur.execute(
                """SELECT u.id, u.username, u.passhash, r.id as role_id, r.name as role_name, r.dashboard_type
                FROM users u
                LEFT JOIN roles r ON u.role_id = r.id
                WHERE u.username=%s""",
                (u,))
            user_info = cur.fetchone()

            if not user_info:
                return None

            # گام ۲: تلاش برای بررسی رمز با روش جدید و امن
            try:
                if verify_password(p, user_info['passhash']):
                    # اگر موفق بود، یعنی هش از قبل به‌روز است.
                    pass
                else:
                    # اگر موفق نبود، یعنی رمز اشتباه است.
                    return None
            except UnknownHashError:
                # اگر با خطای UnknownHashError مواجه شدیم، یعنی هش از نوع قدیمی sha256 است
                print(f"INFO: Old hash format detected for user '{u}'. Attempting legacy verification...")
                if _hash_legacy(p) == user_info['passhash']:
                    # رمز با روش قدیمی صحیح است. حالا آن را به فرمت جدید آپدیت می‌کنیم.
                    print(f"INFO: Legacy password verified. Upgrading hash for user '{u}'...")
                    new_hash = hash_password(p)
                    cur.execute("UPDATE users SET passhash = %s WHERE id = %s", (new_hash, user_info['id']))
                else:
                    # رمز با روش قدیمی هم اشتباه است.
                    return None
            
            # (بقیه کد برای خواندن دسترسی‌ها بدون تغییر است)
            result = dict(user_info)
            if not user_info['role_id']:
                result['permissions'] = []
                result['dashboards'] = []
            else:
                role_id = user_info['role_id']
                cur.execute(
                    "SELECT p.code FROM permissions p JOIN role_permissions rp ON p.id = rp.permission_id WHERE rp.role_id = %s",
                    (role_id,))
                result['permissions'] = [p['code'] for p in cur.fetchall()]
                
                cur.execute(
                    "SELECT dashboard_key FROM role_dashboards WHERE role_id = %s",
                    (role_id,)
                )
                result['dashboards'] = [d['dashboard_key'] for d in cur.fetchall()]

            return result    
                                                                                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    # در کلاس DB، این متد را با نسخه جدید جایگزین کنید
    def add_trans(self, tup, usr):
        """
        نسخه اصلاح شده و ایمن: این تابع منسوخ شده و تمام درخواست‌ها را به
        تابع جدید و قدرتمند add_trans_extended هدایت می‌کند.
        FIX: این تابع حالا به جای تاپل، یک دیکشنری استاندارد می‌سازد.
        """
        print("WARNING: Deprecated function 'add_trans' was called. Redirecting to 'add_trans_extended'.")
        
        item_id = tup[0]
        # پیدا کردن یک لوکیشن پیش‌فرض برای کالا
        loc_id_res = self.execute_query("SELECT default_loc FROM items WHERE id=%s", (item_id,), fetch_one=True)
        loc_id = loc_id_res['default_loc'] if loc_id_res and loc_id_res['default_loc'] else self.get_warehouse_default_location('Main')

        # ساخت دیکشنری کامل به جای تاپل ناقص
        trans_data = {
            'item_id': item_id,
            't_type': tup[1],
            'doc_no': tup[2],
            't_date': tup[3],
            'qty': tup[4],
            'notes': tup[5],
            'attach_path': tup[6] if len(tup) > 6 else '',
            'loc_id': loc_id,
            'batch_no': 'LEGACY_DATA', # <<-- اصلاح کلیدی: بچ نامبر واضح‌تر
            'expiry_date': None
        }
        # ارسال دیکشنری به تابع جدید
        self.add_trans_extended(trans_data, usr)
    

    
    # --- DB.delete_user (REPLACE WHOLE METHOD) ---
    def delete_user(self, username: str):
        """
        حذف ایمن کاربر:
        - از حذف کاربر admin جلوگیری می‌کند.
        - اگر رکوردهای فرآیندی به این کاربر ارجاع دهند، به‌جای کرش، پیام خوانا می‌دهد.
        """
        if username.lower() == 'admin':
            raise ValueError("کاربر 'admin' به دلایل امنیتی قابل حذف نیست.")

        import psycopg2
        try:
            with self.transaction() as cur:
                self.execute_query("DELETE FROM users WHERE username = %s", (username,), cursor=cur)
        except psycopg2.errors.ForeignKeyViolation:
            # کاربر در process_instances یا سایر جداول ارجاع شده است
            raise ValueError(
                "این کاربر در سوابق فرایندی/تاریخی استفاده شده و قابل حذف نیست.\n"
                "برای حفظ تمامیت داده، ابتدا فرایندهای ارجاع‌دهنده را منتقل/ویرایش کنید "
                "یا به‌جای حذف، کاربر را نگه دارید (مثلاً نقش را خالی/تغییر دهید)."
            )
                            
    # جایگزین شود
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def min_alert(self):
        """هشدار کسری موجودی بر اساس حداقل تعریف شده برای هر کالا (در صورت وجود ستون مرتبط)."""
        from re import fullmatch

        with self.transaction() as cur:
            has_items = self._table_exists('items', cursor=cur)
            has_stock = self._table_exists('stock', cursor=cur)
            if not (has_items and has_stock):
                return []

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur)) if has_items else set()
            except Exception:
                item_cols = set()

            min_col = next((c for c in ('min_qty','minimum_qty','minquantity','min_stock','min_stock_qty') if c in item_cols), None)
            if not min_col or not fullmatch(r'[A-Za-z_][A-Za-z0-9_]*', min_col):
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:min_alert] skipped reason=min_col_missing')
                return []

            warehouse_exclude = 'Production'
            query = f"""
                WITH stock_qty AS (
                    SELECT s.item_id, SUM(s.qty) AS total_qty
                    FROM stock s
                    JOIN locations l ON s.location_id = l.id
                    JOIN warehouses w ON l.warehouse_id = w.id
                    WHERE w.name <> %s
                    GROUP BY s.item_id
                )
                SELECT i.name
                FROM items i
                LEFT JOIN stock_qty sq ON sq.item_id = i.id
                WHERE COALESCE(sq.total_qty, 0) < COALESCE(i.{min_col}, 0)
                  AND COALESCE(i.{min_col}, 0) > 0
                ORDER BY i.name
            """
            rows = self.execute_query(query, (warehouse_exclude,), cursor=cur) or []

        if DEBUG_DB_RESOLVE:
            print(f'[TRACE:DB:min_alert] rows={len(rows)} min_col={min_col}')
        return [r['name'] for r in rows]

    def exp_alert(self):
            """
            نسخه نهایی: هشدار کالاهای در شرف انقضا را بر اساس بازه زمانی تعریف شده
            در جدول app_settings محاسبه می‌کند.
            """
            # خواندن تنظیمات از دیتابیس با یک مقدار پیش‌فرض امن
            days_str = self.get_setting('expiry_alert_days', '30')
            try:
                days = int(days_str)
            except (ValueError, TypeError):
                days = 30 # اگر مقدار ذخیره شده در دیتابیس معتبر نبود، از ۳۰ استفاده کن

            query = """
                SELECT DISTINCT 
                    i.name,
                    s.batch_no,
                    s.expiry_date
                FROM stock s
                JOIN items i ON s.item_id = i.id
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE 
                    w.name = 'Main' 
                    AND s.qty > 0 
                    AND s.expiry_date IS NOT NULL 
                    AND s.expiry_date BETWEEN NOW() AND NOW() + INTERVAL '%s day'
                ORDER BY s.expiry_date ASC;
            """
            return self.execute_query(query, (days,))
        
    def get_items_count_by_category(self, category_name: str) -> int:
        """تعداد کل کالاها در یک دسته‌بندی (با نادیده‌گرفتن فاصله و نیم‌فاصله)"""
        column = self._resolve_items_category_column()
        if not column:
            self._log_items_category_warning()
            return 0

        query = f"""
            SELECT COUNT(i.id) AS total
            FROM items i
            WHERE REPLACE(REPLACE(COALESCE(i.{column}::text,''), E'\u200c',''), ' ','')
                = REPLACE(REPLACE(%s, E'\u200c',''), ' ','')
        """

        result = self.execute_query(query, (category_name,), fetch_one=True)
        return result['total'] if result else 0

    def items_brief(self, category_filter: str, limit: int, offset: int):
        """
        ????????? ???? ??????????????? ?????? ?? ???? (?????/????????? ?????? ????? ??????)
        + ????? ??????? ???? ? ?????? ?????????.
        """
        category_col = self._resolve_items_category_column()
        if not category_col:
            self._log_items_category_warning()
            return []

        unit_col = self._resolve_items_unit_column()
        parent_col = self.get_parent_column()

        import re as _re
        ident_pattern = _re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')
        if unit_col and not ident_pattern.fullmatch(unit_col):
            unit_col = None
        if parent_col and not ident_pattern.fullmatch(parent_col):
            parent_col = None

        unit_expr = f"i.{unit_col}" if unit_col else 'NULL::INTEGER'
        parent_expr = f"i.{parent_col}" if parent_col else 'NULL::INTEGER'
        category_expr = f"i.{category_col}"

        query = f"""
        WITH paged_items AS (
            SELECT i.id, {unit_expr} AS unit_id, {parent_expr} AS parent_item_id, i.name, {category_expr} AS category,
                i.cost, i.min_qty, i.max_qty,
                i.supplier, i.ent_date, i.notes, i.reporting_group, i.sku, i.is_packed,
                i.is_parent_product, i.net_weight
            FROM items i
            WHERE REPLACE(REPLACE(COALESCE({category_expr},''), E'\u200c',''), ' ','')
                = REPLACE(REPLACE(%s, E'\u200c',''), ' ','')
            ORDER BY i.name
            LIMIT %s OFFSET %s
        )
        SELECT
            pi.*,
            u.name AS unit,
            p.name AS parent_name,
            COALESCE(s.non_prod_qty, 0) AS non_prod_qty
        FROM paged_items pi
        LEFT JOIN units u ON pi.unit_id = u.id
        LEFT JOIN items p ON pi.parent_item_id = p.id
        LEFT JOIN (
            SELECT s.item_id, SUM(s.qty) AS non_prod_qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE w.name != 'Production'
            GROUP BY s.item_id
        ) s ON pi.id = s.item_id
        ORDER BY pi.name;
        """

        rows = self.execute_query(query, (category_filter, limit, offset)) or []
        if DEBUG_DB_RESOLVE:
            unit_label = unit_col or 'NULL'
            print(f"[TRACE:DB:items_brief] unit_col={unit_label} rows={len(rows)}")
        return rows
    def get_all_items_for_selection(self):
        """
        یک لیست بهینه از تمام کالاها برای استفاده در UI برمی‌گرداند؛ در اسکیماهای ناقص خروجی امن دارد.
        """
        from re import fullmatch

        with self.transaction() as cur:
            has_items = self._table_exists('items', cursor=cur)
            if not has_items:
                return []

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur))
            except Exception:
                item_cols = set()

            category_col = self._resolve_items_category_column(cursor=cur)
            if category_col and not fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", category_col):
                category_col = None

            unit_col = self._resolve_items_unit_column(cursor=cur)
            if unit_col and not fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", unit_col):
                unit_col = None

            parent_col = self.get_parent_column()
            if parent_col and parent_col not in item_cols:
                parent_col = None

            category_expr = f"i.{category_col}" if category_col else "NULL::text"
            unit_id_expr = f"i.{unit_col}" if unit_col else "NULL::integer"
            parent_expr = f"i.{parent_col}" if parent_col else "NULL::integer"
            unit_select_expr = "u.name" if unit_col else "NULL::text"
            is_parent_col = 'is_parent_product' if 'is_parent_product' in item_cols else None
            is_parent_expr = f"COALESCE(i.{is_parent_col}, FALSE)" if is_parent_col else "FALSE"

            has_units = unit_col is not None and self._table_exists('units', cursor=cur)
            unit_join = f"LEFT JOIN units u ON u.id = i.{unit_col}" if has_units else ""

            has_stock = self._table_exists('stock', cursor=cur)
            has_locations = self._table_exists('locations', cursor=cur)
            has_warehouses = self._table_exists('warehouses', cursor=cur)
            non_prod_select = "0::numeric AS non_prod_qty"
            non_prod_join = ""
            if has_stock and has_locations and has_warehouses:
                stock_cols = set(self._get_existing_columns('stock', cursor=cur))
                loc_cols = set(self._get_existing_columns('locations', cursor=cur))
                wh_cols = set(self._get_existing_columns('warehouses', cursor=cur))
                if {'item_id','qty','location_id'}.issubset(stock_cols) and 'warehouse_id' in loc_cols and 'name' in wh_cols:
                    non_prod_select = "COALESCE(sq.non_prod_qty, 0) AS non_prod_qty"
                    non_prod_join = """
LEFT JOIN (
    SELECT s.item_id, SUM(s.qty) AS non_prod_qty
    FROM stock s
    JOIN locations l ON s.location_id = l.id
    JOIN warehouses w ON l.warehouse_id = w.id
    WHERE w.name <> 'Production'
    GROUP BY s.item_id
) sq ON sq.item_id = i.id
"""

            query = f"""
                SELECT
                    i.id,
                    i.name,
                    {category_expr} AS category,
                    {unit_id_expr} AS unit_id,
                    {is_parent_expr} AS is_parent_product,
                    {parent_expr} AS parent_item_id,
                    {unit_select_expr} AS unit,
                    {non_prod_select}
                FROM items i
                {unit_join}
                {non_prod_join}
                ORDER BY i.name
            """

            rows = self.execute_query(query, cursor=cur) or []
            if DEBUG_DB_RESOLVE:
                print(f"[TRACE:DB:items_for_select] rows={len(rows)} unit_col={unit_col or 'NONE'} category_col={category_col or 'NONE'} parent_col={parent_col or 'NONE'}")
            return rows

    def loc_label(self, loc_id):
        """
        یک لیبل خوانا برای لوکیشن بر اساس ID آن برمی‌گرداند.
        نسخه اصلاح شده: از متد استاندارد execute_query استفاده می‌کند.
        """
        if not loc_id:
            return ''
        
        query = """
            SELECT w.name || '|' || rack || '-' || shelf || '-' || bin AS lbl
            FROM locations l
            JOIN warehouses w ON w.id = l.warehouse_id
            WHERE l.id = %s
        """
        # به جای باز کردن کانکشن دستی، از ابزار استاندارد استفاده می‌کنیم
        row = self.execute_query(query, (loc_id,), fetch_one=True)
        return row['lbl'] if row else ''
        
    def stock_breakdown(self, item_id: int):
        """Return stock rows for an item with schema-safe fallbacks."""
        from re import fullmatch

        with self.transaction() as cur:
            has_stock = self._table_exists('stock', cursor=cur)
            has_items = self._table_exists('items', cursor=cur)
            if not (has_stock and has_items):
                return []

            try:
                stock_cols = set(self._get_existing_columns('stock', cursor=cur))
            except Exception:
                stock_cols = set()

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur))
            except Exception:
                item_cols = set()

            has_locations = self._table_exists('locations', cursor=cur)
            has_warehouses = self._table_exists('warehouses', cursor=cur)
            loc_cols = set()
            wh_cols = set()
            if has_locations:
                try:
                    loc_cols = set(self._get_existing_columns('locations', cursor=cur))
                except Exception:
                    loc_cols = set()
            if has_warehouses:
                try:
                    wh_cols = set(self._get_existing_columns('warehouses', cursor=cur))
                except Exception:
                    wh_cols = set()

            if 'item_id' not in stock_cols or 'qty' not in stock_cols:
                return []

            def _sel(alias, cols, name, alias_name, default_sql):
                return f"{alias}.{name} AS {alias_name}" if name in cols else f"{default_sql} AS {alias_name}"

            stock_id_expr = _sel('s', stock_cols, 'id', 'id', 'NULL::integer')
            location_id_expr = _sel('s', stock_cols, 'location_id', 'location_id', 'NULL::integer')
            qty_expr = _sel('s', stock_cols, 'qty', 'qty', '0::numeric')
            status_expr = _sel('s', stock_cols, 'status', 'status', 'NULL::text')
            received_expr = _sel('s', stock_cols, 'received_at', 'received_at', 'NULL::timestamp')
            moved_expr = _sel('s', stock_cols, 'last_moved_at', 'last_moved_at', 'NULL::timestamp')
            batch_expr = _sel('s', stock_cols, 'batch_no', 'batch_no', 'NULL::text')

            expiry_col = next((c for c in ('expiry_date', 'exp_date') if c in stock_cols), None)
            expiry_expr = f"s.{expiry_col} AS expiry_date" if expiry_col else 'NULL::date AS expiry_date'

            unit_col = self._resolve_items_unit_column(cursor=cur)
            if unit_col and not fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", unit_col):
                unit_col = None
            has_units = unit_col is not None and self._table_exists('units', cursor=cur)
            unit_join = f"LEFT JOIN units u ON u.id = i.{unit_col}" if has_units else ''
            unit_expr = "COALESCE(u.name, '') AS unit" if has_units else 'NULL::text AS unit'

            loc_join = ''
            wh_join = ''
            warehouse_expr = 'NULL::text AS warehouse_name'
            if has_locations and 'id' in loc_cols:
                loc_join = 'LEFT JOIN locations l ON l.id = s.location_id'
                if has_warehouses and 'warehouse_id' in loc_cols and 'id' in wh_cols:
                    wh_join = 'LEFT JOIN warehouses w ON w.id = l.warehouse_id'
                    if 'name' in wh_cols:
                        warehouse_expr = 'w.name AS warehouse_name'
                elif 'name' in loc_cols:
                    warehouse_expr = 'l.name AS warehouse_name'

            name_expr = "COALESCE(w.name, '')" if wh_join and 'name' in wh_cols else "''"
            rack_label = "COALESCE(l.rack, '-')" if 'rack' in loc_cols else "'-'"
            shelf_label = "COALESCE(l.shelf, '-')" if 'shelf' in loc_cols else "'-'"
            bin_label = "COALESCE(l.bin, '-')" if 'bin' in loc_cols else "'-'"
            loc_label_expr = f"({name_expr} || ' / ' || {rack_label} || '-' || {shelf_label} || '-' || {bin_label}) AS loc" if loc_join else 'NULL::text AS loc'

            rack_expr = _sel('l', loc_cols, 'rack', 'rack', 'NULL::text')
            shelf_expr = _sel('l', loc_cols, 'shelf', 'shelf', 'NULL::text')
            bin_expr = _sel('l', loc_cols, 'bin', 'bin', 'NULL::text')

            select_parts = [
                stock_id_expr,
                location_id_expr,
                warehouse_expr,
                rack_expr,
                shelf_expr,
                bin_expr,
                loc_label_expr,
                batch_expr,
                expiry_expr,
                qty_expr,
                status_expr,
                received_expr,
                moved_expr,
                unit_expr,
            ]

            select_sql = ',\n                    '.join(select_parts)
            join_lines = [j for j in (unit_join, loc_join, wh_join) if j]
            join_sql = ''
            if join_lines:
                join_sql = '\n' + '\n'.join('                ' + j for j in join_lines)

            order_clause = 'i.name'
            if expiry_col:
                order_clause = f"COALESCE(s.{expiry_col}, DATE '9999-12-31'), i.name"

            query = f"""
                SELECT
                    {select_sql}
                FROM stock s
                JOIN items i ON i.id = s.item_id{join_sql}
                WHERE s.item_id = %s
                ORDER BY {order_clause}
            """

            rows = self.execute_query(query, (item_id,), cursor=cur) or []
            if DEBUG_DB_RESOLVE:
                print(f"[TRACE:DB:stock_breakdown] rows={len(rows)} unit_col={unit_col or 'NONE'}")
            return rows

    def items_in_location(self, loc_id: int):
        """Return items stored in a location with schema-safe joins."""
        from re import fullmatch

        with self.transaction() as cur:
            has_stock = self._table_exists('stock', cursor=cur)
            has_items = self._table_exists('items', cursor=cur)
            if not (has_stock and has_items):
                return []

            try:
                stock_cols = set(self._get_existing_columns('stock', cursor=cur))
            except Exception:
                stock_cols = set()

            if 'location_id' not in stock_cols or 'qty' not in stock_cols:
                return []

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur))
            except Exception:
                item_cols = set()

            unit_col = self._resolve_items_unit_column(cursor=cur)
            if unit_col and not fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", unit_col):
                unit_col = None
            has_units = unit_col is not None and self._table_exists('units', cursor=cur)
            unit_join = f"LEFT JOIN units u ON u.id = i.{unit_col}" if has_units else ''
            unit_sql = ''
            unit_expr = "NULL::text"
            if has_units:
                unit_sql = '\n' + '                ' + unit_join
                unit_expr = "COALESCE(u.name, '')"

            qty_expr = 's.qty'
            qty_condition = 's.qty > 0'

            query = f"""
                SELECT
                    i.name AS name,
                    {qty_expr} AS qty,
                    {unit_expr} AS unit
                FROM stock s
                JOIN items i ON i.id = s.item_id{unit_sql}
                WHERE s.location_id = %s AND {qty_condition}
                ORDER BY i.name
            """

            rows = self.execute_query(query, (loc_id,), cursor=cur) or []
            if DEBUG_DB_RESOLVE:
                print(f"[TRACE:DB:items_in_location] rows={len(rows)} unit_col={unit_col or 'NONE'}")
            return rows

    def trans_recent(self, limit=40):
        """آخرین تراکنش‌ها را برای نمایش در داشبورد برمی‌گرداند."""
        query = '''SELECT t.id,i.name,t.t_type,t.qty,t.t_date
                   FROM trans t JOIN items i ON t.item_id=i.id
                   ORDER BY t.id DESC LIMIT %s'''
        return self.execute_query(query, (limit,))
        

    def list_assets_in_stock(self):
        """فقط دارایی‌هایی را برمی‌گرداند که وضعیتشان 'در انبار' است."""
        query = "SELECT * FROM assets WHERE status='در انبار' ORDER BY name"
        return self.execute_query(query)
    

    def asset_trans_recent(self, limit: int = 100):
        """
        نسخه نهایی و کامل: جزئیات تراکنش‌های دارایی را به همراه نام کاربر و تعداد پیوست‌ها برمی‌گرداند.
        """
        query = """
        SELECT  at.id,
                a.code || ' – ' || a.name AS asset_lbl,
                at.t_type,
                at.t_date,
                at.t_no,
                at.notes,
                u.username as user_name,
                (SELECT COUNT(*) FROM asset_trans_files WHERE asset_trans_id = at.id) as files_count
        FROM    asset_trans AS at
        JOIN    assets      AS a  ON a.id = at.asset_id
        LEFT JOIN users     AS u  ON u.id = at.user_id
        ORDER BY at.id DESC
        LIMIT   %s
        """
        return self.execute_query(query, (limit,))
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_consumption(self, item_id: int, include_asset_exit: bool = True):
            """
            نسخه نهایی و بهینه‌سازی شده (V5.2):
            - تابع TRIM از کوئری حذف شد تا به PostgreSQL اجازه استفاده از ایندکس را بدهد.
            """
            import pandas as pd
            
            days_back = int(self.get_setting('reorder_analysis_days', '90'))
            
            out_types = ['خروج', 'خروج به تولید', 'ضایعات', 'کسری انبارگردانی', 'خروج دارایی']
            if not include_asset_exit:
                out_types.remove('خروج دارایی')

            placeholders = ','.join(['%s'] * len(out_types))
            
            # --- *** اصلاح کلیدی: حذف TRIM() از دو خط زیر *** ---
            q = f"""
                SELECT  t.t_date::date AS d, SUM(t.qty) AS total_out
                FROM    trans t
                WHERE   t.item_id = %s
                AND     t.t_type IN ({placeholders})
                AND     t.status = 'تایید شده' 
                AND     t.t_date IS NOT NULL 
                AND     t.t_date >= NOW() - (%s * INTERVAL '1 day')
                GROUP BY d
                ORDER BY d;
            """
            
            params = (item_id, *out_types, days_back)
            rows = self.execute_query(q, params)

            if not rows:
                return pd.Series(dtype=float)

            df = pd.DataFrame(rows, columns=['date', 'qty'])
            df['qty'] = df['qty'].abs()
            df['date'] = pd.to_datetime(df['date'])
            
            end_date = datetime.now().date()
            full_range = pd.date_range(end=end_date, periods=days_back, freq='D')
            
            ser = df.set_index('date')['qty']
            ser = ser.reindex(full_range, fill_value=0)
            
            return ser
                                            
# این متد جدید را به کلاس DB اضافه کنید
    def get_delivery_details(self, delivery_id: int):
        """جزئیات یک رکورد خاص از جدول production_deliveries را برمی‌گرداند."""
        return self.execute_query(
            "SELECT * FROM production_deliveries WHERE id = %s",
            (delivery_id,),
            fetch_one=True
        )
        
                
                    
    def calc_min_max(self, item_id: int, lead_days: int) -> bool:
            """نسخه دیباگ برای چاپ جزئیات محاسبات آماری."""
            import pandas as pd
            from math import sqrt, isnan
            print(f"\n[DEBUG] --- Running calc_min_max for item_id: {item_id} ---")

            service_level = float(self.get_setting('reorder_service_level', '0.95'))
            max_multiplier = float(self.get_setting('reorder_max_multiplier', '1.5'))
            print(f"[DEBUG] Settings: service_level={service_level}, max_multiplier={max_multiplier}")

            ser = self.get_consumption(item_id)
            
            if ser.empty or ser.sum() == 0:
                print("[DEBUG] >>> Calculation stopped: Consumption series is empty or sum is zero.")
                return False

            mu, sigma = ser.mean(), ser.std()
            print(f"[DEBUG] Stats: mean(mu)={mu:.4f}, std_dev(sigma)={sigma:.4f}")
            
            if isnan(mu) or isnan(sigma) or sigma == 0:
                min_q = int(round(mu * lead_days))
                print(f"[DEBUG] Calculated (simple): min_q={min_q}")
            else:
                z = 1.65 if service_level >= 0.95 else (1.28 if service_level >= 0.90 else 1.04)
                safety = z * sigma * sqrt(lead_days)
                min_q = int(round((mu * lead_days) + safety))
                print(f"[DEBUG] Calculated (statistical): z={z}, safety_stock={safety:.2f}, min_q={min_q}")
            
            max_q = int(round(min_q * max_multiplier))
            print(f"[DEBUG] Final calculated values: Min={min_q}, Max={max_q}")
            
            if min_q > 0 or max_q > 0:
                print("[DEBUG] >>> Updating database with new values.")
                with self.transaction() as cur:
                    cur.execute("""UPDATE items SET min_qty = %s, max_qty = %s WHERE id = %s""",
                                (min_q, max_q, item_id))
                return True
            
            print("[DEBUG] >>> Calculation result is zero, no update performed.")
            return False
                
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def add_warehouse(self, name: str):
        """
        یک انبار جدید اضافه کرده یا ID انبار موجود را برمی‌گرداند.
        نسخه نهایی: از context manager برای تضمین اتمی بودن عملیات استفاده می‌کند.
        """
        with self.transaction() as cur:
            # دستور ON CONFLICT DO NOTHING تضمین می‌کند که در صورت وجود انبار، خطایی رخ نمی‌دهد
            self.execute_query(
                "INSERT INTO warehouses(name) VALUES (%s) ON CONFLICT (name) DO NOTHING",
                (name,),
                cursor=cur
            )
            # همیشه ID انبار با نام مشخص شده را برمی‌گردانیم (چه جدید باشد چه از قبل موجود)
            result = self.execute_query(
                "SELECT id FROM warehouses WHERE name=%s",
                (name,),
                fetch_one=True,
                cursor=cur
            )
            return result['id'] if result else None
        
# در کلاس DB، این متد را جایگزین کنید
    def add_location(self, wh_id: int, rack: str, shelf: str, bin_: str):
        """
        یک لوکیشن جدید اضافه کرده و ID آن را برمی‌گرداند.
        نسخه نهایی: از ابزار استاندارد execute_query و مدیریت خطای شفاف استفاده می‌کند.
        """
        query = """
            INSERT INTO locations(warehouse_id, rack, shelf, bin)
            VALUES (%s, %s, %s, %s)
            RETURNING id
        """
        # اگر ورودی برای طبقه خالی بود، مقدار پیش‌فرض '1' را در نظر می‌گیریم
        params = (wh_id, rack, shelf, bin_ if bin_ else '1')
        
        try:
            # این یک عملیات واحد است، پس مستقیماً از execute_query استفاده می‌کنیم.
            result = self.execute_query(query, params, fetch_one=True)
            return result['id'] if result else None
            
        except psycopg2.errors.UniqueViolation:
            # این خطا زمانی رخ می‌دهد که لوکیشن از قبل وجود داشته باشد.
            # یک خطای خواناتر به لایه‌های بالاتر (UI) ارسال می‌کنیم تا به کاربر نمایش داده شود.
            raise ValueError(f"لوکیشن '{rack}-{shelf}-{bin_ or '1'}' از قبل در این انبار وجود دارد.")
        except Exception as e:
            # برای سایر خطاهای پیش‌بینی نشده
            print(f"ERROR in add_location: {e}")
            raise
        
    # BEGIN ADD: DB.list_locations_excluding_warehouse
    def list_locations_excluding_warehouse(self, *args, **kwargs):
        """
        شِم سازگاری برای فراخوانی‌های قدیمی.
        فراخوانی‌های قدیمی list_locations_excluding_warehouse(...) را
        به متد موجود get_item_locations_excluding_warehouse(...) پاس می‌دهد.
        """
        return self.get_item_locations_excluding_warehouse(*args, **kwargs)
    # END ADD: DB.list_locations_excluding_warehouse

                    
                        

    def get_item_locations_excluding_warehouse(self, item_id: int, warehouse_to_exclude: str):
        """لیست لوکیشن‌هایی که یک کالا موجودی دارد را به جز در یک انبار خاص، برمی‌گرداند."""
        query = """
            SELECT l.id, w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label, s.qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0 AND w.name != %s
            ORDER BY w.name, l.rack, l.shelf, l.bin;
        """
        return self.execute_query(query, (item_id, warehouse_to_exclude))
                                                
    def list_locations(self, include_warehouses: list = None, exclude_warehouses: list = None):
        """
        نسخه ساده و اولیه: لیست تمام لوکیشن‌ها را برمی‌گرداند.
        """
        query = """
            SELECT l.id, w.name AS wh, l.rack, l.shelf, l.bin,
                   w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label
            FROM locations l
            JOIN warehouses w ON w.id = l.warehouse_id
        """
        params = []
        conditions = []

        if include_warehouses:
            placeholders = ','.join(['%s'] * len(include_warehouses))
            conditions.append(f"w.name IN ({placeholders})")
            params.extend(include_warehouses)
        
        if exclude_warehouses:
            placeholders = ','.join(['%s'] * len(exclude_warehouses))
            conditions.append(f"w.name NOT IN ({placeholders})")
            params.extend(exclude_warehouses)

        if conditions:
            query += " WHERE " + " AND ".join(conditions)
        
        query += " ORDER BY w.name, l.rack, l.shelf, l.bin;"
        
        return self.execute_query(query, tuple(params))
        
            
            
    def add_or_update_location(self, loc_data: dict, loc_id: int = None):
        """یک لوکیشن جدید را با تمام جزئیات گرافیکی اضافه یا ویرایش می‌کند."""
        with self.transaction() as cur:
            wh_id = self.add_warehouse(loc_data['wh_name'])
            params = {**loc_data, 'wh_id': wh_id, 'id': loc_id, 'bin': loc_data.get('bin') or '1'}

            if loc_id: # حالت ویرایش
                query = """
                    UPDATE locations SET
                        warehouse_id = %(wh_id)s, rack = %(rack)s, shelf = %(shelf)s, bin = %(bin)s,
                        aisle_sequence = %(aisle_sequence)s, rack_sequence = %(rack_sequence)s, shelf_sequence = %(shelf_sequence)s,
                        pos_x = %(pos_x)s, pos_y = %(pos_y)s, width = %(width)s, height = %(height)s
                    WHERE id = %(id)s
                """
            else: # حالت افزودن
                query = """
                    INSERT INTO locations (warehouse_id, rack, shelf, bin, aisle_sequence, rack_sequence, shelf_sequence, pos_x, pos_y, width, height)
                    VALUES (%(wh_id)s, %(rack)s, %(shelf)s, %(bin)s, %(aisle_sequence)s, %(rack_sequence)s, %(shelf_sequence)s, %(pos_x)s, %(pos_y)s, %(width)s, %(height)s)
                """
            try:
                self.execute_query(query, params, cursor=cur)
            except psycopg2.errors.UniqueViolation:
                raise ValueError("لوکیشنی با این مشخصات (انبار، راهرو، قفسه، طبقه) از قبل وجود دارد.")
                        
                                                
                
    def stock_qty(self, item_id: int, loc_id: int, batch_no: str):
        """موجودی یک بچ مشخص از یک کالا در یک لوکیشن خاص را برمی‌گرداند."""
        query = 'SELECT qty FROM stock WHERE item_id=%s AND location_id=%s AND batch_no=%s'
        # استفاده از ابزار استاندارد برای کوتاهی و پایداری
        row = self.execute_query(query, (item_id, loc_id, batch_no), fetch_one=True)
        return row['qty'] if row else 0
                    
    def _upd_stock(self, cur, item_id: int, location_id: int, qty_change: float,
                batch_no: str, expiry_date: dt.date = None, status: str = None,
                return_stock_id: bool = False, entry_status: str = 'تایید شده',
                source_po_item_id: int = None,
                # سازگار با فراخوانی‌های قبلی (اختیاری)
                ignore_status_check: bool = False):
        """
        نسخه اتمیک و سازگار:
        - کاهش: تقسیط روی چند ردیف + امکان wildcard برای expiry=None + گزینه‌ی نادیده‌گیری وضعیت.
        - افزایش: UPSERT اتمیک با به‌روزرسانی entry_value.
        """
        import datetime as _dt

        if not batch_no:
            raise ValueError("برای تغییر موجودی، بچ نامبر باید مشخص باشد.")
        if not location_id:
            raise ValueError("لوکیشن نامعتبر است.")

        now_ts = _dt.datetime.now(_dt.timezone.utc)
        final_status = status or entry_status or 'تایید شده'

        # --- کسر از موجودی ---
        if qty_change < 0:
            needed = float(abs(qty_change))

            # آیا ستون status در stock وجود دارد؟
            try:
                stock_cols = set(self._get_existing_columns('stock', cursor=cur))
            except Exception:
                cur.execute("SELECT * FROM stock LIMIT 0")
                stock_cols = {getattr(d, 'name', d[0]) for d in (cur.description or [])}
            has_status_col = ('status' in stock_cols)

            # سیاست اجازه مصرف از قرنطینه
            allow_q = False
            try:
                rec = self.execute_query(
                    "SELECT value FROM app_settings WHERE key='allow_quarantine_consumption'",
                    fetch_one=True, cursor=cur)
                if rec and isinstance(rec.get('value'), str):
                    allow_q = rec['value'].strip().lower() in ('1', 'true', 'yes', 'on')
            except Exception:
                pass

            allowed_statuses = ['تایید شده', 'موجود']
            if allow_q:
                allowed_statuses.append('قرنطینه')

            # اگر expiry_date تهی باشد، wildcard روی تاریخ (یعنی شرط تاریخ برداشته می‌شود)
            wildcard_expiry = (expiry_date is None)

            def _where_and_params(include_qty_positive: bool = True):
                where = "item_id=%s AND location_id=%s AND batch_no=%s"
                params = [item_id, location_id, batch_no]
                if not wildcard_expiry:
                    where += " AND expiry_date IS NOT DISTINCT FROM %s"
                    params.append(expiry_date)
                # فقط اگر ستون status وجود دارد و قرار نیست نادیده بگیریم
                if has_status_col and (not ignore_status_check):
                    where += " AND (status = ANY(%s))"
                    params.append(list(allowed_statuses))
                if include_qty_positive:
                    where += " AND qty > 0.001"
                return where, params

            # کفایت موجودی کل
            where, params = _where_and_params(include_qty_positive=True)
            cur.execute(
                f"SELECT COALESCE(SUM(qty),0) AS total_qty FROM stock WHERE {where}",
                tuple(params)
            )
            total = float((cur.fetchone() or {}).get('total_qty') or 0.0)
            if total + 1e-9 < needed:
                item_name_rec = self.execute_query(
                    "SELECT name FROM items WHERE id=%s", (item_id,),
                    fetch_one=True, cursor=cur
                )
                item_name = (item_name_rec or {}).get('name') or f"کالای {item_id}"
                loc_label = self.loc_label(location_id)
                raise ValueError(f"موجودی بچ «{batch_no}» از کالای «{item_name}» در «{loc_label}» کافی نیست یا در وضعیت مجاز نیست.")

            # انتخاب ردیف‌ها برای تقسیط و قفل‌گذاری
            where, params = _where_and_params(include_qty_positive=True)
            cur.execute(
                f"""
                SELECT id, qty
                FROM stock
                WHERE {where}
                ORDER BY expiry_date ASC NULLS LAST, id ASC
                FOR UPDATE
                """,
                tuple(params)
            )
            rows = cur.fetchall() or []

            remaining = needed
            first_updated_id = None
            for row in rows:
                if remaining <= 1e-9:
                    break
                row_id = row['id']
                row_qty = float(row['qty'] or 0.0)
                take = min(row_qty, remaining)
                if take <= 0:
                    continue
                cur.execute(
                    "UPDATE stock SET qty = qty - %s, last_moved_at = %s WHERE id = %s",
                    (take, now_ts, row_id)
                )
                if first_updated_id is None and return_stock_id:
                    first_updated_id = row_id
                remaining -= take

            # پاکسازی ردیف‌های تقریباً صفر (بدون شرط qty>0)
            where_no_qty, params_no_qty = _where_and_params(include_qty_positive=False)
            cur.execute(
                f"DELETE FROM stock WHERE {where_no_qty} AND qty < 0.001",
                tuple(params_no_qty)
            )

            return first_updated_id if return_stock_id else None

        # --- افزودن به موجودی ---
        elif qty_change > 0:
            # محاسبه ارزش ورودی (ایمن برای انواع عددی)
            item_cost_rec = self.execute_query(
                "SELECT cost FROM items WHERE id=%s", (item_id,),
                fetch_one=True, cursor=cur
            )
            raw_cost = (item_cost_rec.get('cost', 0.0) if item_cost_rec else 0.0)
            try:
                from decimal import Decimal as _D
                item_cost = float(raw_cost) if isinstance(raw_cost, _D) else float(raw_cost or 0.0)
            except Exception:
                item_cost = float(raw_cost or 0.0)

            try:
                qty_f = float(qty_change or 0.0)
            except Exception:
                from decimal import Decimal as _D
                qty_f = float(qty_change) if isinstance(qty_change, _D) else float(qty_change or 0.0)

            delta_value = item_cost * qty_f

            cur.execute(
                """
                INSERT INTO stock (item_id, location_id, qty, batch_no, expiry_date, status,
                                received_at, last_moved_at, entry_value, source_po_item_id)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON CONFLICT (item_id, location_id, batch_no, expiry_date) DO UPDATE
                SET qty = stock.qty + EXCLUDED.qty,
                    last_moved_at = EXCLUDED.last_moved_at,
                    status = EXCLUDED.status,
                    entry_value = COALESCE(stock.entry_value, 0) + EXCLUDED.entry_value,
                    source_po_item_id = COALESCE(EXCLUDED.source_po_item_id, stock.source_po_item_id)
                RETURNING id;
                """,
                (item_id, location_id, qty_f, batch_no, expiry_date, final_status,
                now_ts, now_ts, delta_value, source_po_item_id)
            )
            if return_stock_id:
                res = cur.fetchone()
                return (res['id'] if res else None)

        # qty_change == 0
        return None
    # در کلاس DB، این متد را به طور کامل جایگزین کنید

    # BEGIN REWRITE: DB.fulfill_request_with_fefo
    def fulfill_request_with_fefo(self, request_id: int, item_id: int, qty_needed: float, doc_no: str, user_id: int):
        """
        انجام درخواست مواد اولیه به روش FEFO با سازگاری کامل با طرح‌های مختلف DB:
        - درج خروج به تولید در جدول trans (ستون‌ها به‌صورت پویا کشف می‌شوند).
        - به‌روزرسانی material_requests تنها با ستون‌های موجود (بدون ارجاع به ستونِ ناموجود).
        """
        with self.transaction() as cur:
            # 0) مقصد تولید و لیست برداشت FEFO
            dest_loc_id = self.get_production_floor_location()
            if not dest_loc_id:
                raise ValueError("لوکیشن پیش‌فرض تولید تعریف نشده است.")
            picks = self.fefo_pick(item_id, qty_needed)
            picked_total = sum(p.get('pick_qty', 0) for p in (picks or []))
            if not picks or picked_total < float(qty_needed) - 1e-6:
                raise ValueError("موجودی کافی برای تامین این درخواست در انبار وجود ندارد.")

            # 1) ستون‌های جدول trans را کشف کن
            trans_cols = set(self._get_existing_columns('trans', cursor=cur))
            has_col = trans_cols.__contains__
            notes_col = 'notes' if has_col('notes') else ('note' if has_col('note') else None)

            # 2) برای هر برداشت: از موجودی کم کن و در trans درج کن
            for pk in picks:
                self._upd_stock(
                    cur,
                    item_id=item_id,
                    location_id=pk['location_id'],
                    qty_change=-abs(pk['pick_qty']),
                    batch_no=pk['batch_no'],
                    expiry_date=pk.get('expiry_date'),
                )

                cols, vals, ph = [], [], []

                # اجزاء ثابت
                cols += ['item_id', 't_type']
                vals += [item_id, TransactionType.EXIT_TO_PROD.value]
                ph   += ['%s', '%s']

                if has_col('t_no'):
                    cols.append('t_no');    vals.append(doc_no);           ph.append('%s')
                if has_col('qty'):
                    cols.append('qty');     vals.append(pk['pick_qty']);   ph.append('%s')
                if notes_col:
                    cols.append(notes_col); vals.append(f"خروج طبق حواله «{doc_no}» برای درخواست #{request_id} (FEFO)"); ph.append('%s')
                if has_col('user_id'):
                    cols.append('user_id'); vals.append(user_id);          ph.append('%s')
                if has_col('src_loc'):
                    cols.append('src_loc'); vals.append(pk['location_id']); ph.append('%s')
                if has_col('dest_loc'):
                    cols.append('dest_loc'); vals.append(dest_loc_id);     ph.append('%s')
                if has_col('status'):
                    cols.append('status');  vals.append(TransactionStatus.PENDING_PRODUCTION_APPROVAL.value); ph.append('%s')
                if has_col('batch_no'):
                    cols.append('batch_no'); vals.append(pk['batch_no']);  ph.append('%s')
                if has_col('expiry_date'):
                    cols.append('expiry_date'); vals.append(pk.get('expiry_date')); ph.append('%s')
                if has_col('t_date'):
                    cols.append('t_date');  ph.append('NOW()')  # بدون پارامتر

                sql = f"INSERT INTO trans ({', '.join(cols)}) VALUES ({', '.join(ph)})"
                cur.execute(sql, tuple(vals))

            # 3) به‌روزرسانی درخواست مادر فقط بر اساس ستون‌های موجود
            mr_cols = set(self._get_existing_columns('material_requests', cursor=cur))
            mc = mr_cols.__contains__

            # Select امن: فقط ستون‌های موجود را بخوان
            sel_cols = []
            if mc('requested_qty'):  sel_cols.append('requested_qty')
            if mc('fulfilled_qty'):  sel_cols.append('fulfilled_qty')
            if mc('status'):         sel_cols.append('status')
            if mc('notes'):          sel_cols.append('notes')

            if sel_cols:
                cur.execute(f"SELECT {', '.join(sel_cols)} FROM material_requests WHERE id=%s FOR UPDATE", (request_id,))
                row = cur.fetchone() or {}
            else:
                row = {}

            requested_qty = float(row.get('requested_qty') or 0)
            prev_fulfilled = float(row.get('fulfilled_qty') or 0)
            new_fulfilled = prev_fulfilled + float(qty_needed)

            # تعیین وضعیت جدید (اگر ستون status داشته باشیم)
            new_status = None
            if mc('status') and requested_qty > 0:
                new_status = TransactionStatus.MR_FULFILLED.value if new_fulfilled >= requested_qty else (row.get('status') or TransactionStatus.MR_PENDING.value)

            # ساخت متن یادداشت
            base_notes = (row.get('notes') or '') if mc('notes') else ''
            add_note = f"مقدار {qty_needed} واحد طبق حواله «{doc_no}» به تولید ارسال شد."
            final_notes = (base_notes + " | " + add_note).strip(" |") if base_notes else add_note

            # UPDATE پویا
            set_parts, params = [], []
            if new_status is not None:
                set_parts.append("status=%s"); params.append(new_status)
            if mc('fulfilled_qty'):
                set_parts.append("fulfilled_qty=%s"); params.append(new_fulfilled)
            if mc('notes'):
                set_parts.append("notes=%s"); params.append(final_notes)
            # ستون‌های «پردازش‌شده توسط» و «زمان پردازش» اگر باشند
            if mc('processed_by_user_id'):
                set_parts.append("processed_by_user_id=%s"); params.append(user_id)
            elif mc('processed_by_id'):
                set_parts.append("processed_by_id=%s"); params.append(user_id)
            elif mc('processed_by'):
                set_parts.append("processed_by=%s"); params.append(user_id)
            if mc('processed_at'):
                set_parts.append("processed_at=NOW()")

            if set_parts:
                cur.execute(
                    f"UPDATE material_requests SET {', '.join(set_parts)} WHERE id=%s",
                    tuple(params + [request_id])
                )

            # داخل کلاس DB، در انتهای متد fulfill_material_request(...) یا fulfill_request_with_fefo(...)
            try:
                self.mark_notification_resolved('FULFILL_REQUEST', int(request_id))
            except Exception:
                pass
            try:
                if hasattr(self, 'signals'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass
            

    def add_trans_extended(self, trans_data: dict, user_id: int) -> int:
        """
        V3.3 (fixed):
        - رویداد QA با context_data ارسال می‌شود (نه payload).
        - وضعیت رکورد trans = 'تایید شده' برای سازگاری کارتکس.
        - ورودیِ QCدار در STOCK با وضعیت 'قرنطینه' ثبت می‌شود.
        """
        with self.transaction() as cur:
            t_type = trans_data['t_type']
            is_exit_type = t_type.startswith('خروج') or t_type == 'ضایعات'

            src = trans_data['loc_id'] if is_exit_type else None
            dst = trans_data['loc_id'] if not is_exit_type else None

            delta = trans_data['qty'] if dst else -abs(trans_data['qty'])
            entry_status = 'قرنطینه' if (not is_exit_type and trans_data.get('requires_qc')) else 'تایید شده'

            # موجودی
            self._upd_stock(
                cur=cur,
                item_id=trans_data['item_id'],
                location_id=trans_data['loc_id'],
                qty_change=delta,
                batch_no=trans_data['batch_no'],
                expiry_date=trans_data.get('expiry_date'),
                entry_status=entry_status
            )

            # سند
            row = self.execute_query(
                """
                INSERT INTO trans
                    (item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date)
                VALUES
                    (%s, %s, %s, NOW(), %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
                """,
                (
                    trans_data['item_id'], t_type, trans_data.get('doc_no'),
                    trans_data['qty'], trans_data.get('notes'), user_id,
                    src, dst, 'تایید شده',
                    trans_data['batch_no'], trans_data.get('expiry_date')
                ),
                fetch_one=True, cursor=cur
            )
            trans_id = row['id']

            self._log_atomic(cur, user_id, 'ADD_TRANS_EXT', f"trans_id:{trans_id}")

        # رویداد QA (بعد از commit)

        # رویداد قرنطینه
        if not is_exit_type and trans_data.get('requires_qc'):
            with self.transaction() as cur:
                stock_row = self.execute_query(
                    "SELECT id FROM stock WHERE item_id=%s AND location_id=%s AND batch_no=%s AND expiry_date IS NOT DISTINCT FROM %s",
                    (trans_data['item_id'], dst, trans_data['batch_no'], trans_data.get('expiry_date')),
                    fetch_one=True, cursor=cur
                )

        return trans_id
    
    
    def transfer(self, item_id: int, qty: float, src_loc_id: int, dest_loc_id: int,
                user_id: int, notes: str, batch_no: str, expiry_date=None) -> int:
        """
        انتقال داخلی یک‌سندی.
        """
        if src_loc_id == dest_loc_id:
            raise ValueError("مبدا و مقصد نمی‌تواند یکسان باشد.")

        with self.transaction() as cur:
            # کم‌کردن از مبدا
            self._upd_stock(cur=cur, item_id=item_id, location_id=src_loc_id,
                            qty_change=-abs(qty), batch_no=batch_no, expiry_date=expiry_date)
            # افزودن به مقصد
            self._upd_stock(cur=cur, item_id=item_id, location_id=dest_loc_id,
                            qty_change=abs(qty), batch_no=batch_no, expiry_date=expiry_date, entry_status='تایید شده')

            # سند انتقال
            row = self.execute_query(
                """
                INSERT INTO trans
                    (item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date)
                VALUES
                    (%s, %s, get_next_seq('TRANS_DOC')::text, NOW(), %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
                """,
                (
                    item_id, TransactionType.TRANSFER.value, abs(qty), notes, user_id,
                    src_loc_id, dest_loc_id, TransactionStatus.APPROVED.value,
                    batch_no, expiry_date
                ),
                fetch_one=True, cursor=cur
            )
            trans_id = row['id']

            self._log_atomic(cur, user_id, 'TRANSFER',
                            f"item={item_id}, qty={qty}, src={src_loc_id}, dst={dest_loc_id}, trans_id={trans_id}")

        return trans_id

    
    # --- NEW: Conversion schema & API -------------------------------------------
    from decimal import Decimal, ROUND_HALF_UP

    def ensure_conversion_schema(self):
        """
        ساخت جدول الگوهای تبدیل A→B (در صورت نبود).
        فیلدها:
        - name: نام/کد الگو
        - src_item_id: آیتم مبدأ (A)
        - dest_item_id: آیتم مقصد (B)
        - ratio: به‌ازای هر 1 واحد A چند واحد B تولید می‌شود (قبل از افت)
        - loss_percent: درصد افت (0..100)
        - notes: توضیحات
        - active: فعال/غیرفعال
        """
        with self._get_conn() as conn:
            cur = conn.cursor()
            cur.execute("""
                CREATE TABLE IF NOT EXISTS conversion_patterns (
                    id SERIAL PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE,
                    src_item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
                    dest_item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
                    ratio NUMERIC(18,6) NOT NULL DEFAULT 1.0,
                    loss_percent NUMERIC(6,3) NOT NULL DEFAULT 0.0,
                    notes TEXT,
                    active BOOLEAN NOT NULL DEFAULT TRUE,
                    created_by INTEGER REFERENCES users(id),
                    created_at TIMESTAMP NOT NULL DEFAULT NOW()
                );
            """)
            # جدول اجرای تبدیل‌ها (لینک به تراکنش‌ها برای رجوع بعدی)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS conversion_runs (
                    id SERIAL PRIMARY KEY,
                    pattern_id INTEGER NOT NULL REFERENCES conversion_patterns(id) ON DELETE RESTRICT,
                    doc_no TEXT NOT NULL,
                    src_trans_id INTEGER REFERENCES trans(id),
                    dest_trans_id INTEGER REFERENCES trans(id),
                    amount_a NUMERIC(18,6) NOT NULL,
                    amount_b NUMERIC(18,6) NOT NULL,
                    created_by INTEGER REFERENCES users(id),
                    created_at TIMESTAMP NOT NULL DEFAULT NOW()
                );
            """)
            conn.commit()

    def create_conversion_pattern(self, name: str, src_item_id: int, dest_item_id: int,
                                user_id: int, notes: str = "") -> int:
        """
        ساخت/ثبت یک الگوی تبدیل A→B (۱:۱).
        الزام: هم A و هم B باید از دسته «مواد اولیه» باشند.
        برای سازگاری با نسخه‌های قبلی، اگر ستون‌های ratio/loss_percent وجود داشته باشند، با 1.0 و 0.0 پر می‌کنیم.
        """
        if not name:
            raise ValueError("نام الگو الزامی است.")
        if int(src_item_id) == int(dest_item_id):
            raise ValueError("A و B نمی‌توانند یک کالا باشند.")

        # هر دو باید «مواد اولیه» باشند
        src_cat = self.execute_query("SELECT category FROM items WHERE id=%s", (src_item_id,), fetch_one=True)
        dest_cat = self.execute_query("SELECT category FROM items WHERE id=%s", (dest_item_id,), fetch_one=True)
        if not src_cat or (src_cat.get('category') or '') != 'مواد اولیه':
            raise ValueError("کالای A باید از دسته «مواد اولیه» باشد.")
        if not dest_cat or (dest_cat.get('category') or '') != 'مواد اولیه':
            raise ValueError("کالای B باید از دسته «مواد اولیه» باشد.")

        with self._get_conn() as conn:
            cur = conn.cursor()
            try:
                # تلاش اول: جدول‌هایی که ratio/loss دارند
                cur.execute("""
                    INSERT INTO conversion_patterns(name, src_item_id, dest_item_id, ratio, loss_percent, notes, created_by, active)
                    VALUES (%s,%s,%s,1.0,0.0,%s,%s,TRUE)
                    RETURNING id
                """, (name.strip(), int(src_item_id), int(dest_item_id), (notes or '').strip(), int(user_id)))
            except Exception:
                # تلاش دوم: نسخه‌های بدون ratio/loss
                cur.execute("""
                    INSERT INTO conversion_patterns(name, src_item_id, dest_item_id, notes, created_by, active)
                    VALUES (%s,%s,%s,%s,%s,TRUE)
                    RETURNING id
                """, (name.strip(), int(src_item_id), int(dest_item_id), (notes or '').strip(), int(user_id)))
            new_id = int(cur.fetchone()[0])
            conn.commit()
            return new_id

    def list_conversion_patterns(self, only_active: bool = True):
        """برگرداندن لیست الگوها برای UI."""
        q = "SELECT id, name, src_item_id, dest_item_id, ratio, loss_percent, notes, active FROM conversion_patterns"
        if only_active:
            q += " WHERE active = TRUE"
        q += " ORDER BY name"
        rows = self.execute_query(q, None) or []
        # غنی‌سازی با نام کالاها
        for r in rows:
            si = self.execute_query("SELECT name FROM items WHERE id=%s", (r['src_item_id'],), fetch_one=True)
            di = self.execute_query("SELECT name FROM items WHERE id=%s", (r['dest_item_id'],), fetch_one=True)
            r['src_name']  = (si or {}).get('name', str(r['src_item_id']))
            r['dest_name'] = (di or {}).get('name', str(r['dest_item_id']))
        return rows

    # --- REWRITE & HARDEN: DB.execute_conversion ---
    def execute_conversion(self, pattern_id: int, amount_a: float, user_id: int,
                        src_batch_no: str = None, src_expiry_date: 'date' = None,
                        dest_batch_no: str = None, dest_expiry_date: 'date' = None,
                        **kwargs) -> dict:
        """
        اجرای تبدیل A→B (۱:۱) فقط از «انبار تولید» با منشأ شفاف.
        سازگاری با نام‌های قدیمی پارامترها: اگر UI/کد جای دیگر نام متفاوتی فرستاد، اینجا نرمال می‌کنیم.
        """
        # --- 0) Alias-normalization: پارامترهای معادل را به نام واحد نگاشت کن
        # src_* aliases
        if src_batch_no is None:
            src_batch_no = kwargs.pop('source_batch_no', None) or kwargs.pop('from_batch_no', None) \
                        or kwargs.pop('src_batch', None)
        if src_expiry_date is None:
            src_expiry_date = kwargs.pop('source_expiry_date', None) or kwargs.pop('from_expiry_date', None) \
                            or kwargs.pop('src_expiry', None)

        # dest_* aliases
        if dest_batch_no is None:
            dest_batch_no = kwargs.pop('dest_batch', None) or kwargs.pop('to_batch_no', None)
        if dest_expiry_date is None:
            dest_expiry_date = kwargs.pop('dest_expiry', None) or kwargs.pop('to_expiry_date', None)

        # اگر کسی هم‌زمان batch_id فرستاده بود، تلاش می‌کنیم شماره بچ را از روی id بیرون بکشیم
        src_batch_id = kwargs.pop('src_batch_id', None)
        if src_batch_id is not None and src_batch_no is None:
            try:
                rec = self.execute_query(
                    "SELECT batch_no, expiry_date FROM stock WHERE id=%s",
                    (int(src_batch_id),), fetch_one=True
                )
                if rec:
                    src_batch_no = rec.get('batch_no')
                    if src_expiry_date is None:
                        src_expiry_date = rec.get('expiry_date')
            except Exception:
                pass

        # اگر هنوز kwargs باقی مانده، یعنی نام‌های ناشناخته آمده؛ پیام واضح بده
        if kwargs:
            bad_keys = ", ".join(kwargs.keys())
            raise TypeError(f"پارامتر(های) نامعتبر: {bad_keys}")

        # --- 1) اعتبارسنجی ورودی‌های اصلی
        from decimal import Decimal, ROUND_HALF_UP
        from datetime import datetime, timedelta
        import jdatetime as jd

        pat = self.execute_query("SELECT * FROM conversion_patterns WHERE id=%s",
                                (pattern_id,), fetch_one=True)
        if not pat or not pat.get('active', True):
            raise ValueError("الگوی تبدیل معتبر یا فعال یافت نشد.")
        if amount_a is None or float(amount_a) <= 0:
            raise ValueError("مقدار A باید بزرگتر از صفر باشد.")

        amt_a = Decimal(str(amount_a)).quantize(Decimal('0.001'), rounding=ROUND_HALF_UP)
        amt_b = amt_a  # نسبت 1:1

        # منبع واحد حقیقت برای لوکیشن تولید
        prod_loc_id = self.get_production_floor_location()

        # چک سمت سرور: بچ انتخابی باید واقعاً در همان انبار تولید موجود باشد
        # (اگر کاربر با ترفند چیزی بیرون از تولید انتخاب کند، اینجا خطا می‌دهیم)
        if src_batch_no is not None or src_expiry_date is not None:
            chk = self.execute_query("""
                SELECT COALESCE(SUM(qty),0) AS q
                FROM stock
                WHERE item_id=%s
                AND location_id=%s
                AND (batch_no IS NOT DISTINCT FROM %s)
                AND (expiry_date IS NOT DISTINCT FROM %s)
            """, (int(pat['src_item_id']), int(prod_loc_id), src_batch_no, src_expiry_date), fetch_one=True)
            if not chk or float(chk.get('q', 0)) <= 0:
                raise ValueError("فقط بچ‌های «انبار تولید» مجازند. لطفاً از فهرست همان انبار انتخاب کن.")
        # شماره سند
        rec = self.execute_query("SELECT 'CNV-'||get_next_seq('TRANS_DOC')::text AS dn", None, fetch_one=True)
        doc_no = rec['dn'] if rec and rec.get('dn') else 'CNV-' + datetime.now().strftime("%Y%m%d%H%M%S")

        src_item_id  = int(pat['src_item_id'])
        dest_item_id = int(pat['dest_item_id'])

        src_name = (self.execute_query("SELECT name FROM items WHERE id=%s", (src_item_id,), fetch_one=True) or {}).get('name', str(src_item_id))
        dest_name = (self.execute_query("SELECT name FROM items WHERE id=%s", (dest_item_id,), fetch_one=True) or {}).get('name', str(dest_item_id))

        note_src  = f"خروج جهت تبدیل به «{dest_name}» با الگو: {pat['name']} (سند: {doc_no})"
        note_dest = f"تبدیل از «{src_name}» با الگو: {pat['name']} (سند: {doc_no})"

        # تاریخ انقضای مقصد اگر نبود: 3 سال بعد (میلادی) تا DB غر نزند
        if not dest_expiry_date:
            dest_expiry_date = (datetime.utcnow().date() + timedelta(days=365*3))

        # بچ مقصد: RE-<MM><YY>-<seq> (شمسی، شمارنده ماهانه)
        if not dest_batch_no:
            jnow = jd.datetime.now()
            mm = f"{jnow.month:02d}"
            yy = f"{jnow.year % 100:02d}"
            prefix = f"RE-{mm}{yy}-"
            last = self.execute_query("SELECT MAX(batch_no) AS last_batch FROM stock WHERE batch_no LIKE %s",
                                    (prefix + '%',), fetch_one=True)
            next_serial = 0
            if last and last.get('last_batch'):
                try:
                    next_serial = int(str(last['last_batch']).split('-')[-1])
                except Exception:
                    next_serial = 0
            dest_batch_no = f"{prefix}{next_serial+1:03d}"

        # --- 2) اجرای اتمیک: ثبت خروج و ورود + به‌روزرسانی موجودی
        with self._get_conn() as conn:
            cur = conn.cursor()
            try:
                # خروج از A (انبار تولید)
                cur.execute("""
                    INSERT INTO trans(item_id, t_type, t_no, qty, src_loc, notes, user_id, status, batch_no, expiry_date, t_date)
                    VALUES (%s,%s,%s,%s,%s,%s,%s,'تایید شده',%s,%s,NOW())
                    RETURNING id
                """, (src_item_id, 'خروج به تبدیل', doc_no, float(-amt_a), prod_loc_id, note_src, user_id,
                    src_batch_no, src_expiry_date))
                src_tid = int(cur.fetchone()[0])
                self._upd_stock(cur, src_item_id, prod_loc_id, float(-amt_a), src_batch_no, src_expiry_date)

                # ورود به B (انبار تولید)
                cur.execute("""
                    INSERT INTO trans(item_id, t_type, t_no, qty, dest_loc, notes, user_id, status, batch_no, expiry_date, t_date)
                    VALUES (%s,%s,%s,%s,%s,%s,%s,'تایید شده',%s,%s,NOW())
                    RETURNING id
                """, (dest_item_id, 'ورود از تبدیل', doc_no, float(amt_b), prod_loc_id, note_dest, user_id,
                    dest_batch_no, dest_expiry_date))
                dest_tid = int(cur.fetchone()[0])
                self._upd_stock(cur, dest_item_id, prod_loc_id, float(amt_b), dest_batch_no, dest_expiry_date)

                # ثبت run اگر جدولش وجود دارد
                try:
                    cur.execute("""
                        INSERT INTO conversion_runs(pattern_id, doc_no, src_trans_id, dest_trans_id, amount_a, amount_b, created_by)
                        VALUES (%s,%s,%s,%s,%s,%s,%s)
                        RETURNING id
                    """, (pattern_id, doc_no, src_tid, dest_tid, float(amt_a), float(amt_b), user_id))
                    run_id = int(cur.fetchone()[0])
                except Exception:
                    run_id = None

                conn.commit()
            except Exception:
                conn.rollback()
                raise

        return {
            "doc_no": doc_no,
            "amount_a": float(amt_a),
            "amount_b": float(amt_b),
            "batch_b": dest_batch_no,
            "run_id": run_id
        }
    # --- END REWRITE: DB.execute_conversion ---

            
# در کلاس DB، این متد را جایگزین کنید

    def total_qty(self, item_id: int):
        """
        مجموع موجودی یک کالا در تمام انبارها را به صورت امن محاسبه می‌کند.
        نسخه نهایی: از ابزار استاندارد execute_query استفاده می‌کند.
        """
        query = "SELECT COALESCE(SUM(qty), 0) AS q FROM stock WHERE item_id=%s"
        result = self.execute_query(query, (item_id,), fetch_one=True)
        return result['q'] if result else 0
    
    
# در کلاس DB، این متد را جایگزین کنید

    def rack_loads(self):
        """
        بار (مجموع مقادیر) هر قفسه را برای نمایش در HeatMap محاسبه می‌کند.
        نسخه نهایی: از ابزار استاندارد execute_query استفاده می‌کند.
        """
        query = """
            SELECT w.name||' / '||rack||'-'||shelf AS loc, SUM(qty) AS load
            FROM stock s
            JOIN locations l ON l.id=s.location_id
            JOIN warehouses w ON w.id=l.warehouse_id
            GROUP BY loc
        """
        return self.execute_query(query)
        

# در کلاس DB، این متد را جایگزین کنید

    def add_form_def(self, name: str, fields: list, user_id: int, form_type: str = 'GENERAL'):
        """یک تعریف فرم جدید را به صورت اتمیک ثبت کرده و ID آن را برمی‌گرداند."""
        with self.transaction() as cur:
            fields_json = json.dumps(fields, ensure_ascii=False)
            query = "INSERT INTO form_defs (name, fields, user_id, form_type) VALUES (%s, %s, %s, %s) RETURNING id"
            params = (name, fields_json, user_id, form_type)
            
            result = self.execute_query(query, params, fetch_one=True, cursor=cur)
            return result['id'] if result else None
                            
                                                        
    def list_form_defs_by_type(self, form_type: str = 'GENERAL', user_id: int = None, is_admin: bool = False):
        """
        لیست فرم‌ها را بر اساس نوع فیلتر می‌کند.
        اگر is_admin نباشد، فرم‌های کاربر مشخص و فرم‌های قدیمی (بدون مالک) را هم نشان می‌دهد.
        """
        if is_admin:
            query = "SELECT * FROM form_defs WHERE form_type = %s ORDER BY name"
            params = (form_type,)
        else:
            query = "SELECT * FROM form_defs WHERE form_type = %s AND (user_id = %s OR user_id IS NULL) ORDER BY name"
            params = (form_type, user_id)
            
        return self.execute_query(query, params)

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def get_form_fields(self, form_id):
        """
        فیلدهای یک فرم را برمی‌گرداند. این نسخه اطلاعات کامل هر فیلد (شامل id) را
        برای فرمت جدید برمی‌گرداند و با فرمت قدیمی نیز سازگار است.
        """
        form_def_row = self.execute_query("SELECT fields FROM form_defs WHERE id=%s", (form_id,), fetch_one=True)
        
        if not form_def_row or not form_def_row.get('fields'):
            return []
        
        fields_data = form_def_row['fields']
        if isinstance(fields_data, str):
            try:
                fields_data = json.loads(fields_data)
            except json.JSONDecodeError:
                return []

        if not isinstance(fields_data, list) or not fields_data:
            return []

        # --- تشخیص هوشمند فرمت ---
        first_field = fields_data[0]
        
        if isinstance(first_field, dict):
            # فرمت جدید: لیست دیکشنری‌ها. کل لیست را برمی‌گردانیم.
            return fields_data
        elif isinstance(first_field, list) and len(first_field) >= 2:
            # فرمت قدیمی: لیست لیست‌ها. آن را به فرمت جدید تبدیل می‌کنیم.
            return [
                {'id': f'legacy_field_{i}', 'label': field[0], 'type': field[1], 'properties': {}}
                for i, field in enumerate(fields_data)
            ]
            
        return []
                    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def add_or_update_form_entry(self, form_id: int, user_id: int, data_json: str, entry_id: int = None):
        """
        نسخه نهایی (V3.0): از context manager امن برای مدیریت تراکنش استفاده می‌کند.
        این تابع حالا به صورت کامل با استخر اتصالات (Connection Pool) هماهنگ است.
        """
        with self.transaction() as cur:
            if entry_id:
                # حالت آپدیت: از ابزار استاندارد برای اجرای کوئری در تراکنش فعلی استفاده می‌کنیم
                self.execute_query(
                    "UPDATE form_entries SET data = %s WHERE id = %s",
                    (data_json, entry_id),
                    cursor=cur
                )
                return entry_id
            else:
                # حالت ثبت: کوئری را اجرا کرده و ID جدید را برمی‌گردانیم
                result = self.execute_query(
                    "INSERT INTO form_entries(form_id, user_id, data) VALUES (%s, %s, %s) RETURNING id",
                    (form_id, user_id, data_json),
                    fetch_one=True,
                    cursor=cur
                )
                return result['id'] if result else None
                            
# در کلاس DB، این متد را جایگزین کنید

    def delete_form_entries_many(self, entry_ids: list):
        """چندین رکورد فرم را بر اساس لیست ID هایشان به صورت اتمیک حذف می‌کند."""
        if not entry_ids:
            return
        with self.transaction() as cur:
            # استفاده از ANY برای بهینه‌سازی و امنیت
            self.execute_query("DELETE FROM form_entries WHERE id = ANY(%s)", (entry_ids,), cursor=cur)
                                    
            
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def delete_form_entry(self, entry_id: int):
        """یک رکورد فرم ثبت شده را به صورت اتمیک حذف می‌کند."""
        try:
            with self.transaction() as cur:
                self.execute_query("DELETE FROM form_entries WHERE id=%s", (entry_id,), cursor=cur)
        except Exception as e:
            print(f"ERROR in delete_form_entry: {e}")
            raise RuntimeError(f"قادر به حذف رکورد فرم با شناسه {entry_id} نبود. خطای دیتابیس: {e}")
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def fefo_pick(self, item_id: int, qty_needed: float) -> list:
        """
        نسخه اصلاح‌شده و عملیاتی (V2.0):
        با توجه به مقدار مورد نیاز، بهترین بچ‌ها را برای برداشت بر اساس تاریخ انقضا (FEFO) پیشنهاد می‌دهد.
        این تابع به جای جدول کاتالوگ (items)، جدول موجودی واقعی (stock) را جستجو می‌کند.
        خروجی: لیستی از دیکشنری‌ها شامل لوکیشن، بچ و مقدار پیشنهادی برای برداشت.
        """
        # کوئری برای پیدا کردن تمام بچ‌های موجود یک کالا، مرتب شده بر اساس FEFO
        # بچ‌های بدون تاریخ انقضا در آخر قرار می‌گیرند
        query = """
            SELECT
                s.id as stock_id,
                s.qty,
                s.batch_no,
                s.expiry_date,
                s.location_id,
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0.001 AND w.name != 'Production'
            ORDER BY s.expiry_date ASC NULLS LAST, s.id ASC;
        """
        available_batches = self.execute_query(query, (item_id,))

        if not available_batches:
            return []  # هیچ موجودی برای این کالا یافت نشد

        total_available = sum(b['qty'] for b in available_batches)
        if total_available < qty_needed:
            # موجودی کل کافی نیست، می‌توان یک خطا ایجاد کرد یا لیست خالی برگرداند
            # فعلا یک هشدار در کنسول چاپ می‌کنیم
            print(f"WARNING: FEFO Pick - Not enough stock for item {item_id}. Needed: {qty_needed}, Available: {total_available}")
            return []

        picks = []
        remaining_needed = qty_needed
        for batch in available_batches:
            if remaining_needed <= 0:
                break
            
            pick_qty = min(batch['qty'], remaining_needed)
            
            picks.append({
                'stock_id': batch['stock_id'],
                'location_id': batch['location_id'],
                'location_label': batch['loc_label'],
                'batch_no': batch['batch_no'],
                'expiry_date': batch['expiry_date'],
                'pick_qty': pick_qty
            })
            
            remaining_needed -= pick_qty
            
        return picks
    

    # [DB] replace this method as-is
    def get_batches_in_location(self, item_id: int, location_id: int) -> list:
        """
        تمام بچ‌های موجود یک کالا در یک لوکیشن مشخص، با خروجی هم‌فرمت با UI:
        item_id, batch_no, expiry_date, qty
        """
        query = """
            SELECT
                s.item_id,
                s.batch_no,
                s.expiry_date,
                SUM(s.qty) AS qty
            FROM stock s
            WHERE s.item_id = %s
            AND s.location_id = %s
            AND s.qty > 0.001
            GROUP BY s.item_id, s.batch_no, s.expiry_date
            ORDER BY s.expiry_date ASC NULLS LAST, s.batch_no
        """
        return self.execute_query(query, (item_id, location_id))

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def add_bom(self, product_code: str, raw_item_id: int, raw_batch: str, qty: float, user_id: int):
        """
        یک ردیف مصرف مواد را به صورت اتمیک ثبت می‌کند (همراه با لاگ حسابرسی).
        نسخه نهایی: از context manager برای تضمین یکپارچگی داده و لاگ استفاده می‌کند.
        """
        with self.transaction() as cur:
            query = """
                INSERT INTO bill_of_materials (product_code, raw_item_id, raw_batch, qty, ts, user_id)
                VALUES (%s, %s, %s, %s, NOW(), %s)
            """
            params = (product_code, raw_item_id, raw_batch, qty, user_id)
            
            # اجرای دستور اصلی
            self.execute_query(query, params, cursor=cur)
            
            # ثبت لاگ در *همان* تراکنش برای تضمین یکپارچگی
            log_details = json.dumps({'prod': product_code, 'raw': raw_item_id, 'qty': qty})
            self._log_atomic(cur, user_id, 'ADD_BOM', log_details)
            
# در کلاس DB، این متد را جایگزین کنید

    def add_asset(self, code: str, name: str, brand: str = '', model: str = '', cost: float = 0.0, user_id: int | None = None) -> int:
        """یک دارایی را به صورت اتمیک ثبت یا ویرایش کرده و لاگ آن را نیز ثبت می‌کند."""
        with self.transaction() as cur:
            query = """
                INSERT INTO assets(code, name, brand, model, cost) VALUES (%s, %s, %s, %s, %s)
                ON CONFLICT(code) DO UPDATE SET
                    name  = EXCLUDED.name,
                    brand = EXCLUDED.brand,
                    model = EXCLUDED.model,
                    cost  = EXCLUDED.cost
                RETURNING id
            """
            params = (code, name, brand, model, cost)
            
            result = self.execute_query(query, params, fetch_one=True, cursor=cur)
            asset_id = result['id']
            
            # ثبت لاگ در همان تراکنش برای تضمین یکپارچگی
            self._log_atomic(cur, user_id or 0, 'ADD_ASSET', f'code={code}')
            
            return asset_id
            
        
# در کلاس DB
    def get_assets_by_assignee(self):
        """دارایی‌هایی که در اختیار پرسنل هستند را به تفکیک تحویل‌گیرنده برمی‌گرداند."""
        query = """
            WITH LatestAssetTrans AS (
                SELECT
                    asset_id,
                    notes,
                    t_type,
                    ROW_NUMBER() OVER(PARTITION BY asset_id ORDER BY t_date DESC) as rn
                FROM asset_trans
            )
            SELECT
                a.code, a.name, a.brand, a.model,
                -- استخراج نام کارمند از یادداشت
                substring(lat.notes from 'تحویل به: (.*)') as employee_name
            FROM assets a
            JOIN LatestAssetTrans lat ON a.id = lat.asset_id
            WHERE lat.rn = 1 AND lat.t_type = 'تحویل به پرسنل'
            ORDER BY employee_name, a.name;
        """
        return self.execute_query(query)

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def asset_exit(self, asset_id: int, t_no: str, t_date, notes: str, user_id: int) -> int:
        """
        تراکنش خروج یک دارایی را ثبت کرده و وضعیت آن را به صورت اتمیک به‌روز می‌کند.
        """
        with self.transaction() as cur:
            # گام ۱: ثبت تراکنش خروج و دریافت ID آن
            trans_result = self.execute_query(
                """INSERT INTO asset_trans(asset_id, t_no, t_date, notes, user_id)
                   VALUES (%s, %s, %s, %s, %s) RETURNING id""",
                (asset_id, t_no, t_date, notes, user_id),
                fetch_one=True,
                cursor=cur
            )
            new_id = trans_result['id']
            
            # گام ۲: به‌روزرسانی وضعیت خود دارایی با استفاده از ثابت استاندارد
            self.execute_query(
                "UPDATE assets SET status=%s WHERE id=%s",
                (AssetStatus.DELIVERED.value, asset_id),
                cursor=cur
            )

            # گام ۳: ثبت لاگ در همان تراکنش
            self._log_atomic(cur, user_id, 'ASSET_EXIT', f'id={asset_id}')
            
            return new_id
        
    def save_form_entry(self, form_id, data_json, user_id):
            """نسخه اصلاح شده نهایی: usr به user_id عددی تغییر کرد."""
            with self.transaction() as cur:
                cur.execute("""INSERT INTO form_entries(form_id,ts,data,user_id)
                            VALUES (%s,%s,%s,%s)""",
                            (form_id, datetime.now(dt.timezone.utc), data_json, user_id))
                                                
# در کلاس DB، این بلوک جایگزین شود

    def get_transactions_for_asset(self, asset_id: int):
        """تمام تراکنش‌های ثبت شده برای یک دارایی خاص را برمی‌گرداند."""
        query = """
            SELECT 
                at.t_type, at.t_no, at.t_date, at.notes, u.username
            FROM asset_trans at
            LEFT JOIN users u ON at.user_id = u.id
            WHERE at.asset_id = %s
            ORDER BY at.t_date DESC
        """
        return self.execute_query(query, (asset_id,))                                               

    def check_batch_expiry_consistency(self, item_id: int, batch_no: str, new_expiry_date: dt.date | None):
        """
        بررسی می‌کند که آیا یک بچ نامبر مشخص، قبلاً با تاریخ انقضای متفاوتی ثبت شده است یا خیر.
        خروجی: (True, None) اگر مشکلی نبود، (False, existing_date) اگر مغایرت وجود داشت.
        """
        # فقط بچ‌هایی را چک می‌کنیم که تاریخ انقضای معتبر دارند
        query = """
            SELECT DISTINCT expiry_date 
            FROM stock 
            WHERE item_id = %s AND batch_no = %s AND expiry_date IS NOT NULL
        """
        existing_records = self.execute_query(query, (item_id, batch_no))
        
        if not existing_records:
            return True, None # این بچ قبلاً ثبت نشده یا تاریخ انقضا نداشته، پس مشکلی نیست

        existing_date = existing_records[0]['expiry_date']

        # اگر تاریخ جدیدی وارد نشده بود، مشکلی نیست
        if new_expiry_date is None:
            return True, None

        # اگر تاریخ جدید با تاریخ موجود مغایرت داشت
        if existing_date != new_expiry_date:
            return False, existing_date
            
        return True, None
                
                
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def reject_raw_material_transfer(self, trans_id: int, rejector_user_id: int, reason: str):
        """
        نسخه 4.0 (معماری فرآیند صحیح و یکپارچه):
        - یک انتقال را رد کرده و موجودی را به انبار مبدأ برمی‌گرداند.
        - به جای ایجاد یک درخواست بازکاری جدید، وضعیت "درخواست اصلی" را به‌روز کرده
          و آن را مجدداً به کارتابل انبار باز می‌گرداند. این کار از ایجاد داده‌های متناقض جلوگیری می‌کند.
        """
        with self.transaction() as cur:
            # گام ۱: پیدا کردن و قفل کردن تراکنش اصلی برای جلوگیری از پردازش همزمان
            cur.execute(
                "SELECT * FROM trans WHERE id = %s AND status = %s FOR UPDATE",
                (trans_id, TransactionStatus.PENDING_PRODUCTION_APPROVAL.value)
            )
            trans = cur.fetchone()
            if not trans:
                raise ValueError("این تراکنش معتبر نیست یا قبلاً پردازش شده است.")

            # گام ۲: بازگرداندن موجودی به انبار مبدأ (منطق فعلی شما - بدون تغییر)
            self._upd_stock(cur, trans['item_id'], trans['src_loc'], abs(trans['qty']), trans['batch_no'], trans.get('expiry_date'))
            
            # گام ۳: به‌روزرسانی وضعیت تراکنش انتقال به "رد شده"
            notes_update = f"دلیل رد توسط تولید: {reason}"
            cur.execute(
                "UPDATE trans SET status = %s, approved_by=%s, approved_at=NOW(), notes = COALESCE(notes, '') || ' | ' || %s WHERE id = %s",
                (TransactionStatus.REJECTED.value, rejector_user_id, notes_update, trans_id)
            )

            # --- *** بخش جدید و استراتژیک: بازگرداندن درخواست اصلی به چرخه *** ---
            
            # گام ۴: پیدا کردن درخواست مادر اصلی از روی یادداشت‌های تراکنش
            # نکته: این روش همچنان به متن یادداشت وابسته است. در آینده می‌توان با افزودن یک ستون dedicated این ارتباط را قوی‌تر کرد.
            original_notes = trans.get('notes', '')
            parent_request_id = None
            if 'برای درخواست #' in original_notes:
                try:
                    import re
                    match = re.search(r'#(\d+)', original_notes)
                    if match:
                        parent_request_id = int(match.group(1))
                except (AttributeError, ValueError) as e:
                    print(f"WARNING: Could not parse parent request ID from notes for trans_id #{trans_id}. Reason: {e}")

            # گام ۵: اگر درخواست مادر پیدا شد، وضعیت آن را اصلاح کن
            if parent_request_id:
                # قفل کردن رکورد درخواست اصلی برای آپدیت امن
                parent_req = self.execute_query("SELECT * FROM material_requests WHERE id = %s FOR UPDATE", (parent_request_id,), fetch_one=True, cursor=cur)
                if parent_req:
                    # کم کردن مقدار رد شده از مقدار "انجام شده" قبلی
                    new_fulfilled = parent_req.get('fulfilled_qty', 0) - abs(trans['qty'])
                    
                    # افزودن دلیل رد شدن به یادداشت‌های درخواست اصلی
                    rework_note = f"بازبینی مورد نیاز: حواله با سند «{trans.get('t_no', '')}» توسط تولید رد شد. دلیل: {reason}"
                    
                    self.execute_query(
                        """UPDATE material_requests 
                           SET status = %s, fulfilled_qty = %s, notes = %s, processed_by_user_id = NULL
                           WHERE id = %s""",
                        (
                            TransactionStatus.MR_REWORK_WAREHOUSE.value, # وضعیت جدید برای نمایش در کارتابل انبار
                            max(0, new_fulfilled), # جلوگیری از منفی شدن
                            rework_note,
                            parent_request_id
                        ),
                        cursor=cur
                    )
            # --- ***************************************************************** ---
            
            self._log_atomic(cur, rejector_user_id, 'TRANSFER_REJECTED_V3', f"Rejected trans_id:{trans_id}, reverted parent request.")
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        return True
        
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def reject_void_transaction(self, trans_id_to_reject: int, user_id: int, reason: str):
        """
        نسخه نهایی: درخواست ابطال یک تراکنش را رد کرده و از استخر اتصالات استفاده می‌کند.
        """
        # به جای with self._conn() از with self.transaction() استفاده می‌کنیم
        with self.transaction() as cur:
            # کوئری‌ها حالا از طریق execute_query استاندارد و با cursor موجود اجرا می‌شوند
            trans_info = self.execute_query(
                "SELECT status, notes FROM trans WHERE id = %s FOR UPDATE", 
                (trans_id_to_reject,), 
                fetch_one=True, 
                cursor=cur
            )
            
            if not trans_info or trans_info['status'] != 'در انتظار تایید ابطال':
                raise ValueError("این تراکنش در وضعیت مناسب برای رد ابطال نیست.")

            new_notes = (trans_info['notes'] or '') + f" | [دلیل رد ابطال: {reason}]"

            self.execute_query(
                "UPDATE trans SET status = 'تایید شده', notes = %s WHERE id = %s",
                (new_notes, trans_id_to_reject),
                cursor=cur
            )
            
            # فراخوانی نسخه اتمیک لاگ که از تراکنش فعلی استفاده می‌کند
            log_details = f"درخواست ابطال برای تراکنش #{trans_id_to_reject} رد شد. دلیل: {reason}"
            self._log_atomic(cur, user_id, 'VOID_REJECTED', log_details)

# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید (متد _log قدیمی حذف خواهد شد)

    def _log_atomic(self, cur, user_id: int, act: str, det: str) -> int:
        """
        نسخه امن برای ثبت وقایع که یک cursor موجود را می‌پذیرد
        و ID لاگ ثبت شده را برمی‌گرداند.
        """
        result = self.execute_query(
            'INSERT INTO audit(stamp, user_id, action, details) VALUES (NOW(), %s, %s, %s) RETURNING id',
            (user_id, act, det),
            fetch_one=True,
            cursor=cur
        )
        return result['id'] if result else None
                                                                                
    # این دو متد جدید را به انتهای کلاس DB اضافه کنید
    def get_pending_raw_material_transfers(self):
        """تمام درخواست‌های انتقال مواد اولیه که منتظر تایید تولید هستند را برمی‌گرداند."""
        query = """
            SELECT
                t.id, i.name as item_name, t.t_no, t.qty, u.username as requester, t.t_date
            FROM trans t
            JOIN items i ON t.item_id = i.id
            JOIN users u ON t.user_id = u.id
            WHERE t.status = 'در انتظار تایید تولید'
            ORDER BY t.id DESC;
        """
        return self.execute_query(query)

# در کلاس DB، این متد را جایگزین کنید

    def approve_raw_material_transfer(self, trans_id: int, approver_user_id: int) -> bool:
        """
        نسخه نهایی (اصلاح شده): انتقال مواد اولیه را تایید کرده و با استفاده از استخر اتصالات (Connection Pool)،
        موجودی را به صورت اتمیک به‌روزرسانی و وضعیت تراکنش را به 'تایید شده' تغییر می‌دهد.
        """
        try:
            with self.transaction() as cur:
                # گام ۱: انتخاب تراکنش و تایید وضعیت
                # FOR UPDATE تضمین می‌کند که هیچ فرآیند دیگری همزمان روی این ردیف کار نکند
                cur.execute(
                    "SELECT * FROM trans "
                    "WHERE id = %s "
                    "AND status = 'در انتظار تایید تولید' "
                    "AND t_type = 'خروج به تولید' "
                    "FOR UPDATE",
                    (trans_id,)
                )
                trans = cur.fetchone()
                if not trans:
                    raise ValueError("تراکنش یافت نشد یا قبلاً پردازش شده است.")
                
                # گام ۲: استخراج اطلاعات لازم
                item_id = trans['item_id']
                dest_loc_id = trans['dest_loc']
                qty_needed = trans['qty']
                batch_no = trans['batch_no']
                expiry_date = trans.get('expiry_date')
                
                # گام ۳: افزودن موجودی به انبار مقصد (تولید)
                self._upd_stock(
                    cur,
                    item_id,
                    dest_loc_id,
                    abs(qty_needed),
                    batch_no=batch_no,
                    expiry_date=expiry_date
                )
                
                # گام ۴: آپدیت وضعیت خود تراکنش به "تایید شده"
                cur.execute(
                    "UPDATE trans "
                    "SET status = %s, approved_by = %s, approved_at = NOW() "
                    "WHERE id = %s",
                    (TransactionStatus.APPROVED.value, approver_user_id, trans_id)
                )
                
                # گام ۵: ثبت لاگ عملیات در همان تراکنش
                self._log_atomic(
                    cur,
                    approver_user_id,
                    'TRANSFER_APPROVAL',
                    f"تایید دریافت مواد اولیه برای تراکنش #{trans_id}"
                )
                
            # با خروج از بلوک with، عملیات به صورت خودکار Commit می‌شود.
            # سیگنال برای آپدیت اعلان‌ها پس از کامیت موفق ارسال می‌شود.
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            return True
            
        except (Exception, psycopg2.Error) as e:
            # context manager به صورت خودکار Rollback را انجام می‌دهد.
            print(f"ERROR during material transfer approval: {e}")
            traceback.print_exc()
            raise  # خطا را دوباره ارسال می‌کنیم تا لایه‌های بالاتر متوجه شوند.            
                                            
# در کلاس DB، این متد را جایگزین کنید

    def add_bom_file(self, bom_id: int, path: str):
        """یک فایل پیوست به یک رکورد BOM به صورت اتمیک اضافه می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "INSERT INTO bom_files(bom_id, path) VALUES (%s, %s)",
                (bom_id, path),
                cursor=cur
            )
            
# در کلاس DB، این متد را جایگزین کنید

    def delete_bom_file(self, file_id: int):
        """یک فایل پیوست BOM را به صورت اتمیک حذف می‌کند."""
        with self.transaction() as cur:
            self.execute_query("DELETE FROM bom_files WHERE id=%s", (file_id,), cursor=cur)
                        
    # ═════════════════════════════════════════════
    #         متدهای جدید برای مدیریت تولید
    # ═════════════════════════════════════════════

    def get_production_floor_location(self):
            """
            نسخه نهایی و صحیح: ID لوکیشن پیش‌فرض انبار «Production» را برمی‌گرداند.
            این تابع دیگر به آدرس‌های قدیمی و حذف شده وابسته نیست.
            """
            # ما از تابع عمومی که قبلاً برای پیدا کردن لوکیشن پیش‌فرض یک انبار داشتیم، استفاده می‌کنیم
            # این روش بسیار مطمئن‌تر و پویاتر است.
            return self.get_warehouse_default_location('Production')
    

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_recipes(self):
        """
        نسخه نهایی: فقط فرمول‌های فعال (ACTIVE) را برمی‌گرداند و اطلاعات محصول خروجی را نیز شامل می‌شود.
        """
        query = """
            SELECT 
                r.id, r.product_name, r.yield_percentage, r.notes, r.part_type,
                r.produces_item_id,
                i.name as produced_item_name -- نام محصولی که واقعا تولید می‌شود
            FROM recipes r
            LEFT JOIN items i ON r.produces_item_id = i.id
            WHERE 
                (r.part_type IS NULL OR r.part_type != 'PACKAGING')
                AND r.status = 'ACTIVE' -- <<<<---- اصلاح کلیدی اینجاست
            ORDER BY r.product_name
        """
        return self.execute_query(query)
                                    
    # BEGIN REWRITE: DB.get_recipe_details
    def get_recipe_details(self, recipe_id: int) -> dict:
        """
        جزئیات یک فرمول + مواد اولیه‌اش را برمی‌گرداند.
        - نام کالا برای هر ماده با JOIN روی items حتماً با alias «item_name» برمی‌گردد.
        """
        with self.transaction() as cur:
            recipe = self.execute_query(
                """
                SELECT r.*,
                    COALESCE(p.name, r.product_name) AS parent_name
                FROM recipes r
                LEFT JOIN items p ON p.id = r.parent_product_id
                WHERE r.id = %s
                LIMIT 1
                """,
                (recipe_id,), fetch_one=True, cursor=cur
            )

            # تشخیص نام ستون آیتم در جدول مواد (raw_material_item_id یا item_id)
            cols = set()
            try:
                cols = set(self._get_existing_columns('recipe_ingredients'))
            except Exception:
                pass
            item_col = 'raw_material_item_id' if 'raw_material_item_id' in cols else ('item_id' if 'item_id' in cols else None)
            if not item_col:
                return {'recipe': recipe, 'ingredients': []}

            ingredients = self.execute_query(
                f"""
                SELECT ri.{item_col} AS item_id,
                    it.name      AS item_name,
                    COALESCE(ri.percentage, 0) AS percentage
                FROM recipe_ingredients ri
                JOIN items it ON it.id = ri.{item_col}
                WHERE ri.recipe_id = %s
                ORDER BY ri.id
                """,
                (recipe_id,), cursor=cur
            ) or []

            return {'recipe': recipe, 'ingredients': ingredients}
    # END REWRITE: DB.get_recipe_details
    
                                                
# در کلاس DB، این متد را جایگزین کنید

    def delete_recipe(self, recipe_id: int):
        """یک فرمول را به صورت اتمیک و کامل حذف می‌کند."""
        with self.transaction() as cur:
            # به لطف ON DELETE CASCADE در دیتابیس، با حذف فرمول،
            # تمام مواد اولیه مرتبط با آن نیز به صورت خودکار حذف می‌شوند.
            self.execute_query("DELETE FROM recipes WHERE id=%s", (recipe_id,), cursor=cur)
            
    def get_detailed_items_in_location(self, loc_id: int):
        """اطلاعات کامل کالاها به همراه حداقل موجودی در یک لوکیشن."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT i.name, s.qty, COALESCE(u.name,'') AS unit, i.min_qty
                    FROM stock AS s
                    JOIN items AS i ON i.id = s.item_id
                    LEFT JOIN units u ON u.id = i.unit_id
                    WHERE s.location_id = %s AND s.qty > 0
                    ORDER BY i.name
                """, (loc_id,))
                return cur.fetchall()
                                
                                                
# این متد جدید را به کلاس DB اضافه کنید
    def _get_bom_user_column_info(self):
        """ساختار ستون کاربر در جدول BOM را بررسی کرده و نام و نوع آن را برمی‌گرداند."""
        if hasattr(self, '_bom_user_col_info'):
            return self._bom_user_col_info

        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT column_name, data_type 
                    FROM information_schema.columns 
                    WHERE table_name = 'bill_of_materials' AND column_name = 'user_id'
                """)
                res = cur.fetchone()
                if res:
                    self._bom_user_col_info = ('user_id', 'INTEGER')
                    return self._bom_user_col_info
                
                self._bom_user_col_info = ('user_', 'TEXT')
                return self._bom_user_col_info
                            
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def list_producible_items(self):
        """لیست محصولاتی که تولید شده‌اند و آماده تحویل به انبار هستند را برمی‌گرداند."""
        query = """
            SELECT id, product_name, production_batch_no, quantity 
            FROM production_deliveries 
            WHERE status = %s
            ORDER BY id DESC
        """
        # استفاده از ثابت استاندارد به جای متن خام
        return self.execute_query(query, (TransactionStatus.PRODUCED.value,))
        
    
    # BEGIN REWRITE: DB.submit_delivery_request
    def submit_delivery_request(self, delivery_id: int) -> bool:
        """
        ارسال بچ از تولید برای تایید انبار:
        - وضعیت را به «در انتظار تایید انبار» ست می‌کند.
        - اگر قبلاً اشتباهاً «در انتظار تایید تولید» شده باشد هم تصحیح می‌کند.
        - ستون‌های زمانی (در صورت وجود) مثل requested_at/updated_at را پر می‌کند.
        """
        with self.transaction() as cur:
            # تشخیص امن ستون‌های موجود (ممکن است در برخی اسکیماها نباشند)
            try:
                cols = set(self._get_existing_columns('production_deliveries', cursor=cur))
            except Exception:
                cols = set()

            set_parts = ["status = %s"]
            params = [TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value]

            if 'requested_at' in cols:
                set_parts.append("requested_at = NOW()")
            if 'updated_at' in cols:
                set_parts.append("updated_at = NOW()")

            sql = f"""
                UPDATE production_deliveries
                SET {', '.join(set_parts)}
                WHERE id = %s
                AND status IN (%s, %s)
            """
            params.extend([
                delivery_id,
                TransactionStatus.PRODUCED.value,
                TransactionStatus.PENDING_PRODUCTION_APPROVAL.value
            ])

            # اجرای اتمیک
            self.execute_query(sql, tuple(params), cursor=cur)
            return cur.rowcount > 0
    # END REWRITE: DB.submit_delivery_request
                    
    # BEGIN REWRITE: DB.get_pending_deliveries
    def get_pending_deliveries(self):
        """
        لیست محصولات منتظر تایید انبار (سازگار با اسکیماهای مختلف و مسیرهای قدیمی).
        - اتصال به items بر اساس product_item_id (در صورت وجود)، وگرنه بر اساس نام.
        - برگرداندن نام مادر/فرزند برای نمایش نام کامل در UI.
        - پوشش هر دو وضعیت محتمل: «در انتظار تایید انبار» (اصلی) و «در انتظار تایید تولید» (قدیمی/اشتباهی).
        - تشخیص خودکار ستون‌های batch/created/supervisor.
        """
        with self.transaction() as cur:
            if not self._table_exists('production_deliveries', cursor=cur):
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:pending_deliv] table_exists=False rows=0')
                return []

            cols = set(self._get_existing_columns('production_deliveries', cursor=cur))
            if not cols:
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:pending_deliv] table_exists=False rows=0')
                return []

            has  = cols.__contains__

            # انتخاب امن ستون تاریخ ایجاد
            created_col = next((c for c in ('created_at','createdon','created_date','ts') if has(c)), None)
            created_expr = f"pd.{created_col}" if created_col else "NOW()"

            # انتخاب امن ستون شماره بچ
            batch_expr = "pd.production_batch_no" if has('production_batch_no') else "pd.batch_no"

            # انتخاب امن ستون کاربرِ ثبت‌کننده/سرپرست
            sup_candidates = [c for c in ('supervisor_user_id','created_by','supervisor_id') if has(c)]
            if sup_candidates:
                join_user = f"LEFT JOIN users u ON u.id = COALESCE({', '.join('pd.'+c for c in sup_candidates)})"
                sup_select = "u.username AS supervisor_name"
            else:
                join_user = ""
                sup_select = "NULL::text AS supervisor_name"

            # اگر ستون product_item_id هست، با id وصل شو؛ در هر صورت، اتصال کمکی با name هم انجام می‌شود
            join_i1 = "LEFT JOIN items i1 ON i1.id = pd.product_item_id" if has('product_item_id') else ""
            join_i2 = "LEFT JOIN items i2 ON i2.name = pd.product_name"

            import re as _re

            has_items = bool(self._table_exists('items', cursor=cur))
            has_units = bool(self._table_exists('units', cursor=cur))

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur)) if has_items else set()
            except Exception:
                item_cols = set()

            ident_pattern = _re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")

            unit_col = None
            if has_items and has_units:
                unit_col = self._resolve_items_unit_column(cursor=cur)
                if unit_col and not ident_pattern.fullmatch(unit_col):
                    unit_col = None

            if 'is_packed' in item_cols:
                if has('product_item_id'):
                    is_packed_expr = 'COALESCE(i1.is_packed, i2.is_packed, TRUE)'
                else:
                    is_packed_expr = 'COALESCE(i2.is_packed, TRUE)'
            else:
                is_packed_expr = 'TRUE'

            parent_col = None
            for candidate in ("parent_item_id", "parent_id"):
                if candidate in item_cols:
                    parent_col = candidate
                    break

            if parent_col and not ident_pattern.fullmatch(parent_col):
                parent_col = None

            if parent_col:
                if has('product_item_id'):
                    parent_expr = f"COALESCE(i1.{parent_col}, i2.{parent_col})"
                else:
                    parent_expr = f"i2.{parent_col}"
                join_parent = f"LEFT JOIN items p ON p.id = {parent_expr}"
                parent_select = "p.name AS parent_name"
            else:
                join_parent = ""
                parent_select = "NULL::text AS parent_name"

            # نام فرزند را از items بگیر؛ اگر نشد، از متن production_deliveries
            child_name_expr = "COALESCE(i1.name, i2.name, pd.product_name)"

            sql = f"""
                SELECT
                    pd.id,
                    {child_name_expr} AS product_name,
                    {parent_select},
                    {batch_expr} AS production_batch_no,
                    pd.quantity,
                    {sup_select},
                    {created_expr} AS created_at
                FROM production_deliveries pd
                {join_i1}
                {join_i2}
                {join_parent}
                {join_user}
                WHERE pd.status IN (%s, %s)
                AND {is_packed_expr} = TRUE
                ORDER BY pd.id ASC
            """

            # وضعیت اصلی + پوشش قدیمی (اگر جایی اشتباهاً به «تایید تولید» ست شده باشد)
            params = (
                TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value,
                TransactionStatus.PENDING_PRODUCTION_APPROVAL.value
            )
            rows = self.execute_query(sql, params, cursor=cur) or []
            if DEBUG_DB_RESOLVE:
                parent_label = parent_col or 'NONE'
                print(f"[TRACE:DB:pending_deliv] table_exists=True rows={len(rows)} parent_col={parent_label}")
            return rows
    # END REWRITE: DB.get_pending_deliveries
    
    # BEGIN ADD: DB.reject_delivery
    def reject_delivery(self, delivery_id: int, reason: str, approver_user_id: int) -> bool:
        """
        رد کردن «درخواست تحویل از تولید به انبار»
        - فقط ردیف‌های در صف تایید قابل رد هستند.
        - بدون جابجایی موجودی (چون هنوز ورودی به انبار ثبت نشده است).
        - با اسکیماهای مختلف سازگار: ستون‌های دلیل/کاربر/زمان اگر باشند پر می‌شوند.
        """
        if not reason or not str(reason).strip():
            raise ValueError("وارد کردن دلیل رد الزامی است.")

        with self.transaction() as cur:
            # 1) قفل کردن ردیف
            cur.execute("""
                SELECT pd.*
                FROM production_deliveries pd
                WHERE pd.id = %s
                FOR UPDATE
            """, (delivery_id,))
            row = cur.fetchone()
            if not row:
                raise ValueError("درخواست یافت نشد.")

            status_txt = (row.get('status') or '').strip()
            allowed_statuses = {
                getattr(TransactionStatus, 'PENDING_WAREHOUSE_APPROVAL').value,
                getattr(TransactionStatus, 'PENDING_PRODUCTION_APPROVAL').value
            }
            if status_txt not in allowed_statuses:
                raise ValueError("این درخواست در صف تایید نیست یا قبلاً رسیدگی شده است.")

            # 2) تشخیص ستون‌های موجود
            try:
                cols = set(self._get_existing_columns('production_deliveries', cursor=cur))
            except Exception:
                cols = set()

            sets = ["status = %s"]
            params = [getattr(TransactionStatus, 'REJECTED').value]

            # ستون‌های احتمالیِ ذخیره دلیل
            reason_field = None
            for cand in ('rejection_reason', 'reject_reason', 'reason', 'status_reason'):
                if cand in cols:
                    reason_field = cand
                    break

            if reason_field:
                sets.append(f"{reason_field} = %s")
                params.append(str(reason).strip())
            elif 'notes' in cols:
                # اگر فقط notes داریم، دلیل را به آن اضافه می‌کنیم (بدون حذف یادداشت قبلی)
                sets.append("notes = COALESCE(notes,'') || %s")
                params.append(("\n" if (row.get('notes') or '') else "") + f"رد: {str(reason).strip()}")

            if 'approver_user_id' in cols:
                sets.append("approver_user_id = %s"); params.append(approver_user_id)
            if 'rejected_at' in cols:
                sets.append("rejected_at = NOW()")
            if 'updated_at' in cols:
                sets.append("updated_at = NOW()")

            params.append(delivery_id)
            cur.execute(f"UPDATE production_deliveries SET {', '.join(sets)} WHERE id = %s", tuple(params))

            # 3) لاگ
            try:
                self._log_atomic(cur, approver_user_id, 'REJECT_PRODUCTION_DELIVERY',
                                f"delivery_id:{delivery_id}, reason:{str(reason).strip()}")
            except Exception:
                pass

            return True
    # END ADD: DB.reject_delivery

                                                                                                                                            
    # BEGIN REWRITE: DB.list_bom
    def list_bom(self, limit: int = 500):
        """
        تاریخچه مصرف (BOM) — نسخه ایمن:
        - اگر جدول‌های bill_of_materials و bom_files وجود نداشت، با اسکیمای مینیمال ساخته می‌شوند.
        - سپس همان کوئری قبلی اجرا و نتایج برگردانده می‌شود.
        """
        with self.transaction() as cur:
            # 1) تضمین وجود جدول‌های مورد نیاز (ایمن و کم‌ریسک)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS bill_of_materials (
                    id SERIAL PRIMARY KEY,
                    product_code VARCHAR(64),
                    raw_item_id INT NOT NULL,
                    raw_batch VARCHAR(64),
                    qty NUMERIC NOT NULL,
                    ts TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW(),
                    user_id INT,
                    recipe_id INT,
                    status VARCHAR(32) DEFAULT 'ثبت'
                )
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS bom_files (
                    id SERIAL PRIMARY KEY,
                    bom_id INT NOT NULL,
                    file_path TEXT NOT NULL,
                    ts TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW()
                )
            """)

            # 2) کوئری اصلی (بدون تغییر در ظاهر/ستون‌های خروجی UI)
            query = """
                SELECT 
                    b.id,
                    b.product_code,
                    raw.name AS raw_item_name,
                    b.raw_batch,
                    b.qty,
                    b.ts,
                    u.username AS user_,
                    b.status,
                    COALESCE(
                        (SELECT r.product_name FROM recipes r WHERE r.id = b.recipe_id),
                        'محصول نامشخص'
                    ) AS product_name,
                    (SELECT COUNT(*) FROM bom_files bf WHERE bf.bom_id = b.id) AS files_count
                FROM bill_of_materials b
                JOIN items raw ON raw.id = b.raw_item_id
                LEFT JOIN users u ON u.id = b.user_id
                ORDER BY b.id DESC
                LIMIT %s
            """
            cur.execute(query, (limit,))
            return cur.fetchall()
    # END REWRITE: DB.list_bom
                                            
                                
            
# این متد جدید را برای دیباگ به کلاس DB اضافه کنید
    def get_raw_stock_report(self, item_name: str):
        """
        یک گزارش خام از تمام موجودی‌های یک کالا با نام مشخص را برمی‌گرداند.
        """
        query = """
            SELECT 
                i.name as item_name,
                s.qty,
                s.batch_no,
                w.name as warehouse_name,
                l.rack, l.shelf, l.bin
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE i.name = %s AND s.qty > 0
        """
        print(f"--- DEBUG: Fetching raw stock for item: {item_name} ---")
        results = self.execute_query(query, (item_name,))
        print("--- DEBUG: Raw data from DB ---")
        for row in results:
            print(row)
        print("---------------------------------")
        return results
                                    
# در کلاس DB، این متد را جایگزین کنید

    def get_deliveries_by_supervisor(self, user_id: int):
            """تاریخچه تمام درخواست‌های تحویل ثبت شده توسط یک سرپرست خاص را برمی‌گرداند."""
            query = """
                SELECT
                    pd.id, pd.product_name, pd.production_batch_no, pd.quantity,
                    pd.created_at, pd.status, pd.rejection_reason, 
                    approver.username as approver_name,
                    rejecter.username as rejecter_name
                FROM production_deliveries pd
                LEFT JOIN users approver ON pd.approver_user_id = approver.id
                LEFT JOIN users rejecter ON pd.rejected_by_user_id = rejecter.id
                WHERE pd.supervisor_user_id = %s
                ORDER BY pd.id DESC;
            """
            return self.execute_query(query, (user_id,))
                                
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_main_warehouse_location(self):
        """ID لوکیشن پیش‌فرض انبار اصلی را برمی‌گرداند."""
        query = """
            SELECT id FROM locations 
            WHERE rack='A' AND shelf='1' AND bin='1' 
            AND warehouse_id=(SELECT id FROM warehouses WHERE name=%s LIMIT 1)
        """
        # استفاده از پارامتر به جای قرار دادن مستقیم متن در کوئری
        res = self.execute_query(query, ('Main',), fetch_one=True)
        return res['id'] if res else None
                
    def consume_materials_and_log_bom(self, recipe_id: int, production_batch_no: str, consumption_plan: dict, user_id: int):
            """
            فقط مواد اولیه را مصرف کرده و گزارش BOM را ثبت می‌کند.
            این تابع به هیچ وجه موجودی محصول نهایی را تغییر نمی‌دهد.
            """
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("خطا: لوکیشن 'کف کارگاه' تعریف نشده است.")

            with self.transaction() as cur:
                for material_name, batches_to_consume in consumption_plan.items():
                    for batch_info in batches_to_consume:
                        self._upd_stock(
                            cur, 
                            item_id=batch_info['item_id'], 
                            location_id=prod_loc_id, 
                            qty_change=-abs(batch_info['qty_to_consume']), 
                            batch_no=batch_info['batch_no'],
                            expiry_date=batch_info.get('expiry_date')
                        )
                        cur.execute(
                            """INSERT INTO bill_of_materials (product_code, raw_item_id, raw_batch, qty, ts, user_id, recipe_id)
                            VALUES (%s, %s, %s, %s, NOW(), %s, %s)""",
                            (production_batch_no, batch_info['item_id'], batch_info['batch_no'], batch_info['qty_to_consume'], user_id, recipe_id)
                        )
                
                self._log_atomic(cur, user_id, 'CONSUME_FOR_PRODUCTION', f"Consumed materials for Batch:{production_batch_no}")    

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_all_transactions_detailed(self, t_type_filter: str = None):
        """
        نسخه 3.0 (بهینه‌سازی شده و نهایی):
        - کوئری همبسته برای شمارش فایل‌ها با یک JOIN بهینه جایگزین شد تا سرعت به شدت افزایش یابد.
        - باگ مربوط به ستون unit برطرف شد.
        """
        query = """
            SELECT
                t.*,
                i.name as item_name,
                p.name as parent_name,
                un.name as unit, -- <<<--- اصلاح کلیدی اینجاست
                u.username,
                COALESCE(tf.files_count, 0) AS files_count,
                (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin) AS src_loc_full,
                (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin) AS dst_loc_full,
                CASE
                    WHEN t.t_type = 'انتقال' THEN
                        'از: ' || (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin) ||
                        ' به: ' || (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin)
                    ELSE
                        COALESCE(
                            (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin),
                            (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin),
                            ''
                        )
                END AS loc_label
            FROM
                trans t
            LEFT JOIN items i ON i.id = t.item_id
            LEFT JOIN units un ON i.unit_id = un.id -- <<<--- اصلاح کلیدی اینجاست
            LEFT JOIN items p ON i.parent_item_id = p.id
            LEFT JOIN users u ON u.id = t.user_id
            LEFT JOIN locations src_l ON t.src_loc = src_l.id
            LEFT JOIN warehouses src_w ON src_l.warehouse_id = src_w.id
            LEFT JOIN locations dst_l ON t.dest_loc = dst_l.id
            LEFT JOIN warehouses dst_w ON dst_l.warehouse_id = dst_w.id
            LEFT JOIN (
                SELECT trans_id, COUNT(*) as files_count
                FROM trans_files
                GROUP BY trans_id
            ) tf ON t.id = tf.trans_id
        """

        params = []
        if t_type_filter and t_type_filter != 'همه':
            query += " WHERE t.t_type = %s"
            params.append(t_type_filter)

        query += " ORDER BY t.id DESC"

        return self.execute_query(query, tuple(params))                                
                                    
                                                                                
# در کلاس DB، این متد را با نسخه زیر جایگزین کنید
    def submit_delivery_to_warehouse(self, product_item_id: int, quantity: float, batch_no: str, supervisor_user_id: int):
        """
        نسخه نهایی و صحیح: یک تراکنش 'دریافتی از تولید' با وضعیت 'در انتظار تایید' و با استفاده از user_id صحیح ثبت می‌کند.
        """
        prod_loc_id = self.get_production_floor_location()
        main_wh_loc = self.get_main_warehouse_location()
        if not prod_loc_id or not main_wh_loc:
            raise ValueError("خطا: لوکیشن‌های 'تولید' یا 'انبار اصلی' در سیستم تعریف نشده‌اند.")

        with self._conn() as conn:
            with conn.cursor() as cur:
                # ۱. چک کردن موجودی در کف کارگاه (مبدا)
                cur.execute("SELECT qty FROM stock WHERE item_id = %s AND location_id = %s", (product_item_id, prod_loc_id))
                stock_record = cur.fetchone()
                if not stock_record or stock_record.get('qty', 0) < quantity:
                    raise ValueError(f"موجودی بچ '{batch_no}' در کف کارگاه برای تحویل کافی نیست (موجود: {stock_record.get('qty', 0) if stock_record else 0}).")

                # ۲. ثبت تراکنش با استفاده از ستون user_id به جای user_
                cur.execute(
                    """
                    INSERT INTO trans (
                        t_type, item_id, t_no, qty, notes, user_id, 
                        src_loc, dest_loc, status, t_date, attach_path
                    )
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s)
                    """,
                    (
                        'دریافتی از تولید', 
                        product_item_id, 
                        batch_no, 
                        quantity, 
                        f"درخواست تحویل بچ {batch_no} به انبار اصلی", 
                        supervisor_user_id, # <-- FIX: استفاده از ID عددی کاربر
                        prod_loc_id,      # مبدا: کف کارگاه
                        main_wh_loc,      # مقصد: انبار اصلی
                        'در انتظار تایید',
                        ''                # مقدار پیش‌فرض برای attach_path
                    )
                )
                conn.commit()
                                                                                                                            
    def process_delivery(self, delivery_id: int, approver_user: str, approve: bool):
        """یک درخواست تحویل را تایید یا رد می‌کند و در صورت تایید، موجودی انبار اصلی را افزایش می‌دهد."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                new_status = 'approved' if approve else 'rejected'
                
                if approve:
                    cur.execute("SELECT product_item_id, quantity FROM production_deliveries WHERE id=%s", (delivery_id,))
                    delivery_data = cur.fetchone()
                    if delivery_data:
                        cur.execute("SELECT id FROM locations WHERE warehouse_id=(SELECT id FROM warehouses WHERE name='Main') AND rack='A' AND shelf='1' AND bin='1'")
                        main_loc = cur.fetchone()['id']
                        
                        self._upd_stock(delivery_data['product_item_id'], main_loc, delivery_data['quantity'])
                        self._refresh_item_qty(delivery_data['product_item_id'])

                cur.execute("UPDATE production_deliveries SET status = %s, approver_user = %s, processed_at = NOW() WHERE id = %s",
                            (new_status, approver_user, delivery_id))
            conn.commit()
            

    def save_recipe(self, recipe_data: dict, ingredients: list, recipe_id_to_revise: int = None):
        """
        ذخیره/نسخه‌گذاری فرمول با سازگاری‌پذیری ستون‌ها و درج اقلام بدون executemany.
        - نسخه‌های ACTIVE همان محصول قبل از درج نسخهٔ جدید ARCHIVED می‌شوند.
        - INSERT روی جدول recipes فقط ستون‌های موجود را می‌نویسد.
        - اقلام BOM با حلقهٔ امن (execute_query) درج می‌شوند.
        - کُد فرمول علاوه بر ستون اختیاری 'code' در properties.recipe_code هم ذخیره می‌شود.
        - برای پارت‌های A/B اگر مواد تعریف نشده باشد، هیچ فرمولی درج نمی‌شود.
        """
        import re, json
        try:
            import jdatetime as jd
        except Exception:
            jd = None

        # --- تنظیمات اختیاری تریس ---
        DEBUG_TRACE = False
        def _trace(msg):
            if DEBUG_TRACE:
                print(f"[SAVE_RECIPE] {msg}")

        product_name = (recipe_data.get('product_name') or '').strip()
        if not product_name:
            raise ValueError("نام محصول برای فرمول مشخص نیست.")

        parent_id   = recipe_data.get('parent_product_id')
        produces_id = recipe_data.get('produces_item_id')
        notes       = recipe_data.get('notes')
        props_in    = recipe_data.get('properties') or {}
        created_by  = recipe_data.get('created_by_id') or recipe_data.get('user_id')
        explicit_pt = (recipe_data.get('part_type') or '').strip().upper() or None

        def _slug(s: str) -> str:
            s = (s or "").strip()
            s = re.sub(r"\s+", "-", s)
            s = re.sub(r"[^0-9A-Za-z\u0600-\u06FF\-\_]+", "", s)
            return s[:64] or "ITEM"

        def _make_code(pt_letter: str, version_int: int, parent_name: str) -> str:
            yy_mm = "0000"
            if jd:
                now_j = jd.datetime.now()
                yy_mm = f"{now_j.year % 100:02d}{now_j.month:02d}"
            return f"{pt_letter}/{yy_mm}/{int(version_int):03d}/{_slug(parent_name)}"

        # استنباط part_type از ورودی/لیست اقلام
        def _pick_item_id(row): return (row.get('raw_material_item_id') or row.get('component_item_id') or row.get('item_id'))
        def _pick_qty(row):     return (row.get('percentage') or row.get('quantity') or row.get('qty'))

        item_ids = [_pick_item_id(r) for r in (ingredients or []) if _pick_item_id(r)]

        # نقشهٔ دستهٔ آیتم‌ها (برای تشخیص بسته‌بندی)
        cats_map = {}
        if item_ids:
            rows = self.execute_query("SELECT id, category FROM items WHERE id = ANY(%s)", (item_ids,))
            cats_map = {r['id']: r['category'] for r in (rows or [])}

        # ثابت پروژه: نام دستهٔ بسته‌بندی (فرض: تعریف شده است)
        try:
            CATEGORY_PACKAGING
        except NameError:
            CATEGORY_PACKAGING = 'PACKAGING'

        inferred_packaging = (len(item_ids) > 0 and all(cats_map.get(i) == CATEGORY_PACKAGING for i in item_ids))
        part_type = explicit_pt if explicit_pt in {"MASTER","A","B","PACKAGING"} else ("PACKAGING" if inferred_packaging else "MASTER")

        # --- پیش‌اسکن مواد برای جلوگیری از درج بی‌محتوا ---
        filtered_preview = []
        for r in (ingredients or []):
            iid = _pick_item_id(r); q = _pick_qty(r)
            if not iid or q in (None, ""):
                continue
            if 'percentage' in r:
                filtered_preview.append(('RM', iid))
            elif 'qty' in r:
                filtered_preview.append(('CMP', iid))

        # اگر A/B و هیچ ماده/جزئی تعریف نشده، اصلا وارد DB نشو
        if part_type in {"A","B"} and not filtered_preview:
            raise ValueError("هیچ جزءی برای فرمول جزء تعریف نشده است؛ تا تعریف نکنی چیزی ثبت نمی‌کنم.")

        with self.transaction() as cur:
            # اگر نسخهٔ قبلی جهت بازنگری مشخص شده، همان را آرشیو کن
            if recipe_id_to_revise:
                self.execute_query("UPDATE recipes SET status='ARCHIVED' WHERE id=%s", (recipe_id_to_revise,), cursor=cur)

            # همهٔ نسخه‌های ACTIVE همین محصول را آرشیو کن
            self.execute_query(
                "UPDATE recipes SET status='ARCHIVED' WHERE product_name=%s AND status='ACTIVE'",
                (product_name,), cursor=cur
            )

            # نسخهٔ جدید
            rowv = self.execute_query(
                "SELECT COALESCE(MAX(CAST(version AS INTEGER)), 0) AS v FROM recipes WHERE product_name = %s",
                (product_name,), fetch_one=True, cursor=cur
            )
            new_version = int((rowv or {}).get('v') or 0) + 1

            # کُد نسخه
            parent_name = None
            if parent_id:
                pn = self.execute_query("SELECT name FROM items WHERE id=%s", (parent_id,), fetch_one=True, cursor=cur)
                parent_name = (pn or {}).get('name')
            parent_name = parent_name or product_name
            pt_letter = {"MASTER":"M", "A":"A", "B":"B", "PACKAGING":"P"}.get(part_type, "M")
            calc_code = _make_code(pt_letter, new_version, parent_name)

            # ستون‌های واقعی recipes
            rec_cols = set(self._get_existing_columns("recipes", cursor=cur))

            # properties را ایمن ادغام کن و recipe_code را در آن بنویس
            try:
                if isinstance(props_in, str):
                    props_in = json.loads(props_in or "{}")
            except Exception:
                props_in = {}
            if not isinstance(props_in, dict):
                props_in = {}
            props_in = {**props_in, "recipe_code": calc_code}

            all_vals = {
                "product_name": product_name,
                "part_type": part_type,
                "version": str(new_version),
                "status": "ACTIVE",
                "parent_product_id": parent_id,
                "produces_item_id": produces_id,
                "notes": notes,
                "properties": json.dumps(props_in, ensure_ascii=False),
                "created_by": created_by,
                # اگر ستون code وجود داشته باشد پرش می‌کنیم؛ UI فعلا از properties می‌خواند
                "code": calc_code,
            }
            cols = [c for c in all_vals if c in rec_cols]
            vals = [all_vals[c] for c in cols]
            sql = f"INSERT INTO recipes ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(cols))}) RETURNING id"
            rec = self.execute_query(sql, tuple(vals), fetch_one=True, cursor=cur)
            recipe_id = int(rec['id'])

            # اقلام BOM → بدون executemany
            filtered = []
            for r in (ingredients or []):
                iid = _pick_item_id(r); q = _pick_qty(r)
                if not iid or q in (None, ""):
                    continue
                if 'percentage' in r:
                    filtered.append({'raw_material_item_id': iid, 'percentage': float(r['percentage'])})
                elif 'qty' in r:
                    filtered.append({'component_item_id': iid, 'quantity': float(r['qty'])})

            cols_ri = set(self._get_existing_columns("recipe_ingredients", cursor=cur))
            if filtered and 'raw_material_item_id' in filtered[0] and 'raw_material_item_id' in cols_ri:
                for r in filtered:
                    self.execute_query(
                        "INSERT INTO recipe_ingredients (recipe_id, raw_material_item_id, percentage) VALUES (%s,%s,%s)",
                        (recipe_id, r['raw_material_item_id'], r['percentage']), cursor=cur
                    )
            else:
                cols_items = set(self._get_existing_columns("recipe_items", cursor=cur))
                if filtered and 'component_item_id' in filtered[0] and 'component_item_id' in cols_items:
                    for r in filtered:
                        self.execute_query(
                            "INSERT INTO recipe_items (recipe_id, component_item_id, quantity) VALUES (%s,%s,%s)",
                            (recipe_id, r['component_item_id'], r['quantity']), cursor=cur
                        )

            # لاگ اختیاری
            try:
                self._log_atomic(cur, created_by, 'SAVE_RECIPE',
                                f"product={product_name}, version={new_version}, code={calc_code}, id={recipe_id}")
            except Exception:
                pass

            _trace(f"Saved recipe id={recipe_id} code={calc_code} part={part_type} items={len(filtered)}")
            return recipe_id
        
            

                
# این دو متد جدید را به کلاس DB اضافه کنید
    def get_available_bulk_products(self):
        """تمام بچ‌های محصول فله که تولید شده و هنوز مصرف یا تحویل نشده‌اند را برمی‌گرداند."""
        query = """
            SELECT id, product_name, production_batch_no, quantity, expiry_date 
            FROM production_deliveries
            WHERE status = 'تولید شده' AND quantity > 0.001
            ORDER BY id ASC;
        """
        return self.execute_query(query)

    def consume_bulk_product(self, delivery_id: int, qty_to_consume: float, user_id: int):
        """مقداری از یک بچ محصول فله را کسر می‌کند (معمولا در فرآیند بسته‌بندی)."""
        with self.transaction() as cur:
            # ابتدا رکورد را برای آپدیت قفل می‌کنیم تا از برداشت همزمان جلوگیری شود
            cur.execute("SELECT quantity FROM production_deliveries WHERE id = %s AND status = 'تولید شده' FOR UPDATE", (delivery_id,))
            current_record = cur.fetchone()
            if not current_record:
                raise ValueError("این بچ تولیدی یافت نشد یا وضعیت آن دیگر 'تولید شده' نیست.")
            
            current_qty = current_record['quantity']
            if qty_to_consume > current_qty:
                raise ValueError(f"مقدار مصرفی ({qty_to_consume}) از موجودی بچ ({current_qty}) بیشتر است.")

            new_qty = current_qty - qty_to_consume
            # اگر تمام موجودی مصرف شد، وضعیت را تغییر می‌دهیم
            new_status = 'مصرف شده' if new_qty < 0.001 else 'تولید شده'
            
            cur.execute(
                "UPDATE production_deliveries SET quantity = %s, status = %s WHERE id = %s",
                (new_qty, new_status, delivery_id)
            )
            self._log_atomic(cur, user_id, 'CONSUME_BULK', f"Consumed {qty_to_consume} from delivery_id {delivery_id}")
                        
                                
    # BEGIN REWRITE: DB.create_delivery_request
    def create_delivery_request(self, product_item_id: int, batch_no: str, quantity: float,
                                expiry_date: str | None, supervisor_user_id: int,
                                production_order_id: int | None = None):
        """
        ثبت «درخواست تحویل از تولید به انبار» با جلوگیری از دوباره‌درخواست‌کردن بیش از موجودی.
        - مقدار درخواستی نسبت به موجودی فعلیِ کف تولید و مجموع درخواست‌های «در صف» برای همان کالا/بچ سنجیده می‌شود.
        - در صورت کافی نبودن باقیمانده، خطای خوانا برمی‌گرداند.
        - رکورد مستقیماً با وضعیت «در انتظار تایید انبار» درج می‌شود تا رزرو به‌صورت اتمیک انجام شود.
        - خروجی: شناسه‌ی رکورد production_deliveries
        """
        # اعتبارسنجی اولیه
        if quantity is None or float(quantity) <= 0:
            raise ValueError("مقدار درخواست باید بیشتر از صفر باشد.")
        if not product_item_id or not batch_no:
            raise ValueError("شناسه کالا و شماره بچ الزامی است.")

        with self.transaction() as cur:
            # 1) لوکیشن «Production»
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("لوکیشن 'Production' تعریف نشده است.")

            # 2) موجودی فعلیِ این کالا/بچ در کف تولید (قفل برای جلوگیری از ثبت همزمان)
            cur.execute(
                """
                SELECT COALESCE(qty,0) AS qty
                FROM stock
                WHERE item_id = %s
                AND location_id = %s
                AND (batch_no IS NOT DISTINCT FROM %s)
                AND (expiry_date IS NOT DISTINCT FROM %s)
                FOR UPDATE
                """,
                (product_item_id, prod_loc_id, batch_no, expiry_date)
            )
            row = cur.fetchone()
            stock_qty = float((row or {}).get('qty', 0.0))
            if stock_qty <= 0:
                raise ValueError("برای این بچ در انبار تولید موجودی ثبت‌شده‌ای وجود ندارد.")

            # 3) مجموع درخواست‌های «در صف» برای همین کالا/بچ
            cur.execute(
                """
                SELECT COALESCE(SUM(quantity), 0) AS qty
                FROM production_deliveries
                WHERE product_item_id = %s
                AND (production_batch_no IS NOT DISTINCT FROM %s)
                AND (expiry_date IS NOT DISTINCT FROM %s)
                AND status IN (%s, %s)
                """,
                (
                    product_item_id, batch_no, expiry_date,
                    TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value,
                    TransactionStatus.PENDING_PRODUCTION_APPROVAL.value  # پوشش داده‌های قدیمی
                )
            )
            pending_qty = float((cur.fetchone() or {}).get('qty', 0.0))

            # 4) ظرفیت باقی‌مانده
            remaining = stock_qty - pending_qty
            req = float(quantity)
            if remaining <= 0:
                raise ValueError("برای این بچ در حال حاضر چیزی برای درخواست باقی نمانده است (همه در صف تایید هستند یا موجودی صفر است).")
            if req - remaining > 1e-9:
                # محدودیت را شفاف بگوییم
                raise ValueError(f"حداکثر مقدار قابل درخواست از این بچ: {remaining:g}")

            # 5) درج رکورد به‌صورت «در انتظار تایید انبار» (اتمیک = رزرو)
            cur.execute(
                """
                INSERT INTO production_deliveries
                    (product_item_id, product_name, production_batch_no, quantity, status,
                    supervisor_user_id, created_at, expiry_date, production_order_id)
                SELECT id, name, %s, %s, %s, %s, NOW(), %s, %s
                FROM items
                WHERE id = %s
                RETURNING id
                """,
                (
                    batch_no, req,
                    TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value,
                    supervisor_user_id, expiry_date, production_order_id,
                    product_item_id
                )
            )
            new_id = cur.fetchone()['id']

            # 6) لاگ و سیگنال اعلان (بدون توقف جریان در صورت خطا)
            try:
                self._log_atomic(
                    cur, supervisor_user_id, 'QUEUE_DELIVERY_REQUEST',
                    f"Queued item_id:{product_item_id}, Batch:{batch_no}, Qty:{req}"
                )
                if hasattr(self, 'signals') and hasattr(self.signals, 'dataChanged'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass

            return new_id
    # END REWRITE: DB.create_delivery_request
        
# در کلاس DB، این متد را جایگزین کنید

    def get_category_value_stats(self):
        """مجموع ارزش ریالی کالاها را به تفکیک دسته‌بندی برمی‌گرداند (در صورت موجود بودن ستون‌های لازم)."""
        from re import fullmatch

        with self.transaction() as cur:
            has_items = self._table_exists('items', cursor=cur)
            has_stock = self._table_exists('stock', cursor=cur)
            has_locations = self._table_exists('locations', cursor=cur)
            has_warehouses = self._table_exists('warehouses', cursor=cur)
            if not (has_items and has_stock and has_locations and has_warehouses):
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:cat_value] skipped reason=missing_tables')
                return []

            try:
                item_cols = set(self._get_existing_columns('items', cursor=cur)) if has_items else set()
            except Exception:
                item_cols = set()
            stock_cols = set(self._get_existing_columns('stock', cursor=cur)) if has_stock else set()
            loc_cols = set(self._get_existing_columns('locations', cursor=cur)) if has_locations else set()
            wh_cols = set(self._get_existing_columns('warehouses', cursor=cur)) if has_warehouses else set()

            category_col = next((c for c in ('category','category_name','reporting_group','group_name','item_category') if c in item_cols), None)
            cost_col = next((c for c in ('cost','unit_cost','standard_cost','avg_cost','average_cost','price','unit_price') if c in item_cols), None)
            if not category_col or not cost_col or not fullmatch(r'[A-Za-z_][A-Za-z0-9_]*', category_col) or not fullmatch(r'[A-Za-z_][A-Za-z0-9_]*', cost_col):
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:cat_value] skipped reason=missing_category_or_cost')
                return []
            if not {'item_id','qty'}.issubset(stock_cols):
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:cat_value] skipped reason=stock_cols')
                return []
            if 'warehouse_id' not in loc_cols or 'name' not in wh_cols:
                if DEBUG_DB_RESOLVE:
                    print('[TRACE:DB:cat_value] skipped reason=location_cols')
                return []

            production_name = PRODUCTION_WAREHOUSE_NAME
            query = f"""
                SELECT
                    i.{category_col} AS category,
                    SUM(s.qty * i.{cost_col}) AS total_value
                FROM stock s
                JOIN items i ON s.item_id = i.id
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE s.qty > 0
                  AND i.{cost_col} > 0
                  AND w.name <> %s
                GROUP BY i.{category_col}
                HAVING SUM(s.qty * i.{cost_col}) > 0
                ORDER BY i.{category_col}
            """

            rows = self.execute_query(query, (production_name,), cursor=cur) or []
            if DEBUG_DB_RESOLVE:
                print(f"[TRACE:DB:cat_value] rows={len(rows)} category_col={category_col} cost_col={cost_col}")
            return rows

    def get_item_details(self, item_id: int):
        """جزئیات کامل یک کالا، شامل تمام فیلدهای جدید را برمی‌گرداند."""
        query = """
            SELECT 
                i.id, i.name, i.category, i.unit_id, i.cost, i.min_qty, i.max_qty, 
                i.supplier, i.ent_date, i.notes, i.sku, i.is_packed, i.default_loc, 
                i.expiry_lead_days, i.reporting_group, i.is_parent_product,
                i.parent_item_id, -- <<<--- اصلاح کلیدی و نهایی اینجاست
                i.net_weight,
                (w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin) AS location_name
            FROM items i
            LEFT JOIN locations l ON i.default_loc = l.id
            LEFT JOIN warehouses w ON l.warehouse_id = w.id
            WHERE i.id = %s
        """
        return self.execute_query(query, (item_id,), fetch_one=True)

    def get_child_items(self, parent_item_id: int):
        """
        تمام کالاهای فرزند (پک‌ها) برای یک محصول مادر را برمی‌گرداند.
        فقط فرزندانی را برمی‌گرداند که از نوع 'محصول نهایی' باشند.
        خروجی حاوی نام واحد به‌صورت 'unit' است (با JOIN روی جدول units).
        """
        query = """
            SELECT
                i.id,
                i.sku,
                i.name,
                u.name AS unit
            FROM items i
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE i.parent_item_id = %s
            AND i.category = %s
            ORDER BY i.name
        """
        return self.execute_query(query, (parent_item_id, CATEGORY_FINAL_PRODUCT))
    
    def get_pack_children(self, parent_item_id: int):
        """
        پک‌های زیرمجموعهٔ یک محصول مادر را برمی‌گرداند.
        خروجی: list[{'id':int,'name':str,'net_weight':float}]
        """
        rows = self.execute_query(
            """
            SELECT id, name, COALESCE(net_weight,0) AS net_weight
            FROM items
            WHERE parent_item_id = %s
            ORDER BY name
            """,
            (int(parent_item_id),)
        ) or []
        out = []
        for r in rows:
            out.append({'id': int(r['id']), 'name': r['name'], 'net_weight': float(r.get('net_weight') or 0.0)})
        return out
    
    def ensure_daily_inventory_snapshot_schema(self):
        """
        جدول اسنپ‌شاتِ موجودی: روزانه، تجمیع‌شده برای «انبار تولید».
        snapshot_date: تاریخ گزارش (نمایندهٔ موجودی پایان روز قبل)
        warehouse_name: نام انبار تولید (برای استقلال از ID)
        item_id: شناسهٔ قلم
        kind: دسته‌بندی: 'RM' مواد اولیه، 'PKG' بسته‌بندی، 'BULK' محصول فله، 'FG' محصول بسته‌بندی‌شده
        qty_units: مقدار به واحد ثبت (برای FG تعداد پک)
        qty_kg: مقدار به کیلوگرم
        """
        cols = set(self._get_existing_columns("daily_inventory_snapshots"))
        if not cols:
            # ایجاد جدول پایه (سازگار و ساده)
            self.execute_query("""
                CREATE TABLE IF NOT EXISTS daily_inventory_snapshots (
                    snapshot_date DATE NOT NULL,
                    warehouse_name TEXT,
                    item_id INTEGER NOT NULL,
                    kind TEXT NOT NULL,
                    qty_units NUMERIC(18,3) NOT NULL DEFAULT 0,
                    qty_kg    NUMERIC(18,3) NOT NULL DEFAULT 0,
                    created_at TIMESTAMP DEFAULT NOW(),
                    PRIMARY KEY (snapshot_date, warehouse_name, item_id)
                )
            """)
        else:
            # مهاجرت‌های سبک (در صورت نبود ستون‌های جدید)
            if "warehouse_name" not in cols:
                self.execute_query("ALTER TABLE daily_inventory_snapshots ADD COLUMN warehouse_name TEXT")
            if "kind" not in cols:
                self.execute_query("ALTER TABLE daily_inventory_snapshots ADD COLUMN kind TEXT NOT NULL DEFAULT 'RM'")
            if "qty_units" not in cols:
                self.execute_query("ALTER TABLE daily_inventory_snapshots ADD COLUMN qty_units NUMERIC(18,3) NOT NULL DEFAULT 0")
            if "qty_kg" not in cols:
                self.execute_query("ALTER TABLE daily_inventory_snapshots ADD COLUMN qty_kg NUMERIC(18,3) NOT NULL DEFAULT 0")

    
    def get_packaged_output_kg_over_time(self, parent_item_id: int, date_from: str, date_to: str):
        """
        خروجی بسته‌بندی‌شده برحسب کیلوگرم در بازهٔ [date_from, date_to].
        منطق: مجموع(تعداد ثبت‌شده برای هر پک) × net_weight همان پک.
        فرض امن: رکوردهای بسته‌بندیِ نهایی هم در trans با t_type='ورود از تولید' ذخیره می‌شوند.
        خروجی: list[{'pack_id','pack_name','qty_units','net_weight','qty_kg'}] + 'total_kg'
        """
        packs = self.get_pack_children(int(parent_item_id)) or []
        if not packs:
            return {'rows': [], 'total_kg': 0.0}

        pack_ids = [p['id'] for p in packs]
        ph = ",".join(["%s"] * len(pack_ids))
        trans = self.execute_query(
            f"""
            SELECT item_id, SUM(qty) AS qty
            FROM trans
            WHERE status = 'تایید شده'
            AND t_type = 'ورود از تولید'
            AND item_id IN ({ph})
            AND t_date >= %s
            AND t_date < (%s::date + INTERVAL '1 day')
            GROUP BY item_id
            """,
            tuple(pack_ids) + (date_from, date_to)
        ) or []

        id2q = {int(r['item_id']): float(r['qty'] or 0.0) for r in trans}
        rows = []
        total_kg = 0.0
        for p in packs:
            units = float(id2q.get(p['id'], 0.0))
            kg = units * float(p.get('net_weight') or 0.0)
            rows.append({
                'pack_id': p['id'],
                'pack_name': p['name'],
                'qty_units': units,
                'net_weight': float(p.get('net_weight') or 0.0),
                'qty_kg': kg
            })
            total_kg += kg
        rows.sort(key=lambda x: x['pack_name'])
        return {'rows': rows, 'total_kg': total_kg}
    
    # --- [DB] کنار متدهای اسنپ‌شات اضافه کن ---
    def has_inventory_snapshot(self, snap_date: str) -> bool:
        cols = set(self._get_existing_columns("inventory_daily_snapshot"))
        if not {"snap_date","item_id","warehouse_id","qty_kg"}.issubset(cols):
            return False
        row = self.execute_query("SELECT 1 FROM inventory_daily_snapshot WHERE snap_date=%s LIMIT 1",
                                (snap_date,), fetch_one=True)
        return bool(row)
    
    def ensure_inventory_snapshot_schema(self):
        """
        جدول سبک اسنپ‌شات روزانه را تضمین/مهاجرت می‌کند.
        اگر جدول از قبل باشد ولی ستون‌های جدید (kind/qty_units/qty_kg/warehouse_id) را نداشته باشد،
        خودش با ALTER اضافه می‌کند. فقط مقادیر مقداری ذخیره می‌شود.
        """
        # 1) اگر اصلاً جدول نبود: کامل بساز
        cols = set(self._get_existing_columns("inventory_daily_snapshot"))
        if not cols:
            create_sql = """
                CREATE TABLE IF NOT EXISTS inventory_daily_snapshot (
                    snap_date     DATE            NOT NULL,
                    warehouse_id  INTEGER         NOT NULL,
                    item_id       INTEGER         NOT NULL,
                    kind          TEXT            NOT NULL,
                    qty_units     NUMERIC(18,3)   NOT NULL DEFAULT 0,
                    qty_kg        NUMERIC(18,3)   NOT NULL DEFAULT 0,
                    PRIMARY KEY (snap_date, warehouse_id, item_id)
                );
            """
            idx1 = "CREATE INDEX IF NOT EXISTS idx_inv_snap_kind ON inventory_daily_snapshot (snap_date, kind);"
            idx2 = "CREATE INDEX IF NOT EXISTS idx_inv_snap_wh   ON inventory_daily_snapshot (warehouse_id);"
            with self.transaction() as cur:
                self.execute_query(create_sql, cursor=cur)
                self.execute_query(idx1, cursor=cur)
                self.execute_query(idx2, cursor=cur)
            return

        # 2) جدول هست → مهاجرت‌های ستونی سبک
        def _add(col_sql):
            try:
                self.execute_query(col_sql)
            except Exception:
                pass  # اگر قبلاً اضافه شده بود، مشکلی نیست

        if "snap_date" not in cols:
            _add("ALTER TABLE inventory_daily_snapshot ADD COLUMN snap_date DATE NOT NULL DEFAULT CURRENT_DATE")
        if "warehouse_id" not in cols:
            _add("ALTER TABLE inventory_daily_snapshot ADD COLUMN warehouse_id INTEGER NOT NULL DEFAULT 0")
        if "item_id" not in cols:
            _add("ALTER TABLE inventory_daily_snapshot ADD COLUMN item_id INTEGER NOT NULL DEFAULT 0")
        if "kind" not in cols:
            _add("ALTER TABLE inventory_daily_snapshot ADD COLUMN kind TEXT NOT NULL DEFAULT 'RM'")
        if "qty_units" not in cols:
            _add("ALTER TABLE inventory_daily_snapshot ADD COLUMN qty_units NUMERIC(18,3) NOT NULL DEFAULT 0")
        if "qty_kg" not in cols:
            _add("ALTER TABLE inventory_daily_snapshot ADD COLUMN qty_kg NUMERIC(18,3) NOT NULL DEFAULT 0")

        # 3) ایندکس‌ها (بدون حساسیت به وجود قبلی)
        try:
            self.execute_query("CREATE INDEX IF NOT EXISTS idx_inv_snap_kind ON inventory_daily_snapshot (snap_date, kind)")
            self.execute_query("CREATE INDEX IF NOT EXISTS idx_inv_snap_wh   ON inventory_daily_snapshot (warehouse_id)")
        except Exception:
            pass

    
    def get_inventory_snapshot_kg(self, as_of_date: str, kind: str, warehouse_name: str = None):
        """
        خواندن فقط از جدول inventory_daily_snapshot.
        اگر warehouse_name داده شود، فقط همان انبار فیلتر می‌شود؛
        وگرنه مجموع همهٔ انبارهای تولید را می‌دهد.
        kind: 'RM' | 'PKG' | 'BULK' | 'FG' (همچنین معادل‌های فارسی/انگلیسی پذیرفته می‌شود)
        """
        # --- نگاشت ورودی به کد استاندارد ---
        k = (kind or "").strip().lower()
        mapping = {
            'rm': 'RM', 'raw': 'RM', 'مواد اولیه': 'RM',
            'pkg': 'PKG', 'packaging': 'PKG', 'لوازم بسته‌بندی': 'PKG', 'لوازم بسته بندی': 'PKG',
            'bulk': 'BULK', 'محصول فله': 'BULK', 'محصولات فله': 'BULK',
            'fg': 'FG', 'finished': 'FG',
            'محصول بسته‌بندی‌شده': 'FG', 'محصولات بسته‌بندی‌شده': 'FG',
            'محصول بسته بندی شده': 'FG', 'محصولات بسته بندی شده': 'FG',
        }
        kind_code = mapping.get(k, (kind.upper() if kind else 'RM'))
        if kind_code not in ('RM', 'PKG', 'BULK', 'FG'):
            kind_code = 'RM'

        # --- وجود اسنپ‌شات؟ ---
        if not self.has_inventory_snapshot(as_of_date):
            return {"rows": [], "total_kg": 0.0, "snapshot_found": False}

        snap_cols = set(self._get_existing_columns("inventory_daily_snapshot"))
        wh_cols   = set(self._get_existing_columns("warehouses"))
        if not {"snap_date","warehouse_id","item_id","kind","qty_units","qty_kg"}.issubset(snap_cols):
            return {"rows": [], "total_kg": 0.0, "snapshot_found": False}

        # --- تعیین لیست انبارها ---
        wh_ids = []
        if warehouse_name and {"id","name"}.issubset(wh_cols):
            w = self.execute_query("SELECT id FROM warehouses WHERE name=%s", (warehouse_name,), fetch_one=True)
            if w:
                wh_ids = [int(w["id"])]
        if not wh_ids:
            # همهٔ انبارهای تولید (کلیدواژه‌ها)
            keys = ["Production", "کارگاه", "تولید", "Workshop", "مواد اولیه", "محصولات فله", "لوازم بسته‌بندی", "محصولات بسته‌بندی"]
            like = " OR ".join(["name ILIKE %s"] * len(keys))
            rows = self.execute_query(f"SELECT id FROM warehouses WHERE {like}", tuple([f"%{x}%" for x in keys])) or []
            wh_ids = [int(r["id"]) for r in rows]

        if not wh_ids:
            return {"rows": [], "total_kg": 0.0, "snapshot_found": True}

        # --- جمع‌زدن از اسنپ‌شات ---
        ph_wh = ",".join(["%s"] * len(wh_ids))
        rows = self.execute_query(
            f"""
            SELECT s.item_id, SUM(s.qty_units) AS qty_units, SUM(s.qty_kg) AS qty_kg
            FROM inventory_daily_snapshot s
            WHERE s.snap_date=%s AND s.kind=%s AND s.warehouse_id IN ({ph_wh})
            GROUP BY s.item_id
            """,
            tuple([as_of_date, kind_code] + wh_ids)
        ) or []

        if not rows:
            return {"rows": [], "total_kg": 0.0, "snapshot_found": True}

        ids = [int(r["item_id"]) for r in rows]
        ph  = ",".join(["%s"] * len(ids))
        items = self.execute_query(f"SELECT id,name FROM items WHERE id IN ({ph})", tuple(ids)) or []
        id2name = {int(r["id"]): r["name"] for r in items}

        out, total = [], 0.0
        for r in rows:
            iid = int(r["item_id"])
            q_u = float(r.get("qty_units") or 0.0)
            q_k = float(r.get("qty_kg") or 0.0)
            out.append({"item_id": iid, "name": id2name.get(iid, ""), "qty_units": q_u, "qty_kg": q_k})
            total += q_k

        out.sort(key=lambda x: x["name"])
        return {"rows": out, "total_kg": total, "snapshot_found": True}
    
        
    # --- [DB] کنار متد بالا اضافه کن ---
    def materialize_snapshot_for_date(self, snap_date):
        """
        اسنپ‌شات روزانه برای تاریخ snap_date را ثبت/به‌روزرسانی می‌کند.
        منبع داده: همان چیزی که صفحه «موجودی کف کارگاه» نشان می‌دهد:
                get_stock_for_warehouse(نام_انبار_تولید)
        نکته: snap_date نمایندهٔ «موجودی پایان روز قبل» است (ساده و پایدار).
        """
        import datetime as _dt
        if isinstance(snap_date, str):
            snap_date = _dt.datetime.strptime(snap_date, "%Y-%m-%d").date()

        self.ensure_inventory_snapshot_schema()

        prods = self.list_production_warehouses()  # همه انبارهای تولید
        if not prods:
            return False

        # پاک‌سازی اسنپ‌شات قدیمی همان روز (برای درج دوباره)
        with self.transaction() as cur:
            self.execute_query("DELETE FROM inventory_daily_snapshot WHERE snap_date=%s", (snap_date,), cursor=cur)

            for wh in prods:
                wh_id, wh_name = int(wh['id']), wh['name']
                # همان منبعِ صفحهٔ «موجودی کف کارگاه»
                rows = self.get_stock_for_warehouse(wh_name) or []

                # تجمیع بر item_id و نوع
                agg = {}
                for r in rows:
                    iid = int(r['item_id'])
                    cat = (r.get('category') or '').strip()
                    # نگاشت دسته به kind
                    if cat == 'مواد اولیه':
                        kind = 'RM'
                    elif cat == 'لوازم بسته‌بندی':
                        kind = 'PKG'
                    elif cat == 'محصول فله':
                        kind = 'BULK'
                    else:
                        # بقیه در این صفحه «محصول نهایی بسته‌بندی‌شده» هستند
                        kind = 'FG'

                    qty_units = float(r.get('total_qty') or 0.0)  # برای FG = تعداد پک
                    # برای FG تبدیل به کیلو با وزن خالص هر پک (اگر ستونش در items موجود است)
                    if kind == 'FG':
                        meta = self.execute_query("SELECT COALESCE(net_weight,0) AS nw FROM items WHERE id=%s",
                                                (iid,), fetch_one=True) or {'nw': 0}
                        qty_kg = qty_units * float(meta['nw'] or 0.0)
                    else:
                        qty_kg = qty_units  # مواد اولیه/بسته‌بندی/فله در همین صفحه مقداری هستند

                    key = (iid, kind)
                    prev = agg.get(key, (0.0, 0.0))
                    agg[key] = (prev[0] + qty_units, prev[1] + qty_kg)

                # درج اقلام تجمیع‌شده
                for (iid, kind), (q_units, q_kg) in agg.items():
                    self.execute_query(
                        "INSERT INTO inventory_daily_snapshot (snap_date, warehouse_id, item_id, kind, qty_units, qty_kg) "
                        "VALUES (%s,%s,%s,%s,%s,%s) "
                        "ON CONFLICT (snap_date, warehouse_id, item_id) DO UPDATE SET qty_units=EXCLUDED.qty_units, qty_kg=EXCLUDED.qty_kg",
                        (snap_date, wh_id, iid, kind, q_units, q_kg),
                        cursor=cur
                    )
        return True
                
    # --- [DB] بعد از def get_stock_for_warehouse(self, warehouse_name: str): ---
    def list_production_warehouses(self):
        """
        لیست تمام انبارهایی که «تولید/کارگاه» هستند.
        معیار: نام انبار یکی از کلیدواژه‌ها باشد (Production/کارگاه/تولید/Workshop) یا
        برابر با ثابت PRODUCTION_WAREHOUSE_NAME (اگر در فایل تعریف شده).
        خروجی: لیستی از دیکشنری‌ها: [{'id':1,'name':'Production'}, ...]
        """
        keys = ["Production", "کارگاه", "تولید", "Workshop"]
        try:
            # اگر ثابت‌ها تعریف شده باشند، به ابتدای کلیدواژه‌ها اضافه کن
            if 'PRODUCTION_WAREHOUSE_NAME' in globals():
                keys = [globals()['PRODUCTION_WAREHOUSE_NAME']] + keys
        except Exception:
            pass

        wh_cols = set(self._get_existing_columns("warehouses"))
        if not {"id","name"}.issubset(wh_cols):
            return []
        like_sql = " OR ".join(["name ILIKE %s"] * len(keys))
        params   = tuple([f"%{k}%" for k in keys])
        rows = self.execute_query(f"SELECT id,name FROM warehouses WHERE {like_sql} ORDER BY id", params) or []
        # یکتا و مرتب
        seen, out = set(), []
        for r in rows:
            if r['id'] in seen: 
                continue
            seen.add(r['id']); out.append({'id': int(r['id']), 'name': r['name']})
        return out

    
    def detect_workshop_location_id(self):
        """
        شناسهٔ لوکیشن «کارگاه/تولید» را پیدا می‌کند؛ اگر پیدا نشد None.
        بر اساس جدول locations(name).
        """
        try:
            loc_cols = set(self._get_existing_columns("locations"))
            if "id" not in loc_cols or "name" not in loc_cols:
                return None
            keys = ["کارگاه", "تولید", "Production", "Workshop", "Line", "خط تولید"]
            like_sql = " OR ".join(["name ILIKE %s"] * len(keys))
            params = tuple([f"%{k}%" for k in keys])
            rows = self.execute_query(f"SELECT id FROM locations WHERE {like_sql} ORDER BY id LIMIT 1", params) or []
            if rows:
                return int(rows[0]["id"])
        except Exception:
            pass
        return None
    
    def detect_production_location_ids(self):
        """
        لیست ID لوکیشن‌های «انبار تولید/کارگاه» را برمی‌گرداند.
        اولویت کشف:
        1) warehouses.name شامل کارگاه/تولید/Production/Workshop → همهٔ locations آن
        2) از روی تراکنش‌های تیپیک تولید: dst_loc برای 'ورود از تولید' و src_loc برای 'مصرف'
        3) اگر هیچ نبود: لیست خالی
        """
        out = []

        # 1) از جدول انبارها
        wh_cols = set(self._get_existing_columns("warehouses"))
        loc_cols = set(self._get_existing_columns("locations"))
        if {"id","name"}.issubset(wh_cols) and {"id","warehouse_id"}.issubset(loc_cols):
            keys = ("کارگاه", "تولید", "Production", "Workshop")
            like = " OR ".join(["name ILIKE %s"] * len(keys))
            rows = self.execute_query(f"SELECT id,name FROM warehouses WHERE {like} ORDER BY id LIMIT 1",
                                    tuple([f"%{k}%" for k in keys])) or []
            if rows:
                wh_id = int(rows[0]["id"])
                locs = self.execute_query("SELECT id FROM locations WHERE warehouse_id=%s ORDER BY id", (wh_id,)) or []
                out = [int(r["id"]) for r in locs]

        if out:
            return out

        # 2) از روی الگوی تراکنش‌ها
        trans_cols = set(self._get_existing_columns("trans"))
        if {"src_loc","dst_loc","t_type"}.issubset(trans_cols):
            # dst_loc های رایج برای «ورود از تولید»
            prod_in = self.execute_query(
                "SELECT dst_loc, COUNT(*) c FROM trans WHERE t_type IN ('ورود از تولید','ورود از توليد','PROD_IN') "
                "GROUP BY dst_loc ORDER BY c DESC LIMIT 5"
            ) or []
            # src_loc های رایج برای «مصرف مواد اولیه/بسته‌بندی»
            cons = self.execute_query(
                "SELECT src_loc, COUNT(*) c FROM trans WHERE t_type IN ('مصرف مواد اولیه','مصرف بسته بندی','CONSUME') "
                "GROUP BY src_loc ORDER BY c DESC LIMIT 5"
            ) or []
            out = list({int(r["dst_loc"]) for r in prod_in if r.get("dst_loc") is not None}
                    | {int(r["src_loc"]) for r in cons if r.get("src_loc") is not None})
        return out
    
    def _compute_balances_for_locations(self, as_of_date: str, location_ids: list, item_ids: list):
        """
        موجودی پایانِ روز (تا قبل از as_of_date+1) برای item_ids در لوکیشن‌های داده‌شده.
        خروجی: dict[item_id] = qty_units
        """
        if not item_ids:
            return {}
        trans_cols = set(self._get_existing_columns("trans"))
        ph_items = ",".join(["%s"] * len(item_ids))
        params_tail = (as_of_date,)

        # ورودی/خروجی به‌ازای src/dst
        if {"src_loc","dst_loc"}.issubset(trans_cols) and location_ids:
            ph_locs = ",".join(["%s"] * len(location_ids))
            sql = f"""
                SELECT item_id,
                    SUM(CASE WHEN dst_loc IN ({ph_locs}) THEN qty ELSE 0 END)
                    - SUM(CASE WHEN src_loc IN ({ph_locs}) THEN qty ELSE 0 END) AS qty
                FROM trans
                WHERE item_id IN ({ph_items})
                AND t_date < (%s::date + INTERVAL '1 day')
                GROUP BY item_id
            """
            params = tuple(location_ids) + tuple(location_ids) + tuple(item_ids) + params_tail
            rows = self.execute_query(sql, params) or []
            return {int(r["item_id"]): float(r["qty"] or 0.0) for r in rows}

        # فقط loc_id
        if "loc_id" in trans_cols and location_ids:
            ph_locs = ",".join(["%s"] * len(location_ids))
            sql = f"""
                SELECT item_id, SUM(qty) AS qty
                FROM trans
                WHERE item_id IN ({ph_items})
                AND COALESCE(loc_id,0) IN ({ph_locs})
                AND t_date < (%s::date + INTERVAL '1 day')
                GROUP BY item_id
            """
            params = tuple(item_ids) + tuple(location_ids) + params_tail
            rows = self.execute_query(sql, params) or []
            return {int(r["item_id"]): float(r["qty"] or 0.0) for r in rows}

        # مسیر پشتیبان: کل سیستم
        sql = f"""
            SELECT item_id, SUM(qty) AS qty
            FROM trans
            WHERE item_id IN ({ph_items})
            AND t_date < (%s::date + INTERVAL '1 day')
            GROUP BY item_id
        """
        rows = self.execute_query(sql, tuple(item_ids) + params_tail) or []
        return {int(r["item_id"]): float(r["qty"] or 0.0) for r in rows}
    
    def build_daily_inventory_snapshot(self, snapshot_date: str, warehouse_name: str = None):
        """
        اسنپ‌شات روزانه برای snapshot_date را می‌سازد.
        توجه: محتوای این اسنپ‌شات «موجودی پایانِ روز قبل» است.
        مثال: اگر snapshot_date = امروز، محاسبه تا پایان دیروز انجام می‌شود.
        """
        import datetime as dt

        self.ensure_daily_inventory_snapshot_schema()

        # تاریخ هدف برای محاسبه (روز قبل)
        d = dt.datetime.fromisoformat(snapshot_date).date()
        prev = (d - dt.timedelta(days=1)).isoformat()

        # کشف دقیق لوکیشن‌های تولید
        prod_loc_ids = self.detect_production_location_ids()

        # انتخاب اقلام هر دسته
        item_cols = set(self._get_existing_columns("items"))
        # مواد اولیه
        if "is_raw_material" in item_cols:
            rm_items = self.execute_query("SELECT id, name FROM items WHERE is_raw_material=TRUE") or []
        elif "category" in item_cols:
            rm_items = self.execute_query(
                "SELECT id, name FROM items WHERE category IN ('RAW','Raw','raw','مواد اولیه','RM')"
            ) or []
        else:
            rm_items = self.execute_query(
                "SELECT id, name FROM items WHERE parent_item_id IS NULL AND (is_parent_product IS NULL OR is_parent_product=FALSE)"
            ) or []
        # بسته‌بندی
        if "category" in item_cols:
            pkg_items = self.execute_query(
                "SELECT id, name FROM items WHERE category IN ('PACKAGING','Packaging','بسته بندی','PACK')"
            ) or []
        else:
            pkg_items = []
        # محصول فله (مادر)
        bulk_items = self.execute_query("SELECT id, name FROM items WHERE is_parent_product = TRUE") or []
        # محصول بسته‌بندی‌شده (زیرمجموعه)
        fg_items = self.execute_query(
            "SELECT id, name, COALESCE(net_weight,0) AS net_weight FROM items WHERE parent_item_id IS NOT NULL"
        ) or []

        # محاسبهٔ موجودی پایان روز قبل
        def _bal(items):
            ids = [int(r["id"]) for r in items]
            return self._compute_balances_for_locations(prev, prod_loc_ids, ids) if ids else {}

        rm_bal   = _bal(rm_items)
        pkg_bal  = _bal(pkg_items)
        bulk_bal = _bal(bulk_items)
        fg_bal   = _bal(fg_items)

        # پاک‌سازی اسنپ‌شات همان روز (برای درج دوباره)
        self.execute_query("DELETE FROM daily_inventory_snapshots WHERE snapshot_date = %s", (snapshot_date,))

        # درج داده‌ها
        def _ins(rows, kind, with_weight=False):
            for r in rows:
                iid = int(r["id"])
                units = float((rm_bal if kind=="RM" else pkg_bal if kind=="PKG" else bulk_bal if kind=="BULK" else fg_bal).get(iid, 0.0))
                if with_weight:
                    nw = float(r.get("net_weight") or 0.0)
                    kg = units * nw
                else:
                    kg = units
                self.execute_query(
                    "INSERT INTO daily_inventory_snapshots (snapshot_date, warehouse_name, item_id, kind, qty_units, qty_kg)"
                    " VALUES (%s,%s,%s,%s,%s,%s)",
                    (snapshot_date, warehouse_name or "WORKSHOP", iid, kind, units, kg)
                )

        _ins(rm_items,   "RM",   with_weight=False)
        _ins(pkg_items,  "PKG",  with_weight=False)
        _ins(bulk_items, "BULK", with_weight=False)
        _ins(fg_items,   "FG",   with_weight=True)

        return True

    
    def get_location_ids_for_warehouse(self, warehouse_name: str):
        """
        لیست ID تمام لوکیشن‌های یک انبار (به‌نام داده‌شده) را برمی‌گرداند.
        اگر جدول‌ها/ستون‌ها موجود نباشند یا چیزی پیدا نشود، لیست خالی می‌دهد.
        """
        try:
            loc_cols = set(self._get_existing_columns("locations"))
            wh_cols  = set(self._get_existing_columns("warehouses"))
            if not {"id","warehouse_id"}.issubset(loc_cols) or "id" not in wh_cols or "name" not in wh_cols:
                return []
            rows = self.execute_query(
                """
                SELECT l.id
                FROM locations l
                JOIN warehouses w ON w.id = l.warehouse_id
                WHERE w.name = %s
                ORDER BY l.id
                """,
                (warehouse_name,)
            ) or []
            return [int(r["id"]) for r in rows]
        except Exception:
            return []

    
    
    
    # --- NEW: DB.validate_child_pack_rules ---
    def validate_child_pack_rules(self, child_sku: str, parent_id: int, net_weight: float) -> None:
        """
        قوانین اجباری برای «پکِ زیرمجموعه»:
        - وزن خالص باید > 0 باشد.
        - اگر SKU مادر وجود دارد، SKU پک باید با "<SKU مادر>-" شروع شود.
        در صورت نقض، ValueError می‌اندازد.
        """
        # فقط وقتی زیرمجموعه است
        if not parent_id:
            return

        # 1) وزن خالص
        try:
            nw = float(net_weight if net_weight is not None else 0)
        except (TypeError, ValueError):
            nw = 0.0
        if nw <= 0:
            raise ValueError("وزن خالص پک باید بیشتر از صفر باشد.")

        # 2) پیشوند SKU = "<parent_sku>-"
        row = self.execute_query("SELECT sku FROM items WHERE id=%s", (int(parent_id),), fetch_one=True)
        parent_sku = (row or {}).get('sku') if isinstance(row, dict) else (row[0] if row else None)
        parent_sku = (parent_sku or "").strip()
        if parent_sku:
            expected_prefix = f"{parent_sku}-"
            child_sku = (child_sku or "").strip()
            if not child_sku or not child_sku.startswith(expected_prefix):
                raise ValueError(f"کد SKU پک باید با «{expected_prefix}» شروع شود (مثال: {expected_prefix}01).")

    
    # BEGIN REWRITE: DB.add_item_with_locations
    def add_item_with_locations(self, item_data: dict, stock_data: list, user_id: int, ignore_batch_check: bool = False):
        """
        ایجاد آیتم جدید به‌همراه ثبت موجودی اولیه در لوکیشن‌ها.
        - اگر کالا «مادر» باشد:
            * دو جزئی: فقط پارت‌های A و B به‌صورت «محصول فله» و آیتم‌های ریشه ساخته می‌شوند.
            * تک‌جزئی: فقط پارت P به‌صورت «محصول فله» و آیتمِ ریشه ساخته می‌شود.
        - برای موجودی‌های اولیه، هم در stock ثبت می‌شود و هم سند trans ایجاد می‌گردد.
        """
        import re, datetime as dt

        # دسته‌های مورد استفاده (با فالبک اگر کانستنت‌ها نبودند)
        try:
            CATEGORY_BULK = CATEGORY_BULK_PRODUCT
        except NameError:
            CATEGORY_BULK = 'محصول فله'
        BULK_UNIT_NAME = 'کیلوگرم'

        # --- نرمال‌سازی نام ---
        item_name = (item_data.get('name') or '').strip()
        item_name = re.sub(r'\s+', ' ', item_name)
        if not item_name:
            raise ValueError("نام کالا نمی‌تواند خالی باشد.")
        item_data['name'] = item_name

        # --- نرمال‌سازی SKU ---
        sku_value = (item_data.get('sku') or '').strip() or None

        # --- بررسی یکتایی نام ریشه و SKU ---
        parent_value = item_data.get('parent_item_id')
        if parent_value is None:
            parent_value = item_data.get('parent_id')

        with self.transaction() as cur:
            existing_cols = set(self._get_existing_columns('items', cursor=cur))
            parent_col = None
            if 'parent_item_id' in existing_cols:
                parent_col = 'parent_item_id'
            elif 'parent_id' in existing_cols:
                parent_col = 'parent_id'

            ident_pattern = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')
            if parent_col and not ident_pattern.fullmatch(parent_col):
                parent_col = None

            parent_filter = f" AND i.{parent_col} IS NULL" if parent_col else ""
            if 'sku' in existing_cols:
                sku_exists_expr = """EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE in_norm.nsku IS NOT NULL
                          AND i.sku IS NOT NULL
                          AND TRIM(i.sku) = TRIM(in_norm.nsku)
                    ) AS sku_exists"""
            else:
                sku_exists_expr = "FALSE AS sku_exists"

            dup_check_sql = f"""
                WITH in_norm AS (
                    SELECT
                        LOWER(REPLACE(REPLACE(%s, E'\‌',''), ' ', '')) AS nname,
                        %s AS nsku
                )
                SELECT
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE 1=1{parent_filter}
                          AND LOWER(REPLACE(REPLACE(i.name, E'\‌',''), ' ', '')) = in_norm.nname
                    ) AS name_exists_root,
                    {sku_exists_expr}
            """

            row = self.execute_query(dup_check_sql, (item_name, sku_value), fetch_one=True, cursor=cur) or {}
            errs = []
            if not parent_value and row.get('name_exists_root'):
                errs.append(f"کالایی با نام «{item_name}» از قبل در سیستم وجود دارد.")
            if sku_value and row.get('sku_exists'):
                errs.append(f"کد کالا (SKU) «{sku_value}» تکراری است.")
            if errs:
                raise ValueError(' '.join(errs))

            def _prepare_insert_pairs(pairs):
                cols = []
                vals = []
                for col, val in pairs:
                    if col in existing_cols and ident_pattern.fullmatch(col):
                        cols.append(col)
                        vals.append(val)
                return cols, vals

            insert_pairs = [
                ('name', item_data.get('name')),
                ('category', item_data.get('category')),
                ('unit_id', item_data.get('unit_id')),
                ('cost', item_data.get('cost')),
                ('min_qty', item_data.get('min_qty')),
                ('max_qty', item_data.get('max_qty')),
                ('supplier', item_data.get('supplier')),
                ('reporting_group', item_data.get('reporting_group')),
                ('ent_date', item_data.get('ent_date')),
                ('expiry_lead_days', item_data.get('expiry_lead_days')),
                ('notes', item_data.get('notes')),
                ('default_loc', item_data.get('default_loc')),
                ('is_packed', item_data.get('is_packed')),
                ('sku', sku_value),
                ('is_parent_product', item_data.get('is_parent_product')),
                ('net_weight', item_data.get('net_weight')),
                ('is_two_component', item_data.get('is_two_component')),
                ('requires_qc', item_data.get('requires_qc')),
            ]
            if parent_col:
                insert_pairs.append((parent_col, parent_value))

            cols, vals = _prepare_insert_pairs(insert_pairs)
            if not cols:
                raise ValueError('جدول items فاقد ستون‌های لازم برای درج آیتم جدید است.')

            placeholders = ', '.join(['%s'] * len(cols))
            insert_sql = f"INSERT INTO items ({', '.join(cols)}) VALUES ({placeholders}) RETURNING id"
            cur.execute(insert_sql, tuple(vals))
            item_id = cur.fetchone()[0]

            if item_data.get('is_parent_product'):
                kg_unit = self.execute_query("SELECT id FROM units WHERE name = %s", (BULK_UNIT_NAME,), fetch_one=True, cursor=cur)
                bulk_unit_id = (kg_unit['id'] if kg_unit else item_data.get('unit_id'))

                def _insert_bulk_part(part_label: str):
                    nm = f"{item_name} - پارت {part_label}"
                    bulk_pairs = [
                        ('name', nm),
                        ('category', CATEGORY_BULK),
                        ('unit_id', bulk_unit_id),
                        ('is_parent_product', False),
                        ('is_two_component', False),
                        ('requires_qc', False),
                    ]
                    if parent_col:
                        bulk_pairs.append((parent_col, None))

                    b_cols, b_vals = _prepare_insert_pairs(bulk_pairs)
                    if not b_cols:
                        return

                    placeholders_local = ', '.join(['%s'] * len(b_cols))
                    bulk_sql = f"INSERT INTO items ({', '.join(b_cols)}) VALUES ({placeholders_local}) ON CONFLICT DO NOTHING"
                    cur.execute(bulk_sql, tuple(b_vals))

                if item_data.get('is_two_component'):
                    _insert_bulk_part('A'); _insert_bulk_part('B')
                else:
                    _insert_bulk_part('P')

            # --- ثبت موجودی اولیه و تراکنش «موجودی اولیه» برای آیتم اصلی ---
            if stock_data:
                for stock_row in stock_data:
                    # استخراج امنِ شناسهٔ لوکیشن از چند کلید ممکن
                    loc_id = (stock_row.get('location_id') or
                            stock_row.get('loc_id') or
                            stock_row.get('locId') or
                            stock_row.get('loc'))
                    if isinstance(loc_id, str):
                        loc_id = loc_id.strip() or None
                        if loc_id and loc_id.isdigit():
                            loc_id = int(loc_id)

                    qty = stock_row.get('qty') or 0
                    batch_no = stock_row.get('batch_no') or stock_row.get('batch') or stock_row.get('lot')
                    expiry_date = stock_row.get('expiry_date')

                    # 1) ثبت/به‌روزرسانی موجودی
                    self._upd_stock(cur=cur, item_id=item_id, location_id=loc_id,
                                    qty_change=qty, batch_no=batch_no, expiry_date=expiry_date,
                                    status='تایید شده')

                    # 2) تراکنش ورود با عنوان «موجودی اولیه»
                    t_no = f"INIT-{item_id}-{int(dt.datetime.now(dt.timezone.utc).timestamp())}"
                    cur.execute(
                        """INSERT INTO trans (item_id, t_type, qty, src_loc, dest_loc, status, batch_no, expiry_date, t_date, t_no)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s)""",
                        (item_id, 'موجودی اولیه', qty, None, loc_id, 'تایید شده', batch_no, expiry_date, t_no)
                    )

            # لاگ سیستمی
            self._log_atomic(cur, user_id, 'ADD_ITEM_WITH_STOCK', f"name={item_data['name']}, id={item_id}")
            return item_id
    # END REWRITE: DB.add_item_with_locations

    # BEGIN REWRITE: DB.update_item_with_locations
    def update_item_with_locations(self, item_id: int, item_data: dict, user_id: int):
        import re
        with self.transaction() as cur:
            rec = self.execute_query(
                "SELECT id, name, parent_item_id, is_parent_product FROM items WHERE id=%s",
                (item_id,), fetch_one=True, cursor=cur
            )
            if not rec:
                raise ValueError("آیتم موردنظر یافت نشد.")

            parent_id_db = rec.get('parent_item_id')
            is_parent_db = bool(rec.get('is_parent_product'))

            # --- دسته‌ها (با فالبک امن) ---
            try:
                CATEGORY_FINAL = CATEGORY_FINAL_PRODUCT
            except NameError:
                CATEGORY_FINAL = 'محصول نهایی'
            try:
                CATEGORY_BULK = CATEGORY_BULK_PRODUCT
            except NameError:
                CATEGORY_BULK = 'محصول فله'

            # --- نرمال‌سازی نام ---
            item_name = (item_data.get('name') or '')
            item_name_normalized = re.sub(r'\s+', ' ', item_name).strip()
            if not item_name_normalized:
                raise ValueError("نام کالا نمی‌تواند خالی باشد.")
            item_data['name'] = item_name_normalized

            # --- نرمال‌سازی SKU ---
            sku_value = (item_data.get('sku') or '').strip() or None

            # --- چک یکتایی طبق حالت (ریشه یا زیرمجموعه) ---
            if parent_id_db:
                dup_check_sql = """
                WITH in_norm AS (
                    SELECT LOWER(REPLACE(REPLACE(%s, E'\u200c',''), ' ', '')) AS nname,
                        NULLIF(TRIM(%s), '') AS nsku,
                        %s::INT AS my_id,
                        %s::INT AS pid
                )
                SELECT
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE i.parent_item_id = in_norm.pid
                        AND LOWER(REPLACE(REPLACE(i.name, E'\u200c',''), ' ', '')) = in_norm.nname
                        AND i.id <> in_norm.my_id
                    ) AS name_exists_under_parent,
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE in_norm.nsku IS NOT NULL
                        AND i.sku IS NOT NULL
                        AND TRIM(i.sku) = in_norm.nsku
                        AND i.id <> in_norm.my_id
                    ) AS sku_exists;
                """
                row = self.execute_query(
                    dup_check_sql, (item_name_normalized, sku_value, item_id, parent_id_db),
                    fetch_one=True, cursor=cur
                ) or {}
                if row.get('name_exists_under_parent'):
                    raise ValueError(f"نام «{item_name_normalized}» در همین محصولِ مادر تکراری است.")
            else:
                dup_check_sql = """
                WITH in_norm AS (
                    SELECT LOWER(REPLACE(REPLACE(%s, E'\u200c',''), ' ', '')) AS nname,
                        NULLIF(TRIM(%s), '') AS nsku,
                        %s::INT AS my_id
                )
                SELECT
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE i.parent_item_id IS NULL
                        AND LOWER(REPLACE(REPLACE(i.name, E'\u200c',''), ' ', '')) = in_norm.nname
                        AND i.id <> in_norm.my_id
                    ) AS name_exists,
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE in_norm.nsku IS NOT NULL
                        AND i.sku IS NOT NULL
                        AND TRIM(i.sku) = in_norm.nsku
                        AND i.id <> in_norm.my_id
                    ) AS sku_exists;
                """
                row = self.execute_query(
                    dup_check_sql, (item_name_normalized, sku_value, item_id),
                    fetch_one=True, cursor=cur
                ) or {}
                if row.get('name_exists'):
                    raise ValueError(f"کالایی با نام «{item_name_normalized}» از قبل در سیستم وجود دارد.")
            if sku_value and row.get('sku_exists'):
                raise ValueError(f"کد کالا (SKU) «{sku_value}» تکراری است.")

            # --- تعیین فیلدها بر اساس نوع رکورد (بسته‌بندی/مادر/عادی) ---
            if parent_id_db:
                # بسته‌بندی زیرمجموعهٔ مادر
                parent = self.execute_query(
                    "SELECT id, is_two_component FROM items WHERE id=%s",
                    (parent_id_db,), fetch_one=True, cursor=cur
                )
                if not parent:
                    raise ValueError("کالای مادر مربوط به این بسته‌بندی یافت نشد.")
                item_data['is_parent_product'] = False
                item_data['is_two_component']  = bool(parent['is_two_component'])
                item_data['category']          = CATEGORY_FINAL
                item_data['is_packed']         = True
            elif is_parent_db:
                # مادر: دسته اجباری = محصول نهایی (طبق منطق فعلی UI)
                item_data['is_parent_product'] = True
                item_data['is_two_component']  = bool(item_data.get('is_two_component', False))
                item_data['category']          = CATEGORY_FINAL
                item_data['is_packed']         = False
            else:
                # آیتم عادی
                item_data['is_parent_product'] = False
                item_data['is_two_component']  = False

            # --- به‌روزرسانی خود آیتم ---
            item_data['id'] = item_id
            self.execute_query("""
                UPDATE items SET 
                    name=%(name)s, category=%(category)s, unit_id=%(unit_id)s, cost=%(cost)s, 
                    min_qty=%(min_qty)s, max_qty=%(max_qty)s, supplier=%(supplier)s, 
                    notes=%(notes)s, sku=%(sku)s, is_packed=%(is_packed)s,
                    default_loc=%(default_loc)s, expiry_lead_days=%(expiry_lead_days)s,
                    reporting_group=%(reporting_group)s, is_parent_product=%(is_parent_product)s,
                    net_weight=%(net_weight)s, is_two_component=%(is_two_component)s, requires_qc=%(requires_qc)s
                WHERE id=%(id)s
            """, {**item_data, 'sku': sku_value}, cursor=cur)

            # --- اگر مادر است: پارت‌های فله را دقیقاً هم‌راستا کن ---
            if (parent_id_db is None) and item_data.get('is_parent_product'):
                # واحد پارت‌های فله: «کیلوگرم» اگر بود؛ وگرنه از unit فعلی
                kg_unit = self.execute_query("SELECT id FROM units WHERE name = %s", ('کیلوگرم',), fetch_one=True, cursor=cur)
                bulk_unit_id = (kg_unit['id'] if kg_unit else item_data.get('unit_id'))
                parent_name  = item_data['name']
                want_two     = bool(item_data.get('is_two_component'))

                def _bulk_name(lbl: str) -> str:
                    return f"{parent_name} - پارت {lbl}"

                def _ensure_bulk(lbl: str):
                    nm = _bulk_name(lbl)
                    self.execute_query(
                        "INSERT INTO items (name, category, unit_id, is_parent_product, parent_item_id, is_two_component, requires_qc) "
                        "VALUES (%s, %s, %s, FALSE, NULL, FALSE, FALSE) "
                        "ON CONFLICT DO NOTHING",
                        (nm, CATEGORY_BULK, bulk_unit_id), cursor=cur
                    )

                def _can_delete(item_row: dict) -> bool:
                    if not item_row:
                        return False
                    iid = item_row['id']
                    st = self.execute_query("SELECT COALESCE(SUM(qty),0) AS q FROM stock WHERE item_id=%s",
                                            (iid,), fetch_one=True, cursor=cur) or {'q': 0}
                    if (st['q'] or 0) != 0:
                        return False
                    used_trans = self.execute_query("SELECT 1 FROM trans WHERE item_id=%s LIMIT 1",
                                                    (iid,), fetch_one=True, cursor=cur)
                    if used_trans:
                        return False
                    used_prod  = self.execute_query("SELECT 1 FROM recipes WHERE produces_item_id=%s LIMIT 1",
                                                    (iid,), fetch_one=True, cursor=cur)
                    used_comp  = self.execute_query("SELECT 1 FROM recipe_components WHERE raw_material_item_id=%s LIMIT 1",
                                                    (iid,), fetch_one=True, cursor=cur)
                    return not (used_prod or used_comp)

                def _delete_if_safe(lbl: str):
                    nm  = _bulk_name(lbl)
                    row = self.execute_query("SELECT id FROM items WHERE name=%s", (nm,), fetch_one=True, cursor=cur)
                    if row and _can_delete(row):
                        self.execute_query("DELETE FROM items WHERE id=%s", (row['id'],), cursor=cur)

                if want_two:
                    _ensure_bulk('A'); _ensure_bulk('B')
                    _delete_if_safe('P')
                else:
                    _ensure_bulk('P')
                    _delete_if_safe('A'); _delete_if_safe('B')

            # --- لاگ ---
            self._log_atomic(cur, user_id, 'EDIT_ITEM', f"name={item_data['name']}, id={item_id}")
    # END REWRITE: DB.update_item_with_locations
            
    def create_new_count_session(self, count_type: str, notes: str, user_id: int) -> int:
            """
            نسخه ۲.۰ (اصلاح منطق انبارداری):
            - اسنپ‌شات موجودی در سطح بچ/لوکیشن گرفته می‌شود تا شمارش دقیق و واقعی باشد.
            - فقط موجودی انبارهای غیرتولیدی در شمارش لحاظ می‌شود.
            """
            with self.transaction() as cur:
                cur.execute(
                    "INSERT INTO inventory_counts (type, notes, created_by, status) VALUES (%s, %s, %s, %s) RETURNING id",
                    (count_type, notes, user_id, 'OPEN')
                )
                count_id = cur.fetchone()['id']

                # کوئری جدید برای گرفتن اسنپ‌شات دقیق از هر بچ در هر لوکیشن
                cur.execute("""
                    SELECT s.item_id, s.location_id, s.batch_no, s.expiry_date, s.qty
                    FROM stock s
                    JOIN locations l ON s.location_id = l.id
                    JOIN warehouses w ON l.warehouse_id = w.id
                    WHERE s.qty > 0 AND w.name != 'Production'
                """)
                stock_snapshot = cur.fetchall()
                
                if not stock_snapshot:
                    raise ValueError("هیچ کالایی با موجودی مثبت در انبارهای اصلی برای شمارش یافت نشد.")

                # آماده‌سازی داده‌ها برای جدول جدید و دقیق
                count_items_data = [
                    (count_id, rec['item_id'], rec['location_id'], rec['batch_no'], rec.get('expiry_date'), rec['qty'])
                    for rec in stock_snapshot
                ]
                
                cur.executemany(
                    """
                    INSERT INTO inventory_count_items 
                        (count_id, item_id, location_id, batch_no, expiry_date, system_qty) 
                    VALUES (%s, %s, %s, %s, %s, %s)
                    """,
                    count_items_data
                )
                
                self._log_atomic(cur, user_id, 'START_INVENTORY_COUNT', f"id={count_id}, type={count_type}, items_snapshot_count={len(stock_snapshot)}")
                
            return count_id
            
# این متد جدید را به کلاس DB اضافه کنید
    def get_count_sessions(self):
        """لیست تمام اسناد انبارگردانی را برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                # --- اصلاح کلیدی در این کوئری انجام شده است ---
                # اتصال c.created_by به u.id به جای u.username
                cur.execute("""
                    SELECT c.id, c.type, c.status, c.created_at, u.username as created_by
                    FROM inventory_counts c
                    LEFT JOIN users u ON c.created_by = u.id
                    ORDER BY c.id DESC
                """)
                return cur.fetchall()
                        
    def get_items_for_count(self, count_id: int):
            """
            نسخه ۲.۰: اطلاعات کامل شمارش را به تفکیک بچ و لوکیشن، به همراه لیبل خوانای لوکیشن برمی‌گرداند.
            این تابع، زیربنای دیالوگ‌های جدید شمارش و بازبینی است.
            """
            with self.transaction() as cur:
                cur.execute("""
                    SELECT 
                        ci.id AS count_item_id,
                        i.id AS item_id,
                        i.name AS item_name,
                        l.id as location_id,
                        w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label,
                        ci.batch_no,
                        ci.expiry_date,
                        ci.system_qty,
                        ci.counted_qty
                    FROM inventory_count_items ci
                    JOIN items i ON i.id = ci.item_id
                    JOIN locations l ON l.id = ci.location_id
                    JOIN warehouses w ON w.id = l.warehouse_id
                    WHERE ci.count_id = %s
                    ORDER BY loc_label, i.name, ci.batch_no
                """, (count_id,))
                return cur.fetchall()
        
        
    def update_counted_quantity(self, count_item_id: int, counted_qty: float):
        """مقدار شمارش شده یک آیتم در یک سند را به‌روزرسانی می‌کند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    "UPDATE inventory_count_items SET counted_qty = %s WHERE id = %s",
                    (counted_qty, count_item_id)
                )
                conn.commit()

    def change_count_status(self, count_id: int, new_status: str):
        """وضعیت یک سند انبارگردانی را تغییر می‌دهد."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    "UPDATE inventory_counts SET status = %s WHERE id = %s",
                    (new_status, count_id)
                )
                conn.commit()
                
# این متد را در کلاس DB با نسخه کامل زیر جایگزین کنید
    def apply_inventory_adjustment(self, item_id: int, counted_qty: float, location_id: int, batch_no: str, reason: str, user_id: int):
        """
        نسخه نهایی: موجودی یک بچ مشخص در یک لوکیشن را اصلاح کرده و سند ثبت می‌کند.
        """
        with self._conn() as conn:
            with conn.cursor() as cur:
                try:
                    # موجودی فعلی بچ مشخص در لوکیشن مشخص
                    cur.execute("SELECT qty FROM stock WHERE item_id = %s AND location_id = %s AND batch_no = %s", (item_id, location_id, batch_no))
                    stock_record = cur.fetchone()
                    system_qty = stock_record['qty'] if stock_record else 0.0

                    adjustment_qty = counted_qty - system_qty

                    if abs(adjustment_qty) < 0.001:
                        return # نیازی به اصلاح نیست

                    # ثبت تراکنش اصلاحی با دلیل و بچ نامبر
                    cur.execute(
                        """INSERT INTO trans (item_id, t_type, t_no, t_date, qty, notes, user_id, status, src_loc, batch_no)
                           VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id""",
                        (item_id, 'اصلاح انبارگردانی', f'ADJ-{item_id}', datetime.now(dt.timezone.utc), 
                         adjustment_qty, reason, user_id, TransactionStatus.APPROVED.value, location_id, batch_no)
                    )
                    trans_id = cur.fetchone()['id']

                    # به‌روزرسانی جدول stock با استفاده از تابع داخلی
                    self._upd_stock(cur, item_id, location_id, adjustment_qty, batch_no)

                    self._log(user_id, 'INVENTORY_ADJUSTMENT', f"trans_id:{trans_id}, item_id:{item_id}, change:{adjustment_qty}, reason:{reason}")
                    
                    conn.commit()

                except (Exception, psycopg2.Error) as e:
                    conn.rollback()
                    raise e                            
            

    # در کلاس DB، این متد را به طور کامل جایگزین کنید

    def void_transaction(self, trans_id_to_void: int, user_id: int) -> TransactionStatus:
        """
        نسخه نهایی و قطعی (V3.5):
        - رفع کامل ابطال «ورود از تولید» با برعکس‌کردن حرکت: کم از مقصد (با نادیده‌گرفتن وضعیت) + افزودن به تولید.
        - حفظ منطق‌های قبلی (لغو حالت‌های Pending، ابطال انتقال، ثبت رکورد ابطال و ...).
        """
        with self.transaction() as cur:
            cur.execute("SELECT * FROM trans WHERE id = %s FOR UPDATE", (trans_id_to_void,))
            orig_trans = cur.fetchone()
            if not orig_trans:
                raise ValueError("تراکنش مورد نظر یافت نشد")

            current_status = orig_trans['status']
            t_type = orig_trans['t_type']

            # --- حالت‌های در انتظار (بدون تغییر) ---
            if current_status in [TransactionStatus.PENDING_PRODUCTION_APPROVAL.value,
                                TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value,
                                TransactionStatus.PENDING_APPROVAL.value]:
                if t_type.startswith('خروج') or t_type == 'برگشت از تولید':
                    self._upd_stock(cur,
                                    orig_trans['item_id'],
                                    orig_trans['src_loc'],
                                    orig_trans['qty'],
                                    orig_trans['batch_no'],
                                    orig_trans.get('expiry_date'))
                notes = orig_trans.get('notes', '')
                if 'برای درخواست #' in notes:
                    try:
                        import re
                        request_id = int(re.search(r'#(\d+)', notes).group(1))
                        cur.execute(
                            "UPDATE material_requests SET status = 'PENDING', notes = %s, processed_by_user_id = NULL, processed_at = NULL WHERE id = %s",
                            ("تراکنش مربوطه توسط انباردار لغو شد. لطفاً مجدداً رسیدگی شود.", request_id)
                        )
                    except (AttributeError, ValueError) as e:
                        print(f"WARNING: Could not revert material_request status from notes. Reason: {e}")
                cur.execute("UPDATE trans SET status = %s WHERE id = %s",
                            (TransactionStatus.CANCELLED.value, trans_id_to_void))
                self._log_atomic(cur, user_id, 'CANCEL_PENDING_TRANS',
                                f"تراکنش در انتظار #{trans_id_to_void} لغو شد")
                return TransactionStatus.CANCELLED

            elif current_status == TransactionStatus.PENDING_VOID_APPROVAL.value:
                cur.execute("UPDATE trans SET status = %s, notes = COALESCE(notes, '') || ' | ' || %s WHERE id = %s",
                            (TransactionStatus.APPROVED.value,
                            f"درخواست ابطال توسط کاربر #{user_id} پس گرفته شد.",
                            trans_id_to_void))
                self._log_atomic(cur, user_id, 'CANCEL_VOID_REQUEST',
                                f"درخواست ابطال برای تراکنش #{trans_id_to_void} لغو شد")
                return TransactionStatus.CANCELLED

            # --- اجرای ابطال برای تراکنش‌های تایید شده ---
            elif current_status == TransactionStatus.APPROVED.value:
                # --- NEW: برای «ورود از تولید» هم مثل «خروج به تولید»، درخواستِ تأیید ابطال ثبت شود ---
                # تشخیص امنِ ورود از تولید: نام نوع تراکنش + مبدأ = انبار تولید (اگر قابل کشف باشد)
                is_entry_from_production = False
                try:
                    prod_loc_id = self.get_production_floor_location()
                except Exception:
                    prod_loc_id = None

                t_type_norm = str(t_type or "").strip().lower()
                if (
                    t_type == 'ورود از تولید' or
                    t_type_norm in ('entry from production','entry_from_production','from production to warehouse')
                    or (prod_loc_id and orig_trans.get('src_loc') == prod_loc_id)
                ):
                    # مثل قبل: فقط وضعیت را «در انتظار تایید ابطال» بکن، هیچ موجودی را دست نزن
                    cur.execute(
                        "UPDATE trans SET status = %s, notes = COALESCE(notes,'') || ' | ' || %s WHERE id = %s",
                        (TransactionStatus.PENDING_VOID_APPROVAL.value,
                        f"درخواست ابطال ثبت شد توسط کاربر #{user_id}",
                        trans_id_to_void)
                    )
                    # برای لاگ داخلی
                    try:
                        self._log_atomic(cur, user_id, 'REQUEST_VOID_PROD_ENTRY',
                                        f"درخواست ابطال برای «ورود از تولید» #{trans_id_to_void}")
                    except Exception:
                        pass
                    return TransactionStatus.PENDING_VOID_APPROVAL
                # --- END NEW ---

                
                if t_type.startswith('ابطال'):
                    raise ValueError("امکان ابطال یک تراکنش 'ابطال' وجود ندارد.")

                # ابطال خروج به تولید = همان فرآیند درخواست ابطال (بدون تغییر)
                if t_type == 'خروج به تولید':
                    cur.execute("UPDATE trans SET status = %s WHERE id = %s",
                                (TransactionStatus.PENDING_VOID_APPROVAL.value, trans_id_to_void))
                    self._log_atomic(cur, user_id, 'REQUEST_VOID_PRODUCTION',
                                    f"درخواست ابطال برای خروج به تولید #{trans_id_to_void}")
                    return TransactionStatus.PENDING_VOID_APPROVAL

                item_id   = orig_trans['item_id']
                qty       = orig_trans['qty']
                batch_no  = orig_trans.get('batch_no')
                expiry_dt = orig_trans.get('expiry_date')
                if not batch_no:
                    raise ValueError("اطلاعات بچ برای ابطال یافت نشد.")

                did_reverse = False  # برای جلوگیری از اجرای دو‌باره منطق عمومی

                # --- شاخه‌ی ویژه: ابطال «ورود از تولید» ---
                # تشخیص انعطاف‌پذیر (فارسی/انگلیسی)
                _t = (t_type or "").strip().lower()
                if _t == 'ورود از تولید' or ('ورود' in _t and 'تولید' in _t) \
                or _t in ('entry from production', 'entry_from_production', 'entry_from_prod'):
                    dest_loc = orig_trans.get('dest_loc')  # مقصد اصلی ورود (مثلاً Main)
                    src_loc  = orig_trans.get('src_loc')   # مبدأ (انبار تولید) اگر ذخیره شده باشد

                    if not src_loc:
                        # در صورت نبودِ ستون/مقدار، از پیش‌فرض سیستم بگیر
                        src_loc = self.get_production_floor_location()
                    if not dest_loc or not src_loc:
                        raise ValueError("لوکیشن‌های مبدأ/مقصد برای ابطال مشخص نیست.")

                    # 1) از مقصد کم کن (بدون گیر به وضعیت رکوردهای stock)
                    self._upd_stock(cur,
                                    item_id=item_id,
                                    location_id=dest_loc,
                                    qty_change=-abs(qty),
                                    batch_no=batch_no,
                                    expiry_date=expiry_dt,
                                    status=None,
                                    ignore_status_check=True)

                    # 2) به تولید برگردان
                    self._upd_stock(cur,
                                    item_id=item_id,
                                    location_id=src_loc,
                                    qty_change=abs(qty),
                                    batch_no=batch_no,
                                    expiry_date=expiry_dt,
                                    status='تایید شده')
                    did_reverse = True

                # --- ابطال انتقال (بدون تغییر) ---
                if not did_reverse and t_type == TransactionType.TRANSFER.value:
                    src_loc, dest_loc = orig_trans.get('src_loc'), orig_trans.get('dest_loc')
                    if src_loc and dest_loc:
                        self._upd_stock(cur, item_id, dest_loc, -abs(qty), batch_no, expiry_dt)
                        self._upd_stock(cur, item_id, src_loc,  abs(qty), batch_no, expiry_dt)
                    did_reverse = True

                # --- منطق عمومی برای سایر انواع (بدون تغییر) ---
                if not did_reverse:
                    is_entry_type = t_type.startswith('ورود') or t_type == 'برگشت'
                    reversal_qty = -qty if is_entry_type else abs(qty)
                    loc_to_fix = orig_trans.get('dest_loc') or orig_trans.get('src_loc')
                    if loc_to_fix:
                        self._upd_stock(cur, item_id, loc_to_fix, reversal_qty, batch_no, expiry_dt)

                # ثبت تراکنش ابطال (مثل قبل)
                new_void_type = f"ابطال {t_type}"
                notes = f"ابطال تراکنش '{t_type}' (سند اصلی: {orig_trans.get('t_no', 'ندارد')})"
                cur.execute("""
                    INSERT INTO trans (item_id, t_type, t_no, qty, notes, user_id, status, voids_trans_id, batch_no, expiry_date, t_date)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())
                """, (item_id, new_void_type, orig_trans.get('t_no'), -qty, notes, user_id,
                    TransactionStatus.APPROVED.value, trans_id_to_void, batch_no, expiry_dt))

                cur.execute("UPDATE trans SET status = 'باطل شده' WHERE id = %s", (trans_id_to_void,))
                self._log_atomic(cur, user_id, 'VOID_EXECUTE', f"ابطال تراکنش #{trans_id_to_void} انجام شد")
                return TransactionStatus.VOIDED

            else:
                raise ValueError(f"این تراکنش در وضعیت '{current_status}' قرار دارد و قابل ابطال یا لغو نیست.")
                    
                                                            
    def approve_void_transaction(self, trans_id: int, user_id: int):
        import datetime as _dt
        with self.transaction() as cur:
            # قفل و خواندن رکورد اصلی
            cur.execute("SELECT * FROM trans WHERE id=%s FOR UPDATE", (trans_id,))
            t = cur.fetchone()
            if not t:
                raise ValueError("تراکنش یافت نشد")

            # وضعیت‌ها (fallback اگر Enum نبود)
            try:
                PENDING_VOID = TransactionStatus.PENDING_VOID_APPROVAL.value
                VOIDED       = TransactionStatus.VOIDED.value
            except Exception:
                PENDING_VOID = 'در انتظار تایید ابطال'
                VOIDED       = 'باطل شده'

            if str(t.get('status')) == VOIDED:
                # قبلاً تایید و باطل شده؛ idempotent
                return

            if str(t.get('status')) != PENDING_VOID:
                raise ValueError("این تراکنش در وضعیت انتظار تایید ابطال نیست.")

            t_type   = str(t.get('t_type') or '')
            item_id  = t['item_id']
            try:
                qty  = float(t.get('qty') or 0.0)
            except Exception:
                qty  = 0.0
            if qty <= 0:
                raise ValueError("مقدار تراکنش نامعتبر است.")

            batch_no = t.get('batch_no')
            exp_dt   = t.get('expiry_date')

            # ستون‌های لوکیشن‌ها در اسکیماهای مختلف
            src_loc  = t.get('src_loc') or t.get('from_location_id')
            dest_loc = t.get('dest_loc') or t.get('to_location_id')

            # fallback تولید اگر لازم شد
            if not src_loc or not dest_loc:
                try:
                    prod_loc = self.get_production_floor_location()
                except Exception:
                    prod_loc = None
                # در خروج/ورود تولید، یکی از لوکیشن‌ها باید تولید باشد
                if t_type == 'خروج به تولید' and not dest_loc and prod_loc:
                    dest_loc = prod_loc
                if t_type == 'ورود از تولید' and not src_loc and prod_loc:
                    src_loc = prod_loc

            # --- برگرداندن اثر تراکنش ---
            if t_type == 'خروج به تولید':
                # اصل تراکنش: Main -> Production
                # VOID: 1) از مقصد (Production) کم  2) به مبدأ (Main) اضافه
                if not dest_loc or not src_loc:
                    raise ValueError("لوکیشن‌های تراکنش کامل نیست.")
                self._upd_stock(cur, item_id, dest_loc, -abs(qty), batch_no, exp_dt,
                                ignore_status_check=True)     # از تولید کم
                self._upd_stock(cur, item_id, src_loc,  abs(qty),  batch_no, exp_dt,
                                status='تایید شده')           # به انبار اصلی اضافه

            elif t_type == 'ورود از تولید':
                # اصل تراکنش: Production -> Main
                # VOID: 1) از مقصد (Main) کم  2) به مبدأ (Production) اضافه
                if not dest_loc or not src_loc:
                    raise ValueError("لوکیشن‌های تراکنش کامل نیست.")
                self._upd_stock(cur, item_id, dest_loc, -abs(qty), batch_no, exp_dt,
                                ignore_status_check=True)     # از Main کم
                self._upd_stock(cur, item_id, src_loc,  abs(qty),  batch_no, exp_dt,
                                status='تایید شده')           # به تولید اضافه

            else:
                # اگر انواع دیگری دارید، همین‌جا مطابق منطق خودتان هندل کنید
                pass

            # --- UPDATE انعطاف‌پذیر روی trans (بدون وابستگی به ستون‌های غیر موجود) ---
            try:
                cols = set(self._get_existing_columns('trans', cursor=cur))
            except Exception:
                cur.execute("SELECT * FROM trans LIMIT 0")
                cols = {getattr(d, 'name', d[0]) for d in (cur.description or [])}

            sets, params = ["status=%s"], [VOIDED]

            # user/stamp ست می‌شود اگر ستونش باشد
            if 'processed_by' in cols:
                sets.append("processed_by=%s"); params.append(user_id)
            elif 'approved_by' in cols:
                sets.append("approved_by=%s");  params.append(user_id)
            elif 'reviewed_by' in cols:
                sets.append("reviewed_by=%s");  params.append(user_id)

            if 'processed_at' in cols:
                sets.append("processed_at=NOW()")
            elif 'approved_at' in cols:
                sets.append("approved_at=NOW()")
            elif 'updated_at' in cols:
                sets.append("updated_at=NOW()")

            if 'notes' in cols:
                sets.append("notes = COALESCE(notes,'') || %s")
                params.append(" | تایید ابطال توسط کاربر #%s" % user_id)

            params.append(trans_id)
            cur.execute(f"UPDATE trans SET {', '.join(sets)} WHERE id=%s", tuple(params))

            # لاگ
            if hasattr(self, "_log_atomic"):
                self._log_atomic(cur, user_id, 'APPROVE_VOID', f"Void approved for trans#{trans_id}")
            
                                                                                                                                    
    
    # ═════════════════════════════════════════════════════
    # توابع کامل و نهایی برای ماژول مدیریت محرمانگی
    # ═════════════════════════════════════════════════════
    def get_all_reporting_groups(self):
        """لیستی از تمام نام‌های گروه گزارش‌دهی که توسط کاربر تعریف شده را برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                query = "SELECT DISTINCT reporting_group FROM items WHERE reporting_group IS NOT NULL AND reporting_group != '' ORDER BY reporting_group"
                cur.execute(query)
                return [row['reporting_group'] for row in cur.fetchall()]

    def get_raw_materials_for_grouping(self):
        """لیست تمام مواد اولیه را برای نمایش در پنجره مدیریت گروه‌ها برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, name, reporting_group FROM items WHERE category='مواد اولیه' ORDER BY name")
                return cur.fetchall()

            
# ══════════════════════════════════════════════════════════
    # توابع جدید برای ماژول پیشرفته «مرکز کنترل محرمانگی»
    # ══════════════════════════════════════════════════════════
    
# در کلاس DB، این متد را جایگزین کنید

    def get_distinct_main_groups(self):
        """گروه‌های اصلی مواد اولیه را به صورت خودکار و امن استخراج می‌کند."""
        query = """
            SELECT DISTINCT SUBSTRING(name from '^[A-Z_]+') as main_group 
            FROM items 
            WHERE category=%s AND name ~ '^[A-Z_]+[0-9]+'
            ORDER BY main_group;
        """
        # استفاده از ثابت استاندارد به جای متن خام
        rows = self.execute_query(query, (CATEGORY_RAW_MATERIAL,))
        return [row['main_group'] for row in rows] if rows else []
    
# در کلاس DB، این متد را جایگزین کنید

    def get_items_for_main_group(self, group_prefix: str):
        """تمام مواد اولیه‌ای که به یک گروه اصلی تعلق دارند را به صورت امن برمی‌گرداند."""
        query = "SELECT id, name, reporting_group FROM items WHERE category=%s AND name LIKE %s ORDER BY name"
        params = (CATEGORY_RAW_MATERIAL, f"{group_prefix}%")
        return self.execute_query(query, params)
    
# در کلاس DB، این متد را جایگزین کنید

    def save_confidentiality_rule(self, group_prefix: str, report_name: str, exception_ids: list):
        """یک قانون کلی را برای یک گروه به همراه استثناهای آن به صورت اتمیک و امن در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            # گام ۱: اعمال قانون کلی برای تمام اعضای گروه
            # اگر report_name وجود داشته باشد، به عنوان گروه تنظیم می‌شود؛ در غیر این صورت NULL می‌شود.
            main_query = "UPDATE items SET reporting_group = %s WHERE category=%s AND name LIKE %s"
            main_params = (report_name if report_name else None, CATEGORY_RAW_MATERIAL, f"{group_prefix}%")
            self.execute_query(main_query, main_params, cursor=cur)

            # گام ۲: اعمال استثناها (در صورت وجود)
            if exception_ids:
                # اگر قانون اصلی محرمانه بودن است (report_name دارد)، استثناها را شفاف (NULL) کن
                if report_name:
                    except_query = "UPDATE items SET reporting_group = NULL WHERE id = ANY(%s)"
                    except_params = (exception_ids,)
                # اگر قانون اصلی شفاف بودن است، استثناها را محرمانه کن
                else:
                    except_query = "UPDATE items SET reporting_group = %s WHERE id = ANY(%s)"
                    # استفاده نکردن از رشته جادویی برای نام گروه استثنا
                    except_params = (f"گروه محرمانه {group_prefix}", exception_ids)
                
                self.execute_query(except_query, except_params, cursor=cur)
                
            
# در کلاس DB، این متد را جایگزین کنید

    def save_reporting_rules(self, rules: list):
        """لیستی از قوانین گزارش‌دهی را به صورت اتمیک در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            for rule in rules:
                self.execute_query(
                    "UPDATE items SET reporting_group = %s WHERE id = %s",
                    (rule['group_name'], rule['id']),
                    cursor=cur
                )
                            

            

            
# در کلاس DB، این متد را جایگزین کنید

    def get_distinct_product_codes(self):
        """لیستی از تمام بچ‌های محصول نهایی که BOM دارند را برمی‌گرداند."""
        query = "SELECT DISTINCT product_code FROM bill_of_materials ORDER BY product_code DESC"
        rows = self.execute_query(query)
        return [row['product_code'] for row in rows] if rows else []
    
    
    def get_bom_for_product(self, product_name: str):
        # آیا ستون part_type داریم؟
        has_part_type = self.execute_query(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = current_schema()
            AND table_name = 'recipes'
            AND column_name = 'part_type'
            LIMIT 1
            """,
            fetch_one=True
        )

        if has_part_type:
            query = """
                SELECT 
                    ri.id,
                    i.name AS component_name,
                    i.id   AS component_item_id,
                    ri.percentage AS quantity,
                    COALESCE(u.name, '') AS unit
                FROM recipe_ingredients ri
                JOIN recipes r ON r.id = ri.recipe_id
                JOIN items   i ON i.id = ri.raw_material_item_id
                LEFT JOIN units u ON u.id = i.unit_id
                WHERE r.product_name = %s
                AND r.status = 'ACTIVE'
                AND r.part_type = 'PACKAGING'
                ORDER BY i.name
            """
            params = (product_name,)
        else:
            # فیلتر بر اساس دستهٔ جزء (PACKAGING)
            query = """
                SELECT 
                    ri.id,
                    i.name AS component_name,
                    i.id   AS component_item_id,
                    ri.percentage AS quantity,
                    COALESCE(u.name, '') AS unit
                FROM recipe_ingredients ri
                JOIN recipes r ON r.id = ri.recipe_id
                JOIN items   i ON i.id = ri.raw_material_item_id
                LEFT JOIN units u ON u.id = i.unit_id
                WHERE r.product_name = %s
                AND r.status = 'ACTIVE'
                AND i.category = %s
                ORDER BY i.name
            """
            params = (product_name, CATEGORY_PACKAGING)

        return self.execute_query(query, params)
    
        
    # ==== DEBUG-FIX: DB.get_kardex — normalize qty with abs(), keep prints ====
    def get_kardex(self, item_id: int, date_from, warehouse_name: str, date_to, batch_no: str | None):
        DEBUG_TRACE = True
        DEBUG_PRINT_ALL = False
        DEBUG_KEYWORDS = ('تبد', 'convert', 'مصرف', 'تولید')

        import datetime as _dt, re

        def _dstr(x):
            if isinstance(x, str): return x[:10]
            if isinstance(x, _dt.datetime): return x.date().isoformat()
            if isinstance(x, _dt.date): return x.isoformat()
            return str(x)[:10]

        _re_space = re.compile(r'\s+')
        _re_diac  = re.compile(r'[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED]')
        def _norm_text(s: str) -> str:
            if not s: return ''
            s = str(s)
            s = s.replace('\u064A', '\u06CC').replace('\u0643', '\u06A9')
            s = s.replace('\u200c',' ').replace('\u200f',' ').replace('\u200d',' ')
            s = _re_diac.sub('', s)
            s = _re_space.sub(' ', s).strip().lower()
            return s

        def _should_print(ttype_norm: str) -> bool:
            if DEBUG_PRINT_ALL: return True
            return any(k in ttype_norm for k in DEBUG_KEYWORDS)

        d_from = _dstr(date_from)
        d_to   = _dstr(date_to)
        wh     = warehouse_name or None

        batch_cond_open   = ""
        batch_cond_period = ""
        params_open   = [item_id, d_from]
        params_period = [item_id, d_from, d_to]
        if batch_no:
            batch_cond_open   = " AND t.batch_no = %s "
            batch_cond_period = " AND t.batch_no = %s "
            params_open.append(batch_no)
            params_period.append(batch_no)

        with self.transaction() as cur:
            q_open = f"""
                SELECT
                    t.t_date::date AS d,
                    TO_CHAR(t.t_date, 'YYYY-MM-DD HH24:MI:SS') AS dt_iso,
                    t.qty, t.t_type,
                    swh.name AS src_wh, dwh.name AS dest_wh
                FROM trans t
                LEFT JOIN locations   sl  ON t.src_loc = sl.id
                LEFT JOIN warehouses  swh ON sl.warehouse_id = swh.id
                LEFT JOIN locations   dl  ON t.dest_loc = dl.id
                LEFT JOIN warehouses  dwh ON dl.warehouse_id = dwh.id
                WHERE t.item_id = %s
                AND (t.status IS NULL OR t.status = 'تایید شده')
                AND t.t_date < %s::date
                {batch_cond_open}
                ORDER BY t.t_date, t.id
            """
            rows_open = self.execute_query(q_open, tuple(params_open), cursor=cur) or []

            q_period = f"""
                SELECT
                    t.id AS doc_no,
                    t.t_date::date AS d,
                    TO_CHAR(t.t_date, 'YYYY-MM-DD HH24:MI:SS') AS dt_iso,
                    t.qty, t.t_type, t.batch_no,
                    swh.name AS src_wh, dwh.name AS dest_wh
                FROM trans t
                LEFT JOIN locations   sl  ON t.src_loc = sl.id
                LEFT JOIN warehouses  swh ON sl.warehouse_id = swh.id
                LEFT JOIN locations   dl  ON t.dest_loc = dl.id
                LEFT JOIN warehouses  dwh ON dl.warehouse_id = dwh.id
                WHERE t.item_id = %s
                AND (t.status IS NULL OR t.status = 'تایید شده')
                AND DATE(t.t_date) BETWEEN %s AND %s
                {batch_cond_period}
                ORDER BY t.t_date, t.id
            """
            rows_period = self.execute_query(q_period, tuple(params_period), cursor=cur) or []

        # ---------- SIGN DECIDER (uses abs(qty)) ----------
        def _decide_sign(row, wh_name: str | None):
            qty_raw   = float(row.get('qty') or 0)     # ممکن است منفی باشد
            q         = abs(qty_raw)                   # فقط قدر مطلق را به‌عنوان کمیت استفاده می‌کنیم
            ttype_raw = row.get('t_type') or ''
            ttype     = _norm_text(ttype_raw)
            swh       = row.get('src_wh')
            dwh       = row.get('dest_wh')

            rule = None
            sign = None

            # 1) قواعد قطعی (با q=abs)
            if ('خروج' in ttype and 'تولید' in ttype):
                rule, sign = 'IN_TO_PRODUCTION(+)', +q
            elif ('ورود' in ttype and ('تبد' in ttype or 'convert' in ttype)):
                rule, sign = 'IN_FROM_CONVERT(+)', +q
            elif ('خروج' in ttype and ('تبد' in ttype or 'convert' in ttype)):
                rule, sign = 'OUT_TO_CONVERT(-)', -q
            elif ('مصرف' in ttype and 'تولید' in ttype):
                rule, sign = 'CONSUME(-)', -q

            # 2) قواعد عمومی (باز هم با q=abs)
            if sign is None and 'خروج' in ttype:
                if wh_name:
                    if swh == wh_name:           rule, sign = 'GEN:KHOROJ_WH_SRC(-)',  -q
                    elif dwh == wh_name:         rule, sign = 'GEN:KHOROJ_WH_DEST(+)', +q
                    else:                        rule, sign = 'GEN:KHOROJ_WH_NONE',    None
                else:
                    if swh and not dwh:          rule, sign = 'GEN:KHOROJ_ONLY_SRC(-)',  -q
                    elif dwh and not swh:        rule, sign = 'GEN:KHOROJ_ONLY_DEST(+)', +q
                    else:                        rule, sign = 'GEN:KHOROJ_OTHER',       None

            if sign is None and 'ورود' in ttype:
                if wh_name:
                    if dwh == wh_name:           rule, sign = 'GEN:VORUD_WH_DEST(+)', +q
                    elif swh == wh_name:         rule, sign = 'GEN:VORUD_WH_SRC(-)',  -q
                    else:                        rule, sign = 'GEN:VORUD_WH_NONE',    None
                else:
                    if dwh and not swh:          rule, sign = 'GEN:VORUD_ONLY_DEST(+)', +q
                    elif swh and not dwh:        rule, sign = 'GEN:VORUD_ONLY_SRC(-)',  -q
                    else:                        rule, sign = 'GEN:VORUD_OTHER',        None

            # 3) fallback src/dest
            if sign is None:
                if wh_name:
                    if swh == wh_name and dwh == wh_name: rule, sign = 'FALLBACK:WH_BOTH(0)', 0.0
                    elif swh == wh_name and dwh != wh_name: rule, sign = 'FALLBACK:WH_SRC(-)', -q
                    elif dwh == wh_name and swh != wh_name: rule, sign = 'FALLBACK:WH_DEST(+)', +q
                    else: rule, sign = 'FALLBACK:WH_NONE', None
                else:
                    if swh and dwh:  rule, sign = 'FALLBACK:BOTH(0)', 0.0
                    elif dwh and not swh: rule, sign = 'FALLBACK:ONLY_DEST(+)', +q
                    elif swh and not dwh: rule, sign = 'FALLBACK:ONLY_SRC(-)',  -q
                    else: rule, sign = 'FALLBACK:NONE(0)', 0.0

            if DEBUG_TRACE and _should_print(ttype):
                print(f"[KARDEX] doc={row.get('doc_no')} dt={row.get('dt_iso') or row.get('d')} "
                    f"type_raw={ttype_raw!r} norm={ttype!r} qty_raw={qty_raw} q_abs={q} "
                    f"src={swh!r} dest={dwh!r} wh_filter={wh_name!r} -> rule={rule} sign={sign}")
            return sign, rule, ttype_raw, ttype

        # ---------- opening ----------
        opening = 0.0
        for r in rows_open:
            sign, _, _, _ = _decide_sign(r, wh)
            if sign is None: 
                continue
            opening += sign

        # ---------- BOM (مثل قبل) ----------
        def _has_col(table: str, col: str) -> bool:
            q = """
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = current_schema() AND table_name = %s AND column_name = %s
            """
            return bool(self.execute_query(q, (table, col)))

        bom_table = "bill_of_materials"
        bom_exists = bool(self.execute_query(
            "SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name=%s",
            (bom_table,)
        ))

        bom_rows_open, bom_rows_period = [], []
        if bom_exists:
            item_col = "raw_item_id" if _has_col(bom_table, "raw_item_id") else ("item_id" if _has_col(bom_table, "item_id") else None)
            qty_col  = "qty" if _has_col(bom_table, "qty") else None
            date_col = next((c for c in ["t_date","date","created_at","created_on","ts"] if _has_col(bom_table, c)), None)
            if item_col and qty_col and date_col:
                q_bom_open = f"SELECT {date_col}::date AS d, {qty_col} AS qty FROM {bom_table} WHERE {item_col}=%s AND {date_col} < %s::date"
                bom_rows_open   = self.execute_query(q_bom_open, (item_id, d_from)) or []
                q_bom_period = f"SELECT {date_col}::date AS d, {qty_col} AS qty FROM {bom_table} WHERE {item_col}=%s AND {date_col}::date BETWEEN %s AND %s"
                bom_rows_period = self.execute_query(q_bom_period, (item_id, d_from, d_to)) or []

        for r in bom_rows_open:
            opening -= float(r.get('qty') or 0)

        # ---------- rows ----------
        out_rows, sum_in, sum_out = [], 0.0, 0.0
        for r in rows_period:
            sign, rule, ttype_raw, _ = _decide_sign(r, wh)
            if sign is None:
                continue
            in_q  = sign if sign > 0 else 0.0
            out_q = -sign if sign < 0 else 0.0
            sum_in  += in_q
            sum_out += out_q

            out_rows.append({
                'date'   : str(r.get('d') or ''),
                'dt_iso' : r.get('dt_iso') or '',
                'doc_no' : r.get('doc_no'),
                'type'   : ttype_raw,
                'batch'  : r.get('batch_no') or '',
                'src_wh' : r.get('src_wh') or '',
                'dest_wh': r.get('dest_wh') or '',
                'in_qty' : in_q,
                'out_qty': out_q,
                'in'     : in_q,
                'out'    : out_q,
            })
            if DEBUG_TRACE and _should_print(_norm_text(ttype_raw)):
                print(f"[KARDEX-ROW] doc={r.get('doc_no')} -> in={in_q} out={out_q} rule={rule}")

        for r in bom_rows_period:
            q = float(r.get('qty') or 0)
            if q <= 0: 
                continue
            sum_out += q
            out_rows.append({
                'date'   : str(r.get('d') or ''),
                'dt_iso' : f"{str(r.get('d'))} 12:00:00",
                'doc_no' : None,
                'type'   : 'مصرف تولید',
                'batch'  : '',
                'src_wh' : 'Production',
                'dest_wh': '',
                'in_qty' : 0.0,
                'out_qty': q,
                'in'     : 0.0,
                'out'    : q,
            })
            if DEBUG_TRACE:
                print(f"[KARDEX-BOM] consume -> out={q}")

        out_rows.sort(key=lambda r: (r.get('dt_iso') or r.get('date') or '', str(r.get('doc_no') or '')))

        payload = {
            'item_id': int(item_id),
            'warehouse': wh,
            'date_from': d_from,
            'date_to': d_to,
            'opening_balance': round(opening, 6),
            'sum_in': round(sum_in, 6),
            'sum_out': round(sum_out, 6),
            'balance': round(opening + sum_in - sum_out, 6),
            'rows': out_rows
        }

        if DEBUG_TRACE:
            print(f"[KARDEX-SUM] opening={payload['opening_balance']} sum_in={payload['sum_in']} "
                f"sum_out={payload['sum_out']} balance={payload['balance']}")
        return payload
    # ==== END DEBUG-FIX ====
                
    # BEGIN ADD: DB.get_production_variance
    def get_production_variance(self, pack_item_id: int, date_from, date_to, production_wh_name: str = None):
        """
        مقایسهٔ مصرف «استاندارد» (از BOM تاریخی) و «واقعی» (خروج از انبار تولید) برای یک پک در بازهٔ تاریخ.
        خروجی شامل دو بخش است: فله (A/B یا P) و لوازم بسته‌بندی.

        - تولید روزانهٔ پک از trans کشف می‌شود (اولویت: t_type های بسته‌بندی → ورود بدون مبدأ → انتقال از انبار تولید).
        - استاندارد = جمع(BOM_as_of(روز) × تعداد پک تولیدی همان روز).
        - واقعی = خالص خروج از انبار تولید برای همان اقلام در بازه.

        return:
        {
            'pack_item_id': int,
            'date_from': 'YYYY-MM-DD',
            'date_to': 'YYYY-MM-DD',
            'produced_qty': float,
            'bulk': [ {'item_id','name','std','act','var','var_pct'} ],
            'pack': [ {'item_id','name','std','act','var','var_pct'} ],
        }
        """
        import json, re
        from collections import defaultdict

        def _dstr(x):
            if isinstance(x, str):
                return x[:10]
            if hasattr(x, 'date'):
                return str(x.date())
            return str(x)[:10]

        d_from = _dstr(date_from)
        d_to   = _dstr(date_to)

        with self.transaction() as cur:
            # 0) نام انبار تولید (اگر ورودی نداشتیم)
            if production_wh_name is None:
                try:
                    production_wh_name = PRODUCTION_WAREHOUSE_NAME
                except NameError:
                    production_wh_name = 'انبار تولید'

            # 1) خواندن سری تولید پک از trans
            #    اولویت شناسایی تولید:
            #    - t_type ∈ مجموعهٔ رایج بسته‌بندی
            #    - src_loc IS NULL و dest_loc NOT NULL (ایجاد)
            #    - src_wh = انبار تولید (خروج از تولید به مقصد دیگر)
            pack_rows = self.execute_query(
                """
                SELECT t.t_date::date AS d, t.qty, t.t_type, 
                    sw.name AS src_wh, dw.name AS dest_wh,
                    t.src_loc, t.dest_loc
                FROM trans t
                LEFT JOIN locations sl ON t.src_loc = sl.id
                LEFT JOIN warehouses sw ON sl.warehouse_id = sw.id
                LEFT JOIN locations dl ON t.dest_loc = dl.id
                LEFT JOIN warehouses dw ON dl.warehouse_id = dw.id
                WHERE t.item_id = %s
                AND t.status = 'تایید شده'
                AND t.t_date >= %s
                AND t.t_date < (%s::date + INTERVAL '1 day')
                ORDER BY t.t_date, t.id
                """,
                (pack_item_id, d_from, d_to), cursor=cur
            ) or []

            # دسته‌بندی t_type های رایج بسته‌بندی (بدون تغییر DB)
            packaging_types = {'بسته‌بندی', 'بسته بندی', 'ثبت بسته‌بندی', 'Packaging', 'Pack', 'Production Pack'}

            produced_by_day = defaultdict(float)
            total_produced = 0.0
            for r in pack_rows:
                qty = float(r.get('qty') or 0.0)
                if qty <= 0:
                    continue
                d = str(r.get('d'))
                t_type = (r.get('t_type') or '').strip()
                src_wh = r.get('src_wh')
                dest_wh = r.get('dest_wh')
                src_loc = r.get('src_loc')
                dest_loc = r.get('dest_loc')

                is_production = False
                if t_type in packaging_types:
                    is_production = True
                elif (src_loc is None) and (dest_loc is not None):
                    # ورود بدون مبدأ → ایجاد موجودی (اغلب تولید ثبت‌شده)
                    is_production = True
                elif src_wh == production_wh_name and (dest_wh is not None) and (dest_wh != src_wh):
                    # خروج از انبار تولید به انبار دیگر برای کالای پک
                    is_production = True

                if is_production:
                    produced_by_day[d] += qty
                    total_produced += qty

            if total_produced <= 0:
                # خروجی خالی اما محکم
                return {
                    'pack_item_id': pack_item_id,
                    'date_from': d_from,
                    'date_to': d_to,
                    'produced_qty': 0.0,
                    'bulk': [],
                    'pack': [],
                }

            # 2) استاندارد روزانه با BOM تاریخی همان روز
            std_bulk = defaultdict(float)   # item_id -> qty
            std_pack = defaultdict(float)   # item_id -> qty
            for day, qty in produced_by_day.items():
                bom = self.get_flat_bom_for_pack_as_of(pack_item_id, day)
                # فله
                for bp in bom.get('bulk_parts') or []:
                    std_bulk[int(bp['item_id'])] += float(bp.get('qty_per_pack') or 0.0) * float(qty)
                # لوازم بسته‌بندی
                for pi in bom.get('pack_items') or []:
                    std_pack[int(pi['item_id'])] += float(pi.get('qty_per_pack') or 0.0) * float(qty)

            # 3) «مصرف واقعی» = خالص خروج از انبار تولید برای همان اقلام در بازه
            def _actual_consumption_for(items_map: dict) -> dict:
                if not items_map:
                    return {}
                ids = list(items_map.keys())
                # خالص خروج = SUM(CASE src_wh=prod THEN qty) - SUM(CASE dest_wh=prod THEN qty)
                q = """
                    SELECT t.item_id,
                        COALESCE(SUM(CASE WHEN sw.name = %s THEN t.qty ELSE 0 END),0) AS out_qty,
                        COALESCE(SUM(CASE WHEN dw.name = %s THEN t.qty ELSE 0 END),0) AS in_qty
                    FROM trans t
                    LEFT JOIN locations sl ON t.src_loc = sl.id
                    LEFT JOIN warehouses sw ON sl.warehouse_id = sw.id
                    LEFT JOIN locations dl ON t.dest_loc = dl.id
                    LEFT JOIN warehouses dw ON dl.warehouse_id = dw.id
                    WHERE t.item_id = ANY(%s)
                    AND t.status = 'تایید شده'
                    AND t.t_date >= %s
                    AND t.t_date < (%s::date + INTERVAL '1 day')
                    GROUP BY t.item_id
                """
                rows = self.execute_query(q, (production_wh_name, production_wh_name, ids, d_from, d_to), cursor=cur) or []
                out = {}
                for r in rows:
                    iid = int(r['item_id'])
                    out[iid] = float(r.get('out_qty', 0.0)) - float(r.get('in_qty', 0.0))
                # اقلامی که رکوردی ندارند → 0
                for iid in ids:
                    out.setdefault(int(iid), 0.0)
                return out

            act_bulk_map = _actual_consumption_for(std_bulk)
            act_pack_map = _actual_consumption_for(std_pack)

            # 4) مونتاژ خروجی با نام اقلام و واریانس
            def _name_of(iid: int) -> str:
                row = self.execute_query("SELECT name FROM items WHERE id=%s", (iid,), fetch_one=True, cursor=cur) or {}
                return row.get('name', '')

            bulk_rows = []
            for iid, std_q in sorted(std_bulk.items()):
                act_q = float(act_bulk_map.get(iid, 0.0))
                var = act_q - std_q
                var_pct = (var / std_q * 100.0) if std_q > 0 else None
                bulk_rows.append({
                    'item_id': iid, 'name': _name_of(iid),
                    'std': float(std_q), 'act': float(act_q),
                    'var': float(var), 'var_pct': (float(var_pct) if var_pct is not None else None)
                })

            pack_rows_out = []
            for iid, std_q in sorted(std_pack.items()):
                act_q = float(act_pack_map.get(iid, 0.0))
                var = act_q - std_q
                var_pct = (var / std_q * 100.0) if std_q > 0 else None
                pack_rows_out.append({
                    'item_id': iid, 'name': _name_of(iid),
                    'std': float(std_q), 'act': float(act_q),
                    'var': float(var), 'var_pct': (float(var_pct) if var_pct is not None else None)
                })

            return {
                'pack_item_id': pack_item_id,
                'date_from': d_from,
                'date_to': d_to,
                'produced_qty': float(total_produced),
                'bulk': bulk_rows,
                'pack': pack_rows_out,
            }
    # END ADD: DB.get_production_variance
    
    # BEGIN REWRITE: DB.get_flat_bom_for_pack_as_of
    def get_flat_bom_for_pack_as_of(self, pack_item_id: int, as_of_date, pack_count: float = 1.0):
        """
        BOM تخت «مقداری» برای یک بسته‌بندی را در تاریخ مشخص برمی‌گرداند.
        - فله: بر اساس نسبت اختلاطِ دستور مادر (A/B یا P) و وزن خالص پک.
        - بسته‌بندی: اجزای PACKAGING فعال در همان تاریخ.
        - مواد اولیهٔ هر پارت: اقلام فرمول پارت‌ها (A/B یا P) بر حسب کیلوگرم به ازای مقدار تولید همان پارت.
        خروجی: dictهای شامل:
            component_item_id, component_name, unit_name, qty, kind
            kind ∈ {BULK_A,BULK_B,BULK_P,PACK,RM_A,RM_B,RM_P}
        سازگاری عقب‌رو: ردیف‌های قبلی (BULK_*, PACK) بدون تغییر برمی‌گردند.
        """
        import datetime as _dt, json as _json, re as _re

        # --- نرمال‌سازی تاریخ ---
        if isinstance(as_of_date, str):
            as_of_date = as_of_date.replace('/', '-')
            try:
                asof = _dt.datetime.fromisoformat(as_of_date)
            except Exception:
                y, m, d = as_of_date.split('-')
                asof = _dt.datetime(int(y), int(m), int(d))
        elif isinstance(as_of_date, _dt.date) and not isinstance(as_of_date, _dt.datetime):
            asof = _dt.datetime.combine(as_of_date, _dt.time.min)
        elif isinstance(as_of_date, _dt.datetime):
            asof = as_of_date
        else:
            asof = _dt.datetime.now()

        pack_count = float(pack_count or 1.0)
        rows_out = []

        def _norm_digits(s: str) -> str:
            return str(s).translate(str.maketrans("۰۱۲۳۴۵۶۷۸۹٠١٢٣٤٥٦٧٨٩", "01234567890123456789"))

        def _norm_ratio_val(v):
            if v is None:
                return 0.0
            if isinstance(v, (int, float)):
                return float(v)
            s = _norm_digits(str(v).strip()).replace('%', '').replace(',', '.')
            m = _re.match(r'^\s*(\d+(?:\.\d+)?)\s*[:/]\s*(\d+(?:\.\d+)?)\s*$', s)
            if m:
                return float(m.group(1)), float(m.group(2))
            try:
                return float(s)
            except Exception:
                return 0.0

        def _table_exists(tbl, cursor):
            try:
                q = """
                    SELECT 1
                    FROM information_schema.tables
                    WHERE table_schema = current_schema() AND table_name = %s
                    LIMIT 1
                """
                return bool(self.execute_query(q, (tbl,), fetch_one=True, cursor=cursor))
            except Exception:
                return False

        with self.transaction() as cur:
            # --- اطلاعات بسته‌بندی و والد ---
            pack_row = self.execute_query(
                "SELECT id, name, parent_item_id, COALESCE(net_weight,0) AS net_weight FROM items WHERE id=%s",
                (pack_item_id,), fetch_one=True, cursor=cur
            )
            if not pack_row:
                raise ValueError("بسته‌بندی در سیستم یافت نشد.")
            parent_id = pack_row.get('parent_item_id')
            if not parent_id:
                raise ValueError("این آیتم، زیرمجموعهٔ یک مادر نیست.")

            parent_row = self.execute_query(
                "SELECT id, name, COALESCE(is_two_component,false) AS is_two_component FROM items WHERE id=%s",
                (parent_id,), fetch_one=True, cursor=cur
            ) or {}
            is_two = bool(parent_row.get('is_two_component'))

            net_w = float(pack_row.get('net_weight') or 0.0)
            if net_w <= 0:
                raise ValueError("وزن خالص برای این بسته‌بندی ثبت نشده است.")
            bulk_need_total = net_w * pack_count  # مقدار فلهٔ لازم برای این تعداد پک

            # --- کشف ستون‌های recipes ---
            rec_cols = set(self._get_existing_columns("recipes", cursor=cur)) if hasattr(self, "_get_existing_columns") else set()
            has_part_type = ('part_type' in rec_cols)
            has_effective = ('effective_from' in rec_cols)
            has_valid_to  = ('valid_to' in rec_cols)
            out_col = 'produces_item_id' if 'produces_item_id' in rec_cols else ('output_item_id' if 'output_item_id' in rec_cols else None)

            def _pick_recipe(where_sql: str, params: tuple):
                if has_effective:
                    sql = f"""
                        SELECT id, properties{(','+out_col) if out_col else ''}
                        FROM recipes
                        WHERE {where_sql}
                        AND COALESCE(status,'ACTIVE')='ACTIVE'
                        AND effective_from <= %s
                        { "AND (valid_to IS NULL OR valid_to > %s)" if has_valid_to else "" }
                        ORDER BY effective_from DESC, id DESC
                        LIMIT 1
                    """
                    p = tuple(params) + (asof,) + ((asof,) if has_valid_to else tuple())
                else:
                    sql = f"""
                        SELECT id, properties{(','+out_col) if out_col else ''}
                        FROM recipes
                        WHERE {where_sql}
                        AND COALESCE(status,'ACTIVE')='ACTIVE'
                        ORDER BY id DESC
                        LIMIT 1
                    """
                    p = tuple(params)
                return self.execute_query(sql, p, fetch_one=True, cursor=cur)

            # ---------- محاسبهٔ فله ----------
            need_a = need_b = 0.0
            rec_a = rec_b = rec_p = None

            if is_two:
                # نسبت از دستور مادر (MIX/MASTER/M)
                mix_row = _pick_recipe("parent_product_id=%s AND part_type IN ('MIX','MASTER','M')", (parent_id,)) if has_part_type else _pick_recipe("parent_product_id=%s", (parent_id,))
                mix_props = {}
                if mix_row and mix_row.get('properties'):
                    mix_props = _json.loads(mix_row['properties']) if isinstance(mix_row['properties'], str) else (mix_row['properties'] or {})

                mix = (mix_props.get('mix_ratio') or mix_props.get('mix') or {})
                ra_raw = mix.get('A', mix.get('a', mix_props.get('ratio_a')))
                rb_raw = mix.get('B', mix.get('b', mix_props.get('ratio_b')))
                if isinstance(ra_raw, str) and (':' in ra_raw or '/' in ra_raw):
                    ra_raw, rb_raw = _norm_ratio_val(ra_raw)

                ra = float(_norm_ratio_val(ra_raw))
                rb = float(_norm_ratio_val(rb_raw))
                total = ra + rb
                if total <= 0:
                    raise ValueError("نسبت اختلاط در دستور مادر صفر است.")

                need_a = (bulk_need_total / total) * ra
                need_b = (bulk_need_total / total) * rb

                rec_a = _pick_recipe("parent_product_id=%s AND part_type='A'", (parent_id,)) if has_part_type else None
                rec_b = _pick_recipe("parent_product_id=%s AND part_type='B'", (parent_id,)) if has_part_type else None
                if not rec_a or not rec_b or not out_col or (not rec_a.get(out_col)) or (not rec_b.get(out_col)):
                    raise ValueError("فرمول فعال برای پارت A یا B یافت نشد.")

                name_a = self.execute_query("SELECT name FROM items WHERE id=%s", (rec_a[out_col],), fetch_one=True, cursor=cur)['name']
                name_b = self.execute_query("SELECT name FROM items WHERE id=%s", (rec_b[out_col],), fetch_one=True, cursor=cur)['name']
                rows_out.append({'component_item_id': rec_a[out_col], 'component_name': name_a, 'unit_name': 'کیلوگرم', 'qty': need_a, 'kind': 'BULK_A'})
                rows_out.append({'component_item_id': rec_b[out_col], 'component_name': name_b, 'unit_name': 'کیلوگرم', 'qty': need_b, 'kind': 'BULK_B'})
            else:
                rec_p = _pick_recipe("parent_product_id=%s AND part_type='P'", (parent_id,)) if has_part_type else None
                bulk_p_id = None
                if rec_p and out_col and rec_p.get(out_col):
                    bulk_p_id = rec_p[out_col]
                if not bulk_p_id:
                    raise ValueError("فرمول/پارت P یافت نشد.")
                name_p = self.execute_query("SELECT name FROM items WHERE id=%s", (bulk_p_id,), fetch_one=True, cursor=cur)['name']
                rows_out.append({'component_item_id': bulk_p_id, 'component_name': name_p, 'unit_name': 'کیلوگرم', 'qty': bulk_need_total, 'kind': 'BULK_P'})

            # ---------- مواد اولیهٔ پارت‌ها (RM_*) ----------
            use_ri = _table_exists('recipe_ingredients', cur)
            use_items = _table_exists('recipe_items', cur)

            def _read_rm_from_recipe(recipe_id: int, total_output_needed: float, part_label: str):
                if not recipe_id or total_output_needed <= 0:
                    return
                if use_ri:
                    sql = """
                        SELECT i.id AS item_id, i.name AS name, COALESCE(ri.percentage,0) AS percentage
                        FROM recipe_ingredients ri
                        JOIN items i ON i.id = ri.raw_material_item_id
                        WHERE ri.recipe_id = %s
                        ORDER BY i.name
                    """
                    ing = self.execute_query(sql, (recipe_id,), cursor=cur) or []
                    for r in ing:
                        qty = float(total_output_needed) * (float(r['percentage'] or 0) / 100.0)
                        rows_out.append({'component_item_id': r['item_id'], 'component_name': r['name'], 'unit_name': 'کیلوگرم', 'qty': qty, 'kind': f'RM_{part_label}'})
                elif use_items:
                    ri_cols = set(self._get_existing_columns("recipe_items", cursor=cur)) if hasattr(self, "_get_existing_columns") else set()
                    qty_col = 'quantity' if 'quantity' in ri_cols else ( 'percentage' if 'percentage' in ri_cols else None )
                    unit_fk = 'unit_id' if 'unit_id' in ri_cols else None
                    sql = "SELECT i.id AS item_id, i.name AS name"
                    if qty_col: sql += f", COALESCE(ri.{qty_col},0) AS val"
                    else: sql += ", 0::NUMERIC AS val"
                    if unit_fk: sql += ", COALESCE(u.name,'') AS unit_name"
                    else: sql += ", '' AS unit_name"
                    sql += " FROM recipe_items ri JOIN items i ON i.id = ri.component_item_id"
                    if unit_fk: sql += " LEFT JOIN units u ON u.id = ri.unit_id"
                    sql += " WHERE ri.recipe_id = %s AND i.category IN ('مواد اولیه','مواد اولیه و افزودنی')"
                    ing = self.execute_query(sql, (recipe_id,), cursor=cur) or []
                    if 'percentage' == qty_col:
                        for r in ing:
                            qty = float(total_output_needed) * (float(r['val'] or 0) / 100.0)
                            rows_out.append({'component_item_id': r['item_id'], 'component_name': r['name'], 'unit_name': 'کیلوگرم', 'qty': qty, 'kind': f'RM_{part_label}'})
                    else:
                        total_qty = sum(float(r['val'] or 0) for r in ing)
                        if total_qty > 0:
                            factor = float(total_output_needed) / total_qty
                            for r in ing:
                                qty = float(r['val'] or 0) * factor
                                unit_name = r.get('unit_name') or 'کیلوگرم'
                                rows_out.append({'component_item_id': r['item_id'], 'component_name': r['name'], 'unit_name': unit_name, 'qty': qty, 'kind': f'RM_{part_label}'})
                else:
                    return

            if is_two:
                _read_rm_from_recipe(rec_a['id'], need_a, 'A')
                _read_rm_from_recipe(rec_b['id'], need_b, 'B')
            else:
                _read_rm_from_recipe(rec_p['id'], bulk_need_total, 'P')

            # ---------- بسته‌بندی نهایی ----------
            pack_rows = []
            if has_part_type:
                r = _pick_recipe("part_type='PACKAGING' AND product_name=%s", (pack_row['name'],))
                if r:
                    ri_cols = set(self._get_existing_columns("recipe_items", cursor=cur)) if hasattr(self, "_get_existing_columns") else set()
                    qty_col = 'quantity' if 'quantity' in ri_cols else ('percentage' if 'percentage' in ri_cols else None)
                    unit_fk = 'unit_id' if 'unit_id' in ri_cols else None
                    sql = "SELECT i.id AS component_item_id, i.name AS component_name"
                    sql += f", ri.{qty_col} AS qty" if qty_col else ", 1::NUMERIC AS qty"
                    sql += ", u.name AS unit_name" if unit_fk else ", '' AS unit_name"
                    sql += " FROM recipe_items ri JOIN items i ON i.id = ri.component_item_id"
                    if unit_fk:
                        sql += " LEFT JOIN units u ON u.id = ri.unit_id"
                    sql += " WHERE ri.recipe_id = %s ORDER BY i.name"
                    pack_rows = self.execute_query(sql, (r['id'],), cursor=cur) or []

            for pr in pack_rows:
                rows_out.append({
                    'component_item_id': pr['component_item_id'],
                    'component_name'  : pr['component_name'],
                    'unit_name'       : pr.get('unit_name', ''),
                    'qty'             : float(pr.get('qty') or 0.0) * pack_count,
                    'kind'            : 'PACK'
                })

        return rows_out
    # END REWRITE: DB.get_flat_bom_for_pack_as_of
    
        # BEGIN ADD: DB.get_consumption_variance_for_pack
    def get_consumption_variance_for_pack(self, pack_item_id: int, date_from, date_to, production_wh_name: str = None) -> dict:
        """
        خروجی کمیّتی مصرف «واقعی در برابر استاندارد» برای یک محصول بسته‌بندی‌شده در یک بازهٔ تاریخی.
        - استاندارد: از BOM تاریخی همان روز (As-Of) × مقدار تولید همان روز.
        - واقعی: خالص خروج از انبار تولید برای اقلام درگیر (فله و لوازم بسته‌بندی) در همان بازه.
        برمی‌گرداند:
            {
            'pack_item_id': ...,
            'date_from': 'YYYY-MM-DD', 'date_to': 'YYYY-MM-DD',
            'produced_qty': float,
            'bulk': [{'item_id': int, 'std': float, 'act': float, 'var': float, 'var_pct': float|None}, ...],
            'pack': [{'item_id': int, 'std': float, 'act': float, 'var': float, 'var_pct': float|None}, ...],
            }
        """
        from collections import defaultdict
        import datetime as dt

        # نرمال‌سازی تاریخ‌ها به رشته YYYY-MM-DD
        def _to_date_str(d):
            if d is None:
                return None
            if isinstance(d, str):
                return d
            if isinstance(d, dt.date):
                return d.isoformat()
            if isinstance(d, dt.datetime):
                return d.date().isoformat()
            return str(d)

        d_from = _to_date_str(date_from)
        d_to   = _to_date_str(date_to)

        # نام انبار تولید
        if production_wh_name:
            prod_wh = production_wh_name
        else:
            try:
                prod_wh = PRODUCTION_WAREHOUSE_NAME
            except NameError:
                # فالبک رایج
                prod_wh = 'انبار تولید'

        # نوع‌های تراکنش که «تولید/بسته‌بندی محصول نهایی» تلقی می‌شوند
        packaging_types = {
            'بسته‌بندی', 'تحویل محصول بسته‌بندی شده به انبار',
            'PACKING', 'DELIVER_PACKED_GOODS'
        }

        def _normalize_bom_structure(bom_data):
            if isinstance(bom_data, dict):
                return {'bulk_parts': list(bom_data.get('bulk_parts') or []),'pack_items': list(bom_data.get('pack_items') or [])}
            if isinstance(bom_data, list):
                bulk_parts = []
                pack_items = []
                for entry in bom_data:
                    kind = str(entry.get('kind') or '').upper()
                    item_id = entry.get('component_item_id') or entry.get('item_id')
                    if not item_id:
                        continue
                    try:
                        item_id = int(item_id)
                    except Exception:
                        continue
                    qty_val = float(entry.get('qty') or entry.get('quantity') or 0.0)
                    record = {'item_id': item_id, 'qty_per_pack': qty_val}
                    if kind.startswith('BULK'):
                        bulk_parts.append(record)
                    elif kind.startswith('PACK'):
                        pack_items.append(record)
                return {'bulk_parts': bulk_parts, 'pack_items': pack_items}
            return {'bulk_parts': [], 'pack_items': []}

        with self.transaction() as cur:
            # 1) مقدار تولید روزانهٔ همین کالای پک در بازه
            #   از جدول trans و انبارها: اگر نوع تراکنش از نوع‌های بسته‌بندی باشد
            #   یا ورود بدون مبدأ باشد، یا از انبار تولید خارج شده باشد → تولید محسوب می‌کنیم.
            pack_rows = self.execute_query(
                """
                SELECT
                    DATE(t.t_date) AS d,
                    t.qty,
                    COALESCE(t.t_type, '') AS t_type,
                    sl.id       AS src_loc,  dl.id       AS dest_loc,
                    sw.name     AS src_wh,   dw.name     AS dest_wh
                FROM trans t
                LEFT JOIN locations sl ON t.src_loc = sl.id
                LEFT JOIN warehouses sw ON sl.warehouse_id = sw.id
                LEFT JOIN locations dl ON t.dest_loc = dl.id
                LEFT JOIN warehouses dw ON dl.warehouse_id = dw.id
                WHERE t.item_id = %s
                AND DATE(t.t_date) BETWEEN %s AND %s
                AND (t.status IS NULL OR t.status = 'تایید شده')
                """,
                (pack_item_id, d_from, d_to),
                cursor=cur
            ) or []

            produced_by_day = defaultdict(float)
            total_produced = 0.0
            for r in pack_rows:
                qty = float(r.get('qty') or 0.0)
                if qty <= 0:
                    continue
                d = str(r.get('d'))
                t_type  = (r.get('t_type') or '').strip()
                src_wh  = r.get('src_wh')
                dest_wh = r.get('dest_wh')
                src_loc = r.get('src_loc')
                dest_loc= r.get('dest_loc')

                is_production = False
                if t_type in packaging_types:
                    is_production = True
                elif (src_loc is None) and (dest_loc is not None):
                    # ورود بدون مبدأ → ایجاد موجودی (اغلب تولید ثبت‌شده)
                    is_production = True
                elif src_wh == prod_wh and (dest_wh is not None) and (dest_wh != src_wh):
                    # خروج از انبار تولید به انبار دیگر برای کالای پک
                    is_production = True

                if is_production:
                    produced_by_day[d] += qty
                    total_produced += qty

            if total_produced <= 0:
                return {
                    'pack_item_id': pack_item_id,
                    'date_from': d_from, 'date_to': d_to,
                    'produced_qty': 0.0,
                    'bulk': [], 'pack': []
                }

            # 2) استاندارد بر پایهٔ BOM تاریخی هر روز × تولید همان روز
            std_bulk = defaultdict(float)  # item_id -> qty
            std_pack = defaultdict(float)  # item_id -> qty
            for day, qty in produced_by_day.items():
                try:
                    bom_raw = self.get_flat_bom_for_pack_as_of(pack_item_id, day)
                except Exception:
                    # اگر BOM آن روز ناقص بود، از آن روز صرف‌نظر می‌کنیم تا گزارش کل قطع نشود
                    continue
                bom = _normalize_bom_structure(bom_raw)
                # فله
                for bp in bom.get('bulk_parts') or []:
                    std_bulk[int(bp['item_id'])] += float(bp.get('qty_per_pack') or 0.0) * float(qty)
                # لوازم بسته‌بندی
                for pi in bom.get('pack_items') or []:
                    std_pack[int(pi['item_id'])] += float(pi.get('qty_per_pack') or 0.0) * float(qty)

            # 3) مصرف «واقعی» = خالص خروج از انبار تولید در بازه برای همان اقلام
            def _actual_consumption_for(items_map: dict) -> dict:
                if not items_map:
                    return {}
                ids = list(items_map.keys())
                q = """
                    SELECT t.item_id,
                        COALESCE(SUM(CASE WHEN sw.name = %s THEN t.qty ELSE 0 END),0) AS out_qty,
                        COALESCE(SUM(CASE WHEN dw.name = %s THEN t.qty ELSE 0 END),0) AS in_qty
                    FROM trans t
                    LEFT JOIN locations sl ON t.src_loc = sl.id
                    LEFT JOIN warehouses sw ON sl.warehouse_id = sw.id
                    LEFT JOIN locations dl ON t.dest_loc = dl.id
                    LEFT JOIN warehouses dw ON dl.warehouse_id = dw.id
                    WHERE t.item_id = ANY(%s)
                    AND DATE(t.t_date) BETWEEN %s AND %s
                    AND (t.status IS NULL OR t.status = 'تایید شده')
                    GROUP BY t.item_id
                """
                rows = self.execute_query(q, (prod_wh, prod_wh, ids, d_from, d_to), cursor=cur) or []
                act = {}
                for r in rows:
                    # خالص کاهش موجودی در انبار تولید = خروج - ورود
                    net = float(r.get('out_qty') or 0.0) - float(r.get('in_qty') or 0.0)
                    act[int(r['item_id'])] = max(0.0, net)
                # اگر بعضی اقلام تراکنشی نداشتند → صفر
                for k in ids:
                    act.setdefault(int(k), 0.0)
                return act

            act_bulk = _actual_consumption_for(std_bulk)
            act_pack = _actual_consumption_for(std_pack)

            def _merge(std_map: dict, act_map: dict):
                out = []
                for k, std in std_map.items():
                    act = float(act_map.get(k, 0.0))
                    var = act - std
                    var_pct = (var / std) if std > 0 else None
                    out.append({'item_id': int(k), 'std': float(std), 'act': float(act), 'var': float(var), 'var_pct': (float(var_pct) if var_pct is not None else None)})
                return out

            return {
                'pack_item_id': pack_item_id,
                'date_from': d_from, 'date_to': d_to,
                'produced_qty': float(total_produced),
                'bulk': _merge(std_bulk, act_bulk),
                'pack': _merge(std_pack, act_pack)
            }
    # END ADD: DB.get_consumption_variance_for_pack

    
# در کلاس DB، این متد را جایگزین کنید

    def list_bom_financial(self, pcode: str):
        """گزارش BOM مالی را برای یک بچ خاص با منطق گروه‌بندی ایجاد می‌کند."""
        query = """
            SELECT raw.name as raw_item_name, raw.reporting_group, b.qty
            FROM bill_of_materials b
            JOIN items raw ON raw.id = b.raw_item_id
            WHERE b.product_code = %s
        """
        raw_rows = self.execute_query(query, (pcode,))
        
        report_data = {}
        # منطق پردازش داده بدون تغییر باقی می‌ماند
        for row in raw_rows:
            rep_group = row.get('reporting_group')
            if rep_group and rep_group.strip():
                group_name = rep_group
                if group_name not in report_data: report_data[group_name] = 0
                report_data[group_name] += row['qty']
            else:
                item_name = row['raw_item_name']
                report_data[item_name] = report_data.get(item_name, 0) + row['qty']
        
        return [{'ماده اولیه': name, 'مقدار مصرف': value} for name, value in report_data.items()]  
    
    def list_bom_quantitative(self, pcode: str):
        """
        گزارش BOM «فقط مقداری» و «حفظ محرمانگی».
        به‌جای نام مادهٔ خام، فقط نام گروه گزارش (reporting_group) را برمی‌گرداند.
        خروجی: list[{'group_name': str, 'total_qty': float}]
        """
        query = """
            SELECT
                COALESCE(NULLIF(raw.reporting_group, ''), 'سایر') AS group_name,
                SUM(b.qty) AS total_qty
            FROM bill_of_materials b
            JOIN items raw ON raw.id = b.raw_item_id
            WHERE b.product_code = %s
            GROUP BY COALESCE(NULLIF(raw.reporting_group, ''), 'سایر')
            ORDER BY group_name ASC
        """
        rows = self.execute_query(query, (pcode,))
        return rows or []
      

            

    def get_available_batches(self, item_name: str, location_id: int):
        """
        لیست بچ‌های مختلف یک کالا با نام مشخص را در یک لوکیشن خاص،
        به همراه موجودی هر بچ، و مرتب شده بر اساس تاریخ ورود (FIFO) برمی‌گرداند.
        """
        with self._conn() as conn:
            with conn.cursor() as cur:
                # این کوئری تمام آیتم‌هایی (بچ‌های مختلف) که نام یکسان دارند
                # و در لوکیشن مورد نظر موجودی دارند را واکشی می‌کند.
                query = """
                    SELECT
                        i.id,
                        i.batch,
                        s.qty,
                        i.ent_date
                    FROM stock s
                    JOIN items i ON s.item_id = i.id
                    WHERE i.name = %s AND s.location_id = %s AND s.qty > 0
                    ORDER BY i.ent_date ASC, i.id ASC
                """
                cur.execute(query, (item_name, location_id))
                return cur.fetchall()
     
# در کلاس DB، این متد را جایگزین کنید
    def get_production_summary_last_n_days(self, days: int = 7):
        """
        مجموع مقدار محصولات نهایی تایید شده در n روز گذشته را به تفکیک روز برمی‌گرداند.
        نسخه اصلاح شده با پارامترگذاری امن.
        """
        query = """
            SELECT 
                DATE(processed_at) as production_date,
                SUM(quantity) as total_quantity
            FROM production_deliveries
            WHERE 
                status = 'تایید شده' AND 
                processed_at >= NOW() - (%s * INTERVAL '1 day')
            GROUP BY production_date
            ORDER BY production_date ASC;
        """
        return self.execute_query(query, (days,))
    
    
    # این متد جدید را به کلاس DB اضافه کنید
    def get_components_at_production_location(self):
        """تمام محصولات موجود در کف کارگاه (برای استفاده به عنوان جزء) را برمی‌گرداند."""
        prod_loc_id = self.get_production_floor_location()
        if not prod_loc_id:
            return []
        # این کوئری دیگر فیلتر is_packed را ندارد
        return self.get_finished_goods_at_location(prod_loc_id, packed_only=False)

    def get_finished_goods_at_location(self, location_id: int, packed_only: bool = True):
        """کالاهای 'محصول نهایی' در یک لوکیشن به‌همراه واحد و parent."""
        query = """
            SELECT i.id AS item_id, i.name, i.parent_item_id,
                s.batch_no, s.qty, COALESCE(u.name,'') AS unit, s.expiry_date
            FROM stock s
            JOIN items i      ON s.item_id = i.id
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE s.location_id = %s AND i.category = %s AND s.qty > 0
        """
        params = [location_id, CATEGORY_FINAL_PRODUCT]
        if packed_only:
            query += " AND i.is_packed = TRUE"
        query += " ORDER BY i.name, s.batch_no"
        return self.execute_query(query, tuple(params))
                                                                
    # در کلاس DB
    def request_delivery_from_production(self, product_name: str, batch_no: str, quantity: float, supervisor_user_id: int, expiry_date: dt.date = None):
        with self.transaction() as cur:
            cur.execute(
                "INSERT INTO production_deliveries (product_name, production_batch_no, quantity, status, supervisor_user_id, expiry_date) "
                "VALUES (%s, %s, %s, 'تولید شده', %s, %s) RETURNING id",
                (product_name, batch_no, quantity, supervisor_user_id, expiry_date)
            )
            # --- اصلاح کلیدی: برگرداندن ID ---
            new_id = cur.fetchone()['id']
            self._log_atomic(cur, supervisor_user_id, 'REQUEST_DELIVERY', f"Product:{product_name}, Batch:{batch_no}, Qty:{quantity}")
            return new_id
                    
# در کلاس DB، این متد را با نسخه زیر جایگزین کنید
    def get_item_locations_with_stock(self, item_id: int, include_warehouses: list = None, exclude_warehouses: list = None):
        """
        نسخه نهایی و صحیح:
        لیست تمام بچ‌های یک کالا را از تمام لوکیشن‌های داخل انبارهای مشخص شده برمی‌گرداند.
        """
        query = """
            SELECT 
                l.id, 
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label, 
                s.qty, 
                s.batch_no
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0
        """
        params = [item_id]

        conditions = []
        if include_warehouses:
            # ایجاد placeholder به تعداد اعضای لیست
            placeholders = ','.join(['%s'] * len(include_warehouses))
            conditions.append(f"w.name IN ({placeholders})")
            params.extend(include_warehouses)
        
        if exclude_warehouses:
            placeholders = ','.join(['%s'] * len(exclude_warehouses))
            conditions.append(f"w.name NOT IN ({placeholders})")
            params.extend(exclude_warehouses)

        if conditions:
            query += " AND " + " AND ".join(conditions)
        
        query += " ORDER BY w.name, l.rack, s.batch_no;"
        
        return self.execute_query(query, tuple(params))
        
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def delete_items_by_ids(self, item_ids: list, user_id: int):
        """
        نسخه نهایی و امن:
        کالاها را فقط در صورتی حذف می‌کند که هیچ سابقه تاریخی یا وابستگی در هیچ ماژولی نداشته باشند.
        """
        if not item_ids:
            return

        with self.transaction() as cur:
            placeholders = ','.join(['%s'] * len(item_ids))
            
            # چک کردن وابستگی به عنوان محصول مادر (بدون تغییر)
            query_check_children = f"SELECT parent_item_id FROM items WHERE parent_item_id IN ({placeholders}) LIMIT 1"
            parent_in_use = self.execute_query(query_check_children, tuple(item_ids), fetch_one=True, cursor=cur)
            if parent_in_use:
                parent_id = parent_in_use['parent_item_id']
                parent_name_rec = self.execute_query("SELECT name FROM items WHERE id = %s", (parent_id,), fetch_one=True, cursor=cur)
                parent_name = parent_name_rec['name'] if parent_name_rec else "کالای انتخاب شده"
                raise ValueError(f"کالای «{parent_name}» قابل حذف نیست زیرا به عنوان محصول مادر برای یک یا چند پک دیگر تعریف شده است.")

            # --- *** اصلاح کلیدی: افزودن جداول فراموش شده به لیست بررسی *** ---
            tables_to_check = {
                'trans': 'تراکنش‌ها',
                'stock': 'موجودی انبار',
                'purchase_requests': 'درخواست‌های خرید',
                'purchase_order_items': 'اقلام سفارشات خرید',
                'sales_order_items': 'اقلام سفارشات فروش',
                'recipe_ingredients': 'دستورهای ساخت (BOM)'
            }
            # --- ********************************************************** ---

            for table, fa_name in tables_to_check.items():
                column = 'raw_material_item_id' if table == 'recipe_ingredients' else 'item_id'
                
                query_check = f"SELECT {column} FROM {table} WHERE {column} IN ({placeholders}) LIMIT 1"
                
                referenced_item = self.execute_query(query_check, tuple(item_ids), fetch_one=True, cursor=cur)
                
                if referenced_item:
                    item_id_with_history = referenced_item[column]
                    item_name_rec = self.execute_query("SELECT name FROM items WHERE id = %s", (item_id_with_history,), fetch_one=True, cursor=cur)
                    item_name = item_name_rec['name'] if item_name_rec else "کالای حذف شده"
                    raise ValueError(f"کالای «{item_name}» قابل حذف نیست زیرا در بخش «{fa_name}» دارای سابقه است.")

            # اگر هیچ سابقه‌ای پیدا نشد، حذف کن
            query_delete = f"DELETE FROM items WHERE id IN ({placeholders})"
            self.execute_query(query_delete, tuple(item_ids), cursor=cur)
            
            log_details = f"Deleted item IDs with no history: {item_ids}"
            self._log_atomic(cur, user_id, 'DELETE_ITEMS_SAFE', log_details)
                        
                                                                            
    def list_locations_for_warehouse(self, warehouse_name: str):
            """لیست تمام لوکیشن‌های یک انبار مشخص را برمی‌گرداند."""
            query = """
                SELECT l.id, w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label
                FROM locations l
                JOIN warehouses w ON w.id = l.warehouse_id
                WHERE w.name = %s
                ORDER BY l.id
            """
            return self.execute_query(query, (warehouse_name,))
            
            

            
            
                                
    def get_pending_voids(self):
        """نسخه جدید: تراکنش‌هایی که وضعیتشان 'در انتظار تایید ابطال' است را واکشی می‌کند."""
        query = """
            SELECT t.id, t.id as voids_trans_id, t.t_type as original_type, i.name AS item_name, t.qty 
            FROM trans AS t
            JOIN items AS i ON t.item_id = i.id
            WHERE t.status = 'در انتظار تایید ابطال'
        """
        return self.execute_query(query)            
    # ═════════════════════════════════════════════
    #         توابع جدید برای مدیریت نقش‌ها
    # ═════════════════════════════════════════════
# در کلاس DB، این متد را جایگزین کنید

    def get_all_roles(self):
        """
        تمام نقش‌های تعریف شده در سیستم را برمی‌گرداند.
        نسخه نهایی: از ابزار استاندارد execute_query استفاده می‌کند.
        """
        return self.execute_query("SELECT id, name FROM roles ORDER BY name")
    
    def get_all_permissions(self):
        """تمام دسترسی‌های ممکن در سیستم را برمی‌گرداند."""
        return self.execute_query("SELECT id, code, description FROM permissions ORDER BY code")

    def get_permissions_for_role(self, role_id: int):
        """تمام IDهای دسترسی برای یک نقش خاص را برمی‌گرداند."""
        rows = self.execute_query("SELECT permission_id FROM role_permissions WHERE role_id = %s", (role_id,))
        return [row['permission_id'] for row in rows]

# در کلاس DB، این متد را جایگزین کنید

    def add_role(self, role_name: str):
        """یک نقش جدید به سیستم به صورت اتمیک اضافه می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "INSERT INTO roles (name) VALUES (%s) ON CONFLICT (name) DO NOTHING",
                (role_name,),
                cursor=cur
            )
            
    def check_role_in_use(self, role_id: int):
            """
            بررسی می‌کند که آیا یک نقش به کاربری اختصاص یافته یا خیر و لیست کاربران را برمی‌گرداند.
            """
            # **FIX**: استفاده از تابع صحیح execute_query به جای _execute
            users_with_role = self.execute_query("SELECT username FROM users WHERE role_id = %s", (role_id,))
            
            if users_with_role:
                # اگر کاربری وجود داشت، لیست نام‌هایشان را برگردان
                return [u['username'] for u in users_with_role]
            # اگر هیچ کاربری نبود، None برگردان
            return None
        
    def get_role_name(self, role_id: int) -> str:
        """
        نام نقش را برمی‌گرداند. در صورت نبود، رشتهٔ خالی.
        """
        if not role_id:
            return ""
        try:
            row = self.execute_query("SELECT name FROM roles WHERE id=%s", (int(role_id),))
            if not row:
                return ""
            r = row[0]
            return (r["name"] if isinstance(r, dict) else (r[0] if r else "")) or ""
        except Exception:
            return ""
        
    def _infer_approval_stage_from_role(self, role_name: str) -> str | None:
        """
        از روی نام نقش، مرحلهٔ تأیید را حدس می‌زند.
        - CEO → 'CEO'
        - بازرگانی/تأمین/خرید → 'COMMERCE'
        - مدیر واحد/سرپرست/مدیر → 'DEPT_MANAGER'
        """
        ru = (role_name or "").strip().upper()
        if "CEO" in ru:
            return "CEO"
        if any(k in ru for k in ("COMMERCE", "PURCHAS", "PURCHASE", "SOURC", "PROCURE")):
            return "COMMERCE"
        if any(k in ru for k in ("DEPT", "UNIT", "MANAGER", "SUPERVISOR", "HEAD")):
            return "DEPT_MANAGER"
        return None
    
    def _safe_log(self, cur, user_id: int, action: str, details: str = ""):
        """
        رَپر بی‌خطر برای لاگ‌گذاری؛ در صورت خطا سکوت می‌کند تا رفتار بیرونی تغییر نکند.
        """
        try:
            self._log_atomic(cur, user_id, action, details)
        except Exception:
            pass

    
    def delete_role(self, role_id: int):
        """
        حذف ایمن نقش:
        - اگر به کاربر اختصاص داده شده باشد، حذف را متوقف می‌کند (پیام خوانا).
        - وابستگی به workflow_steps حذف شد.
        """
        # 1) جلوگیری از حذف نقش‌های در حال استفاده توسط کاربران
        users_in_role = self.check_role_in_use(role_id)
        if users_in_role:
            user_list = ", ".join(users_in_role)
            raise ValueError(f"این نقش به کاربران زیر تخصیص یافته و قابل حذف نیست: {user_list}")

        # 2) (حذف امن) هیچ ارجاعی به workflow_steps بررسی نمی‌شود.

        # 3) حذف نهایی
        with self.transaction() as cur:
            self.execute_query("DELETE FROM roles WHERE id = %s", (role_id,), cursor=cur)
                            
# در کلاس DB، این متد را با نسخه نهایی و قطعی زیر جایگزین کنید
    def update_permissions_for_role(self, role_id: int, permission_ids: list):
        """
        نسخه نهایی و استاندارد (V2.0):
        - از context manager استاندارد برنامه برای تضمین ثبت قطعی تغییرات استفاده می‌کند.
        """
        try:
            with self.transaction() as cur:
                # گام ۱: حذف دسترسی‌های قدیمی
                cur.execute("DELETE FROM role_permissions WHERE role_id = %s", (role_id,))
                
                # گام ۲: افزودن دسترسی‌های جدید
                if permission_ids:
                    args_list = [(role_id, perm_id) for perm_id in permission_ids]
                    cur.executemany(
                        "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s)",
                        args_list
                    )
            print(f"SUCCESS: Permissions for role_id {role_id} transaction block finished.")
        except Exception as e:
            print(f"ERROR during permission update. Transaction should have rolled back. Reason: {e}")
            # خطا را دوباره ارسال می‌کنیم تا به کاربر نمایش داده شود
            raise e
        
        
    def get_item_locations_in_warehouse(self, item_id: int, warehouse_name: str):
        """لیست و موجودی لوکیشن‌هایی که یک کالا در یک انبار خاص دارد را برمی‌گرداند."""
        query = """
            SELECT l.id, w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label, s.qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0 AND w.name = %s
            ORDER BY l.rack, l.shelf, l.bin;
        """
        return self.execute_query(query, (item_id, warehouse_name))
    
    # BEGIN ADD: DB.submit_material_request_bulk
    def submit_material_request_bulk(self, lines: list[dict], requester_id: int, notes: str = '') -> int:
        """
        ثبت «یک سند درخواست مواد/لوازم» با چند قلم در یک شماره سند.
        - از زیرساخت موجود استفاده می‌کند و تغییری در توابع قدیمی نمی‌دهد.
        - برای سازگاری، برای هر قلم یک ردیف در material_requests (child) درج می‌شود
        و همه با ستون parent_request_id به یک رکورد «سربرگ» متصل می‌شوند.
        - اگر جدول material_request_items در دسترس باشد، ردیف‌های آن نیز پر می‌شود.
        خروجی: شناسهٔ سند (id سربرگ) که می‌تواند به صورت MR-<id> نمایش داده شود.
        """
        # پاک‌سازی ورودی‌ها
        clean_lines = []
        if lines:
            for ln in lines:
                try:
                    iid = int(ln.get('item_id'))
                    qty = float(ln.get('quantity'))
                    if iid > 0 and qty > 0:
                        clean_lines.append({'item_id': iid, 'quantity': qty})
                except Exception:
                    continue
        if not clean_lines:
            raise ValueError("هیچ قلم معتبری برای ثبت در درخواست وجود ندارد.")
        
        with self.transaction() as cur:
            # ستون‌های جدول درخواست
            try:
                mr_cols = set(self._get_existing_columns('material_requests', cursor=cur))
            except Exception:
                mr_cols = set()
            has = mr_cols.__contains__
            
            # اطمینان از وجود requester_user_id (بی‌خطر)
            if not has('requester_user_id') and has('requester_id'):
                try:
                    cur.execute("ALTER TABLE material_requests ADD COLUMN IF NOT EXISTS requester_user_id INTEGER")
                    mr_cols = set(self._get_existing_columns('material_requests', cursor=cur))
                    has = mr_cols.__contains__
                except Exception:
                    pass
            
            # 1) درج سربرگ (بدون item_id)
            hdr_cols = []
            hdr_vals = []
            if has('requester_user_id'):
                hdr_cols += ['requester_user_id']; hdr_vals += [requester_id]
            elif has('requester_id'):
                hdr_cols += ['requester_id']; hdr_vals += [requester_id]
            if has('status'):
                hdr_cols += ['status']; hdr_vals += [TransactionStatus.MR_PENDING.value]
            if has('notes'):
                hdr_cols += ['notes']; hdr_vals += [notes or 'سند چندقلمه']
            if has('created_at'):
                hdr_cols += ['created_at']; hdr_vals += [None]  # DEFAULT NOW()
            
            placeholders = ",".join(['%s']*len(hdr_cols)) if hdr_cols else ""
            cols_sql = f"({', '.join(hdr_cols)})" if hdr_cols else "()"
            insert_hdr = f"INSERT INTO material_requests {cols_sql} VALUES ({placeholders}) RETURNING id" if hdr_cols else "INSERT INTO material_requests DEFAULT VALUES RETURNING id"
            cur.execute(insert_hdr, tuple(hdr_vals) if hdr_vals else None)
            parent_id = cur.fetchone()[0]
            
            # 2) درج اقلام در material_requests (child)
            parentable = has('parent_request_id')
            for ln in clean_lines:
                cols = ['item_id']
                vals = [ln['item_id']]
                if has('requested_qty'): cols.append('requested_qty'); vals.append(ln['quantity'])
                elif has('qty'): cols.append('qty'); vals.append(ln['quantity'])
                if has('status'): cols.append('status'); vals.append(TransactionStatus.MR_PENDING.value)
                if has('requester_user_id'): cols.append('requester_user_id'); vals.append(requester_id)
                elif has('requester_id'): cols.append('requester_id'); vals.append(requester_id)
                if parentable: cols.append('parent_request_id'); vals.append(parent_id)
                if has('notes'): cols.append('notes'); vals.append((notes or '') + f" | زیرسندِ MR-{parent_id}")
                if has('created_at'): cols.append('created_at'); vals.append(None)  # DEFAULT NOW()
                
                cur.execute(f"INSERT INTO material_requests ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(cols))})", tuple(vals))
            
            # 3) در صورت وجود جدول اقلام، آن را نیز پر کن
            try:
                mri_cols = set(self._get_existing_columns('material_request_items', cursor=cur))
            except Exception:
                mri_cols = set()
            
            if mri_cols:
                has_i = mri_cols.__contains__
                for ln in clean_lines:
                    cols = []
                    vals = []
                    if has_i('request_id'): cols.append('request_id'); vals.append(parent_id)
                    if has_i('item_id'): cols.append('item_id'); vals.append(ln['item_id'])
                    if has_i('requested_qty'): cols.append('requested_qty'); vals.append(ln['quantity'])
                    elif has_i('qty'): cols.append('qty'); vals.append(ln['quantity'])
                    cur.execute(f"INSERT INTO material_request_items ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(cols))})", tuple(vals))
            
            # 4) لاگ و نوتیفیکیشن
            self._log_atomic(cur, requester_id, 'ADD_MATERIAL_REQUEST_BULK', f"MR-{parent_id} ({len(clean_lines)} lines)")
            try:
                if hasattr(self, 'signals') and hasattr(self.signals, 'dataChanged'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass
            
            return parent_id
    # END ADD: DB.submit_material_request_bulk

    
                                                
                                                                    
    
    def get_packed_batches_in_location(self, location_id: int):
        """
        لیست تمام بچ‌های محصولات بسته‌بندی شده که در یک لوکیشن خاص موجودی دارند را برمی‌گرداند.
        """
        query = """
            SELECT s.batch_no, i.name, s.qty
            FROM stock s
            JOIN items i ON s.item_id = i.id
            WHERE s.location_id = %s AND i.is_packed = TRUE AND s.qty > 0
            ORDER BY s.id DESC;
        """
        return self.execute_query(query, (location_id,))
    
    # BEGIN REWRITE: DB.submit_material_request
    def submit_material_request(self, item_id: int, requested_qty: float, requester_id: int, notes: str = ''):
        """
        ثبت «درخواست مواد اولیه» با سازگاری با نسخه‌های قدیمی DB:
        - اگر ستون‌های جدید مثل requester_user_id یا created_at موجود نباشند، درج بدون آن‌ها انجام می‌شود.
        - کمبود موجودی فقط در یادداشت هشدار می‌دهد و مانع ثبت نمی‌شود.
        - از زیرساخت موجود (transaction/_get_existing_columns/_log_atomic/signals) استفاده می‌کند.
        """
        with self.transaction() as cur:
            # 1) کشف/ترمیم نرم ستون‌ها
            try:
                cols = set(self._get_existing_columns('material_requests', cursor=cur))
            except Exception:
                cols = set()
            # در صورت نبود requester_user_id سعی می‌کنیم اضافه‌اش کنیم (بی‌خطر)
            if 'requester_user_id' not in cols:
                try:
                    cur.execute("ALTER TABLE material_requests ADD COLUMN IF NOT EXISTS requester_user_id INTEGER")
                    cols = set(self._get_existing_columns('material_requests', cursor=cur))
                except Exception:
                    pass  # اگر موفق نشد، در درج با requester_id ادامه می‌دهیم

            # 2) بررسی موجودی انبارهای غیرتولیدی (اطلاع صرف)
            try:
                cur.execute(
                    """
                    SELECT COALESCE(SUM(s.qty), 0) AS total_available
                    FROM stock s
                    JOIN locations l  ON s.location_id = l.id
                    JOIN warehouses w ON l.warehouse_id = w.id
                    WHERE s.item_id = %s AND w.name != %s;
                    """,
                    (item_id, PRODUCTION_WAREHOUSE_NAME)
                )
                row = cur.fetchone()
                available_qty = row['total_available'] if row else 0
            except Exception:
                available_qty = None  # در صورت ناسازگاری، بررسی موجودی را نادیده می‌گیریم

            if isinstance(available_qty, (int, float)) and available_qty < requested_qty:
                warn = f"توجه: موجودی انبار اصلی ({available_qty}) از مقدار درخواستی کمتر است. نیازمند تامین."
                notes = (notes + " | " + warn).strip(" |") if notes else warn

            # 3) ساخت INSERT متناسب با ستون‌های موجود
            insert_cols = ['item_id', 'requested_qty']
            placeholders = ['%s', '%s']
            params = [item_id, requested_qty]

            # ستونِ درخواست‌کننده: اولویت با requester_user_id
            if 'requester_user_id' in cols:
                insert_cols.append('requester_user_id'); placeholders.append('%s'); params.append(requester_id)
            elif 'requester_id' in cols:
                insert_cols.append('requester_id'); placeholders.append('%s'); params.append(requester_id)

            # وضعیت
            insert_cols.append('status'); placeholders.append('%s'); params.append(TransactionStatus.MR_PENDING.value)

            # created_at اگر باشد، از NOW() استفاده کنیم (بدون پارامتر)
            if 'created_at' in cols:
                insert_cols.append('created_at'); placeholders.append('NOW()')

            # notes اگر وجود داشته باشد
            if 'notes' in cols:
                insert_cols.append('notes'); placeholders.append('%s'); params.append(notes)

            sql = f"INSERT INTO material_requests ({', '.join(insert_cols)}) VALUES ({', '.join(placeholders)}) RETURNING id"
            cur.execute(sql, tuple(params))
            res = cur.fetchone()
            request_id = res['id'] if res else None

            # 4) لاگ و سیگنال
            try:
                self._log_atomic(cur, requester_id, 'SUBMIT_MATERIAL_REQUEST', f"Request ID:{request_id}")
            except Exception:
                pass
            try:
                if hasattr(self, 'signals') and hasattr(self.signals, 'dataChanged'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass

            return request_id
    # END REWRITE: DB.submit_material_request
            
    # BEGIN REWRITE: DB.get_pending_material_requests
    def get_pending_material_requests(self) -> list[dict]:
        """
        فقط درخواست‌های «در انتظار رسیدگی انبار» را برمی‌گرداند.
        خروجی: [{id,item_id,item_name,requested_qty,requester_name,created_at,status,notes,(fulfilled_qty)}]
        """ 
        # پیدا کردن جدول
        candidate_tables = ['material_requests', 'internal_material_requests', 'internal_requests', 'store_requests']
        tbl = None
        for t in candidate_tables:
            try:
                row = self.execute_query(
                    "SELECT 1 FROM information_schema.tables WHERE table_name=%s LIMIT 1",
                    (t,), fetch_one=True
                )
                if row:
                    tbl = t
                    break
            except Exception:
                pass
        if not tbl:
            return []

        # کشف ستون‌ها
        try:
            cols = set(self._get_existing_columns(tbl))
        except Exception:
            cols = set()

        def pick(*names):
            for n in names:
                if n in cols:
                    return n
            return None

        item_col    = pick('item_id', 'product_id', 'inventory_item_id')
        qty_col     = pick('requested_qty', 'qty', 'quantity', 'amount')
        status_col  = pick('status', 'state')
        created_col = pick('created_at', 'createdon', 'request_date', 'created', 'created_ts', 'created_time')
        notes_col   = pick('notes', 'note', 'description', 'reject_reason')
        req_usercol = pick('requester_user_id', 'requester_id', 'user_id', 'requested_by')
        fulfilled_c = pick('fulfilled_qty', 'supplied_qty')

        if not item_col or not qty_col:
            return []

        # عبارت نام کاربر (بدون وابستگی به helper)
        uname = ("NULLIF(TRIM(COALESCE(u.full_name, "
                "NULLIF(TRIM(COALESCE(u.first_name,'') || ' ' || COALESCE(u.last_name,'')), ''), "
                "u.username)), '')")

        # وضعیت‌های «در انتظار» (فارسی و انگلیسی)
        persian_pending = []
        try:
            persian_pending.append(TransactionStatus.MR_PENDING.value)  # «در انتظار رسیدگی انبار»
        except Exception:
            pass
        try:
            persian_pending.append(getattr(TransactionStatus, 'MR_REWORK_WAREHOUSE').value)  # اگر وجود داشت
        except Exception:
            pass
        english_pending = ("'pending','submitted','awaiting_approval','awaiting_fulfillment','awaiting_warehouse'")

        # SELECT
        sel = [
            "mr.id AS id",
            f"mr.{item_col} AS item_id",
            "i.name AS item_name",
            f"COALESCE(mr.{qty_col}, 0) AS requested_qty",
            f"COALESCE({uname}, '-') AS requester_name",
            (f"mr.{created_col}" if created_col else "NOW()") + " AS created_at",
            (f"COALESCE(mr.{status_col}, '')" if status_col else "''") + " AS status",
            (f"COALESCE(mr.{notes_col}, '')" if notes_col else "''") + " AS notes",
        ]
        if fulfilled_c:
            sel.append(f"COALESCE(mr.{fulfilled_c}, 0) AS fulfilled_qty")

        sql = f"""
            SELECT {", ".join(sel)}
            FROM {tbl} mr
            JOIN items i ON i.id = mr.{item_col}
            {"LEFT JOIN users u ON u.id = mr." + req_usercol if req_usercol else ""}
        """

        # WHERE: فقط معلق‌ها
        params = []
        completion_guard = ""
        if fulfilled_c and qty_col:
            # قید تکمیل: فقط درخواست‌هایی که هنوز کامل نشده‌اند
            completion_guard = f" AND COALESCE(mr.{fulfilled_c},0) < COALESCE(mr.{qty_col},0)"

        if status_col:
            where_parts = [
                f"LOWER(COALESCE(mr.{status_col}, '')) IN ({english_pending})",
            ]
            # فارسی‌ها را با پارامتر اضافه می‌کنیم
            for _ in persian_pending:
                where_parts.append(f"mr.{status_col} = %s")
            # کمبود موجودی
            where_parts.append(f"mr.{status_col} LIKE 'نیازمند تامین%%'")
            sql += " WHERE (" + " OR ".join(where_parts) + ")"
            sql += completion_guard
            params.extend(persian_pending)
        else:
            # اگر ستون وضعیت نداریم، فقط با قید تکمیل کار می‌کنیم تا امن بماند
            if completion_guard:
                sql += " WHERE 1=1 " + completion_guard

        sql += " ORDER BY mr.id DESC"

        try:
            return self.execute_query(sql, tuple(params) if params else None) or []
        except Exception:
            # نسخه ساده بدون WHERE (اگر طرح DB خیلی متفاوت بود)
            fallback = f"""
                SELECT mr.id AS id, mr.{item_col} AS item_id, i.name AS item_name,
                    COALESCE(mr.{qty_col}, 0) AS requested_qty,
                    '-' AS requester_name,
                    {("mr."+created_col) if created_col else "NOW()"} AS created_at,
                    {("COALESCE(mr."+status_col+", '')") if status_col else "''"} AS status,
                    {("COALESCE(mr."+notes_col+", '')") if notes_col else "''"} AS notes
                FROM {tbl} mr
                JOIN items i ON i.id = mr.{item_col}
                ORDER BY mr.id DESC
            """
            return self.execute_query(fallback, None) or []
    # END REWRITE: DB.get_pending_material_requests
        
    def get_request_history_for_user(self, user_id: int):
        """تاریخچه تمام درخواست‌های ثبت شده توسط یک کاربر خاص را برمی‌گرداند."""
        query = """
            SELECT 
                mr.id, i.name as item_name, mr.requested_qty, mr.status, 
                mr.created_at, mr.processed_at, mr.notes
            FROM material_requests mr
            JOIN items i ON mr.item_id = i.id
            WHERE mr.requester_user_id = %s
            ORDER BY mr.id DESC;
        """
        return self.execute_query(query, (user_id,))    
        
    # ------------------- [DB class] fulfill_material_request -------------------
    def fulfill_material_request(self, request_id: int, user_id: int, trans_data: dict):
        """
        خروج به تولید + بروزرسانی وضعیت درخواست.
        بعد از موفقیت: ناتیف متناظر را resolved می‌کنیم تا برنگردد.
        """
        with self.transaction() as cur:
            # گام ۱: کسر موجودی (بدون تغییر نسبت به منطق شما)
            self._upd_stock(
                cur,
                trans_data['item_id'],
                trans_data['src_loc_id'],
                -abs(trans_data['qty']),
                trans_data['batch_no'],
                trans_data.get('expiry_date')
            )

            # گام ۲: ثبت تراکنش خروج به تولید (بدون تغییر نسبت به منطق شما)
            cur.execute(
                """
                INSERT INTO trans(item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date)
                VALUES (%s,'خروج به تولید', NULL, NOW(), %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
                """,
                (
                    trans_data['item_id'],
                    -abs(trans_data['qty']),
                    trans_data.get('notes'),
                    user_id,
                    trans_data['src_loc_id'],
                    self.get_production_floor_location(),
                    TransactionStatus.PENDING_PRODUCTION_APPROVAL.value,
                    trans_data['batch_no'],
                    trans_data.get('expiry_date')
                )
            )
            trans_id = cur.fetchone()['id']

            # گام ۳: بروزرسانی خود درخواست
            notes = f"این درخواست طی تراکنش خروج به تولید با شناسه {trans_id} انجام شد."
            cur.execute(
                "UPDATE material_requests SET status='FULFILLED', processed_by_user_id=%s, processed_at=NOW(), notes=COALESCE(notes,'') || E'\n' || %s WHERE id=%s",
                (user_id, notes, request_id)
            )

        try:
            self.mark_notification_resolved('FULFILL_REQUEST', request_id)
            self._dbg(f"[TRACE:NOTIF:store] resolved key=FULFILL_REQUEST:{request_id}")
        except Exception as e:
            self._dbg(f"[TRACE:NOTIF:store] resolve-failed: {e}")
        return trans_id        
    # در کلاس DB، این متد جدید را اضافه کنید
    def get_pending_transfers_to_production(self):
        """تمام تراکنش‌های خروج به تولید که منتظر تایید سرپرست تولید هستند را برمی‌گرداند."""
        query = """
            SELECT
                t.id, i.name as item_name, t.t_no, t.qty, u.username as requester, t.t_date, t.batch_no
            FROM trans t
            JOIN items i ON t.item_id = i.id
            JOIN users u ON t.user_id = u.id
            WHERE t.status = 'در انتظار تایید تولید'
            ORDER BY t.id DESC;
        """
        return self.execute_query(query)

    # BEGIN REWRITE: DB.finalize_transfer_to_production
    def finalize_transfer_to_production(self, anchor_id: int, approver_user_id: int, notes: str = ''):
        """
        تایید نهایی دریافت مواد اولیه در تولید (بدون QA).
        - anchor_id: شناسه یکی از ردیف‌های جدول trans (خروج به تولید).
        - همه اقلام با همان شماره سند (t_no) با هم تایید می‌شوند.
        - موجودی مقصد (لوکیشن تولید) افزوده می‌شود.
        - درخواست‌های مرتبط بدون اتکا به ستون‌های قدیمی مثل request_no به‌روز می‌شوند.
        """
        def _cols(tbl: str):
            try:
                return set(self._get_existing_columns(tbl))
            except Exception:
                return set()

        with self.transaction() as cur:
            trans_cols = _cols('trans')
            mr_cols    = _cols('material_requests')

            # 1) ردیف لنگر و شماره سند
            anchor = self.execute_query(
                "SELECT id" + (", t_no" if 't_no' in trans_cols else "") + " FROM trans WHERE id=%s LIMIT 1",
                (anchor_id,), fetch_one=True, cursor=cur
            )
            if not anchor:
                raise ValueError("Anchor transaction not found.")

            doc_no = anchor.get('t_no') if isinstance(anchor, dict) else None

            # 2) آوردن همهٔ ردیف‌های «خروج به تولید» که منتظر تایید تولید‌اند (همین سند)
            fields = ["t.id", "t.item_id", "t.qty"]
            if 'src_loc' in trans_cols:    fields.append("t.src_loc")
            if 'dest_loc' in trans_cols:   fields.append("t.dest_loc")
            if 'batch_no' in trans_cols:   fields.append("t.batch_no")
            if 'expiry_date' in trans_cols:fields.append("t.expiry_date")
            if 't_no' in trans_cols:       fields.append("t.t_no")
            if 'request_id' in trans_cols: fields.append("t.request_id")

            where = ["t.t_type = %s"]
            params = [TransactionType.EXIT_TO_PROD.value]

            if 'status' in trans_cols:
                where.append("t.status = %s")
                params.append(TransactionStatus.PENDING_PRODUCTION_APPROVAL.value)

            if 't_no' in trans_cols and doc_no:
                where.append("t.t_no = %s")
                params.append(doc_no)
            else:
                where.append("t.id = %s")
                params.append(anchor_id)

            rows = self.execute_query(
                f"SELECT {', '.join(fields)} FROM trans t WHERE {' AND '.join(where)} ORDER BY t.id",
                tuple(params), cursor=cur
            ) or []

            # تلاش دوم: اگر ستونی مثل status نبود/متفاوت بود، حداقل همان ردیف را تایید کنیم
            if not rows:
                rows = self.execute_query(
                    f"SELECT {', '.join(fields)} FROM trans t WHERE t.id=%s AND t.t_type=%s",
                    (anchor_id, TransactionType.EXIT_TO_PROD.value), cursor=cur
                ) or []

            if not rows:
                raise ValueError("No pending transfers found for this document.")

            # 3) پیدا کردن مقصد تولید در صورت نیاز
            def _resolve_dest_loc(dest_loc_id):
                if dest_loc_id:
                    return dest_loc_id
                try:
                    loc = self.get_production_floor_location()
                    if loc:
                        return loc
                except Exception:
                    pass
                try:
                    res = self.execute_query(
                        """
                        SELECT l.id
                        FROM locations l
                        JOIN warehouses w ON w.id = l.warehouse_id
                        WHERE w.name = %s
                        ORDER BY l.id LIMIT 1
                        """,
                        ('Production',), fetch_one=True, cursor=cur
                    )
                    if res and res.get('id'):
                        return res['id']
                except Exception:
                    pass
                return None

            # 4) افزودن موجودی مقصد و تایید تراکنش‌ها
            delivered_note = ("\n[Production approval] " + notes) if notes else "\n[Production approval]"
            for r in rows:
                item_id  = r['item_id']
                qty      = float(r.get('qty') or 0)
                dest_loc = _resolve_dest_loc(r.get('dest_loc') if 'dest_loc' in trans_cols else None)
                if not dest_loc:
                    raise ValueError("Production location is not configured.")

                # افزایش موجودی مقصد
                self._upd_stock(
                    cur,
                    item_id=item_id,
                    location_id=dest_loc,
                    qty_change=abs(qty),
                    batch_no=str(r.get('batch_no') or '') if 'batch_no' in trans_cols else '',
                    expiry_date=r.get('expiry_date') if 'expiry_date' in trans_cols else None
                )

                # تایید ردیف trans
                set_parts, upd_params = ["status=%s"], [TransactionStatus.APPROVED.value]
                if 'approved_by' in trans_cols:
                    set_parts.append("approved_by=%s"); upd_params.append(approver_user_id)
                elif 'approved_user_id' in trans_cols:
                    set_parts.append("approved_user_id=%s"); upd_params.append(approver_user_id)
                elif 'approver_id' in trans_cols:
                    set_parts.append("approver_id=%s"); upd_params.append(approver_user_id)
                if 'approved_at' in trans_cols:
                    set_parts.append("approved_at=NOW()")
                if 'notes' in trans_cols:
                    set_parts.append("notes=COALESCE(notes,'') || %s"); upd_params.append(delivered_note)
                elif 'note' in trans_cols:
                    set_parts.append("note=COALESCE(note,'') || %s");  upd_params.append(delivered_note)

                self.execute_query(
                    f"UPDATE trans SET {', '.join(set_parts)} WHERE id=%s",
                    tuple(upd_params + [r['id']]), cursor=cur
                )

            # 5) به‌روزرسانی درخواست/درخواست‌ها (با request_id یا بر اساس سند/یادداشت)
            req_ids = []
            if 'request_id' in trans_cols:
                req_ids = [x.get('request_id') for x in rows if x.get('request_id')]
                req_ids = list({int(x) for x in req_ids})  # unique

            mr_set, mr_params, mr_where, mr_where_params = [], [], [], []
            delivered_status = getattr(TransactionStatus, 'MR_DELIVERED_TO_PROD', None)
            delivered_value  = delivered_status.value if delivered_status else TransactionStatus.MR_FULFILLED.value

            if 'status' in mr_cols:
                mr_set.append("status=%s"); mr_params.append(delivered_value)
            if 'processed_by_user_id' in mr_cols:
                mr_set.append("processed_by_user_id=%s"); mr_params.append(approver_user_id)
            elif 'processed_by_id' in mr_cols:
                mr_set.append("processed_by_id=%s"); mr_params.append(approver_user_id)
            elif 'processed_by' in mr_cols:
                mr_set.append("processed_by=%s"); mr_params.append(approver_user_id)
            if 'processed_at' in mr_cols:
                mr_set.append("processed_at=NOW()")
            if 'notes' in mr_cols:
                mr_set.append("notes=COALESCE(notes,'') || %s"); mr_params.append("\n[Delivered to production]")

            if req_ids:
                mr_where.append("id = ANY(%s)"); mr_where_params.append(req_ids)
            else:
                if doc_no and 'request_no' in mr_cols:
                    mr_where.append("request_no = %s"); mr_where_params.append(doc_no)
                if doc_no and 'notes' in mr_cols:
                    mr_where.append("notes LIKE %s"); mr_where_params.append(f"%{doc_no}%")
                # آخرین راه: اگر anchor عملاً شناسهٔ درخواست بود
                if not mr_where and isinstance(anchor, dict) is False:
                    mr_where.append("id = %s"); mr_where_params.append(anchor_id)

            if mr_set and mr_where:
                self.execute_query(
                    f"UPDATE material_requests SET {', '.join(mr_set)} WHERE {' OR '.join(mr_where)}",
                    tuple(mr_params + mr_where_params), cursor=cur
                )

            # 6) سیگنال رفرش
            try:
                if hasattr(self, 'signals'):
                    self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            except Exception:
                pass
    # END REWRITE: DB.finalize_transfer_to_production

                            
    # BEGIN REWRITE: DB.register_pending_delivery
    def register_pending_delivery(self, product_name: str, batch_no: str, quantity: float,
                                supervisor_user_id: int, expiry_date: dt.date):
        """
        ثبت خروجی فلهٔ تولید شده در جدول production_deliveries + افزودن موجودی در انبار «Production».
        - نگاشت کالا را به‌صورت مقاوم انجام می‌دهد:
            1) جستجوی مستقیم در items بر اساس name
            2) اگر پیدا نشد: جستجو در recipes با product_name = %s و استفاده از produces_item_id
        - سطر production_deliveries را با product_item_id معتبر درج می‌کند (در صورت وجود ستون‌ها).
        - موجودی stock را در لوکیشن پیش‌فرض انبار Production افزایش می‌دهد.
        - خروجی: شناسهٔ رکورد درج‌شده در production_deliveries.
        """
        # --- 0) اعتبارسنجی‌های اولیه
        if not product_name or not batch_no:
            raise ValueError("نام محصول و شماره بچ الزامی است.")
        if quantity is None or float(quantity) <= 0:
            raise ValueError("مقدار تولید باید بزرگتر از صفر باشد.")

        with self.transaction() as cur:
            # --- 1) یافتن شناسه کالای مربوط ---
            # تلاش اول: مستقیماً بر اساس نام کالا
            cur.execute("SELECT id, name FROM items WHERE name = %s ORDER BY id ASC LIMIT 1", (product_name,))
            row = cur.fetchone()
            item_id = row['id'] if row else None
            resolved_name = row['name'] if row else product_name

            # تلاش دوم: از جدول recipes با نام فرمول (در صورتی که produces_item_id تنظیم شده باشد)
            if not item_id:
                try:
                    cur.execute(
                        """
                        SELECT r.produces_item_id, i.name AS item_name
                        FROM recipes r
                        LEFT JOIN items i ON i.id = r.produces_item_id
                        WHERE r.status = 'ACTIVE' AND r.product_name = %s
                        ORDER BY r.version DESC
                        LIMIT 1
                        """,
                        (product_name,)
                    )
                    rrow = cur.fetchone()
                    if rrow and rrow.get('produces_item_id'):
                        item_id = rrow['produces_item_id']
                        resolved_name = rrow.get('item_name') or resolved_name
                except Exception:
                    # اگر به هر دلیل جستجو در recipes شکست خورد، بعداً خطا می‌دهیم
                    pass

            if not item_id:
                raise ValueError(f"کالای متناظر با «{product_name}» یافت نشد. لطفاً در فرمول، «محصول خروجی» را به آیتمی از جدول کالاها لینک کنید.")

            # --- 2) تشخیص ستون‌های موجود در production_deliveries ---
            cols_exist = set()
            try:
                cols_exist = set(self._get_existing_columns('production_deliveries', cursor=cur))
            except Exception:
                cols_exist = set()

            def has(col): return col in cols_exist

            cols, vals, ph = [], [], []

            # فیلدهای الزامی/اصلی
            if has('product_item_id'):
                cols.append('product_item_id'); vals.append(item_id); ph.append('%s')
            if has('product_name'):
                cols.append('product_name'); vals.append(resolved_name); ph.append('%s')
            if has('production_batch_no'):
                cols.append('production_batch_no'); vals.append(batch_no); ph.append('%s')
            elif has('batch_no'):
                cols.append('batch_no'); vals.append(batch_no); ph.append('%s')
            if has('quantity'):
                cols.append('quantity'); vals.append(quantity); ph.append('%s')
            if has('status'):
                cols.append('status'); vals.append(TransactionStatus.PRODUCED.value if hasattr(TransactionStatus, 'PRODUCED') else 'تولید شده'); ph.append('%s')
            if has('supervisor_user_id'):
                cols.append('supervisor_user_id'); vals.append(supervisor_user_id); ph.append('%s')
            elif has('supervisor_id'):
                cols.append('supervisor_id'); vals.append(supervisor_user_id); ph.append('%s')
            elif has('created_by'):
                cols.append('created_by'); vals.append(supervisor_user_id); ph.append('%s')
            if has('expiry_date') and expiry_date:
                cols.append('expiry_date'); vals.append(expiry_date); ph.append('%s')
            if has('created_at'):
                cols.append('created_at'); ph.append('NOW()')  # بدون پارامتر

            # حداقل مجموعهٔ مینیمال (اگر جدول خیلی مینیمال باشد)
            if not cols:
                cols = ['product_name', 'production_batch_no', 'quantity']
                vals = [resolved_name, batch_no, quantity]
                ph = ['%s', '%s', '%s']

            insert_sql = f"INSERT INTO production_deliveries ({', '.join(cols)}) VALUES ({', '.join(ph)}) RETURNING id"
            cur.execute(insert_sql, tuple(vals))
            delivery_id = cur.fetchone()['id']

            # --- 3) افزایش موجودی در انبار Production ---
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("لوکیشن پیش‌فرض انبار «Production» تعریف نشده است.")
            # استفاده از هستهٔ واحد به‌روزرسانی موجودی
            self._upd_stock(
                cur,
                item_id=item_id,
                location_id=prod_loc_id,
                qty_change=abs(float(quantity)),
                batch_no=batch_no,
                expiry_date=expiry_date,
                status='موجود',
                return_stock_id=False
            )

            # --- 4) لاگ حسابرسی ---
            try:
                self._log_atomic(cur, supervisor_user_id, 'REGISTER_PRODUCTION_OUTPUT',
                                f"Item:{resolved_name} (id={item_id}), Batch:{batch_no}, Qty:{quantity}")
            except Exception:
                pass

            return delivery_id
    # END REWRITE: DB.register_pending_delivery

                                                                
                        
    # BEGIN REWRITE: DB.consume_materials_for_production
    def consume_materials_for_production(self, recipe_id: int, production_batch_no: str, consumption_plan: dict, user_id: int):
        """
        مواد اولیه را از موجودی «کف کارگاه» کسر می‌کند و در صورت وجود جدول BOM،
        ردیف مصرف را در آن ثبت می‌کند. اگر جدول 'bill_of_materials' وجود نداشته باشد،
        فقط کسر موجودی انجام می‌شود و برنامه خطا نمی‌دهد (زیرساخت جدید اضافه نمی‌شود).
        """
        prod_loc_id = self.get_production_floor_location()
        if not prod_loc_id:
            raise ValueError("خطا: لوکیشن 'کف کارگاه' تعریف نشده است.")

        def _bom_table_exists(cur) -> bool:
            cur.execute("""
                SELECT 1
                FROM information_schema.tables
                WHERE table_schema = current_schema()
                AND table_name = 'bill_of_materials'
                LIMIT 1
            """)
            return cur.fetchone() is not None

        with self._conn() as conn:
            with conn.cursor() as cur:
                try:
                    has_bom = _bom_table_exists(cur)

                    # consumption_plan = { "نام ماده": [ {item_id, batch_no, qty_to_consume, expiry_date?}, ... ], ... }
                    for _, batches in (consumption_plan or {}).items():
                        for b in (batches or []):
                            item_id = b.get('item_id')
                            qty     = float(b.get('qty_to_consume') or 0)
                            batch_no = b.get('batch_no')
                            expiry   = b.get('expiry_date')  # می‌تواند None باشد

                            # داده ناقص را رد کن؛ خطا ایجاد نکن
                            if not item_id or not batch_no or qty <= 0:
                                continue

                            # 1) کسر موجودی از «کف کارگاه»
                            self._upd_stock(
                                cur,
                                item_id=item_id,
                                location_id=prod_loc_id,
                                qty_change=-qty,
                                batch_no=batch_no,
                                expiry_date=expiry
                            )

                            # 2) اگر جدول BOM موجود است، لاگ مصرف را ثبت کن
                            if has_bom:
                                cur.execute(
                                    """
                                    INSERT INTO bill_of_materials
                                        (product_code, raw_item_id, raw_batch, qty, ts, user_id, recipe_id, status)
                                    VALUES (%s, %s, %s, %s, NOW(), %s, %s, 'ACTIVE')
                                    """,
                                    (production_batch_no, item_id, batch_no, qty, user_id, recipe_id)
                                )

                    conn.commit()
                except Exception:
                    conn.rollback()
                    raise
    # END REWRITE: DB.consume_materials_for_production
                        
                
        
# این متد جدید را به کلاس DB خود اضافه کنید

    def list_bom_files(self, bom_id: int):
        """لیست تمام فایل‌های پیوست شده به یک رکورد BOM را برمی‌گرداند."""
        # ما از متد execute_query که از قبل وجود دارد، استفاده می‌کنیم
        return self.execute_query(
            "SELECT id, path FROM bom_files WHERE bom_id = %s ORDER BY id",
            (bom_id,)
        )
        
        
    # [DB] replace this method as-is
    def get_available_batches_for_item(self, item_id: int, location_id: int) -> list:
        """
        لیست بچ‌های قابل مصرف برای UI تخصیص:
        - همیشه کلیدهای: item_id, batch_no, expiry_date, qty را برمی‌گرداند.
        - تجمیع روی (item_id, batch_no, expiry_date) تا ردیف تکراری حذف شود.
        - وابستگی به ستون‌های غیرقطعی مثل status ندارد.
        """
        query = """
            SELECT
                s.item_id,
                s.batch_no,
                s.expiry_date,
                SUM(s.qty) AS qty
            FROM stock s
            WHERE s.item_id = %s
            AND s.location_id = %s
            AND s.qty > 0.001
            GROUP BY s.item_id, s.batch_no, s.expiry_date
            ORDER BY s.expiry_date ASC NULLS LAST, s.batch_no
        """
        return self.execute_query(query, (item_id, location_id))
            
# این متد جدید را به کلاس DB اضافه کنید
    def item_exists(self, item_name: str, exclude_id: int = None) -> bool:
        """
        بررسی می‌کند که آیا کالایی با نام مشخص در دیتابیس وجود دارد یا خیر.
        در حالت ویرایش، می‌توان ID کالای فعلی را مستثنی کرد.
        """
        with self._conn() as conn:
            with conn.cursor() as cur:
                query = "SELECT id FROM items WHERE name = %s"
                params = [item_name]
                if exclude_id is not None:
                    query += " AND id != %s"
                    params.append(exclude_id)
                
                cur.execute(query, tuple(params))
                return cur.fetchone() is not None
                        
# In the DB class

    # BEGIN REWRITE: DB.factory_reset
    def factory_reset(
        self,
        selections: dict | None = None,
        *,
        include_attachments: bool = False,
        backup_confirmed: bool = False,
        backup_dir: str | None = None,
        reset_password: str | None = None,
    ):
        """
        ریست کارخانه‌ای (انعطاف‌پذیر و ایمن).

        رفتار پیش‌فرض (سازگار با نسخه‌های قبل):
        - اگر selections=None باشد، تقریباً همهٔ داده‌های عملیاتی پاک می‌شود،
            اما کاربران/نقش‌ها دست‌نخورده می‌ماند.
        - رمز/بکاپ/حذف پیوست فقط در صورت ارسال پارامتر فعال است.

        پارامترها:
        selections: dict گروه‌ها -> True/False. اگر None باشد همهٔ گروه‌ها (به جز users) حذف می‌شوند.
            گروه‌ها: 'inventory', 'catalog', 'production', 'forms', 'assets', 'procurement', 'audit', 'users'
        include_attachments: حذف فایل‌های پیوست روی دیسک.
        backup_confirmed: گرفتن بکاپ کامل DB و (در صورت امکان) پیوست‌ها.
        backup_dir: پوشهٔ ذخیرهٔ بکاپ‌ها (برای backup_confirmed لازم است).
        reset_password: اگر مقداردهی شود باید با رمز ثابت برابر باشد.

        خروجی: dict خلاصهٔ عملیات.
        """
        import os, time, zipfile

        # 0) رمز ثابت ریست — حتماً عوضش کن
        EXPECTED_RESET_PASSWORD = "Meg1234@"
        if reset_password is not None and reset_password != EXPECTED_RESET_PASSWORD:
            raise ValueError("رمز ریست صحیح نیست.")

        # 1) گروه‌های جداول
        groups: dict[str, list[str]] = {
            'inventory':  ['stock', 'trans', 'trans_files'],
            'catalog':    ['items', 'units', 'warehouses', 'locations'],
            'production': ['recipes', 'recipe_ingredients', 'bill_of_materials', 'production_deliveries', 'bom_files'],
            'forms':      ['form_entries', 'form_fields', 'form_defs'],
            'assets':     ['asset_trans_files', 'asset_trans', 'assets'],
            'procurement':['purchase_request_groups', 'purchase_requests', 'supplier_quotes', 'pr_attachments', 'material_requests'],
            'audit':      ['audit'],
            # پیش‌فرض پاک نمی‌کنیم:
            'users':      ['user_roles', 'role_permissions', 'permissions', 'roles', 'users'],
        }

        # 2) انتخاب گروه‌ها
        if selections is None:
            enabled_groups = [k for k in groups.keys() if k != 'users']
        else:
            enabled_groups = [k for k, v in selections.items() if v and k in groups]
            if not enabled_groups:
                return {'ok': True, 'skipped': True, 'msg': 'هیچ گروهی برای حذف انتخاب نشد.'}

        # 3) جدول‌های واقعی موجود
        def _exists(name: str) -> bool:
            try:
                return self._table_exists(name)
            except Exception:
                return False

        tables: list[str] = []
        seen = set()
        for g in enabled_groups:
            for t in groups[g]:
                if _exists(t) and t not in seen:
                    tables.append(t); seen.add(t)

        # 4) مسیر فایل‌های پیوست (برای بکاپ/حذف)
        files_to_handle: list[str] = []
        def _collect_paths(table: str):
            # نام ستون‌های رایج برای مسیر فایل
            candidate_cols = ('file_path', 'path', 'filepath')
            try:
                with self.transaction() as cur:
                    cols = set(self._get_existing_columns(table, cursor=cur))
                    col = next((c for c in candidate_cols if c in cols), None)
                    if not col:
                        return
                    cur.execute(f"SELECT {col} FROM {table}")
                    for row in cur.fetchall():
                        p = row[0] if isinstance(row, (list, tuple)) else list(row.values())[0]
                        if isinstance(p, str) and p.strip():
                            files_to_handle.append(p.strip())
            except Exception:
                pass  # جمع‌آوری پیوست‌ها نباید کل ریست را متوقف کند

        if backup_confirmed or include_attachments:
            for tbl in ('trans_files', 'asset_trans_files', 'bom_files'):
                if _exists(tbl):
                    _collect_paths(tbl)

        # 5) بکاپ (اختیاری)
        backup_summary = {}
        if backup_confirmed and backup_dir and os.path.isdir(backup_dir):
            ts = time.strftime("%Y%m%d_%H%M%S")
            # 5-الف) بکاپ دیتابیس
            try:
                backup_db_path = os.path.join(backup_dir, f"db_backup_{ts}.dump")
                ok, msg = backup_database(self.config, backup_db_path)
                backup_summary['db'] = {'ok': bool(ok), 'path': backup_db_path, 'msg': msg}
            except Exception as e:
                backup_summary['db'] = {'ok': False, 'error': str(e)}
            # 5-ب) بکاپ پیوست‌ها
            if files_to_handle:
                try:
                    zip_path = os.path.join(backup_dir, f"attachments_{ts}.zip")
                    with zipfile.ZipFile(zip_path, 'w', compression=zipfile.ZIP_DEFLATED) as zf:
                        for p in files_to_handle:
                            if os.path.isfile(p):
                                zf.write(p, arcname=os.path.join("attachments", os.path.basename(p)))
                    backup_summary['attachments'] = {'ok': True, 'path': zip_path, 'count': len(files_to_handle)}
                except Exception as e:
                    backup_summary['attachments'] = {'ok': False, 'error': str(e)}
        elif backup_confirmed and (not backup_dir or not os.path.isdir(backup_dir)):
            backup_summary['db'] = {'ok': False, 'error': 'مسیر بکاپ معتبر نیست.'}

        # 6) حذف جداول انتخاب‌شده
        truncated = []
        with self.transaction() as cur:
            for t in tables:
                try:
                    cur.execute(f"TRUNCATE TABLE {t} RESTART IDENTITY CASCADE;")
                    truncated.append(t)
                except Exception as e:
                    truncated.append(f"{t} (FAILED: {e})")

        # 7) حذف فایل‌های پیوست از دیسک
        removed_files = 0
        if include_attachments and files_to_handle:
            for p in files_to_handle:
                try:
                    if os.path.isfile(p):
                        os.remove(p); removed_files += 1
                except Exception:
                    pass

        # 8) سیگنال برای UI
        try:
            self.signals.dataChanged.emit('FACTORY_RESET')
        except Exception:
            pass

        return {
            'ok': True,
            'truncated_tables': truncated,
            'attachments': {'collected': len(files_to_handle), 'removed': removed_files} if (backup_confirmed or include_attachments) else None,
            'backup': backup_summary or None,
        }
    # END REWRITE: DB.factory_reset
                
# این سه متد جدید را به انتهای کلاس DB اضافه کنید

# در کلاس DB، این متد را جایگزین کنید

    def add_asset_file(self, asset_trans_id: int, path: str):
        """یک فایل پیوست به یک تراکنش دارایی به صورت اتمیک اضافه می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "INSERT INTO asset_trans_files(asset_trans_id, path) VALUES (%s, %s)",
                (asset_trans_id, path),
                cursor=cur
            )
            
            
    def list_asset_files(self, asset_trans_id: int):
        """لیست تمام فایل‌های پیوست یک تراکنش دارایی را برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, path FROM asset_trans_files WHERE asset_trans_id=%s", (asset_trans_id,))
                return cur.fetchall()

    def delete_asset_file(self, file_id: int):
        """یک فایل پیوست دارایی را حذف می‌کند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM asset_trans_files WHERE id=%s", (file_id,))
            conn.commit()
            
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def log_asset_event(self, asset_id: int, t_type: str, notes: str, t_no: str, user_id: int):
        """
        نسخه 2.0:
        - یک رویداد برای دارایی ثبت می‌کند و وضعیت آن را به‌روز می‌کند.
        - پس از تغییر، رویداد ASSET_STATUS_CHANGED را اعلام می‌کند.
        """
        new_status_map = {
            "خروج (تعمیرات)": AssetStatus.OUT_FOR_REPAIR.value,
            "خروج (پروژه)": AssetStatus.OUT_FOR_PROJECT.value,
            "بازگشت به انبار": AssetStatus.IN_STOCK.value,
            "اسقاط": AssetStatus.SCRAPPED.value,
            "تحویل به پرسنل": AssetStatus.ASSIGNED.value
        }
        new_status = new_status_map.get(t_type)
        
        with self.transaction() as cur:
            asset = self.execute_query("SELECT status FROM assets WHERE id = %s FOR UPDATE", (asset_id,), fetch_one=True, cursor=cur)
            if not asset: raise ValueError("دارایی مورد نظر یافت نشد.")

            if t_type != 'بازگشت به انبار' and asset['status'] != AssetStatus.IN_STOCK.value:
                if asset['status'] != AssetStatus.ASSIGNED.value or t_type == 'تحویل به پرسنل':
                     raise ValueError(f"این دارایی با وضعیت '{asset['status']}' در انبار موجود نیست و این عملیات روی آن مجاز نیست.")

            trans_id = self.execute_query(
                """INSERT INTO asset_trans (asset_id, t_type, t_no, t_date, notes, user_id)
                   VALUES (%s, %s, %s, NOW(), %s, %s) RETURNING id""",
                (asset_id, t_type, t_no, notes, user_id),
                fetch_one=True, cursor=cur
            )['id']
            
            if new_status:
                self.execute_query("UPDATE assets SET status = %s WHERE id = %s", (new_status, asset_id), cursor=cur)

            self._log_atomic(cur, user_id, 'ASSET_EVENT', f"AssetID:{asset_id}, Type:{t_type}")

                                
        
    def get_asset_details(self, asset_id: int):
        """جزئیات کامل یک دارایی را بر اساس ID آن برمی‌گرداند."""
        return self.execute_query("SELECT * FROM assets WHERE id = %s", (asset_id,), fetch_one=True)
    
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def apply_inventory_adjustments(self, count_id: int, user_id: int, discrepancies_with_reasons: list, doc_no: str):
        """
        نسخه 2.2:
        - پس از ثبت تمام اصلاحیه‌ها، یک رویداد INVENTORY_ADJUSTMENT_APPLIED را اعلام می‌کند.
        """
        with self.transaction() as cur:
            now_utc = datetime.now(dt.timezone.utc)
            if not doc_no:
                doc_no = f"COUNT-{count_id}"
            
            total_discrepancy_value = 0
            
            for item in discrepancies_with_reasons:
                item_details = self.get_item_details(item['item_id'])
                item_cost = item_details.get('cost', 0) if item_details else 0
                total_discrepancy_value += abs(item['adjustment_qty'] * item_cost)
                
                adjustment_qty = item['adjustment_qty']
                if abs(adjustment_qty) < 1e-9: continue
                
                t_type = 'اضافه شدنی انبارگردانی' if adjustment_qty > 0 else 'کسری انبارگردانی'
                trans_note = f"{t_type} طبق سند {doc_no}. دلیل: {item['reason']}"
                
                cur.execute("""INSERT INTO trans 
                                (item_id, t_type, t_no, t_date, qty, notes, user_id, status, src_loc, dest_loc, batch_no, expiry_date)
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) 
                                RETURNING id""",
                            (item['item_id'], t_type, doc_no, now_utc, adjustment_qty, trans_note, 
                             user_id, TransactionStatus.APPROVED.value, 
                             item['location_id'] if adjustment_qty < 0 else None,
                             item['location_id'] if adjustment_qty > 0 else None,
                             item['batch_no'], item.get('expiry_date')))
                
                trans_id = cur.fetchone()['id']
                self._upd_stock(cur, item['item_id'], item['location_id'], adjustment_qty, item['batch_no'], item.get('expiry_date'))
            
            cur.execute("UPDATE inventory_counts SET status = 'APPROVED', finalized_by = %s, finalized_at = %s WHERE id = %s",
                        (user_id, now_utc, count_id))
            
            self._log_atomic(cur, user_id, 'INVENTORY_APPROVAL', f"Approved inventory count {count_id} with doc no {doc_no}")
        
                                                                    
        
    # این متد جدید را به کلاس DB اضافه کنید
    def request_material_return(self, component_data: dict, qty_to_return: float, reason: str, user_id: int):
        """یک درخواست برای بازگرداندن مواد اولیه از تولید به انبار ثبت می‌کند."""
        with self.transaction() as cur:
            # یک تراکنش با نوع جدید و وضعیت "در انتظار تایید" ایجاد می‌کنیم
            cur.execute(
                """INSERT INTO trans (item_id, t_type, qty, notes, user_id, status, src_loc, batch_no, expiry_date)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)""",
                (
                    component_data['item_id'], 'برگشت از تولید', qty_to_return, reason, user_id,
                    'در انتظار تایید انبار', self.get_production_floor_location(),
                    component_data['batch_no'], component_data.get('expiry_date')
                )
            )
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

            
    # BEGIN REWRITE: DB.get_all_user_initiated_requests (computed processed_at)
    def get_all_user_initiated_requests(self, user_id: int, limit: int = 2000):
        """
        تاریخچه‌ی درخواست‌های کاربر از منابع:
        - material_requests
        - internal_requests
        - trans (برگشت مواد)
        خروجی: id, item_id, qty, status, created_at, processed_at, notes, request_type
        """
        def _cols(table):
            try: return set(self._get_existing_columns(table))
            except Exception: return set()

        def _pick_expr(alias: str, cols_set: set, candidates: tuple, default_sql: str = "NULL"):
            for c in candidates:
                if c in cols_set:
                    return f"{alias}.{c}"
            return default_sql

        mr_cols = _cols('material_requests')
        ir_cols = _cols('internal_requests')
        tr_cols = _cols('trans')

        selects, params = [], []

        # --- 1) material_requests ---
        if mr_cols:
            mr_user = _pick_expr("mr", mr_cols, ("requester_user_id", "requester_id"))
            if mr_user != "NULL":
                mr_qty     = _pick_expr("mr", mr_cols, ("requested_qty","qty","quantity"), default_sql="0")
                mr_created = _pick_expr("mr", mr_cols, ("created_at",), default_sql="NOW()")
                mr_proc_raw = _pick_expr("mr", mr_cols, ("processed_at","fulfilled_at","approved_at","closed_at","updated_at"))
                mr_proc = f"""
                CASE 
                WHEN {mr_proc_raw} IS NOT NULL THEN {mr_proc_raw}
                WHEN COALESCE(mr.status,'') IN ('FULFILLED','ارسال شده به تولید','تحویل شده به تولید','ارسال شده به انبار') THEN {mr_created}
                ELSE NULL
                END
                """
                mr_notes = _pick_expr("mr", mr_cols, ("notes","note","description","remark","remarks"), default_sql="''")
                selects.append(f"""
                    SELECT
                        mr.id AS id,
                        mr.item_id AS item_id,
                        COALESCE({mr_qty}, 0) AS qty,
                        COALESCE(mr.status,'') AS status,
                        {mr_created} AS created_at,
                        {mr_proc}   AS processed_at,
                        COALESCE({mr_notes},'') AS notes,
                        'درخواست مواد' AS request_type
                    FROM material_requests mr
                    WHERE {mr_user} = %s AND mr.item_id IS NOT NULL
                """)
                params.append(user_id)

        # --- 2) internal_requests ---
        if ir_cols:
            ir_user = _pick_expr("ir", ir_cols, ("requester_user_id",), default_sql="NULL")
            if ir_user != "NULL":
                ir_qty     = _pick_expr("ir", ir_cols, ("quantity","qty","requested_qty"), default_sql="0")
                ir_created = _pick_expr("ir", ir_cols, ("created_at",), default_sql="NOW()")
                ir_proc_raw = _pick_expr("ir", ir_cols, ("processed_at","fulfilled_at","approved_at","closed_at","updated_at"))
                ir_proc = f"""
                CASE 
                WHEN {ir_proc_raw} IS NOT NULL THEN {ir_proc_raw}
                WHEN COALESCE(ir.status,'') IN ('FULFILLED','ارسال شده به تولید','تحویل شده به تولید','ارسال شده به انبار') THEN {ir_created}
                ELSE NULL
                END
                """
                ir_notes = _pick_expr("ir", ir_cols, ("notes","note","description","remark","remarks"), default_sql="''")
                selects.append(f"""
                    SELECT
                        ir.id AS id,
                        ir.item_id AS item_id,
                        COALESCE({ir_qty}, 0) AS qty,
                        COALESCE(ir.status,'') AS status,
                        {ir_created} AS created_at,
                        {ir_proc}   AS processed_at,
                        COALESCE({ir_notes},'') AS notes,
                        'درخواست داخلی' AS request_type
                    FROM internal_requests ir
                    WHERE {ir_user} = %s AND ir.item_id IS NOT NULL
                """)
                params.append(user_id)
        
        # --- 3) برگشت مواد از تولید (trans) ---
        if tr_cols:
            t_user = _pick_expr("t", tr_cols, ("user_id",), default_sql="NULL")
            if t_user != "NULL":
                t_created = _pick_expr("t", tr_cols, ("t_date","tt_date","created_at","t_datetime"), default_sql="NOW()")
                t_qty     = _pick_expr("t", tr_cols, ("qty",), default_sql="0")
                t_notes   = _pick_expr("t", tr_cols, ("notes","note","description","remark","remarks"), default_sql="''")
                # برگشت مواد را همان لحظه «پردازش‌شده» در نظر می‌گیریم
                t_proc    = t_created
                type_sql = "FALSE"
                if "t_type" in tr_cols:
                    type_sql = (
                        "t.t_type IN ('برگشت از تولید','برگشت مواد') OR "
                        "LOWER(COALESCE(t.t_type,'')) IN ('return from production','return_from_production')"
                    )
                selects.append(f"""
                    SELECT
                        t.id AS id,
                        t.item_id AS item_id,
                        COALESCE({t_qty}, 0) AS qty,
                        COALESCE(t.status,'') AS status,
                        {t_created} AS created_at,
                        {t_proc}   AS processed_at,
                        COALESCE({t_notes},'') AS notes,
                        'برگشت مواد' AS request_type
                    FROM trans t
                    WHERE {t_user} = %s AND ({type_sql})
                """)
                params.append(user_id)

        if not selects:
            return []

        union_sql = "\nUNION ALL\n".join(s.strip() for s in selects)
        sql = f"""
            SELECT * FROM (
                {union_sql}
            ) x
            ORDER BY x.created_at DESC, x.id DESC
            LIMIT %s
        """
        params.append(int(limit))
        return self.execute_query(sql, tuple(params)) or []
    # END REWRITE
    
        
    def void_production_batch(self, product_batch_no: str, user_id: int, reason: str):
        """ابطال بچ تولید: صفرکردن موجودیِ همان بچ + برگشت مواد اولیه + ثبت دلیل (بدون شکستن API)."""
        import datetime as _dt
        DEBUG_TRACE = bool(getattr(self, 'DEBUG_TRACE', False))

        def _dec_with_fallback(cur, *, row):
            """
            تلاش برای کم کردن از طریق _upd_stock؛ اگر امضا/فیلتر وضعیت گیر داد،
            همان ردیف stock.id به شکل امن صفر می‌شود.
            """
            rid      = row['id']
            item_id  = row['item_id']
            loc_id   = row['location_id']
            qty_here = float(row['qty'] or 0)
            exp_dt   = row.get('expiry_date')

            if qty_here <= 0:
                return

            # تلاش اول: با نادیده‌گرفتن فیلتر وضعیت (اگر پشتیبانی شود)
            try:
                self._upd_stock(cur,
                                item_id=item_id,
                                location_id=(loc_id or prod_loc_id),
                                qty_change=-abs(qty_here),
                                batch_no=product_batch_no,
                                expiry_date=exp_dt,
                                ignore_status_check=True)  # ممکن است موجود نباشد
                if DEBUG_TRACE:
                    print(f"[TRACE] void_dec via _upd_stock(ignore_status): id={rid} qty={qty_here}")
                return
            except TypeError:
                # نسخه‌ی قدیمی _upd_stock پارامتر را ندارد؛ با امضای قدیمی امتحان می‌کنیم
                try:
                    self._upd_stock(cur,
                                    item_id=item_id,
                                    location_id=(loc_id or prod_loc_id),
                                    qty_change=-abs(qty_here),
                                    batch_no=product_batch_no,
                                    expiry_date=exp_dt)
                    if DEBUG_TRACE:
                        print(f"[TRACE] void_dec via _upd_stock(legacy): id={rid} qty={qty_here}")
                    return
                except Exception as e:
                    err = str(e)
            except Exception as e:
                err = str(e)

            # اگر هنوز خطا داشتیم (معمولاً «کافی نیست/وضعیت مجاز نیست»): صفر کردن مستقیم همان ردیف
            # اتمیک و دقیق روی id، بدون دست‌کاری اسکیما/منطق دیگر
            cur.execute(
                "UPDATE stock SET qty = 0, last_moved_at = %s WHERE id = %s",
                (_dt.datetime.now(_dt.timezone.utc), rid)
            )
            if DEBUG_TRACE:
                print(f"[TRACE] void_dec via direct UPDATE (fallback): id={rid} qty={qty_here} err={err}")

            # پاکسازی رکوردهای تقریبا صفر (همان منطق متد مرکزی)
            cur.execute("DELETE FROM stock WHERE id = %s AND qty < 0.001", (rid,))

        with self.transaction() as cur:
            # 1) BOMهای فعال این بچ (برای برگشت مواد اولیه)
            cur.execute(
                "SELECT * FROM bill_of_materials WHERE product_code = %s AND status = 'ACTIVE'",
                (product_batch_no,)
            )
            bom_entries = cur.fetchall()
            if not bom_entries:
                raise ValueError(f"هیچ گزارش مصرف فعالی برای بچ تولید '{product_batch_no}' یافت نشد.")

            # 2) مکان کف کارگاه
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # 3) انتخاب دقیق ردیف‌های همین batch از stock (با id برای fallback)
            cur.execute(
                """
                SELECT id, item_id, location_id, qty, batch_no, expiry_date, status
                FROM stock
                WHERE batch_no = %s AND qty > 0
                """,
                (product_batch_no,)
            )
            stock_rows = cur.fetchall() or []

            # 3.1) هر ردیف را کم کن (اول تلاش از مسیر استاندارد، در صورت لزوم fallback)
            for st in stock_rows:
                _dec_with_fallback(cur, row=st)

            # 4) اگر تحویل‌های «تولید شده» ثبت باشد، آن‌ها را هم invalidate کن (بدون تغییر معماری)
            cur.execute(
                "SELECT * FROM production_deliveries WHERE production_batch_no = %s AND status = 'تولید شده'",
                (product_batch_no,)
            )
            fg_rows = cur.fetchall() or []

            # 5) تاریخ انقضای برگشت مواد اولیه را تعیین کن
            def _resolve_raw_expiry(entry, cursor):
                exp = (
                    entry.get('raw_material_expiry_date')
                    or entry.get('raw_expiry_date')
                    or entry.get('expiry_date')
                    or None
                )
                if exp:
                    return exp
                cursor.execute(
                    """
                    SELECT expiry_date
                    FROM stock
                    WHERE item_id = %s
                    AND batch_no = %s
                    AND expiry_date IS NOT NULL
                    ORDER BY expiry_date ASC NULLS LAST, qty DESC
                    LIMIT 1
                    """,
                    (entry['raw_item_id'], entry['raw_batch'])
                )
                row = cursor.fetchone()
                return row['expiry_date'] if row and row.get('expiry_date') is not None else None

            # 6) برگشت مواد اولیه به Production
            for entry in bom_entries:
                resolved_expiry = _resolve_raw_expiry(entry, cur)
                try:
                    # اگر ignore_status_check پشتیبانی شد، مشکلی هم پیش نیاید
                    self._upd_stock(
                        cur,
                        item_id=entry['raw_item_id'],
                        location_id=prod_loc_id,
                        qty_change=abs(entry['qty']),
                        batch_no=entry['raw_batch'],
                        expiry_date=resolved_expiry,
                        ignore_status_check=True
                    )
                except TypeError:
                    # نسخه‌ی قدیمی _upd_stock
                    self._upd_stock(
                        cur,
                        item_id=entry['raw_item_id'],
                        location_id=prod_loc_id,
                        qty_change=abs(entry['qty']),
                        batch_no=entry['raw_batch'],
                        expiry_date=resolved_expiry
                    )

            # 7) ثبت «باطل شده» در production_deliveries و نوشتن دلیل در هر ستونی که واقعاً داری
            update_note = f"ابطال توسط کاربر {user_id}: {reason or ''}"
            try:
                pd_cols = set(self._get_existing_columns('production_deliveries', cursor=cur))
            except Exception:
                cur.execute("SELECT * FROM production_deliveries LIMIT 0")
                pd_cols = {getattr(d, 'name', d[0]) for d in (cur.description or [])}

            sets, params = ["status = %s"], ['باطل شده']
            if 'rejection_reason' in pd_cols:
                sets.append("rejection_reason = %s"); params.append(update_note)
            elif 'reject_reason' in pd_cols:
                sets.append("reject_reason = %s"); params.append(update_note)
            elif 'notes' in pd_cols:
                sets.append("notes = COALESCE(notes,'') || %s"); params.append("\n" + update_note)
            if 'updated_at' in pd_cols:
                sets.append("updated_at = CURRENT_TIMESTAMP")

            params.append(product_batch_no)
            cur.execute(
                f"UPDATE production_deliveries SET {', '.join(sets)} "
                "WHERE production_batch_no = %s AND status = 'تولید شده'",
                tuple(params)
            )

            if cur.rowcount == 0 and not fg_rows and not stock_rows:
                raise ValueError("این بچ تولیدی یافت نشد یا قبلا مصرف/تحویل/ابطال شده است.")

            # 8) ابطال BOMها
            bom_ids_to_void = [e['id'] for e in bom_entries]
            if bom_ids_to_void:
                placeholders = ','.join(['%s'] * len(bom_ids_to_void))
                cur.execute(
                    f"UPDATE bill_of_materials SET status = 'باطل شده' WHERE id IN ({placeholders})",
                    tuple(bom_ids_to_void)
                )

            # 9) لاگ
            self._log_atomic(cur, user_id, 'VOID_PRODUCTION_BATCH',
                            f"ابطال کامل بچ تولید: {product_batch_no}. دلیل: {reason}")
                        
            
    # === BEGIN PATCH: DB.void_packing_operation (V3, safe & compatible) ===
    def void_packing_operation(self, packed_product_batch_no: str, user_id: int, reason: str):
        """
        ابطال بسته‌بندیِ یک بچ خروجی:
        - لاگ‌های جدید و قدیمی را شناسایی می‌کند (EXECUTE_MANUAL_PACKING_PLAN / EXECUTE_PACKING_PLAN_FROM_PROD / EXECUTE_PACKING_PLAN / PACKING_EVENT%).
        - محصول بسته‌شده را کم می‌کند و مواد فله و لوازم بسته‌بندیِ مصرف‌شده را برمی‌گرداند.
        - بدون تغییر اسکیمای موجود. کمینه و اتمیک.
        """
        import json, datetime as dt

        def _parse_date(s):
            if not s or s in ('None', ''):
                return None
            try:
                return dt.date.fromisoformat(str(s)[:10])
            except Exception:
                return None

        with self.transaction() as cur:
            # 1) پیدا کردن لاگ عملیات بسته‌بندی برای این بچ
            # پوشش اکشن‌های جدید و قدیمی + فقط لاگ‌های JSON
            cur.execute(
                """
                SELECT id, action, details
                FROM audit
                WHERE details LIKE '{%%}'
                AND (
                        action IN ('EXECUTE_MANUAL_PACKING_PLAN','EXECUTE_PACKING_PLAN_FROM_PROD','EXECUTE_PACKING_PLAN')
                        OR action LIKE 'PACKING_EVENT%%'
                    )
                AND (
                        (details::jsonb) #>> '{output_product,batch}' = %s
                        OR (details::jsonb) ->> 'batch' = %s
                    )
                ORDER BY id DESC
                LIMIT 1
                """,
                (packed_product_batch_no, packed_product_batch_no)
            )
            audit_log = cur.fetchone()
            if not audit_log:
                raise ValueError(
                    f"هیچ عملیات بسته‌بندی قابل ابطال برای بچ «{packed_product_batch_no}» یافت نشد."
                    " (احتمالاً لاگ غیر JSON/قدیمی است)"
                )

            try:
                data = audit_log['details']
                if isinstance(data, str):
                    data = json.loads(data or "{}")
            except Exception:
                data = {}

            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # 2) کم‌کردن موجودی محصول خروجی بسته‌بندی
            out = data.get('output_product') or {}
            out_item_id = out.get('item_id')
            out_qty = float(out.get('qty') or 0)
            out_exp = _parse_date(out.get('expiry_date'))
            if out_item_id and out_qty > 0:
                self._upd_stock(cur,
                                item_id=out_item_id,
                                location_id=prod_loc_id,
                                qty_change=-abs(out_qty),
                                batch_no=packed_product_batch_no,
                                expiry_date=out_exp,
                                # کلید: در ابطال روی وضعیت گیر نکنیم
                                ignore_status_check=True)

            # 3) برگرداندن اجزای فله
            bulk_plan = data.get('bulk_components_plan') or []
            legacy_components = data.get('components_plan') or data.get('components') or []
            if bulk_plan:
                for pick in bulk_plan:
                    self._upd_stock(cur,
                                    item_id=pick['item_id'],
                                    location_id=pick.get('location_id') or prod_loc_id,
                                    qty_change=abs(float(pick.get('pick_qty', 0))),
                                    batch_no=pick['batch_no'],
                                    expiry_date=_parse_date(pick.get('expiry_date')))
            elif legacy_components:
                for comp in legacy_components:
                    qty = abs(float(
                        comp.get('pick_qty')
                        or comp.get('qty_to_consume')
                        or comp.get('qty')
                        or 0
                    ))
                    if qty <= 0:
                        continue
                    delivery_id = comp.get('delivery_id')
                    if delivery_id:
                        # اگر از WIP مصرف شده بود، همان تحویل را برگردان
                        cur.execute(
                            "UPDATE production_deliveries "
                            "SET quantity = quantity + %s, status = 'تولید شده' "
                            "WHERE id = %s",
                            (qty, delivery_id)
                        )
                    else:
                        self._upd_stock(cur,
                                        item_id=comp['item_id'],
                                        location_id=comp.get('location_id') or prod_loc_id,
                                        qty_change=qty,
                                        batch_no=comp.get('batch_no') or f"VOID-RETURN-{packed_product_batch_no}",
                                        expiry_date=_parse_date(comp.get('expiry_date')))

            # 4) برگرداندن لوازم بسته‌بندی
            pack_supplies = data.get('packaging_supplies_plan') or []
            if pack_supplies:
                for pick in pack_supplies:
                    self._upd_stock(cur,
                                    item_id=pick['item_id'],
                                    location_id=pick.get('location_id') or prod_loc_id,
                                    qty_change=abs(float(pick.get('pick_qty', 0))),
                                    batch_no=pick['batch_no'],
                                    expiry_date=_parse_date(pick.get('expiry_date')))

            # 5) لاگ ابطال
            log_note = {
                "batch": packed_product_batch_no,
                "reason": reason,
                "reverted_from_audit_id": audit_log['id'],
                "orig_action": audit_log['action'],
                "at": dt.datetime.now().isoformat()
            }
            self._log_atomic(cur, user_id, 'VOID_PACKING_EVENT', json.dumps(log_note, ensure_ascii=False))
    # === END PATCH ===









    def get_actionable_notifications(self, permissions, user_id, role_name):
        """Build actionable notification payloads for dashboards and panels."""
        resolved_keys = self._load_notif_set("notif_resolved_keys")
        dismissed_keys = self._load_notif_set("notif_dismissed_keys")
        read_keys = self._load_notif_set("notif_read_keys")

        raw_entries: list[dict] = []
        notifications: list[dict] = []
        kinds_seen: set[str] = set()
        gc_events = []
        removed_by_filter = 0
        excluded_flags = {"resolved": 0, "dismissed": 0}
        reactivated_keys = set()

        def make_key(action_key, action_data):
            return self._notif_key(action_key, action_data)

        def _timestamp(value) -> float:
            from datetime import datetime, timezone
            if value is None:
                return 0.0
            if isinstance(value, (int, float)):
                return float(value)
            if isinstance(value, str):
                s = value.strip()
                if not s:
                    return 0.0
                if s.endswith('Z'):
                    s = s[:-1] + '+00:00'
                try:
                    value = datetime.fromisoformat(s)
                except Exception:
                    return 0.0
            if isinstance(value, datetime):
                if value.tzinfo is None:
                    value = value.replace(tzinfo=timezone.utc)
                return value.timestamp()
            return 0.0

        def record_entry(payload: dict):
            nonlocal removed_by_filter
            raw_entries.append(payload)
            key = make_key(payload["action_key"], payload["action_data"])
            if key in resolved_keys:
                excluded_flags["resolved"] += 1
                removed_by_filter += 1
                gc_events.append((key, "resolved", True))
                return
            if key in dismissed_keys:
                excluded_flags["dismissed"] += 1
                reactivated_keys.add(key)
            payload["is_read"] = key in read_keys
            notifications.append(payload)
            kind = payload.get("kind")
            if kind:
                kinds_seen.add(str(kind))

        def has_any(*perms):
            perm_set = set(permissions or [])
            return any(p in perm_set for p in perms)

        def map_route_title(name: str) -> str:
            base = (name or "").strip()
            if base == "عملیات انبار":
                mapped = "ارتباط با تولید"
                if globals().get('DEBUG_NOTIF', False):
                    print(f"[TRACE:NOTIF:map] route_in={base!r} → route_out={mapped!r}")
                return mapped
            return base or "ارتباط با تولید"

        comm_page = map_route_title("عملیات انبار")

        memo_rows = []
        unread_memo_fn = getattr(self, 'get_unread_memos_for_user', None)
        if callable(unread_memo_fn) and user_id:
            try:
                memo_rows = unread_memo_fn(user_id) or []
            except Exception:
                memo_rows = []
        internal_added = 0
        for memo in memo_rows:
            record_entry({
                "kind": "internal",
                "type": "پیام داخلی",
                "priority": 1,
                "details": f"پیام جدید از {memo.get('author_name') or '-'} - موضوع: {memo.get('subject') or 'بدون عنوان'}",
                "date": memo.get("created_at") or datetime.now(),
                "action_key": "VIEW_MEMO",
                "action_data": memo.get("memo_id"),
            })
            internal_added += 1
        if internal_added and globals().get('DEBUG_MAIL_NOTIF', False):
            print(f"[TRACE:MAIL:fetch] kind=internal rows_db={len(memo_rows)} after_flags={internal_added} after_cap=pending")

        if has_any('warehouse:fulfill_request', 'production:fulfill_request', 'production:approve_request'):
            material_requests = getattr(self, 'get_pending_material_requests', lambda: [])() or []
            for req in material_requests:
                record_entry({
                    "kind": "material_request",
                    "type": "درخواست مواد",
                    "priority": 2,
                    "details": f"{comm_page} → تب «درخواست‌های مواد» (شماره {req.get('id')})",
                    "date": req.get("created_at") or datetime.now(),
                    "action_key": "FULFILL_REQUEST",
                    "action_data": req.get("id"),
                })

        get_pending_transfers = getattr(self, "get_pending_transfers_to_production", None)
        if has_any('production:approve_transfer', 'warehouse:approve_transfer') and callable(get_pending_transfers):
            for transfer in (get_pending_transfers() or []):
                transfer_id = transfer.get('id')
                doc_label = transfer.get('t_no') or transfer_id
                record_entry({
                    "kind": "prod_receive",
                    "type": "تأیید دریافت مواد اولیه",
                    "priority": 1,
                    "details": f"{comm_page} → تب «دریافت مواد اولیه» (سند {doc_label})",
                    "date": transfer.get('t_date') or datetime.now(),
                    "action_key": "APPROVE_TRANSFER",
                    "action_data": transfer_id,
                })

        get_pending_deliveries = (
            getattr(self, "get_pending_deliveries", None)
            or getattr(self, "get_pending_transfers_to_production", None)
            or (lambda: [])
        )
        if has_any('warehouse:approve_delivery', 'production:approve_delivery', 'production:approve_transfer'):
            for delivery in (get_pending_deliveries() or []):
                record_entry({
                    "kind": "prod_delivery",
                    "type": "تحویل از تولید",
                    "priority": 2,
                    "details": f"{comm_page} → تب «تحویل از تولید» (سند {delivery.get('id')})",
                    "date": delivery.get("created_at") or datetime.now(),
                    "action_key": "APPROVE_DELIVERY",
                    "action_data": delivery.get("id"),
                })

        get_pending_returns = (
            getattr(self, "get_pending_returns_from_production", None)
            or getattr(self, "get_pending_returns", None)
            or (lambda: [])
        )
        if has_any('warehouse:approve_return', 'production:approve_return'):
            for ret in (get_pending_returns() or []):
                record_entry({
                    "kind": "prod_return",
                    "type": "برگشت از تولید",
                    "priority": 2,
                    "details": f"{comm_page} → تب «برگشتی‌ها» (سند {ret.get('id')})",
                    "date": ret.get("created_at") or datetime.now(),
                    "action_key": "APPROVE_RETURN",
                    "action_data": ret.get("id"),
                })

        get_pending_voids = getattr(self, 'get_pending_voids', None)
        if has_any('warehouse:approve_void', 'transactions:void') and callable(get_pending_voids):
            for void_row in (get_pending_voids() or []):
                void_id = void_row.get('id')
                source_type = void_row.get('original_type') or ''
                item_name = void_row.get('item_name') or ''
                details = f"{comm_page} → تب «ابطال‌ها» ({source_type} - {item_name})"
                record_entry({
                    "kind": "void",
                    "type": "تایید ابطال انبار",
                    "priority": 1,
                    "details": details,
                    "date": datetime.now(),
                    "action_key": "APPROVE_VOID",
                    "action_data": void_id,
                })

        if has_any('warehouse:open_communications', 'production:open_communications'):
            record_entry({
                "kind": "link",
                "type": "پیام داخلی",
                "priority": 3,
                "details": f"باز کردن صفحه «{comm_page}»",
                "date": datetime.now(),
                "action_key": "VIEW_COMMUNICATIONS",
                "action_data": "",
            })

        if reactivated_keys:
            dismissed_snapshot = set(dismissed_keys)
            remaining = dismissed_snapshot - reactivated_keys
            if remaining != dismissed_snapshot:
                self._save_notif_set('notif_dismissed_keys', remaining)
                dismissed_keys = remaining
            for key in sorted(reactivated_keys):
                gc_events.append((key, 'reactivated', True))

        if gc_events and (getattr(self, "DEBUG_NOTIF", False) or globals().get("DEBUG_NOTIF", False)):
            for key, reason, removed_flag in gc_events:
                print(f"[TRACE:NOTIF:gc] id={key} reason={reason} removed={str(removed_flag).lower()}")

        notifications.sort(key=lambda entry: _timestamp(entry.get('date') or entry.get('created_at') or entry.get('ts')), reverse=True)
        if globals().get('DEBUG_NOTIF', False):
            sample_keys = [round(_timestamp(n.get('date') or n.get('created_at') or n.get('ts')), 3) for n in notifications[:3]]
            print(f"[TRACE:NOTIF:sort] normalized_keys_sample={sample_keys}")

        limit = 20
        after_flags = len(notifications)
        if after_flags > limit:
            notifications = notifications[:limit]
            if globals().get('DEBUG_NOTIF', False):
                print(f"[TRACE:NOTIF:cap] total_before={after_flags} after_trim={len(notifications)} limit={limit} order_by=date")

        if getattr(self, "DEBUG_NOTIF", False) or globals().get("DEBUG_NOTIF", False):
            kinds_str = ",".join(sorted(kinds_seen)) if kinds_seen else "-"
            filters_repr = f"{{resolved:{excluded_flags['resolved']},dismissed:{excluded_flags['dismissed']}}}"
            print(f"[TRACE:NOTIF:fetch] filters={filters_repr} rows_db={len(raw_entries)} after_flags={after_flags} after_cap={len(notifications)} kinds={kinds_str}")

        return notifications

    def get_unread_memos_for_user(self, user_id: int, limit: int = 50):
        """Return unread internal memos for notification cards."""
        query = """
            SELECT
                mr.memo_id AS memo_id,
                m.subject,
                m.created_at,
                COALESCE(u.username, '-') AS author_name
            FROM memo_recipients mr
            JOIN internal_memos m ON m.id = mr.memo_id
            LEFT JOIN users u ON u.id = m.author_user_id
            WHERE mr.recipient_user_id = %s AND mr.read_at IS NULL
            ORDER BY COALESCE(m.created_at, NOW()) DESC
            LIMIT %s
        """
        try:
            rows = self.execute_query(query, (user_id, int(limit)))
        except Exception:
            return []
        return rows or []

    def get_next_memo_number(self, *, cursor=None) -> str:
        """
        ??????? ???? ???? ????? ?? ?? ??????? ?? ??????? ???????? ????? ??????.
        ??? ????? ?? ????? ????? ?? ????? ????? (MAX) ????????? ?? ????? ????? ????.
        """
        now_jalali = jd.datetime.now()
        year_short = f"{now_jalali.year % 100:02d}"
        sequence_key = f"memo_{year_short}"
        prefix = f"MEMO-{year_short}-"

        if cursor is None:
            with self.transaction() as cur:
                return self.get_next_memo_number(cursor=cur)

        debug_on = bool(getattr(self, 'DEBUG_MEMO_NO', False) or globals().get('DEBUG_MEMO_NO', False))

        try:
            # ????? ?? ???? ????? ???? ???? ? ?? ?? ??? ??
            cursor.execute(
                "INSERT INTO sequences (name, value) VALUES (%s, 0) ON CONFLICT (name) DO NOTHING",
                (sequence_key,),
            )
            seq_row = self.execute_query(
                "SELECT value FROM sequences WHERE name = %s FOR UPDATE",
                (sequence_key,),
                fetch_one=True,
                cursor=cursor,
            )
            current_val = int(seq_row.get('value') or 0) if seq_row else 0
            next_serial = current_val + 1

            # ??? ??????? ????? ???? ??????? ?? ???????? ??
            max_row = self.execute_query(
                "SELECT MAX(memo_number) AS last_memo FROM internal_memos WHERE memo_number LIKE %s",
                (f"{prefix}%",),
                fetch_one=True,
                cursor=cursor,
            )
            if max_row and max_row.get('last_memo'):
                try:
                    suffix = int(str(max_row['last_memo']).split('-')[-1])
                    if suffix >= next_serial:
                        next_serial = suffix + 1
                except (ValueError, TypeError):
                    pass

            cursor.execute(
                "UPDATE sequences SET value = %s WHERE name = %s",
                (next_serial, sequence_key),
            )
            memo_no = f"{prefix}{next_serial:05d}"
            if debug_on:
                print(f"[TRACE:MEMO:NO] source=sequence key={sequence_key} value={memo_no} ok=True")
            return memo_no
        except Exception as exc:
            if debug_on:
                print(f"[TRACE:MEMO:NO] source=sequence key={sequence_key} ok=False err={exc}")
            row = self.execute_query(
                "SELECT MAX(memo_number) AS last_memo FROM internal_memos WHERE memo_number LIKE %s",
                (f"{prefix}%",),
                fetch_one=True,
                cursor=cursor,
            )
            next_serial = 1
            if row and row.get('last_memo'):
                try:
                    suffix = int(str(row['last_memo']).split('-')[-1])
                    next_serial = suffix + 1
                except (ValueError, TypeError):
                    next_serial = 1
            memo_no = f"{prefix}{next_serial:05d}"
            try:
                cursor.execute(
                    "UPDATE sequences SET value = %s WHERE name = %s",
                    (next_serial, sequence_key),
                )
            except Exception:
                pass
            if debug_on:
                print(f"[TRACE:MEMO:NO] source=fallback key={sequence_key} value={memo_no} ok=True")
            return memo_no

    def create_memo(self, author_id: int, subject: str, body: str, to_user_ids=None, cc_user_ids=None, *, created_at=None):
        """????? ?? ???? ????? ? ??????????? ?? ????????."""
        to_user_ids = list(to_user_ids or [])
        cc_user_ids = list(cc_user_ids or [])
        if not to_user_ids and not cc_user_ids:
            raise ValueError("????? ?? ?????? ???? ?????? ???.")

        created_at = created_at or dt.datetime.utcnow()
        memo_id = None
        attempts = 0
        max_attempts = 3
        debug_no = bool(getattr(self, 'DEBUG_MEMO_NO', False) or globals().get('DEBUG_MEMO_NO', False))
        last_exc = None

        while attempts < max_attempts and memo_id is None:
            memo_number = None
            try:
                with self.transaction() as cur:
                    memo_number = self.get_next_memo_number(cursor=cur)
                    cur.execute(
                        """
                        INSERT INTO internal_memos (memo_number, subject, body, author_user_id, created_at)
                        VALUES (%s, %s, %s, %s, %s)
                        RETURNING id
                        """
                        (memo_number, subject, body, author_id, created_at)
                    )
                    memo_id = cur.fetchone()['id']
                    recipients = []
                    for uid in to_user_ids:
                        recipients.append((memo_id, int(uid), 'TO'))
                    for uid in cc_user_ids:
                        recipients.append((memo_id, int(uid), 'CC'))
                    if recipients:
                        cur.executemany(
                            "INSERT INTO memo_recipients (memo_id, recipient_user_id, recipient_type) VALUES (%s, %s, %s)",
                            recipients
                        )
            except psycopg2.errors.UniqueViolation as exc:
                attempts += 1
                last_exc = exc
                memo_id = None
                if debug_no and memo_number:
                    print(f"[TRACE:MEMO:NO] collision retry={attempts} new_no={memo_number}")
                continue
            except Exception as exc:
                if globals().get('DEBUG_NOTIF', False):
                    print(f"[TRACE:MEMO:create] ok=False memo_id={memo_id} err={exc}")
                raise

        if memo_id is None:
            if debug_no and memo_number:
                print(f"[TRACE:MEMO:NO] collision abort retries={attempts} last_no={memo_number}")
            if last_exc:
                raise last_exc
            raise RuntimeError("Failed to create memo after retries.")

        if globals().get('DEBUG_NOTIF', False):
            print(f"[TRACE:MEMO:create] ok=True memo_id={memo_id}")
        try:
            if hasattr(self, 'signals') and hasattr(self.signals, 'dataChanged'):
                self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        except Exception:
            pass
        return memo_id

    def get_user_sent_items(self, user_id: int):
        """تمام نامه‌های ارسالی یک کاربر را برمی‌گرداند."""
        query = """
            SELECT id, memo_number, subject, created_at FROM internal_memos
            WHERE author_user_id = %s
            ORDER BY created_at DESC
        """
        return self.execute_query(query, (user_id,))


    def mark_memo_as_read(self, memo_id: int, user_id: int, read_at=None) -> dict:
        """Set memo as read for a user; returns status dict."""
        read_at = read_at or dt.datetime.utcnow()
        updated = False
        try:
            with self.transaction() as cur:
                cur.execute(
                    "UPDATE memo_recipients SET read_at = %s WHERE memo_id = %s AND recipient_user_id = %s AND read_at IS NULL",
                    (read_at, memo_id, user_id)
                )
                updated = cur.rowcount > 0
            if updated:
                try:
                    self.mark_notification_resolved('VIEW_MEMO', memo_id)
                except Exception as exc:
                    if globals().get('DEBUG_MAIL_NOTIF', False):
                        print(f"[TRACE:MAIL:resolve] key=VIEW_MEMO:{memo_id} mode=resolved_keys stored=False err={exc}")
                else:
                    if globals().get('DEBUG_MAIL_NOTIF', False):
                        print(f"[TRACE:MAIL:resolve] key=VIEW_MEMO:{memo_id} mode=resolved_keys stored=True")
            if globals().get('DEBUG_MAIL_NOTIF', False):
                print(f"[TRACE:MAIL:read] memo_id={memo_id} db_mark_ok={updated} user_id={user_id}")
            print(f"NOTIF:MEMO:MARK_READ ok memo_id={memo_id} user={user_id} changed={'1' if updated else '0'}")
            return {'ok': True, 'changed': updated}
        except Exception as exc:
            print(f"NOTIF:MEMO:MARK_READ fail memo_id={memo_id} err={exc}")
            return {'ok': False, 'changed': False}

    def get_memo_details(self, memo_id: int, user_id: int):
        """Return memo metadata and body for viewing without mutating read state."""
        query = """
            SELECT m.memo_number, m.subject, m.body, u_author.username as author_name, m.created_at,
                (SELECT array_agg(u.username) FROM memo_recipients mr JOIN users u ON mr.recipient_user_id = u.id WHERE mr.memo_id = m.id AND mr.recipient_type = 'TO') as to_list,
                (SELECT array_agg(u.username) FROM memo_recipients mr JOIN users u ON mr.recipient_user_id = u.id WHERE mr.memo_id = m.id AND mr.recipient_type = 'CC') as cc_list
            FROM internal_memos m
            JOIN users u_author ON m.author_user_id = u_author.id
            WHERE m.id = %s
        """
        with self.transaction() as cur:
            return self.execute_query(query, (memo_id,), fetch_one=True, cursor=cur)

    def get_user_sent_items_detailed(self, user_id: int):
        """تمام نامه‌های ارسالی یک کاربر را به همراه لیست گیرندگان برمی‌گرداند."""
        query = """
            SELECT m.id, m.memo_number, m.subject, m.created_at,
                (SELECT string_agg(u.username, ', ') FROM memo_recipients mr JOIN users u ON mr.recipient_user_id = u.id WHERE mr.memo_id = m.id) as recipients_list
            FROM internal_memos m
            WHERE m.author_user_id = %s
            ORDER BY m.created_at DESC
        """
        return self.execute_query(query, (user_id,))
    
    def get_document_history(self, doc_identifier: str):
        """تاریخچه کامل یک سند را با جستجو در جداول مختلف پیدا کرده و برمی‌گرداند."""
        doc_identifier = doc_identifier.strip()
        history = []
        
        # جستجو در درخواست‌های خرید
        pr_query = """
            SELECT 'درخواست خرید' as doc_type, pr.status, pr.created_at, u.username as creator, i.name as item_name
            FROM purchase_requests pr
            JOIN users u ON pr.requester_id = u.id
            JOIN items i ON pr.item_id = i.id
            WHERE pr.id::text = %s
        """
        pr_result = self.execute_query(pr_query, (doc_identifier,), fetch_one=True)
        if pr_result:
            history.append(f"نوع سند: {pr_result['doc_type']} برای کالای «{pr_result['item_name']}»")
            history.append(f"ایجاد شده توسط: {pr_result['creator']} در تاریخ {to_shamsi(pr_result['created_at'])}")
            history.append(f"وضعیت فعلی: {pr_result['status']}")
            return history

        # جستجو در سفارشات خرید
        po_query = """
            SELECT 'سفارش خرید' as doc_type, po.status, po.issue_date, u.username as creator, s.name as supplier_name
            FROM purchase_orders po
            JOIN users u ON po.created_by_id = u.id
            JOIN suppliers s ON po.supplier_id = s.id
            WHERE po.po_number = %s
        """
        po_result = self.execute_query(po_query, (doc_identifier,), fetch_one=True)
        if po_result:
            history.append(f"نوع سند: {po_result['doc_type']} برای تامین‌کننده «{po_result['supplier_name']}»")
            history.append(f"ایجاد شده توسط: {po_result['creator']} در تاریخ {to_shamsi(po_result['issue_date'])}")
            history.append(f"وضعیت فعلی: {po_result['status']}")
            return history
            
        # در آینده می‌توان جستجو در جداول دیگر را نیز به اینجا اضافه کرد

        return ["سندی با این شناسه یافت نشد."]
    
# کجا بچسبون
# inventory.py → کلاس DB → جایگزین کامل متد get_user_tasks_for_kanban

    # BEGIN REWRITE<DB.get_user_tasks_for_kanban>
    def get_user_tasks_for_kanban(self, user_id: int, user_role_id: int) -> list[dict]:
        """
        فقط «کارهای شخصیِ کاربر» را برای برد کانبان برمی‌گرداند.
        هیچ PR/Workflowی اینجا ظاهر نمی‌شود.
        """
        rows = self.list_user_personal_kanban_tasks(user_id, include_done=False) or []

        def _map_state(s: str) -> str:
            s = (s or "TODO").upper()
            if s in ("DOING", "IN_PROGRESS"):
                return "in_progress"
            if s == "DONE":
                return "done"
            return "new"

        tasks = []
        for r in rows:
            tasks.append({
                "process_instance_id": r.get("id"),
                "related_record_id":   r.get("id"),
                "related_table_name":  "kanban_tasks",
                "workflow_name":       "PERSONAL",
                "step_name":           "PERSONAL",
                "started_at":          r.get("due_date"),
                "kanban_state":        _map_state(r.get("status")),
                "title":               r.get("title"),
                "description":         r.get("description"),
                "priority":            r.get("priority"),
            })
        return tasks
    # END REWRITE<DB.get_user_tasks_for_kanban>

    # BEGIN REWRITE<DB.update_task_kanban_state>
    def get_pending_tasks_for_user_role(self, user_id: int, role_identifier) -> list[dict]:
        """Alias wrapper برای سازگاری UI قبلی."""
        role_id = None
        if role_identifier is not None:
            try:
                role_id = int(role_identifier)
            except Exception:
                try:
                    role_id = int(self.get_role_id_by_name(role_identifier)) if hasattr(self, 'get_role_id_by_name') else None
                except Exception:
                    role_id = None
        if not role_id:
            if globals().get('DEBUG_NOTIF', False):
                print("[TRACE:TASKS:pending] ok=False reason=no-role")
            return []
        try:
            tasks = self.get_user_tasks_for_kanban(user_id, role_id) or []
        except Exception as exc:
            if globals().get('DEBUG_NOTIF', False):
                print(f"[TRACE:TASKS:pending] ok=False reason={exc}")
            return []
        if globals().get('DEBUG_NOTIF', False):
            print(f"[TRACE:TASKS:pending] ok=True count={len(tasks)}")
        return tasks


    def update_task_kanban_state(self, process_instance_id, new_state) -> bool:
        """
        به‌روزرسانی حالت کارت کانبان:
        - اگر جدول شخصی `kanban_tasks` وجود داشته باشد، ستون status همان‌جا آپدیت می‌شود.
        - وگرنه (سازگاری قدیمی) تلاش می‌کند در `manager_approvals.kanban_state` بنویسد.
        همواره True برمی‌گرداند تا UI خطا نبیند.
        """
        try:
            if new_state is None:
                new_state = "new"
            new_state = str(new_state).strip().lower()[:32] or "new"

            with self.transaction() as cur:
                # کمک‌ها
                def _exists(table: str) -> bool:
                    cur.execute("SELECT to_regclass(%s) IS NOT NULL AS ok", (f"public.{table}",))
                    r = cur.fetchone()
                    return bool((r or {}).get("ok") if isinstance(r, dict) else (r and r[0]))

                def _cols(table: str) -> set:
                    cur.execute("""
                        SELECT column_name FROM information_schema.columns
                        WHERE table_schema='public' AND table_name=%s
                    """, (table,))
                    return {(x["column_name"] if isinstance(x, dict) else x[0])
                            for x in (cur.fetchall() or [])}

                # 1) مسیر جدید: kanban_tasks.status
                if _exists("kanban_tasks"):
                    cols = _cols("kanban_tasks")
                    if {"id", "status"} <= cols:
                        state_map = {
                            "new": "TODO",
                            "in_progress": "DOING",
                            "doing": "DOING",
                            "done": "DONE",
                        }
                        status_val = state_map.get(new_state, "TODO")
                        cur.execute("UPDATE kanban_tasks SET status=%s WHERE id=%s",
                                    (status_val, process_instance_id))
                        return True  # موفق

                # 2) مسیر قدیمی: manager_approvals.kanban_state (no-op اگر ستون نبود)
                if _exists("manager_approvals"):
                    cols = _cols("manager_approvals")
                    if "id" in cols and "kanban_state" in cols:
                        cur.execute("UPDATE manager_approvals SET kanban_state=%s WHERE id=%s",
                                    (new_state, process_instance_id))
                return True
        except Exception:
            return True  # fail-safe
    # END REWRITE<DB.update_task_kanban_state>

    def get_new_tasks_count(self, user_id: int, user_role_id: int) -> int:
        """
        تعداد وظایف منتظر اقدام کاربر؛ اکنون با هِلپر نقش و نگاشت مرحله.
        رفتار بیرونی تغییری نکرده: فقط یک عدد برمی‌گرداند.
        """
        if not (user_id and user_role_id):
            return 0
        try:
            role_name = self.get_role_name(user_role_id)
            stage = self._infer_approval_stage_from_role(role_name)
            if not stage:
                return 0
            rows = self.list_pending_manager_approvals(
                only_mine=True,
                manager_id=int(user_id),
                workflow=stage
            ) or []
            return len(rows)
        except Exception:
            return 0

    def get_unread_memos_count(self, user_id: int):
        """تعداد نامه‌های خوانده نشده یک کاربر را برمی‌گرداند."""
        query = "SELECT COUNT(id) as count FROM memo_recipients WHERE recipient_user_id = %s AND read_at IS NULL"
        result = self.execute_query(query, (user_id,), fetch_one=True)
        return result['count'] if result else 0

        
    
    # این متد کاملا جدید را به انتهای کلاس DB اضافه کنید
    def save_advanced_form_def(self, form_data: dict, user_id: int):
        """یک تعریف فرم پیشرفته را از فرم‌ساز جدید، ثبت یا ویرایش می‌کند."""
        with self.transaction() as cur:
            fields_json = json.dumps(form_data['fields'], ensure_ascii=False)
            form_id = form_data.get('id')
            
            if form_id: # حالت ویرایش
                cur.execute(
                    "UPDATE form_defs SET name = %s, fields = %s, form_type = %s WHERE id = %s",
                    (form_data['name'], fields_json, form_data['type'], form_id)
                )
                return form_id
            else: # حالت افزودن
                cur.execute(
                    "INSERT INTO form_defs (name, fields, user_id, form_type) VALUES (%s, %s, %s, %s) RETURNING id",
                    (form_data['name'], fields_json, user_id, form_data['type'])
                )
                return cur.fetchone()['id']
    
# در کلاس DB، این متد را به طور کامل با نسخه امن زیر جایگزین کنید
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def delete_form_def(self, fid: int):
        """
        یک تعریف فرم را به صورت امن حذف می‌کند.
        نسخه نهایی: از context manager برای تضمین اتمی بودن عملیات استفاده می‌کند.
        """
        try:
            with self.transaction() as cur:
                # به لطف ON DELETE CASCADE در جدول form_entries،
                # با حذف این ردیف، تمام رکوردهای مرتبط نیز حذف می‌شوند.
                self.execute_query("DELETE FROM form_defs WHERE id=%s", (fid,), cursor=cur)
        except Exception as e:
            # در صورت بروز خطای پیش‌بینی نشده (مثلا وابستگی در جدول دیگر)
            print(f"ERROR in delete_form_def: {e}")
            raise RuntimeError(f"قادر به حذف فرم با شناسه {fid} نبود. ممکن است این فرم در جای دیگری استفاده شده باشد.")
                    

            
# این متد جدید را به کلاس DB اضافه کنید
    def get_distinct_item_categories(self):
        """لیستی از تمام دسته‌بندی‌های منحصر به فرد کالاها را برمی‌گرداند."""
        rows = self.execute_query("SELECT DISTINCT category FROM items WHERE category IS NOT NULL AND category != '' ORDER BY category")
        return [row['category'] for row in rows]
    
            
# این متد جدید را به کلاس DB اضافه کنید
    def check_for_stock_triggers(self):
        """
        کالاهایی که به زیر حد سفارش رسیده‌اند و هیچ درخواست خرید فعالی ندارند را پیدا می‌کند.
        """
        query = """
            SELECT i.id, i.name, i.max_qty
            FROM items i
            LEFT JOIN (
                SELECT item_id, SUM(qty) as total_qty
                FROM stock
                GROUP BY item_id
            ) s ON i.id = s.item_id
            WHERE 
                COALESCE(s.total_qty, 0) < i.min_qty 
                AND i.min_qty > 0
                AND NOT EXISTS (
                    SELECT 1 FROM purchase_requests pr
                    WHERE pr.item_id = i.id AND pr.status NOT IN ('تکمیل شده', 'رد شده', 'باطل شده')
                );
        """
        return self.execute_query(query)
    
  
# Add this new method to your DB class
    def form_name_exists(self, name: str, user_id: int, exclude_form_id: int = None) -> bool:
        """Checks if a form with the given name already exists for the specified user."""
        query = "SELECT 1 FROM form_defs WHERE name = %s AND user_id = %s"
        params = [name, user_id]
        if exclude_form_id:
            query += " AND id != %s"
            params.append(exclude_form_id)
        
        result = self.execute_query(query, tuple(params), fetch_one=True)
        return result is not None
    

    def save_system_operation_mappings(self, mappings: dict):
        """نگاشت جدید عملیات‌های سیستمی به فرآیندها را در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            cur.execute("TRUNCATE TABLE system_operation_mappings;")
            if mappings:
                args_list = list(mappings.items())
                cur.executemany(
                    "INSERT INTO system_operation_mappings (operation_key, workflow_id) VALUES (%s, %s)",
                    args_list
                )                
            
    # BEGIN REWRITE: DB.receive_purchase_order
    def receive_purchase_order(self, po_id: int, receiver_id: int, items: list[dict],
                            receipt_no: str | None = None, received_at: str | None = None):
        """
        دریافت اقلام سفارش + ثبت رسید + به‌روزرسانی موجودی + به‌روزرسانی وضعیت‌های PO/PR (اتمیک).
        - بدون وابستگی تازه؛ با کشف خودکار نام/ستون جداول (مثل کُدهای دیگر).
        - خروجی دقیقاً مثل قبل می‌ماند: {'updated': n, 'complete': bool, 'duplicate': bool}
        """
        if not items:
            return {'updated': 0, 'complete': False, 'duplicate': False}

        def _table_exists(cur, name: str) -> bool:
            cur.execute("SELECT to_regclass(%s) IS NOT NULL", (f'public.{name}',))
            r = cur.fetchone()
            return bool(r and (r[0] is True))

        def _columns(cur, name: str) -> set[str]:
            cur.execute("""
                SELECT column_name FROM information_schema.columns
                WHERE table_schema='public' AND table_name=%s
            """, (name,))
            return {r[0] for r in (cur.fetchall() or [])}

        def _find_inventory_table(cur):
            for tbl in ('stock', 'inventory', 'inventories', 'stock_levels'):
                if _table_exists(cur, tbl):
                    cols = _columns(cur, tbl)
                    if 'qty' in cols: qcol = 'qty'
                    elif 'quantity' in cols: qcol = 'quantity'
                    else: qcol = None
                    return tbl, qcol, cols
            return None, None, set()

        def _find_po_items_table(cur):
            for tbl in ('purchase_order_items', 'po_items'):
                if _table_exists(cur, tbl):
                    cols = _columns(cur, tbl)
                    if {'id', 'po_id', 'item_id'} <= cols and ({'qty','quantity','ordered_qty'} & cols):
                        if 'qty' in cols: qcol = 'qty'
                        elif 'quantity' in cols: qcol = 'quantity'
                        else: qcol = 'ordered_qty'
                        rcv_col = 'received_qty' if 'received_qty' in cols else None
                        # کلید PR در آیتم‌ها
                        pr_fk = 'pr_id' if 'pr_id' in cols else ('purchase_request_id' if 'purchase_request_id' in cols else None)
                        return tbl, qcol, rcv_col, pr_fk, cols
            return None, None, None, None, set()

        # ادغام ردیف‌های هم‌کلید در سطح همان رسید
        clean_map = {}
        for it in (items or []):
            try:
                pid = int(it.get('po_item_id'))
                q = float(it.get('qty', 0))
            except Exception:
                continue
            if q <= 0:
                continue
            key = (
                pid,
                (it.get('batch_no') or None),
                (it.get('expiry_date') or None),
                (it.get('location_id') or None),
                bool(it.get('requires_qc', False))
            )
            clean_map[key] = clean_map.get(key, 0.0) + q

        merged_items = []
        for (pid, batch_no, expiry_dt, location_id, requires_qc), q in clean_map.items():
            merged_items.append({
                'po_item_id': pid,
                'qty': q,
                'batch_no': batch_no,
                'expiry_date': expiry_dt,
                'location_id': location_id,
                'requires_qc': requires_qc
            })
        if not merged_items:
            return {'updated': 0, 'complete': False, 'duplicate': False}

        updated = 0
        po_complete = False
        duplicate_receipt = False
        completed_pr_ids = set()
        touched_pr_ids = set()

        with self.transaction() as cur:
            # جداول هدف
            poi_tbl, poi_qty_col, poi_rcv_col, poi_pr_fk, poi_cols = _find_po_items_table(cur)
            inv_tbl, inv_qty_col, inv_cols = _find_inventory_table(cur)
            if not (poi_tbl and inv_tbl and inv_qty_col):
                return {'updated': 0, 'complete': False, 'duplicate': False}

            # اسکیمای PO (ایمن)
            try:
                self.ensure_purchase_orders_schema()
            except Exception:
                pass

            # اسکیمای رسیدها (در صورت وجود)
            has_receipts = _table_exists(cur, 'receipts')
            has_receipt_items = _table_exists(cur, 'receipt_items')
            if has_receipts and has_receipt_items:
                # پیشگیری از ثبت تکراری شماره رسید برای همان PO
                existing_receipt_id = None
                if receipt_no:
                    cur.execute("SELECT id FROM receipts WHERE po_id=%s AND receipt_no=%s LIMIT 1", (po_id, receipt_no))
                    r = cur.fetchone()
                    if r:
                        existing_receipt_id = int(r[0] if not isinstance(r, dict) else r['id'])
                if existing_receipt_id:
                    duplicate_receipt = True
                    return {'updated': 0, 'complete': False, 'duplicate': True}

                # ساخت هدر رسید
                cur.execute("""
                    INSERT INTO receipts (po_id, receiver_id, receipt_no, received_at, created_at)
                    VALUES (%s, %s, %s, COALESCE(%s, NOW()), NOW())
                    RETURNING id
                """, (po_id, receiver_id, (receipt_no or None), received_at))
                receipt_id = int((cur.fetchone() or [0])[0])
            else:
                receipt_id = None

            # ثبت آیتم‌ها + به‌روزرسانی موجودی + افزایش received_qty
            for it in merged_items:
                pid = int(it['po_item_id'])
                q = float(it['qty'])
                batch_no = it.get('batch_no')
                expiry_dt = it.get('expiry_date')
                location_id = it.get('location_id')
                requires_qc = bool(it.get('requires_qc', False))

                # تشخیص کالا برای درج/تجمیع موجودی
                cur.execute(f"SELECT item_id FROM {poi_tbl} WHERE id=%s", (pid,))
                row = cur.fetchone()
                if not row:
                    continue
                item_id = int(row[0] if not isinstance(row, dict) else row['item_id'])

                # نوشتن آیتم‌های رسید
                if receipt_id and has_receipt_items:
                    cols_ri = ['receipt_id', 'po_item_id', 'qty']
                    vals_ri = [receipt_id, pid, q]
                    if 'batch_no' in _columns(cur, 'receipt_items'):
                        cols_ri.append('batch_no'); vals_ri.append(batch_no)
                    if 'expiry_date' in _columns(cur, 'receipt_items'):
                        cols_ri.append('expiry_date'); vals_ri.append(expiry_dt)
                    if 'location_id' in _columns(cur, 'receipt_items'):
                        cols_ri.append('location_id'); vals_ri.append(location_id)
                    if 'requires_qc' in _columns(cur, 'receipt_items'):
                        cols_ri.append('requires_qc'); vals_ri.append(requires_qc)
                    cur.execute(
                        f"INSERT INTO receipt_items ({', '.join(cols_ri)}) VALUES ({', '.join(['%s']*len(vals_ri))})",
                        tuple(vals_ri)
                    )

                # درج/تجمیع موجودی (قرنطینه برای QC)
                if 'location_id' in inv_cols and 'batch_no' in inv_cols and 'expiry_date' in inv_cols and 'status' in inv_cols:
                    # مدل لوکیشن‌دار
                    if location_id is None:
                        try:
                            location_id = self.get_warehouse_default_location('Main')
                        except Exception:
                            location_id = None
                    # تلاش برای ردیف موجود مشابه
                    cur.execute(f"""
                        SELECT id FROM {inv_tbl}
                        WHERE item_id=%s
                        AND COALESCE(location_id,0)=COALESCE(%s,0)
                        AND COALESCE(batch_no,'')=COALESCE(%s,'')
                        AND COALESCE(expiry_date::date,DATE '1970-01-01')=COALESCE(%s::date,DATE '1970-01-01')
                        AND COALESCE(status,'تایید شده')=%s
                        LIMIT 1
                    """, (item_id, location_id, batch_no, expiry_dt, ('قرنطینه' if requires_qc else 'تایید شده')))
                    r = cur.fetchone()
                    if r:
                        sid = int(r[0] if not isinstance(r, dict) else r['id'])
                        cur.execute(f"UPDATE {inv_tbl} SET {inv_qty_col}=COALESCE({inv_qty_col},0)+%s WHERE id=%s", (q, sid))
                    else:
                        cols = ['item_id', inv_qty_col]
                        vals = [item_id, q]
                        if 'location_id' in inv_cols: cols.append('location_id'); vals.append(location_id)
                        if 'batch_no' in inv_cols: cols.append('batch_no'); vals.append(batch_no)
                        if 'expiry_date' in inv_cols: cols.append('expiry_date'); vals.append(expiry_dt)
                        if 'status' in inv_cols: cols.append('status'); vals.append('قرنطینه' if requires_qc else 'تایید شده')
                        cur.execute(f"INSERT INTO {inv_tbl} ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(vals))})", tuple(vals))
                else:
                    # مدل تجمیعی ساده
                    cur.execute(f"UPDATE {inv_tbl} SET {inv_qty_col}=COALESCE({inv_qty_col},0)+%s WHERE item_id=%s", (q, item_id))
                    if cur.rowcount == 0:
                        cur.execute(f"INSERT INTO {inv_tbl} (item_id, {inv_qty_col}) VALUES (%s,%s)", (item_id, q))

                # به‌روزرسانی دریافتی آیتم PO (اگر ستونش وجود دارد)
                if poi_rcv_col:
                    cur.execute(f"UPDATE {poi_tbl} SET {poi_rcv_col}=COALESCE({poi_rcv_col},0)+%s WHERE id=%s", (q, pid))

                # PR لمس‌شده را نگه داریم
                if poi_pr_fk:
                    cur.execute(f"SELECT {poi_pr_fk} FROM {poi_tbl} WHERE id=%s", (pid,))
                    rr = cur.fetchone()
                    if rr:
                        touched_pr_ids.add(int(rr[0] if not isinstance(rr, dict) else rr[poi_pr_fk]))

                updated += 1

            # آیا کل سفارش کامل شد؟
            if poi_rcv_col:
                cur.execute(f"SELECT bool_and(COALESCE({poi_rcv_col},0) >= {poi_qty_col}) FROM {poi_tbl} WHERE po_id=%s", (po_id,))
                po_complete = bool((cur.fetchone() or [False])[0])
            elif _table_exists(cur, 'receipt_items'):
                cur.execute(f"""
                    WITH ord AS (SELECT id AS po_item_id, {poi_qty_col} AS ordered FROM {poi_tbl} WHERE po_id=%s),
                        rcv AS (SELECT po_item_id, COALESCE(SUM(qty),0) AS received
                                FROM receipt_items WHERE po_item_id IN (SELECT po_item_id FROM ord)
                                GROUP BY po_item_id)
                    SELECT bool_and(COALESCE(rcv.received,0) >= ord.ordered)
                    FROM ord LEFT JOIN rcv ON rcv.po_item_id = ord.po_item_id
                """, (po_id,))
                po_complete = bool((cur.fetchone() or [False])[0])

            # وضعیت PO اگر کامل شد
            try:
                if po_complete and _table_exists(cur, 'purchase_orders') and 'status' in _columns(cur, 'purchase_orders'):
                    cur.execute("UPDATE purchase_orders SET status=%s WHERE id=%s", ('دریافت کامل شد', po_id))
            except Exception:
                pass

            # به‌روزرسانی وضعیت PRها
            if touched_pr_ids:
                for pr_id in list(touched_pr_ids):
                    try:
                        self._transit_pr_status(pr_id, 'انبار', allow_from=['سفارش صادر شد','در انتظار تایید بازرگانی','باز'], cursor=cur)
                    except Exception:
                        pass

                    pr_complete = False
                    try:
                        if poi_rcv_col:
                            cur.execute(f"""
                                SELECT bool_and(COALESCE({poi_rcv_col},0) >= {poi_qty_col})
                                FROM {poi_tbl}
                                WHERE {poi_pr_fk}=%s
                            """, (pr_id,))
                            pr_complete = bool((cur.fetchone() or [False])[0])
                        elif _table_exists(cur, 'receipt_items'):
                            cur.execute(f"""
                                WITH ord AS (
                                    SELECT id AS po_item_id, {poi_qty_col} AS ordered
                                    FROM {poi_tbl}
                                    WHERE {poi_pr_fk}=%s
                                ),
                                rcv AS (
                                    SELECT po_item_id, COALESCE(SUM(qty),0) AS received
                                    FROM receipt_items
                                    WHERE po_item_id IN (SELECT po_item_id FROM ord)
                                    GROUP BY po_item_id
                                )
                                SELECT bool_and(COALESCE(rcv.received,0) >= ord.ordered)
                                FROM ord LEFT JOIN rcv ON rcv.po_item_id = ord.po_item_id
                            """, (pr_id,))
                            pr_complete = bool((cur.fetchone() or [False])[0])
                    except Exception:
                        pr_complete = False

                    if pr_complete:
                        try:
                            self._transit_pr_status(pr_id, 'تکمیل شده',
                                                    allow_from=['انبار','سفارش صادر شد','در انتظار تایید بازرگانی','باز'],
                                                    cursor=cur)
                        except Exception:
                            pass

        # اعلان‌های تازه‌سازی UI/پیگیری
        try:
            if hasattr(self, "_notify"):
                self._notify('NOTIFICATIONS_CHANGED')
                self._notify('PURCHASING_LISTS_CHANGED')
        except Exception:
            pass

        return {
            'updated': int(updated),
            'complete': bool(po_complete),
            'duplicate': bool(duplicate_receipt)
        }
    # END REWRITE: DB.receive_purchase_order
    
    # BEGIN ADD: DB.preview_receive_purchase_order
    def preview_receive_purchase_order(self, po_id: int, items: list[dict], receipt_no: str | None = None,
                                    warn_expiry_days: int = 30) -> dict:
        """
        پیش‌نمایش دریافت برای PO: ادغام ردیف‌های مشابه همان رسید + محاسبهٔ مانده و هشدارها.
        خروجی: {items: [...], warnings: [str,...], duplicates: bool, over_receipt: [po_item_id,...]}
        ثبت در دیتابیس انجام نمی‌شود.
        """
        warnings = []
        if not items:
            return {"items": [], "warnings": ["هیچ ردیفی ارسال نشده"], "duplicates": False, "over_receipt": []}

        # ادغام ورودی‌های هم‌کلید (همان منطق مرحلهٔ ۲)
        clean_map = {}
        for it in items:
            try:
                pid = int(it.get('po_item_id')); q = float(it.get('qty'))
            except Exception:
                continue
            if q <= 0:
                continue
            key = (
                pid,
                (it.get('batch_no') or None),
                (it.get('expiry_date') or None),
                (it.get('location_id') or None),
                bool(it.get('requires_qc', False))
            )
            clean_map[key] = clean_map.get(key, 0.0) + q

        merged = []
        for (pid, batch_no, expiry_dt, location_id, requires_qc), q in clean_map.items():
            merged.append({'po_item_id': pid, 'qty': q, 'batch_no': batch_no, 'expiry_date': expiry_dt,
                        'location_id': location_id, 'requires_qc': requires_qc})
        if not merged:
            return {"items": [], "warnings": ["همهٔ مقدارها صفر شد"], "duplicates": False, "over_receipt": []}

        # خواندن اطلاعات آیتم‌های سفارش برای مانده
        over_ids = []
        with self.transaction() as cur:
            def _table_exists(name: str) -> bool:
                cur.execute("SELECT to_regclass(%s) IS NOT NULL", (f'public.{name}',))
                r = cur.fetchone(); return bool(r and (r[0] is True))
            def _columns(name: str) -> set[str]:
                cur.execute("SELECT column_name FROM information_schema.columns WHERE table_schema='public' AND table_name=%s", (name,))
                return {r[0] for r in (cur.fetchall() or [])}

            # مانده هر ردیف PO
            poi_tbl = 'purchase_order_items' if _table_exists('purchase_order_items') else ('po_items' if _table_exists('po_items') else None)
            if poi_tbl:
                cols = _columns(poi_tbl)
                qty_col = 'ordered_qty' if 'ordered_qty' in cols else ('qty' if 'qty' in cols else 'quantity')
                rcv_col = 'received_qty' if 'received_qty' in cols else None
                info = {}
                cur.execute(f"SELECT id, {qty_col} FROM {poi_tbl} WHERE po_id=%s", (po_id,))
                for rid, ordered in (cur.fetchall() or []):
                    prev = 0.0
                    if _table_exists('receipt_items'):
                        cur.execute("SELECT COALESCE(SUM(qty),0) FROM receipt_items WHERE po_item_id=%s", (rid,))
                        prev = float((cur.fetchone() or [0])[0] or 0)
                    info[int(rid)] = {'ordered': float(ordered), 'received_so_far': prev}
                # بررسی بیش‌از-مانده
                for it in merged:
                    m = info.get(int(it['po_item_id']))
                    if m:
                        remain = max(0.0, m['ordered'] - m['received_so_far'])
                        if float(it['qty']) > remain + 1e-9:
                            over_ids.append(int(it['po_item_id']))
            else:
                warnings.append('جدول آیتم‌های سفارش پیدا نشد؛ مانده محاسبه نشد.')

            # هشدارهای تاریخ انقضا
            from datetime import datetime, timedelta
            today = datetime.utcnow().date()
            soon  = today + timedelta(days=int(warn_expiry_days))
            for it in merged:
                x = it.get('expiry_date')
                if not x:
                    continue
                try:
                    d = datetime.fromisoformat(str(x)).date()
                    if d < today:
                        warnings.append(f"ردیف {it['po_item_id']}: تاریخ انقضا گذشته است ({d.isoformat()}).")
                    elif d <= soon:
                        warnings.append(f"ردیف {it['po_item_id']}: تاریخ انقضا نزدیک است ({d.isoformat()}).")
                except Exception:
                    warnings.append(f"ردیف {it['po_item_id']}: فرمت تاریخ انقضا نامعتبر است.")

            # بررسی تکراری همان رسید (اگر شمارهٔ رسید دادید و جداول موجودند)
            duplicates = False
            if receipt_no and _table_exists('receipts') and _table_exists('receipt_items'):
                cur.execute("SELECT id FROM receipts WHERE po_id=%s AND receipt_no=%s LIMIT 1", (po_id, receipt_no))
                row = cur.fetchone()
                if row:
                    duplicates = True

        return {
            "items": merged,
            "warnings": warnings,
            "duplicates": bool(duplicates),
            "over_receipt": sorted(list(set(over_ids)))
        }
    # END ADD: DB.preview_receive_purchase_order
    
    # BEGIN ADD: DB.suggest_item_location
    def suggest_item_location(self, item_id: int, fallback_warehouse_name: str = 'Main') -> int | None:
        """لوکیشن پیشنهادی برای یک کالا بر اساس بیشترین موجودی غیرقرنطینه؛ در غیر اینصورت لوکیشن پیش‌فرض انبار Main."""
        with self.transaction() as cur:
            try:
                cur.execute("""
                    SELECT location_id FROM stock
                    WHERE item_id=%s AND COALESCE(status,'تایید شده') <> 'قرنطینه'
                    GROUP BY location_id
                    ORDER BY SUM(COALESCE(qty,0)) DESC
                    LIMIT 1
                """, (item_id,))
                row = cur.fetchone()
                if row and row[0]:
                    return int(row[0])
            except Exception:
                pass
            try:
                return self.get_warehouse_default_location(fallback_warehouse_name)
            except Exception:
                return None
    # END ADD: DB.suggest_item_location
    
    # BEGIN ADD: DB.place_receipt_items
    def place_receipt_items(self, receipt_id: int | None, placer_id: int, placements: list[dict]) -> dict:
        """
        جایگذاری اقلام دریافت‌شده از «قرنطینه» به «لوکیشن نهایی» (Putaway) بدون workflow.
        ورودی placement هر آیتم (حداقل یکی از شِماهای زیر):
        A) {"po_item_id": 101, "qty": 5, "to_location_id": 3, "batch_no": "...", "expiry_date": "2025-12-31"}
        B) {"inventory_id": 555, "qty": 5, "to_location_id": 3}
        C) {"item_id": 77, "qty": 5, "from_location_id": 2, "to_location_id": 3, "batch_no": "...", "expiry_date": "..."}
        خروجی: {"moved": n, "skipped": k, "errors": e}
        """
        if not placements:
            return {"moved": 0, "skipped": 0, "errors": 0}

        def _table_exists(cur, name: str) -> bool:
            cur.execute("SELECT to_regclass(%s) IS NOT NULL", (f'public.{name}',))
            r = cur.fetchone()
            return bool(r and (r[0] is True))

        def _columns(cur, name: str) -> set[str]:
            cur.execute("""
                SELECT column_name FROM information_schema.columns
                WHERE table_schema='public' AND table_name=%s
            """, (name,))
            return {r[0] for r in (cur.fetchall() or [])}

        def _find_inventory_table(cur):
            for tbl in ('stock', 'inventory', 'inventories', 'stock_levels'):
                if _table_exists(cur, tbl):
                    cols = _columns(cur, tbl)
                    qcol = 'qty' if 'qty' in cols else ('quantity' if 'quantity' in cols else None)
                    return tbl, qcol, cols
            return None, None, set()

        moved = 0
        skipped = 0
        errors = 0

        with self.transaction() as cur:
            inv_tbl, inv_qty_col, inv_cols = _find_inventory_table(cur)
            if not (inv_tbl and inv_qty_col and 'item_id' in inv_cols):
                return {"moved": 0, "skipped": len(placements), "errors": 0}

            has_status = 'status' in inv_cols
            has_location = 'location_id' in inv_cols
            has_batch = 'batch_no' in inv_cols
            has_expiry = 'expiry_date' in inv_cols

            def _default_loc():
                try:
                    return self.get_warehouse_default_location('Main')
                except Exception:
                    return None

            # تجمیع ورودی‌های هم‌کلید
            agg = {}
            for p in placements:
                try:
                    qty = float(p.get('qty', 0) or 0)
                except Exception:
                    qty = 0
                if qty <= 0:
                    skipped += 1
                    continue

                key = (
                    p.get('po_item_id'),
                    p.get('inventory_id'),
                    p.get('item_id'),
                    p.get('from_location_id'),
                    p.get('to_location_id'),
                    p.get('batch_no'),
                    p.get('expiry_date')
                )
                agg[key] = agg.get(key, 0.0) + qty

            for (po_item_id, inventory_id, item_id, from_loc, to_loc, batch_no, expiry_dt), qty in agg.items():
                try:
                    # 1) کشف/اعتبارسنجی منبع (قرنطینه)
                    src_rows = []

                    if inventory_id:
                        cur.execute(f"SELECT id, item_id, {inv_qty_col}, "
                                    f"{'location_id,' if has_location else ''}"
                                    f"{'batch_no,' if has_batch else ''}"
                                    f"{'expiry_date,' if has_expiry else ''}"
                                    f"{'status' if has_status else 'NULL as status'} "
                                    f"FROM {inv_tbl} WHERE id=%s", (inventory_id,))
                        r = cur.fetchone()
                        if not r:
                            skipped += 1
                            continue
                        src_rows = [r]

                    elif po_item_id:
                        if not has_location and not has_status:
                            cur.execute(f"SELECT id, item_id, {inv_qty_col} FROM {inv_tbl} WHERE item_id IN "
                                        f"(SELECT item_id FROM purchase_order_items WHERE id=%s) LIMIT 1", (po_item_id,))
                            r = cur.fetchone()
                            if not r:
                                skipped += 1
                                continue
                            src_rows = [r]
                        else:
                            clauses = [f"item_id = (SELECT item_id FROM purchase_order_items WHERE id=%s)"]
                            params = [po_item_id]
                            if has_status:
                                clauses.append("(status='قرنطینه' OR UPPER(COALESCE(status,''))='QUARANTINE')")
                            if has_batch and batch_no:
                                clauses.append("COALESCE(batch_no,'')=COALESCE(%s,'')"); params.append(batch_no)
                            if has_expiry and expiry_dt:
                                clauses.append("COALESCE(expiry_date::date,DATE '1970-01-01')=COALESCE(%s::date,DATE '1970-01-01')")
                                params.append(expiry_dt)
                            if has_location and from_loc is not None:
                                clauses.append("COALESCE(location_id,0)=COALESCE(%s,0)"); params.append(from_loc)
                            cur.execute(f"SELECT id, item_id, {inv_qty_col}, "
                                        f"{'location_id,' if has_location else ''}"
                                        f"{'batch_no,' if has_batch else ''}"
                                        f"{'expiry_date,' if has_expiry else ''}"
                                        f"{'status' if has_status else 'NULL as status'} "
                                        f"FROM {inv_tbl} WHERE {' AND '.join(clauses)} "
                                        f"ORDER BY {inv_qty_col} DESC", tuple(params))
                            src_rows = cur.fetchall() or []

                    else:
                        clauses = ["item_id=%s"]; params = [item_id]
                        if has_status:
                            clauses.append("(status='قرنطینه' OR UPPER(COALESCE(status,''))='QUARANTINE')")
                        if has_batch and batch_no:
                            clauses.append("COALESCE(batch_no,'')=COALESCE(%s,'')"); params.append(batch_no)
                        if has_expiry and expiry_dt:
                            clauses.append("COALESCE(expiry_date::date,DATE '1970-01-01')=COALESCE(%s::date,DATE '1970-01-01')")
                            params.append(expiry_dt)
                        if has_location and from_loc is not None:
                            clauses.append("COALESCE(location_id,0)=COALESCE(%s,0)"); params.append(from_loc)
                        cur.execute(f"SELECT id, item_id, {inv_qty_col}, "
                                    f"{'location_id,' if has_location else ''}"
                                    f"{'batch_no,' if has_batch else ''}"
                                    f"{'expiry_date,' if has_expiry else ''}"
                                    f"{'status' if has_status else 'NULL as status'} "
                                    f"FROM {inv_tbl} WHERE {' AND '.join(clauses)} "
                                    f"ORDER BY {inv_qty_col} DESC", tuple(params))
                        src_rows = cur.fetchall() or []

                    if not src_rows:
                        skipped += 1
                        continue

                    # 2) مقصد
                    if has_location and (to_loc is None):
                        to_loc = _default_loc()

                    # 3) انتقال از قرنطینه به مقصد
                    remaining = qty
                    for r in src_rows:
                        if isinstance(r, dict):
                            sid = r['id']; s_item = r['item_id']; s_qty = float(r.get(inv_qty_col) or 0)
                            s_loc = r.get('location_id') if has_location else None
                            s_batch = r.get('batch_no') if has_batch else None
                            s_expiry = r.get('expiry_date') if has_expiry else None
                        else:
                            idx = 0
                            sid = r[idx]; idx += 1
                            s_item = r[idx]; idx += 1
                            s_qty = float(r[idx] or 0); idx += 1
                            s_loc = r[idx] if has_location else None; idx += (1 if has_location else 0)
                            s_batch = r[idx] if has_batch else None; idx += (1 if has_batch else 0)
                            s_expiry = r[idx] if has_expiry else None
                        take = min(remaining, max(s_qty, 0.0))
                        if take <= 0:
                            continue

                        # کم کردن از منبع
                        cur.execute(f"UPDATE {inv_tbl} SET {inv_qty_col}=GREATEST(COALESCE({inv_qty_col},0)-%s,0) WHERE id=%s", (take, sid))

                        # افزودن به مقصد (Approved)
                        dest_status = 'تایید شده'
                        dest_loc = to_loc if has_location else None
                        dest_batch = batch_no if batch_no is not None else s_batch
                        dest_expiry = expiry_dt if expiry_dt is not None else s_expiry

                        where_parts = ["item_id=%s"]; params = [s_item]
                        if has_location: where_parts.append("COALESCE(location_id,0)=COALESCE(%s,0)"); params.append(dest_loc)
                        if has_batch:    where_parts.append("COALESCE(batch_no,'')=COALESCE(%s,'')"); params.append(dest_batch)
                        if has_expiry:   where_parts.append("COALESCE(expiry_date::date,DATE '1970-01-01')=COALESCE(%s::date,DATE '1970-01-01')"); params.append(dest_expiry)
                        if has_status:   where_parts.append("COALESCE(status,'تایید شده')=%s"); params.append(dest_status)

                        cur.execute(f"SELECT id FROM {inv_tbl} WHERE {' AND '.join(where_parts)} LIMIT 1", tuple(params))
                        dest = cur.fetchone()
                        if dest:
                            did = dest['id'] if isinstance(dest, dict) else dest[0]
                            cur.execute(f"UPDATE {inv_tbl} SET {inv_qty_col}=COALESCE({inv_qty_col},0)+%s WHERE id=%s", (take, did))
                        else:
                            cols, vals = ['item_id', inv_qty_col], [s_item, take]
                            if has_location: cols.append('location_id'); vals.append(dest_loc)
                            if has_batch:    cols.append('batch_no'); vals.append(dest_batch)
                            if has_expiry:   cols.append('expiry_date'); vals.append(dest_expiry)
                            if has_status:   cols.append('status'); vals.append(dest_status)
                            cur.execute(f"INSERT INTO {inv_tbl} ({', '.join(cols)}) VALUES ({', '.join(['%s']*len(vals))})", tuple(vals))

                        remaining -= take
                        moved += (1 if take > 0 else 0)
                        if remaining <= 0:
                            break

                    # ثبت در receipt_items در صورت وجود ستون placed_qty
                    if receipt_id is not None and _table_exists(cur, 'receipt_items'):
                        cols_ri = _columns(cur, 'receipt_items')
                        if 'placed_qty' in cols_ri and po_item_id:
                            cur.execute("""
                                UPDATE receipt_items
                                SET placed_qty = COALESCE(placed_qty,0) + %s
                                WHERE receipt_id=%s AND po_item_id=%s
                            """, (qty, receipt_id, po_item_id))

                except Exception:
                    errors += 1
                    continue

            # تایم‌لاین اختیاری
            try:
                tl_cols = _columns(cur, 'request_timeline')
                if {'purchase_request_id','event','created_at'}.issubset(tl_cols) and _table_exists(cur, 'purchase_order_items'):
                    cur.execute("""
                        SELECT DISTINCT COALESCE(poi.pr_id, poi.purchase_request_id) AS pr_id
                        FROM purchase_order_items poi
                        JOIN receipt_items ri ON ri.po_item_id = poi.id
                        WHERE ri.receipt_id = %s
                    """, (receipt_id,))
                    for rr in (cur.fetchall() or []):
                        pr_id = rr['pr_id'] if isinstance(rr, dict) else rr[0]
                        cur.execute("""
                            INSERT INTO request_timeline (purchase_request_id, event, created_at, actor_id)
                            VALUES (%s, %s, NOW(), %s)
                        """, (pr_id, "جایگذاری اقلام از قرنطینه به انبار", placer_id))
            except Exception:
                pass

        # سیگنال‌های سبک برای تازه‌سازی UI/پیگیری
        try:
            if hasattr(self, "signals"):
                self.signals.dataChanged.emit("WAREHOUSE_PUTAWAY")
                self.signals.dataChanged.emit("MY_REQUESTS_TRACKING_CHANGED")
        except Exception:
            pass

        return {"moved": moved, "skipped": skipped, "errors": errors}
    # END ADD: DB.place_receipt_items
    
    # BEGIN ADD: DB.search_purchase_requests_for_user
    def search_purchase_requests_for_user(self, user_id: int,
                                        statuses: list[str] | None = None,
                                        date_from: str | None = None,
                                        date_to: str | None = None,
                                        q: str | None = None,
                                        limit: int = 100, offset: int = 0) -> list[dict]:
        """
        جست‌وجو/فیلتر برای «پیگیری من» بر اساس وضعیت، بازهٔ تاریخ و متن آزاد.
        خروجی مشابه get_purchase_requests_for_user است.
        """
        with self.transaction() as cur:
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            items_cols = set(self._get_existing_columns('items', cursor=cur))
            units_cols = set(self._get_existing_columns('units', cursor=cur))

            status_col  = 'status' if 'status' in pr_cols else ('state' if 'state' in pr_cols else None)
            qty_col     = 'requested_qty' if 'requested_qty' in pr_cols else ('quantity' if 'quantity' in pr_cols else 'qty')
            item_fk     = 'item_id' if 'item_id' in pr_cols else None
            unit_fk     = 'requested_unit_id' if 'requested_unit_id' in pr_cols else None
            created_col = None
            for c in ('request_date','created_at','created','submitted_at'):
                if c in pr_cols: created_col = c; break

            item_name_col = 'name' if 'name' in items_cols else ('title' if 'title' in items_cols else None)
            unit_name_col = 'name' if 'name' in units_cols else None

            from psycopg2 import sql as _sql
            where = [_sql.SQL('pr.requester_id = %s')]
            args  = [user_id]

            if statuses and status_col:
                where.append(_sql.SQL(f"pr.{status_col} = ANY(%s)"))
                args.append(statuses)
            if date_from and created_col:
                where.append(_sql.SQL(f"pr.{created_col}::date >= %s"))
                args.append(date_from)
            if date_to and created_col:
                where.append(_sql.SQL(f"pr.{created_col}::date <= %s"))
                args.append(date_to)
            if q and item_name_col:
                where.append(_sql.SQL(f"({ ' OR '.join([f'LOWER(it.{item_name_col}) LIKE %s', 'LOWER(pr.notes) LIKE %s', 'LOWER(pr.specs) LIKE %s']) })"))
                qq = f"%{(q or '').strip().lower()}%"; args += [qq, qq, qq]

            item_name_expr = _sql.SQL(f"it.{item_name_col}") if item_name_col else _sql.SQL("NULL::text")
            unit_join_expr = _sql.SQL(f"COALESCE(pr.{unit_fk}, it.unit_id)") if unit_fk else _sql.SQL("it.unit_id")
            unit_name_expr = _sql.SQL(f"un.{unit_name_col}") if unit_name_col else _sql.SQL("NULL::text")

            select_parts = [
                _sql.SQL("pr.id AS id"),
                _sql.SQL(f"pr.{qty_col} AS quantity"),
                _sql.SQL(f"pr.{status_col} AS status") if status_col else _sql.SQL("'' AS status"),
                item_name_expr.as_string(cur) if hasattr(item_name_expr, 'as_string') else item_name_expr,
                unit_name_expr.as_string(cur) if hasattr(unit_name_expr, 'as_string') else unit_name_expr,
            ]

            qsql = _sql.SQL("""
                SELECT pr.id AS id,
                    pr.{qty} AS quantity,
                    {status} AS status,
                    {item_name} AS item_name,
                    {unit_name} AS unit_name
                FROM purchase_requests pr
                LEFT JOIN items it ON it.id = pr.{fk}
                LEFT JOIN units un ON un.id = {unit_join}
                WHERE {where}
                ORDER BY pr.id DESC
                LIMIT %s OFFSET %s
            """).format(
                qty=_sql.Identifier(qty_col),
                status=_sql.SQL(f"pr.{status_col}") if status_col else _sql.SQL("''"),
                item_name=_sql.SQL(f"it.{item_name_col}") if item_name_col else _sql.SQL("NULL::text"),
                unit_name=_sql.SQL(f"un.{unit_name_col}") if unit_name_col else _sql.SQL("NULL::text"),
                fk=_sql.Identifier(item_fk) if item_fk else _sql.Identifier('item_id'),
                unit_join=unit_join_expr,
                where=_sql.SQL(' AND ').join(where)
            )
            args2 = args + [limit, offset]
            cur.execute(qsql, args2)
            rows = cur.fetchall() or []
            desc = [d.name for d in cur.description]; idx = {name: i for i, name in enumerate(desc)}

            out = []
            for row in rows:
                out.append({
                    'id': row[idx['id']],
                    'item_name': row[idx.get('item_name')],
                    'quantity': row[idx.get('quantity')],
                    'status': self._display_status(row[idx.get('status')]),
                    'unit_name': row[idx.get('unit_name')],
                })
            return out
    # END ADD: DB.search_purchase_requests_for_user
    
    # BEGIN ADD: DB.get_my_requests_tracking
    def get_my_requests_tracking(self, user_id: int, limit: int = 200) -> list[dict]:
        """
        ردیابی «درخواست‌های من» بدون workflow.
        خروجی برای هر PR:
        {
            "pr_id": int,
            "item_name": str,
            "requested_qty": float|None,
            "stage": str,
            "approval_status": str|None,
            "status_text": str|None,
            "has_po": bool,
            "received_pct": float,   # 0..100
            "last_update": datetime,
        }
        """
        with self.transaction() as cur:
            # کشف ستون‌های PR
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            if not pr_cols:
                return []

            # نام‌های سازگار
            status_col   = 'state' if 'state' in pr_cols else ('status' if 'status' in pr_cols else None)
            approval_col = 'approval_status' if 'approval_status' in pr_cols else None
            selq_col     = 'selected_quote_id' if 'selected_quote_id' in pr_cols else None
            upd_col      = 'updated_at' if 'updated_at' in pr_cols else None
            req_qty_col  = 'requested_qty' if 'requested_qty' in pr_cols else None
            item_fk_col  = 'item_id' if 'item_id' in pr_cols else None
            req_user_col = 'requester_id' if 'requester_id' in pr_cols else None
            req_date_col = 'request_date' if 'request_date' in pr_cols else None

            if not req_user_col:
                return []

            # اتصال‌های کمکی
            poi_tbl = None; poi_cols = set()
            for t in ('purchase_order_items', 'po_items'):
                cols = set(self._get_existing_columns(t, cursor=cur))
                if cols:
                    poi_tbl = t; poi_cols = cols; break

            po_tbl  = 'purchase_orders' if set(self._get_existing_columns('purchase_orders', cursor=cur)) else None
            rcv_tbl = 'receipt_items' if set(self._get_existing_columns('receipt_items', cursor=cur)) else None
            items_tbl = 'items' if set(self._get_existing_columns('items', cursor=cur)) else None

            # ستون‌های آیتم PO
            poi_po_fk = 'po_id' if 'po_id' in poi_cols else None
            poi_pr_fk = 'pr_id' if 'pr_id' in poi_cols else ('purchase_request_id' if 'purchase_request_id' in poi_cols else None)
            poi_qty_col = 'quantity' if 'quantity' in poi_cols else ('qty' if 'qty' in poi_cols else ('ordered_qty' if 'ordered_qty' in poi_cols else None))
            poi_rcv_col = 'received_qty' if 'received_qty' in poi_cols else None

            # زیرکوئری‌های جمع‌بندی
            agg_po = {}
            if poi_tbl and poi_pr_fk:
                if poi_rcv_col:
                    cur.execute(f"""
                        SELECT {poi_pr_fk} AS pr_id,
                            COUNT(DISTINCT {poi_po_fk}) AS po_count,
                            COALESCE(SUM({poi_qty_col}::numeric),0) AS ordered_total,
                            COALESCE(SUM({poi_rcv_col}::numeric),0) AS received_total
                        FROM {poi_tbl}
                        GROUP BY {poi_pr_fk}
                    """)
                else:
                    if rcv_tbl and 'po_item_id' in set(self._get_existing_columns(rcv_tbl, cursor=cur)):
                        cur.execute(f"""
                            WITH ord AS (
                                SELECT {poi_pr_fk} AS pr_id,
                                    COUNT(DISTINCT {poi_po_fk}) AS po_count,
                                    COALESCE(SUM({poi_qty_col}::numeric),0) AS ordered_total
                                FROM {poi_tbl}
                                GROUP BY {poi_pr_fk}
                            ),
                            rcv AS (
                                SELECT poi.{poi_pr_fk} AS pr_id,
                                    COALESCE(SUM(ri.qty::numeric),0) AS received_total
                                FROM {poi_tbl} poi
                                JOIN {rcv_tbl} ri ON ri.po_item_id = poi.id
                                GROUP BY poi.{poi_pr_fk}
                            )
                            SELECT ord.pr_id, ord.po_count, ord.ordered_total, COALESCE(rcv.received_total,0) AS received_total
                            FROM ord LEFT JOIN rcv ON rcv.pr_id = ord.pr_id
                        """)
                    else:
                        cur.execute(f"""
                            SELECT {poi_pr_fk} AS pr_id,
                                COUNT(DISTINCT {poi_po_fk}) AS po_count,
                                0::numeric AS ordered_total,
                                0::numeric AS received_total
                            FROM {poi_tbl}
                            GROUP BY {poi_pr_fk}
                        """)
                for r in cur.fetchall() or []:
                    if isinstance(r, dict):
                        agg_po[int(r['pr_id'])] = {
                            'po_count': int(r['po_count'] or 0),
                            'ordered_total': float(r['ordered_total'] or 0),
                            'received_total': float(r['received_total'] or 0)
                        }
                    else:
                        agg_po[int(r[0])] = {
                            'po_count': int(r[1] or 0),
                            'ordered_total': float(r[2] or 0),
                            'received_total': float(r[3] or 0)
                        }

            # زمان‌های مکمل: آخرین زمان PO و Receipt برای هر PR
            last_po_time = {}
            if po_tbl and poi_tbl and poi_pr_fk and poi_po_fk:
                cols_po = set(self._get_existing_columns(po_tbl, cursor=cur))
                created_col = 'created_at' if 'created_at' in cols_po else ('issued_at' if 'issued_at' in cols_po else None)
                if created_col:
                    cur.execute(f"""
                        SELECT poi.{poi_pr_fk} AS pr_id, MAX(po.{created_col}) AS last_po
                        FROM {poi_tbl} poi
                        JOIN {po_tbl} po ON po.id = poi.{poi_po_fk}
                        GROUP BY poi.{poi_pr_fk}
                    """)
                    for r in cur.fetchall() or []:
                        last_po_time[int(r['pr_id'] if isinstance(r, dict) else r[0])] = r['last_po'] if isinstance(r, dict) else r[1]

            last_rcv_time = {}
            if rcv_tbl and poi_tbl:
                cur.execute(f"""
                    SELECT poi.{poi_pr_fk} AS pr_id, MAX(ri.created_at) AS last_rcv
                    FROM {rcv_tbl} ri
                    JOIN {poi_tbl} poi ON poi.id = ri.po_item_id
                    GROUP BY poi.{poi_pr_fk}
                """)
                for r in cur.fetchall() or []:
                    last_rcv_time[int(r['pr_id'] if isinstance(r, dict) else r[0])] = r['last_rcv'] if isinstance(r, dict) else r[1]

            # کشیدن PRهای متعلق به کاربر
            select_bits = ["pr.id AS pr_id"]
            if item_fk_col and items_tbl:
                select_bits.append("i.name AS item_name")
            else:
                select_bits.append("NULL AS item_name")
            if req_qty_col: select_bits.append(f"pr.{req_qty_col} AS requested_qty")
            else: select_bits.append("NULL AS requested_qty")
            if approval_col: select_bits.append(f"pr.{approval_col} AS approval_status")
            else: select_bits.append("NULL AS approval_status")
            if status_col: select_bits.append(f"pr.{status_col} AS status_text")
            else: select_bits.append("NULL AS status_text")
            if selq_col: select_bits.append(f"pr.{selq_col} AS selected_quote_id")
            else: select_bits.append("NULL AS selected_quote_id")
            if upd_col: select_bits.append(f"pr.{upd_col} AS updated_at")
            else: select_bits.append("NULL AS updated_at")
            if req_date_col: select_bits.append(f"pr.{req_date_col} AS request_date")
            else: select_bits.append("NOW() AS request_date")

            join_items = f"LEFT JOIN {items_tbl} i ON i.id = pr.{item_fk_col}" if (item_fk_col and items_tbl) else ""

            cur.execute(f"""
                SELECT {', '.join(select_bits)}
                FROM purchase_requests pr
                {join_items}
                WHERE pr.{req_user_col} = %s
                ORDER BY COALESCE(pr.{upd_col if upd_col else req_date_col}, NOW()) DESC, pr.id DESC
                LIMIT %s
            """, (user_id, limit))
            rows = cur.fetchall() or []

        # ترکیب و تعیین مرحله
        results = []
        for r in rows:
            if not isinstance(r, dict):
                keys = ['pr_id','item_name','requested_qty','approval_status','status_text','selected_quote_id','updated_at','request_date']
                r = dict(zip(keys, r))

            pr_id = int(r.get('pr_id'))
            status_text = (r.get('status_text') or '').strip()
            approval_status = (r.get('approval_status') or '').strip().upper()
            selected_quote_id = r.get('selected_quote_id')

            po_meta = agg_po.get(pr_id, {'po_count':0,'ordered_total':0.0,'received_total':0.0})
            po_count = int(po_meta['po_count'])
            ordered_total = float(po_meta['ordered_total'] or 0.0)
            received_total = float(po_meta['received_total'] or 0.0)
            received_pct = 0.0
            if ordered_total > 0:
                received_pct = max(0.0, min(100.0, (received_total / ordered_total) * 100.0))

            last_update = r.get('updated_at') or last_rcv_time.get(pr_id) or last_po_time.get(pr_id) or r.get('request_date')

            s_text_up = (status_text or '').upper()
            stage = "ثبت شد"
            if "REJECT" in s_text_up or status_text == "رد شد":
                stage = "رد شد"
            elif po_count > 0 and ordered_total > 0 and received_total >= ordered_total:
                stage = "تکمیل شد"
            elif po_count > 0 and received_total > 0:
                stage = "در حال دریافت/انبار"
            elif po_count > 0:
                stage = "سفارش شد"
            elif selected_quote_id:
                stage = "آمادهٔ سفارش"
            elif ("SOURCE" in s_text_up) or ("COMMERCE" in s_text_up) or (approval_status in ("APPROVED","تایید شد")):
                stage = "بازرگانی/استعلام"
            elif ("CEO" in s_text_up) or ("مدیرعامل" in status_text):
                stage = "در انتظار مدیرعامل"
            else:
                stage = "در انتظار بررسی"

            results.append({
                "pr_id": pr_id,
                "item_name": r.get('item_name'),
                "requested_qty": r.get('requested_qty'),
                "stage": stage,
                "approval_status": r.get('approval_status'),
                "status_text": status_text or None,
                "has_po": bool(po_count > 0),
                "received_pct": round(received_pct, 2),
                "last_update": last_update
            })

        return results
    # END ADD: DB.get_my_requests_tracking

    
    # BEGIN ADD: DB._display_status
    def _display_status(self, raw: str) -> str:
        """نگاشت سادهٔ وضعیت برای نمایش یکنواخت (صرفاً نمایشی)."""
        m = (raw or '').strip()
        return {
            'Issued': 'باز',
            'Closed': 'بسته',
            'Cancelled': 'لغو',
            'سفارش صادر شد': 'سفارش صادر شد',
            'تامین‌کننده انتخاب شد': 'تامین‌کننده انتخاب شد',
            'در انتظار تایید مدیر واحد': 'در انتظار تایید مدیر واحد',
            'در انتظار تایید بازرگانی': 'در انتظار تایید بازرگانی',
            'رد شده': 'رد شده',
        }.get(m, m)
    # END ADD: DB._display_status
    
    # BEGIN ADD: DB._notify
    def _notify(self, topic: str) -> None:
        """اعلان سبک پس از تغییر کلیدی (در صورت وجود signals)."""
        try:
            if hasattr(self, 'signals') and getattr(self.signals, 'dataChanged', None):
                self.signals.dataChanged.emit(topic)
        except Exception:
            pass
    # END ADD: DB._notify    

    # BEGIN ADD: DB.get_purchase_request_timeline
    def get_purchase_request_timeline(self, pr_id: int) -> list[dict]:
        """
        تایم‌لاین سادهٔ یک PR بر پایهٔ جداول موجود (بدون تغییر اسکیما).
        رویدادها (در صورت وجود جدول/ستون):
        - ساخته شدن PR
        - تاییدها (مدیر واحد/مدیرعامل/بازرگانی)
        - ثبت کوئوت‌ها و انتخاب برنده
        - صدور سفارش (PO)
        - دریافت‌ها (Receipt)
        خروجی: [{ts, event, ref, extra?}, ...] مرتب‌شده بر اساس زمان.
        """
        out = []
        with self.transaction() as cur:
            def _exists(tbl: str) -> bool:
                cur.execute("SELECT to_regclass(%s) IS NOT NULL", (f'public.{tbl}',)); r = cur.fetchone(); return bool(r and r[0] is True)
            def _cols(tbl: str) -> set[str]:
                cur.execute("SELECT column_name FROM information_schema.columns WHERE table_schema='public' AND table_name=%s", (tbl,))
                return {x[0] for x in (cur.fetchall() or [])}

            # PR created
            if _exists('purchase_requests'):
                cols = _cols('purchase_requests')
                tcol = 'request_date' if 'request_date' in cols else ('created_at' if 'created_at' in cols else None)
                dcol = 'pr_no' if 'pr_no' in cols else ('physical_no' if 'physical_no' in cols else None)
                cur.execute(f"SELECT {tcol}, COALESCE({dcol}, id::text) FROM purchase_requests WHERE id=%s" if tcol else "SELECT NULL, id::text FROM purchase_requests WHERE id=%s", (pr_id,))
                row = cur.fetchone()
                if row:
                    out.append({'ts': row[0], 'event': 'ثبت درخواست', 'ref': (row[1] if len(row) > 1 else str(pr_id))})

            # approvals
            if _exists('manager_approvals'):
                cur.execute("""
                    SELECT decided_at, role, decision FROM manager_approvals
                    WHERE pr_id=%s ORDER BY decided_at
                """, (pr_id,))
                for t, role, dec in (cur.fetchall() or []):
                    out.append({'ts': t, 'event': f'تایید/عدم تایید ({role})', 'ref': dec})

            # quotes
            if _exists('supplier_quotes'):
                cur.execute("SELECT created_at, id, is_winner FROM supplier_quotes WHERE pr_id=%s ORDER BY created_at", (pr_id,))
                for t, qid, win in (cur.fetchall() or []):
                    out.append({'ts': t, 'event': ('کوئوت' + (" (برنده)" if win else "")), 'ref': f'Q#{qid}'})

            # PO
            if _exists('purchase_order_items') and _exists('purchase_orders'):
                cur.execute("""
                    SELECT po.created_at, po.order_no, po.id
                    FROM purchase_order_items poi
                    JOIN purchase_orders po ON po.id = poi.po_id
                    WHERE poi.pr_id=%s
                    ORDER BY po.created_at
                """, (pr_id,))
                for t, ono, pid in (cur.fetchall() or []):
                    out.append({'ts': t, 'event': 'صدور سفارش', 'ref': ono or f'PO#{pid}'})

            # Receipts
            if _exists('receipt_items') and _exists('receipts'):
                cur.execute("""
                    SELECT r.received_at, r.receipt_no, SUM(ri.qty) AS qty
                    FROM receipt_items ri JOIN receipts r ON r.id = ri.receipt_id
                    JOIN purchase_order_items poi ON poi.id = ri.po_item_id
                    WHERE poi.pr_id=%s
                    GROUP BY r.id, r.received_at, r.receipt_no
                    ORDER BY r.received_at
                """, (pr_id,))
                for t, rno, qty in (cur.fetchall() or []):
                    out.append({'ts': t, 'event': 'دریافت', 'ref': rno, 'extra': {'qty': float(qty or 0)}})

        out = [e for e in out if e.get('ts')]
        out.sort(key=lambda x: (x['ts'] or 0))
        return out
    # END ADD: DB.get_purchase_request_timeline
                        

    def get_stock_details_by_id(self, stock_id: int):
        """جزئیات کامل یک رکورد خاص از جدول stock را برمی‌گرداند."""
        query = """
            SELECT s.*, i.name as item_name
            FROM stock s
            JOIN items i ON s.item_id = i.id
            WHERE s.id = %s
        """
        return self.execute_query(query, (stock_id,), fetch_one=True)# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_quarantined_stock(self):
            """لیست تمام موجودی‌هایی که در وضعیت 'قرنطینه' هستند را به همراه جزئیات کامل برمی‌گرداند."""
            query = """
                SELECT 
                    s.id as stock_id,
                    i.name as item_name,
                    s.batch_no,
                    s.qty,
                    u.name as unit,
                    w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS location_label,
                    s.expiry_date,
                    (SELECT sup.name FROM suppliers sup JOIN purchase_orders po ON sup.id = po.supplier_id 
                    JOIN purchase_order_items poi ON po.id = poi.purchase_order_id
                    WHERE poi.id = s.source_po_item_id LIMIT 1) as supplier_name
                FROM stock s
                JOIN items i ON s.item_id = i.id
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                LEFT JOIN units u ON i.unit_id = u.id
                WHERE s.status = 'قرنطینه'
                ORDER BY s.id ASC;
            """
            return self.execute_query(query)

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def update_stock_status(self, stock_id: int, new_status: str, user_id: int, notes: str = ''):
        """
        نسخه 3.0 (کاملاً رویداد-محور):
        - وضعیت یک رکورد موجودی را تغییر می‌دهد.
        - پس از تغییر، رویداد مناسب (تایید یا رد) را برای اتصال به فرآیندهای QA اعلام می‌کند.
        """
        # --- *** اصلاح ۱: وضعیت 'موجود' نیز به عنوان وضعیت نهایی تایید شده پذیرفته می‌شود *** ---
        valid_statuses = ['تایید شده', 'موجود', 'رد شده']
        if new_status not in valid_statuses:
            raise ValueError(f"وضعیت جدید نامعتبر است. فقط وضعیت‌های {valid_statuses} مجاز هستند.")

        item_id = None
        with self.transaction() as cur:
            stock_info = self.execute_query("SELECT item_id, batch_no, qty FROM stock WHERE id = %s AND status = 'قرنطینه' FOR UPDATE", (stock_id,), fetch_one=True, cursor=cur)
            if not stock_info:
                raise ValueError("این رکورد موجودی یافت نشد یا دیگر در وضعیت قرنطینه نیست.")
            
            item_id = stock_info['item_id']
            # اگر وضعیت جدید 'موجود' بود، آن را به 'تایید شده' که استاندارد سیستم است تبدیل می‌کنیم
            final_status_for_db = 'تایید شده' if new_status == 'موجود' else new_status
            
            cur.execute("UPDATE stock SET status = %s WHERE id = %s", (final_status_for_db, stock_id))
            log_details = f"Stock ID:{stock_id} status changed to '{final_status_for_db}'. Item ID:{item_id}, Batch:{stock_info['batch_no']}. Notes: {notes}"
            self._log_atomic(cur, user_id, 'STOCK_STATUS_UPDATE', log_details)
        
            
                        
            
    def get_stock_details_by_id(self, stock_id: int):
        """جزئیات کامل یک رکورد خاص از جدول stock را برمی‌گرداند."""
        query = """
            SELECT s.*, i.name as item_name
            FROM stock s
            JOIN items i ON s.item_id = i.id
            WHERE s.id = %s
        """
        return self.execute_query(query, (stock_id,), fetch_one=True)
    
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def search_qc_form_entries(self, product_name: str = None, batch_no: str = None):
        """
        گزارش‌های ثبت شده کنترل کیفیت را بر اساس نام محصول یا شماره بچ جستجو می‌کند.
        """
        # ابتدا ID فرم "گزارش کنترل کیفیت محصول نهایی" را پیدا می‌کنیم
        # این فرض می‌کند که نام فرم ثابت است. در آینده می‌توان این بخش را هوشمندتر کرد.
        form_def = self.execute_query(
            "SELECT id FROM form_defs WHERE name = 'گزارش کنترل کیفیت محصول نهایی' AND form_type = 'QA' LIMIT 1",
            fetch_one=True
        )
        if not form_def:
            return [] # اگر فرم تعریف نشده باشد، هیچ رکوردی وجود ندارد

        form_id = form_def['id']
        
        query = """
            SELECT 
                fe.id, 
                fe.ts as submission_date, 
                u.username as submitted_by,
                fe.data
            FROM form_entries fe
            LEFT JOIN users u ON fe.user_id = u.id
            WHERE fe.form_id = %s
        """
        params = [form_id]

        if product_name:
            # جستجو در JSON بر اساس بخشی از نام محصول (در فیلد "انتخاب بچ...")
            query += " AND fe.data ->> 'انتخاب بچ تولید جهت بازرسی' ILIKE %s"
            params.append(f"%{product_name}%")
        
        if batch_no:
            # جستجو در JSON بر اساس بخشی از شماره بچ
            query += " AND fe.data ->> 'انتخاب بچ تولید جهت بازرسی' ILIKE %s"
            params.append(f"%{batch_no}%")
            
        query += " ORDER BY fe.id DESC"
        
        return self.execute_query(query, tuple(params))
    
# این دو متد جدید را به انتهای کلاس DB اضافه کنید

    def get_rejected_stock(self):
        """لیست تمام موجودی‌هایی که در وضعیت 'رد شده' هستند را برمی‌گرداند."""
        query = """
            SELECT
                s.id as stock_id,
                i.name as item_name,
                s.batch_no,
                s.qty,
                u.name as unit,
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS location_label
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE s.status = 'رد شده'
            ORDER BY s.id ASC;
        """
        return self.execute_query(query)

    def resolve_rejected_stock(self, stock_id: int, resolution_type: str, user_id: int, notes: str):
        """
        برای یک کالای رد شده تعیین تکلیف کرده، آن را از موجودی کسر و تراکنش مربوطه را ثبت می‌کند.
        """
        valid_resolutions = ['مرجوع به تامین‌کننده', 'ضایعات']
        if resolution_type not in valid_resolutions:
            raise ValueError("نوع تعیین تکلیف نامعتبر است.")

        with self.transaction() as cur:
            # اطلاعات کامل رکورد موجودی را برای ثبت تراکنش واکشی و قفل می‌کنیم
            stock_info = self.execute_query("SELECT * FROM stock WHERE id = %s AND status = 'رد شده' FOR UPDATE", (stock_id,), fetch_one=True, cursor=cur)
            if not stock_info:
                raise ValueError("این رکورد یافت نشد یا دیگر در وضعیت 'رد شده' قرار ندارد.")

            item_id = stock_info['item_id']
            qty = stock_info['qty']
            location_id = stock_info['location_id']
            batch_no = stock_info['batch_no']
            expiry_date = stock_info.get('expiry_date')

            # ۱. ثبت تراکنش خروج (از نوع مرجوعی یا ضایعات)
            trans_type = f"خروج ({resolution_type})"
            doc_no = f"RES-{stock_id}" # Resolution ID
            self.execute_query(
                """INSERT INTO trans (item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, status, batch_no, expiry_date)
                   VALUES (%s, %s, %s, NOW(), %s, %s, %s, %s, %s, %s, %s)""",
                (item_id, trans_type, doc_no, qty, notes, user_id, location_id, 'تایید شده', batch_no, expiry_date),
                cursor=cur
            )
            
            # ۲. حذف کامل رکورد از جدول موجودی (stock)
            # چون کالا تعیین تکلیف شده، دیگر نباید در موجودی ما (حتی موجودی رد شده) باقی بماند.
            self.execute_query("DELETE FROM stock WHERE id = %s", (stock_id,), cursor=cur)

            log_details = f"Resolved rejected stock ID:{stock_id} as '{resolution_type}'"
            self._log_atomic(cur, user_id, 'REJECTED_STOCK_RESOLVED', log_details)
            
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_all_customers(self, active_only=False):
        """لیست تمام مشتریان را برمی‌گرداند."""
        query = "SELECT * FROM customers"
        params = []
        if active_only:
            query += " WHERE is_active = %s"
            params.append(True)
        query += " ORDER BY name"
        return self.execute_query(query, tuple(params))

    def add_or_update_customer(self, customer_data: dict, customer_id: int = None):
        """یک مشتری جدید را اضافه یا مشتری موجود را ویرایش می‌کند."""
        if not customer_data.get('name'):
            raise ValueError("نام مشتری نمی‌تواند خالی باشد.")
        
        with self.transaction() as cur:
            if customer_id:
                params = {**customer_data, 'id': customer_id}
                query = """
                    UPDATE customers SET 
                        name = %(name)s, contact_person = %(contact_person)s, phone = %(phone)s,
                        email = %(email)s, address = %(address)s, tax_id = %(tax_id)s,
                        notes = %(notes)s, is_active = %(is_active)s
                    WHERE id = %(id)s
                """
                self.execute_query(query, params, cursor=cur)
            else:
                query = """
                    INSERT INTO customers (name, contact_person, phone, email, address, tax_id, notes, is_active)
                    VALUES (%(name)s, %(contact_person)s, %(phone)s, %(email)s, %(address)s, %(tax_id)s, %(notes)s, %(is_active)s)
                """
                self.execute_query(query, customer_data, cursor=cur)

# در کلاس DB، این دو متد را جایگزین کنید

    def delete_customer(self, customer_id: int):
        """یک مشتری را فقط در صورتی حذف می‌کند که هیچ سفارش فروشی نداشته باشد."""
        with self.transaction() as cur:
            # گام ۱: بررسی وابستگی در جدول سفارشات فروش
            in_use = self.execute_query(
                "SELECT 1 FROM sales_orders WHERE customer_id = %s LIMIT 1",
                (customer_id,),
                cursor=cur,
                fetch_one=True
            )
            if in_use:
                raise ValueError("این مشتری دارای سوابق سفارش فروش است و قابل حذف نیست. لطفاً به جای حذف، آن را غیرفعال کنید.")
            
            # گام ۲: اگر وابستگی وجود نداشت، حذف کن
            self.execute_query("DELETE FROM customers WHERE id = %s", (customer_id,), cursor=cur)

    def delete_supplier(self, supplier_id: int):
        """یک تامین‌کننده را فقط در صورتی حذف می‌کند که هیچ سفارش خریدی نداشته باشد."""
        with self.transaction() as cur:
            # گام ۱: بررسی وابستگی در جداول مرتبط (سفارشات خرید و پیشنهاد قیمت)
            in_use_po = self.execute_query(
                "SELECT 1 FROM purchase_orders WHERE supplier_id = %s LIMIT 1",
                (supplier_id,), cursor=cur, fetch_one=True
            )
            in_use_quote = self.execute_query(
                "SELECT 1 FROM supplier_quotes WHERE supplier_id = %s LIMIT 1",
                (supplier_id,), cursor=cur, fetch_one=True
            )
            if in_use_po or in_use_quote:
                raise ValueError("این تامین‌کننده دارای سوابق سفارش خرید یا پیشنهاد قیمت است و قابل حذف نیست. لطفاً به جای حذف، آن را غیرفعال کنید.")
            
            # گام ۲: اگر وابستگی وجود نداشت، حذف کن
            self.execute_query("DELETE FROM suppliers WHERE id = %s", (supplier_id,), cursor=cur)
                        
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_next_so_number(self):
        """یک شماره سریال جدید برای سفارش فروش تولید می‌کند."""
        now_jalali = jd.datetime.now()
        year_month = f"{now_jalali.year}{now_jalali.month:02d}"
        prefix = f"SO-{year_month}-"
        
        query = "SELECT MAX(so_number) as last_so FROM sales_orders WHERE so_number LIKE %s"
        last_so_rec = self.execute_query(query, (f"{prefix}%",), fetch_one=True)
        
        next_serial = 1
        if last_so_rec and last_so_rec.get('last_so'):
            try:
                last_serial_str = last_so_rec['last_so'].split('-')[-1]
                next_serial = int(last_serial_str) + 1
            except (IndexError, ValueError):
                pass # در صورت بروز خطا، از همان ۱ استفاده می‌شود
                
        return f"{prefix}{next_serial:04d}"

    # این متد را در کلاس DB به طور کامل جایگزین کنید
    def create_sales_order(self, so_data: dict, items_data: list, user_id: int):
        """
        یک سفارش فروش جدید را ثبت کرده و در صورت نیاز، رویداد شروع فرآیند را اعلام می‌کند.
        """
        so_id = None
        with self.transaction() as cur:
            so_number = self.get_next_so_number()
            total_amount = sum(item['quantity'] * item['unit_price'] for item in items_data)

            so_result = self.execute_query(
                """INSERT INTO sales_orders 
                (so_number, customer_id, issue_date, status, total_amount, notes, created_by_id, order_type)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING id""",
                (so_number, so_data['customer_id'], so_data['issue_date'], 'ثبت شده', 
                total_amount, so_data['notes'], user_id, so_data.get('order_type', 'STOCK')),
                fetch_one=True, cursor=cur
            )
            so_id = so_result['id']

            items_to_insert = [(so_id, item['item_id'], item['quantity'], item['unit_price']) for item in items_data]
            cur.executemany(
                "INSERT INTO sales_order_items (sales_order_id, item_id, quantity, unit_price) VALUES (%s, %s, %s, %s)",
                items_to_insert
            )
            self._log_atomic(cur, user_id, 'CREATE_SALES_ORDER', f"SO created: {so_number} with type {so_data.get('order_type', 'STOCK')}.")

        return so_id
            
    def get_all_sales_orders(self):
        """
        لیست سفارش‌های فروش + ستون «current_workflow_step» برای حفظ اسکیمای قبلی.
        وابستگی به process_instances/workflow_steps حذف شد؛ ستون مزبور به‌صورت NULL نگه داشته می‌شود.
        """
        query = """
            SELECT 
                so.id,
                so.so_number,
                c.name AS customer_name,
                so.issue_date,
                so.total_amount,
                so.status,
                u.username AS creator_name,
                /* جمع مقدار آیتم‌ها */
                (SELECT COALESCE(SUM(soi.quantity),0)
                FROM sales_order_items soi
                WHERE soi.sales_order_id = so.id) AS total_quantity,
                /* لیست اقلام به‌صورت رشته */
                (SELECT string_agg(
                            CASE WHEN p.name IS NOT NULL THEN p.name || ' - ' || i.name
                                ELSE i.name END, ', ')
                FROM sales_order_items soi
                JOIN items i ON soi.item_id = i.id
                LEFT JOIN items p ON i.parent_item_id = p.id
                WHERE soi.sales_order_id = so.id) AS items_list,
                /* حفظ سازگاری اسکیمای قدیم: مرحله فعلی فرآیند */
                NULL::text AS current_workflow_step
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            LEFT JOIN users u ON so.created_by_id = u.id
            ORDER BY so.issue_date DESC, so.id DESC
        """
        return self.execute_query(query)
    
        
        
    def get_slow_moving_stock(self, days_idle: int = 90):
        """
        لیست کالاهایی که برای مدت زمان مشخص شده هیچ جابجایی نداشته‌اند (کالاهای راکد)
        را برمی‌گرداند. این متد از فیلد last_moved_at استفاده می‌کند.
        """
        query = """
            SELECT
                i.name as item_name,
                s.batch_no,
                s.qty,
                u.name as unit,
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS location_label,
                s.last_moved_at
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE 
                w.name != 'Production' AND
                s.last_moved_at IS NOT NULL AND
                s.last_moved_at < NOW() - INTERVAL '%s days'
            ORDER BY s.last_moved_at ASC;
        """
        return self.execute_query(query, (days_idle,))
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_abc_analysis_data(self, analysis_period_days: int, mode: str = 'value'):
        """
        نسخه 2.0:
        - داده‌های تحلیل ABC را به همراه نام محصول مادر (در صورت وجود) آماده می‌کند.
        """
        if mode not in ['value', 'movement']:
            raise ValueError("حالت تحلیل باید 'value' یا 'movement' باشد.")

        # بخش اول: محاسبه معیار اصلی برای هر کالا
        if mode == 'value':
            query = """
                SELECT
                    t.item_id, i.name, p.name as parent_name, i.category,
                    COALESCE(SUM(t.qty * i.cost), 0) as total_value
                FROM trans t
                JOIN items i ON t.item_id = i.id
                LEFT JOIN items p ON i.parent_item_id = p.id
                WHERE 
                    t.t_type LIKE 'خروج%%' AND
                    t.status = 'تایید شده' AND
                    t.t_date >= NOW() - INTERVAL '%s days'
                GROUP BY t.item_id, i.name, p.name, i.category
                HAVING COALESCE(SUM(t.qty * i.cost), 0) > 0;
            """
            measure_column = 'total_value'
        else: # mode == 'movement'
            query = """
                SELECT
                    t.item_id, i.name, p.name as parent_name, i.category,
                    COUNT(t.id) as total_movements
                FROM trans t
                JOIN items i ON t.item_id = i.id
                LEFT JOIN items p ON i.parent_item_id = p.id
                WHERE 
                    t.t_type LIKE 'خروج%%' AND
                    t.status = 'تایید شده' AND
                    t.t_date >= NOW() - INTERVAL '%s days'
                GROUP BY t.item_id, i.name, p.name, i.category
                HAVING COUNT(t.id) > 0;
            """
            measure_column = 'total_movements'

        items_data = self.execute_query(query, (analysis_period_days,))
        if not items_data:
            return []

        # بخش دوم: دسته‌بندی A, B, C در پایتون (بدون تغییر)
        try:
            import pandas as pd
            df = pd.DataFrame(items_data)
            df = df.sort_values(by=measure_column, ascending=False)
            df['cumulative_percentage'] = df[measure_column].cumsum() / df[measure_column].sum()
            def assign_class(percentage):
                if percentage <= 0.8: return 'A'
                elif percentage <= 0.95: return 'B'
                else: return 'C'
            df['abc_class'] = df['cumulative_percentage'].apply(assign_class)
            return df.to_dict('records')
        except ImportError:
            return sorted(items_data, key=lambda x: x[measure_column], reverse=True)
        
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_supplier_performance_data(self):
        """
        عملکرد کیفی تامین‌کنندگان را بر اساس تعداد کل بچ‌های دریافتی و تعداد بچ‌های رد شده
        تحلیل کرده و نرخ رد کیفی (Rejection Rate) را برای هر کدام محاسبه می‌کند.
        """
        # این کوئری تمام بچ‌های ورودی که از طریق سفارش خرید ثبت شده‌اند را شمارش می‌کند
        # و سپس تعداد آنهایی که وضعیتشان 'رد شده' است را محاسبه می‌کند.
        # توجه: این کوئری فرض می‌کند که یادداشت تراکنش ورود، حاوی شناسه آیتم سفارش خرید است.
        query = """
            WITH supplier_batches AS (
                SELECT 
                    po.supplier_id,
                    s.id as stock_id,
                    s.status
                FROM stock s
                JOIN trans t ON s.batch_no = t.batch_no AND s.item_id = t.item_id AND s.location_id = t.dest_loc
                JOIN purchase_order_items poi ON t.t_no LIKE 'PO-%%' AND poi.id = CAST(SUBSTRING(t.notes FROM 'PO \(شناسه آیتم سفارش: (\d+)\)') AS INTEGER)
                JOIN purchase_orders po ON poi.purchase_order_id = po.id
                WHERE t.t_type = 'ورود' AND t.status = 'تایید شده'
            )
            SELECT 
                sup.name as supplier_name,
                COUNT(sb.stock_id) as total_batches,
                COUNT(sb.stock_id) FILTER (WHERE sb.status = 'رد شده') as rejected_batches
            FROM suppliers sup
            LEFT JOIN supplier_batches sb ON sup.id = sb.supplier_id
            GROUP BY sup.name
            HAVING COUNT(sb.stock_id) > 0 -- فقط تامین‌کنندگانی که حداقل یک بچ داشته‌اند
            ORDER BY rejected_batches DESC, total_batches DESC;
        """
        
        performance_data = self.execute_query(query)
        
        # محاسبه نرخ رد کیفی در پایتون
        for row in performance_data:
            total = row['total_batches']
            rejected = row.get('rejected_batches', 0)
            if total > 0:
                row['rejection_rate'] = (rejected / total) * 100
            else:
                row['rejection_rate'] = 0
                
        return sorted(performance_data, key=lambda x: x['rejection_rate'], reverse=True)
    
    
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def update_location_position(self, loc_id: int, pos_x: float, pos_y: float):
        """مختصات گرافیکی یک لوکیشن را در دیتابیس به‌روزرسانی می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "UPDATE locations SET pos_x = %s, pos_y = %s WHERE id = %s",
                (pos_x, pos_y, loc_id),
                cursor=cur
            )
            
# این دو متد جدید را به انتهای کلاس DB اضافه کنید

    def get_po_details(self, po_id: int):
        """اطلاعات اصلی (هدر) یک سفارش خرید مشخص را برمی‌گرداند."""
        query = """
            SELECT 
                po.*, 
                s.name as supplier_name,
                u.username as creator_name
            FROM purchase_orders po
            JOIN suppliers s ON po.supplier_id = s.id
            LEFT JOIN users u ON po.created_by_id = u.id
            WHERE po.id = %s
        """
        return self.execute_query(query, (po_id,), fetch_one=True)

    def get_po_line_items(self, po_id: int):
        """لیست تمام اقلام (line items) مربوط به یک سفارش خرید را برمی‌گرداند."""
        query = """
            SELECT 
                poi.*,
                i.name as item_name,
                u.name as unit
            FROM purchase_order_items poi
            JOIN items i ON poi.item_id = i.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE poi.purchase_order_id = %s
            ORDER BY i.name
        """
        return self.execute_query(query, (po_id,))
    
    def get_po_items_by_po_id(self, po_id: int) -> list[dict]:
        """
        اقلام PO برای فرم دریافت.
        خروجی: [{po_item_id,item_name,ordered_qty,received_qty,remaining_qty,unit_price}, ...]
        """
        # آیا جداول رسید موجودند؟
        has = self.execute_query(
            "SELECT to_regclass('public.receipts') IS NOT NULL AND to_regclass('public.receipt_items') IS NOT NULL",
            fetch_one=True
        )
        has_receipts = bool((has[0] if has and not isinstance(has, dict) else list(has.values())[0]) if has else False)

        if has_receipts:
            q = """
                WITH recv AS (
                    SELECT ri.po_item_id, SUM(ri.received_qty) AS s
                    FROM receipt_items ri
                    JOIN receipts r ON r.id = ri.receipt_id
                    WHERE r.po_id = %s
                    GROUP BY ri.po_item_id
                )
                SELECT poi.id AS po_item_id,
                    COALESCE(i.name,'') AS item_name,
                    poi.ordered_qty,
                    COALESCE(poi.received_qty,0) + COALESCE(recv.s,0) AS received_qty,
                    GREATEST(poi.ordered_qty - (COALESCE(poi.received_qty,0) + COALESCE(recv.s,0)), 0) AS remaining_qty,
                    COALESCE(poi.unit_price,0) AS unit_price
                FROM purchase_order_items poi
                LEFT JOIN recv ON recv.po_item_id = poi.id
                LEFT JOIN items i ON i.id = poi.item_id
                WHERE poi.po_id = %s
                ORDER BY poi.id
            """
            return self.execute_query(q, (po_id, po_id)) or []
        else:
            q = """
                SELECT poi.id AS po_item_id,
                    COALESCE(i.name,'') AS item_name,
                    poi.ordered_qty,
                    COALESCE(poi.received_qty,0) AS received_qty,
                    GREATEST(poi.ordered_qty - COALESCE(poi.received_qty,0), 0) AS remaining_qty,
                    COALESCE(poi.unit_price,0) AS unit_price
                FROM purchase_order_items poi
                LEFT JOIN items i ON i.id = poi.item_id
                WHERE poi.po_id = %s
                ORDER BY poi.id
            """
            return self.execute_query(q, (po_id,)) or []
        
    def get_supplier_quotes(self, pr_id: int) -> list[dict]:
        """
        نرمال‌سازی خروجی کوئوت‌ها از لایه DB برای مصرف مستقیم در UI.
        انتظار: DB.list_quotes_for_pr(pr_id) فهرستی از دیکشنری‌ها برگرداند.
        """
        try:
            rows = self.db.list_quotes_for_pr(pr_id) or []
            normalized: list[dict] = []
            for q in rows:
                normalized.append({
                    'id':            q.get('id') or q.get('quote_id'),
                    'supplier_name': q.get('supplier_name', ''),
                    'unit_price':    q.get('unit_price', 0),
                    'currency':      q.get('currency', ''),
                    'lead_time_days': (q.get('lead_time_days')
                                    if q.get('lead_time_days') is not None else q.get('lead_time', 0)),
                    'min_order_qty': q.get('min_order_qty', 0),
                    'is_winner':     1 if (q.get('is_winner') or q.get('is_selected')) else 0,
                    'notes':         q.get('notes', '')
                })
            return normalized
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در خواندن پیشنهادها", str(e))
            return []

    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_open_sales_orders(self):
        """لیست تمام سفارشات فروشی که در وضعیت 'آماده ارسال' هستند را برمی‌گرداند."""
        query = """
            SELECT 
                so.id,
                so.so_number,
                c.name as customer_name,
                so.issue_date,
                (SELECT string_agg(i.name || ' (' || soi.quantity::text || ')', ', ') 
                 FROM sales_order_items soi 
                 JOIN items i ON soi.item_id = i.id 
                 WHERE soi.sales_order_id = so.id) as items_summary
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            WHERE so.status = 'آماده ارسال'
            ORDER BY so.issue_date ASC;
        """
        return self.execute_query(query)
        
# این سه متد جدید را به انتهای کلاس DB اضافه کنید

    def get_user_favorites(self, user_id: int):
        """لیست تمام علاقه‌مندی‌های ثبت شده برای یک کاربر را برمی‌گرداند."""
        query = "SELECT favorite_key, display_name FROM user_favorites WHERE user_id = %s ORDER BY display_name"
        return self.execute_query(query, (user_id,))

    def add_to_favorites(self, user_id: int, favorite_key: str, display_name: str):
        """یک آیتم را به لیست علاقه‌مندی‌های کاربر اضافه می‌کند."""
        # ON CONFLICT DO NOTHING از ثبت موارد تکراری جلوگیری می‌کند
        query = """
            INSERT INTO user_favorites (user_id, favorite_key, display_name)
            VALUES (%s, %s, %s) ON CONFLICT (user_id, favorite_key) DO NOTHING
        """
        with self.transaction() as cur:
            self.execute_query(query, (user_id, favorite_key, display_name), cursor=cur)

    def remove_from_favorites(self, user_id: int, favorite_key: str):
        """یک آیتم را از لیست علاقه‌مندی‌های کاربر حذف می‌کند."""
        query = "DELETE FROM user_favorites WHERE user_id = %s AND favorite_key = %s"
        with self.transaction() as cur:
            self.execute_query(query, (user_id, favorite_key), cursor=cur)
            
    def get_production_summary_by_day(self, days_history: int = 30):
        """نسخه 2.0: با CAST کردن تاریخ، از صحت عملکرد JOIN اطمینان حاصل می‌کند."""
        query = """
            WITH date_series AS (
                SELECT generate_series(
                    CURRENT_DATE - INTERVAL '%s days', CURRENT_DATE, '1 day'
                )::date AS report_date
            )
            SELECT 
                d.report_date, COALESCE(SUM(t.qty), 0) AS total_production
            FROM date_series d
            LEFT JOIN trans t ON t.t_date::date = d.report_date 
                             AND t.t_type = 'ورود از تولید' AND t.status = 'تایید شده'
            GROUP BY d.report_date
            ORDER BY d.report_date ASC;
        """
        return self.execute_query(query, (days_history,))
    
    
    def get_bom_summary_over_time(self, date_from: str, date_to: str):
        """
        خلاصه BOM بر پایه‌ی تاریخچه‌ی مصرف (bill_of_materials).
        خروجی برای UI (جهت نمایش درختی):
        [
            {
            'product_name': '<نام کالا> — <بچ>',
            'total_produced_qty': None,   # فعلاً استفاده نمی‌شود
            'items': [ {'rm_display': '<alias|name|sku>', 'qty_kg': <float>}, ... ]
            }, ...
        ]
        """
        # وجود جدول تاریخچه مصرف
        try:
            self.execute_query("SELECT 1 FROM bill_of_materials LIMIT 1")
        except Exception:
            return []

        rows = self.execute_query(
            """
            SELECT
                COALESCE(r.product_name, p.name, '')       AS product_name,
                COALESCE(b.product_code,'')                AS batch_no,
                /* نمایش امنِ نام ماده: اول alias محرمانگی، بعد name، بعد sku */
                COALESCE(NULLIF(TRIM(ir.reporting_group),''),
                        NULLIF(TRIM(ir.name),''),
                        NULLIF(TRIM(ir.sku),''),
                        'نام‌نامشخص')                    AS rm_display,
                COALESCE(b.qty,0)::float                   AS qty_kg
            FROM bill_of_materials b
            LEFT JOIN recipes r ON r.id = b.recipe_id
            LEFT JOIN items   p ON p.id = r.produces_item_id
            LEFT JOIN items   ir ON ir.id = b.raw_item_id
            WHERE DATE(b.ts) BETWEEN %s AND %s
            ORDER BY
                COALESCE(r.product_name, p.name, ''),
                COALESCE(b.product_code,''),
                COALESCE(NULLIF(TRIM(ir.reporting_group),''), NULLIF(TRIM(ir.name),''), NULLIF(TRIM(ir.sku),''), 'نام‌نامشخص')
            """,
            (date_from, date_to)
        ) or []

        if not rows:
            return []

        # گروه‌بندی: (کالا، بچ) ← اقلام مصرف
        by_prod_batch = {}
        for r in rows:
            pname = (r.get('product_name') or '').strip()
            batch = (r.get('batch_no') or '').strip()
            disp  = (r.get('rm_display') or '').strip()
            qty   = float(r.get('qty_kg') or 0.0)

            key = (pname, batch)
            g = by_prod_batch.setdefault(key, {})
            g[disp] = g.get(disp, 0.0) + qty

        # ساخت خروجی
        out = []
        for (pname, batch), mats in sorted(by_prod_batch.items(), key=lambda kv: (kv[0][0], kv[0][1])):
            items = [{'rm_display': d, 'qty_kg': float(q)} for d, q in mats.items()]
            out.append({
                'product_name': f"{pname} — {batch}" if batch else pname,
                'total_produced_qty': None,
                'items': items
            })
        return out

    
                
    def get_sales_summary_by_day(self, days_history: int = 30):
        """نسخه 2.0: با CAST کردن تاریخ، از صحت عملکرد JOIN اطمینان حاصل می‌کند."""
        query = """
            WITH date_series AS (
                SELECT generate_series(
                    CURRENT_DATE - INTERVAL '%s days', CURRENT_DATE, '1 day'
                )::date AS report_date
            )
            SELECT 
                d.report_date, COALESCE(SUM(so.total_amount), 0) AS total_sales
            FROM date_series d
            LEFT JOIN sales_orders so ON so.issue_date::date = d.report_date AND so.status NOT IN ('لغو شده', 'باطل شده')
            GROUP BY d.report_date
            ORDER BY d.report_date ASC;
        """
        return self.execute_query(query, (days_history,))
        
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_sales_summary_by_product(self, days_history: int = 30, top_n: int = 5):
        """
        لیست N محصول پرفروش را بر اساس تعداد کل فروخته شده در بازه زمانی مشخص برمی‌گرداند.
        """
        query = """
            SELECT 
                i.name as product_name,
                SUM(soi.quantity) as total_quantity
            FROM sales_order_items soi
            JOIN sales_orders so ON soi.sales_order_id = so.id
            JOIN items i ON soi.item_id = i.id
            WHERE 
                so.issue_date >= CURRENT_DATE - INTERVAL '%s days'
                AND so.status NOT IN ('لغو شده', 'باطل شده')
            GROUP BY i.name
            ORDER BY total_quantity DESC
            LIMIT %s;
        """
        return self.execute_query(query, (days_history, top_n))
    
    def get_cogs_summary_by_day(self, days_history: int = 30):
        """نسخه 2.0: با CAST کردن تاریخ، از صحت عملکرد JOIN اطمینان حاصل می‌کند."""
        query = """
            WITH date_series AS (
                SELECT generate_series(
                    CURRENT_DATE - INTERVAL '%s days', CURRENT_DATE, '1 day'
                )::date AS report_date
            ),
            sold_items_daily AS (
                SELECT 
                    so.issue_date::date as sale_date, soi.item_id, SUM(soi.quantity) as total_sold_qty
                FROM sales_order_items soi
                JOIN sales_orders so ON soi.sales_order_id = so.id
                WHERE so.status NOT IN ('لغو شده', 'باطل شده')
                GROUP BY so.issue_date::date, soi.item_id
            )
            SELECT 
                d.report_date,
                COALESCE(SUM(
                    (SELECT SUM(bom.qty * raw_item.cost) 
                     FROM bill_of_materials bom
                     JOIN items raw_item ON bom.raw_item_id = raw_item.id
                     WHERE bom.product_code = i.name)
                * sid.total_sold_qty), 0) as total_cogs
            FROM date_series d
            LEFT JOIN sold_items_daily sid ON sid.sale_date = d.report_date
            LEFT JOIN items i ON sid.item_id = i.id
            GROUP BY d.report_date
            ORDER BY d.report_date ASC;
        """
        return self.execute_query(query, (days_history,))
    
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_invoice_data_for_sales_order(self, sales_order_id: int):
        """
        تمام اطلاعات لازم برای صدور فاکتور فروش را برای یک سفارش مشخص،
        از جمله جزئیات کامل مشتری و اقلام سفارش (با نام کامل مادر-فرزند)، آماده می‌کند.
        """
        # گام ۱: واکشی اطلاعات اصلی سفارش و مشتری
        header_query = """
            SELECT 
                so.so_number, so.issue_date, so.notes as order_notes,
                c.name as customer_name, c.contact_person, c.phone, 
                c.address, c.tax_id
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            WHERE so.id = %s
        """
        header_data = self.execute_query(header_query, (sales_order_id,), fetch_one=True)
        
        if not header_data:
            return None

        # گام ۲: واکشی اقلام سفارش با نام کامل
        items_query = """
            SELECT 
                -- *** اصلاح کلیدی اینجاست: ساخت نام کامل ***
                CASE 
                    WHEN p.name IS NOT NULL THEN p.name || ' - ' || i.name
                    ELSE i.name 
                END as full_item_name,
                i.sku,
                soi.quantity, soi.unit_price
            FROM sales_order_items soi
            JOIN items i ON soi.item_id = i.id
            LEFT JOIN items p ON i.parent_item_id = p.id -- اتصال به خود جدول برای پیدا کردن والد
            WHERE soi.sales_order_id = %s
        """
        items_data = self.execute_query(items_query, (sales_order_id,))
        
        return {
            "header": header_data,
            "items": items_data
        }
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def get_prepopulation_data(self, source_table: str, source_id: int):
        """نسخه نهایی (هوشمند): بر اساس نوع سند، داده‌های صحیح را از جداول مختلف برمی‌گرداند."""
        if not source_table or not source_id:
            return None

        if source_table == 'sales_orders':
            query = """
                SELECT so.so_number AS "SO_NUMBER", c.name AS "CUSTOMER_NAME", c.address AS "CUSTOMER_ADDRESS",
                       c.tax_id AS "CUSTOMER_TAX_ID",
                       (SELECT string_agg(i.name || ' (' || soi.quantity::text || ' ' || u.name || ')', E'\n') 
                        FROM sales_order_items soi JOIN items i ON soi.item_id = i.id
                        LEFT JOIN units u ON i.unit_id = u.id WHERE soi.sales_order_id = so.id) AS "SO_ITEMS_SUMMARY"
                FROM sales_orders so JOIN customers c ON so.customer_id = c.id WHERE so.id = %s
            """
            return self.execute_query(query, (source_id,), fetch_one=True)
        
        # --- *** بخش جدید برای خواندن اطلاعات از اقلام سفارش فروش *** ---
        elif source_table == 'sales_order_items':
            query = """
                SELECT 
                    i.name AS "SO_ITEM_NAME",
                    soi.quantity AS "SO_ITEM_QTY",
                    soi.unit_price AS "SO_ITEM_PRICE",
                    so.so_number AS "SO_NUMBER",
                    c.name AS "CUSTOMER_NAME"
                FROM sales_order_items soi
                JOIN items i ON soi.item_id = i.id
                JOIN sales_orders so ON soi.sales_order_id = so.id
                JOIN customers c ON so.customer_id = c.id
                WHERE soi.id = %s
            """
            return self.execute_query(query, (source_id,), fetch_one=True)
        
        elif source_table == 'purchase_requests':
            query = """
                SELECT i.name as "PR_ITEM_NAME", pr.requested_qty as "PR_REQUESTED_QTY"
                FROM purchase_requests pr JOIN items i ON pr.item_id = i.id WHERE pr.id = %s
            """
            return self.execute_query(query, (source_id,), fetch_one=True)
            
        return None
    
        
    def get_proforma_invoice_history(self, user_id: int):
        """
        تاریخچهٔ «پیش‌فاکتورهای در جریان» کاربر فعلی، بدون اتکا به workflow.
        ستون‌ها را مثل قبل نگه می‌داریم: so_number, customer_name, started_at, current_step, process_status
        """
        query = """
            SELECT
                so.so_number,
                c.name AS customer_name,
                /* started_at سابقاً از process_instances می‌آمد؛ حالا از issue_date استفاده می‌کنیم */
                so.issue_date AS started_at,
                /* current_step برای سازگاری */
                NULL::text AS current_step,
                /* process_status برای سازگاری */
                so.status AS process_status
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            WHERE so.created_by_id = %s
            ORDER BY so.issue_date DESC, so.id DESC
        """
        return self.execute_query(query, (user_id,))
    
# این سه متد را جایگزین متد get_traceability_report قبلی در کلاس DB کنید

    def _trace_bulk_batch_to_suppliers(self, product_batch_no: str):
        """
        (داخلی) برای یک بچ محصول فله، مواد اولیه و تامین‌کنندگان را ردیابی می‌کند.
        """
        query = """
            WITH consumed_batches AS (
                SELECT DISTINCT raw_item_id, raw_batch
                FROM bill_of_materials
                WHERE product_code = %s AND status = 'ACTIVE'
            ),
            entry_transactions AS (
                SELECT
                    t.id as trans_id, t.item_id, t.batch_no,
                    CAST(substring(t.notes from '\\(شناسه آیتم سفارش: (\\d+)\\)') AS INTEGER) as po_item_id
                FROM trans t
                JOIN consumed_batches cb ON t.item_id = cb.raw_item_id AND t.batch_no = cb.raw_batch
                WHERE t.t_type = 'ورود' AND t.status = 'تایید شده' AND t.notes LIKE '%%شناسه آیتم سفارش%%'
            )
            SELECT
                cb.raw_batch, i_raw.name as raw_material_name,
                po.po_number, s.name as supplier_name
            FROM consumed_batches cb
            JOIN items i_raw ON cb.raw_item_id = i_raw.id
            LEFT JOIN entry_transactions et ON cb.raw_item_id = et.item_id AND cb.raw_batch = et.batch_no
            LEFT JOIN purchase_order_items poi ON et.po_item_id = poi.id
            LEFT JOIN purchase_orders po ON poi.purchase_order_id = po.id
            LEFT JOIN suppliers s ON po.supplier_id = s.id
            GROUP BY cb.raw_batch, i_raw.name, po.po_number, s.name;
        """
        return self.execute_query(query, (product_batch_no,))

    def _find_bulk_batches_for_packed_batch(self, packed_product_batch_no: str) -> list:
        """
        مرحله اول ردیابی: با جستجو در لاگ بسته‌بندی، بچ(های) محصول فله استفاده شده را پیدا می‌کند.
        """
        query = """
            SELECT details FROM audit 
            WHERE action LIKE 'PACKING_EVENT%%'
              AND details LIKE '{%%}'
              AND details::jsonb -> 'output_product' ->> 'batch' = %s
            ORDER BY id DESC LIMIT 1
        """
        audit_log = self.execute_query(query, (packed_product_batch_no,), fetch_one=True)
        if not audit_log or not audit_log.get('details'):
            return []
            
        try:
            packing_data = json.loads(audit_log['details'])
            bulk_components = packing_data.get('components', [])
            
            bulk_batch_nos = []
            for comp in bulk_components:
                delivery_id = comp.get('delivery_id')
                if delivery_id:
                    delivery_rec = self.get_delivery_details(delivery_id)
                    if delivery_rec and delivery_rec.get('production_batch_no'):
                        bulk_batch_nos.append(delivery_rec['production_batch_no'])
            return list(set(bulk_batch_nos))
        except (json.JSONDecodeError, KeyError):
            return []

    def get_full_traceability_report(self, final_product_batch_no: str) -> dict:
        """
        تابع اصلی و کامل ردیابی سرتاسری.
        """
        report = {}
        # مرحله ۱: پیدا کردن بچ‌های فله
        bulk_batches = self._find_bulk_batches_for_packed_batch(final_product_batch_no)
        
        # اگر بچ فله‌ای از طریق لاگ بسته‌بندی پیدا نشد،
        # شاید بچ ورودی خودش یک بچ فله باشد. پس آن را هم امتحان می‌کنیم.
        if not bulk_batches:
            bulk_batches = [final_product_batch_no]

        # مرحله ۲: ردیابی هر بچ فله به مواد اولیه
        for bulk_batch in bulk_batches:
            raw_materials = self._trace_bulk_batch_to_suppliers(bulk_batch)
            if raw_materials:
                report[bulk_batch] = raw_materials
        
        return report
    
# این متد موقت را برای دیباگ به انتهای کلاس DB اضافه کنید

    def debug_get_packing_audit_log(self, packed_product_batch_no: str):
        """(فقط برای دیباگ) محتوای خام لاگ حسابرسی برای یک بچ بسته‌بندی را جستجو کرده و برمی‌گرداند."""
        try:
            # ابتدا تمام لاگ‌های مربوط به بسته‌بندی را می‌خوانیم
            query = """
                SELECT id, stamp, action, details FROM audit
                WHERE action LIKE 'PACKING_EVENT%%' ORDER BY id DESC
            """
            all_packing_logs = self.execute_query(query)

            if not all_packing_logs:
                return "هیچ لاگ بسته‌بندی (PACKING_EVENT) در جدول audit یافت نشد."

            # در پایتون به دنبال بچ نامبر مورد نظر می‌گردیم تا از خطای SQL جلوگیری کنیم
            for log in all_packing_logs:
                details_str = log.get('details', '')
                if packed_product_batch_no in details_str:
                    # اگر پیدا شد، آن را برای تحلیل برمی‌گردانیم
                    return f"--- Log Found (ID: {log['id']}, Action: {log['action']}) ---\n\n{details_str}"
            
            return f"لاگ بسته‌بندی برای بچ '{packed_product_batch_no}' یافت نشد. لطفاً از وجود چنین لاگی اطمینان حاصل کنید."
        except Exception as e:
            return f"An unexpected error occurred during debug search: {e}"
                        
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def get_stock_details_for_item_in_warehouse(self, item_id: int, warehouse_name: str):
        """جزئیات کامل موجودی یک کالا را فقط در یک انبار مشخص برمی‌گرداند."""
        query = """
            SELECT
                i.name as item_name,
                s.batch_no,
                s.qty,
                u.name as unit,
                s.expiry_date
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE s.item_id = %s AND w.name = %s AND s.qty > 0.001
            ORDER BY s.expiry_date ASC NULLS LAST, s.batch_no;
        """
        return self.execute_query(query, (item_id, warehouse_name))
    
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def get_all_transactional_items(self):
        """
        شناسه تمام کالاهایی که می‌توانند تراکنش داشته باشند (محصولات مادر نیستند) را برمی‌گرداند.
        """
        query = "SELECT id FROM items WHERE is_parent_product = FALSE"
        return self.execute_query(query)
    
# این متدهای جدید را به انتهای کلاس DB اضافه کنید


    def get_all_users_brief(self):
        """لیست مختصر کاربران (id, username, display_name) را برمی‌گرداند."""
        source = 'fallback'
        rows = []
        try:
            detailed = self.get_all_users_detailed() or []
            if detailed:
                rows = [
                    {
                        'id': user.get('id'),
                        'username': user.get('username'),
                        'display_name': f"{user.get('username')} ({user.get('role_name')})".strip()
                        if user.get('role_name') else user.get('username')
                    }
                    for user in detailed
                ]
                source = 'detailed'
        except Exception:
            cols = set()
            try:
                cols = set(self._get_existing_columns('users'))
            except Exception:
                pass
            name_expr = 'username'
            if 'full_name' in cols:
                name_expr = "COALESCE(NULLIF(TRIM(full_name), ''), username)"
            elif 'name' in cols:
                name_expr = "COALESCE(NULLIF(TRIM(name), ''), username)"
            elif {'first_name', 'last_name'} <= cols:
                name_expr = "COALESCE(NULLIF(TRIM(first_name || ' ' || last_name), ''), username)"
            query = f"SELECT id, username, {name_expr} AS display_name FROM users ORDER BY username"
            rows = self.execute_query(query) or []
        if globals().get('DEBUG_NOTIF', False):
            print(f"[TRACE:MEMO:users] source={source} count={len(rows)}")
        return rows

    def get_all_users_detailed(self):
        """لیست کامل کاربران را به همراه نام نقش و واحد سازمانی آن‌ها برمی‌گرداند."""
        query = """
            SELECT u.id, u.username, r.name as role_name, d.name as department_name, u.department_id, u.role_id
            FROM users u 
            LEFT JOIN roles r ON u.role_id = r.id
            LEFT JOIN departments d ON u.department_id = d.id
            ORDER BY u.username
        """
        return self.execute_query(query)

    def add_or_update_user(self, username: str, password: str, role_id: int, department_id: int, is_new: bool):
        """یک کاربر جدید را اضافه یا یک کاربر موجود را ویرایش می‌کند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                if is_new:
                    if not password:
                        raise ValueError("برای کاربر جدید، وارد کردن رمز الزامی است.")
                    cur.execute("""
                        INSERT INTO users(username, passhash, role_id, department_id) VALUES (%s, %s, %s, %s)
                    """, (username, hash_password(password), role_id, department_id))
                else: # حالت ویرایش
                    if password: # اگر رمز جدیدی وارد شده بود
                        cur.execute("UPDATE users SET passhash = %s, role_id = %s, department_id = %s WHERE username = %s", 
                                    (hash_password(password), role_id, department_id, username))
                    else: # اگر رمز جدیدی وارد نشده بود (فقط نقش یا واحد تغییر کرده)
                        cur.execute("UPDATE users SET role_id = %s, department_id = %s WHERE username = %s", 
                                    (role_id, department_id, username))
            conn.commit()
            
    # در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def create_production_order_from_so(self, sales_order_id: int, user_id: int, cur=None):
        """
        برای یک سفارش فروش مشخص، سفارش(های) تولید متناظر را ایجاد می‌کند.
        این نسخه می‌تواند در یک تراکنش موجود شرکت کند.
        """
        if not cur:
            raise ValueError("A database cursor is required for this operation.")

        so_items = self.execute_query("SELECT item_id, quantity FROM sales_order_items WHERE sales_order_id = %s", (sales_order_id,), cursor=cur)
        if not so_items:
            raise ValueError(f"سفارش فروش با شناسه {sales_order_id} هیچ کالایی برای تولید ندارد.")

        created_ids = []
        for item in so_items:
            res = self.execute_query(
                """INSERT INTO production_orders (source_sales_order_id, item_id, quantity, status, notes)
                VALUES (%s, %s, %s, %s, %s) RETURNING id""",
                (sales_order_id, item['item_id'], item['quantity'], 
                'در انتظار تولید', 'ایجاد شده به صورت خودکار از فرآیند فروش'),
                fetch_one=True, cursor=cur
            )
            created_ids.append(res['id'])

        self.execute_query("UPDATE sales_orders SET status = 'در حال تولید' WHERE id = %s", (sales_order_id,), cursor=cur)
        log_details = f"Created Production Order(s) {created_ids} from Sales Order ID: {sales_order_id}"
        self._log_atomic(cur, user_id, 'CREATE_PROD_ORDER_FROM_SO', log_details)

        return created_ids
            
# این متد جدید را به کلاس DB اضافه کنید
    def get_wip_stock_for_item(self, item_id: int) -> float:
        """موجودی یک کالای فله که تولید شده ولی هنوز به انبار اصلی تحویل نشده را برمی‌گرداند."""
        query = """
            SELECT COALESCE(SUM(quantity), 0) as total_qty
            FROM production_deliveries
            WHERE product_item_id = %s AND status = 'تولید شده'
        """
        result = self.execute_query(query, (item_id,), fetch_one=True)
        return result['total_qty'] if result else 0.0

# متد get_pending_production_orders را در کلاس DB با این نسخه جایگزین کنید
    def get_pending_production_orders(self):
        """لیست تمام سفارشات تولیدی که در وضعیت‌های مختلف 'در انتظار' هستند را برمی‌گرداند."""
        query = """
            SELECT 
                po.id,
                i.name as item_name,
                po.quantity,
                so.so_number,
                c.name as customer_name,
                po.created_at,
                po.status  -- ستون وضعیت اضافه شد
            FROM production_orders po
            JOIN items i ON po.item_id = i.id
            LEFT JOIN sales_orders so ON po.source_sales_order_id = so.id
            LEFT JOIN customers c ON so.customer_id = c.id
            WHERE po.status IN ('در انتظار تولید', 'در انتظار محصول فله', 'در انتظار بسته‌بندی')
            ORDER BY po.created_at ASC;
        """
        return self.execute_query(query)
        
    # این متد جدید را به کلاس DB اضافه کنید
    def create_bulk_request_for_pack_order(self, pack_order_id: int, user_id: int):
        """برای یک سفارش 'پک'، سفارش تولید 'فله' متناظر آن را به صورت خودکار ایجاد می‌کند."""
        with self.transaction() as cur:
            pack_order = self.execute_query("SELECT item_id, quantity FROM production_orders WHERE id = %s", (pack_order_id,), fetch_one=True, cursor=cur)
            if not pack_order: raise ValueError("سفارش تولید اصلی یافت نشد.")

            pack_item_details = self.get_item_details(pack_order['item_id'])
            if not pack_item_details or not pack_item_details.get('parent_item_id'):
                raise ValueError("این کالا یک محصول مادر (فله) ندارد. نمی‌توان برای آن سفارش تولید فله ایجاد کرد.")

            parent_bulk_item_id = pack_item_details['parent_item_id']
            # مقدار فله مورد نیاز بر اساس وزن خالص پک محاسبه می‌شود
            required_bulk_qty = pack_order['quantity'] * (pack_item_details.get('net_weight', 1.0))
            if required_bulk_qty <= 0:
                raise ValueError("وزن خالص برای این پک (net_weight) به درستی تعریف نشده و محاسبه مقدار فله ممکن نیست.")

            existing = self.execute_query("SELECT id FROM production_orders WHERE parent_production_order_id = %s", (pack_order_id,), fetch_one=True, cursor=cur)
            if existing:
                raise ValueError("یک سفارش تولید فله از قبل برای این پک ایجاد شده است.")

            res = self.execute_query(
                """INSERT INTO production_orders (item_id, quantity, status, parent_production_order_id, notes)
                VALUES (%s, %s, %s, %s, %s) RETURNING id""",
                (parent_bulk_item_id, required_bulk_qty, 'در انتظار تولید', pack_order_id, f"تولید فله برای سفارش پک #{pack_order_id}"),
                fetch_one=True, cursor=cur
            )['id']

            # وضعیت سفارش پک اصلی را به‌روزرسانی می‌کنیم
            self.execute_query("UPDATE production_orders SET status = 'در انتظار محصول فله' WHERE id = %s", (pack_order_id,), cursor=cur)

            self._log_atomic(cur, user_id, 'CREATE_BULK_ORDER', f"Created bulk order {res['id']} for pack order {pack_order_id}")
            return res['id']
        
    def get_diagnostic_report_data(self):
        """
        گزارش عیب‌یابی سبک، بدون هرگونه JOIN به workflow/process_instances.
        """
        report = {}

        # 1) وضعیت «فلو فروش» قبلاً از جدول workflows خوانده می‌شد؛ اکنون حذف می‌شود.
        report['sales_workflow'] = None

        # 2) آخرین فرآیندهای تکمیل‌شده (قدیم) حذف؛ سازگاری با مقدار خالی
        report['last_completed_instances'] = []

        # 3) آخرین لاگ‌های حسابرسی همچنان مفیدند (بدون وابستگی مستقیم)
        report['last_audit_logs'] = self.execute_query(
            """
            SELECT stamp, action, details
            FROM audit
            WHERE action IN ('WORKFLOW_STEP_ACTION', 'CREATE_PROD_ORDER_FROM_SO')
            ORDER BY id DESC
            LIMIT 10
            """
        ) or []

        return report
    
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def get_item_stock_in_warehouse(self, item_id: int, warehouse_name: str, cursor=None) -> float:
        """مجموع موجودی یک کالا در یک انبار مشخص را برمی‌گرداند."""
        query = """
            SELECT COALESCE(SUM(s.qty), 0) as total_qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND w.name = %s
        """
        result = self.execute_query(query, (item_id, warehouse_name), fetch_one=True, cursor=cursor)
        return result['total_qty'] if result else 0.0
    
# این متد جدید و بسیار مهم را به انتهای کلاس DB اضافه کنید
    def execute_packing_plan(self, packing_data: dict, user_id: int):
        """
        یک پلن بسته‌بندی کامل را به صورت اتمیک اجرا می‌کند:
        - مواد فله را از انبار اصلی کسر می‌کند.
        - لوازم بسته‌بندی را از انبار تولید کسر می‌کند.
        - محصول نهایی را به انبار تولید اضافه می‌کند.
        - وضعیت سفارش تولید را به‌روز می‌کند.
        - یک لاگ حسابرسی جامع ثبت می‌کند.
        """
        with self.transaction() as cur:
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # ۱. کسر موجودی اجزای فله از انبار اصلی
            for pick in packing_data['bulk_components_plan']:
                self._upd_stock(cur,
                    item_id=pick['item_id'], location_id=pick['location_id'],
                    qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'],
                    expiry_date=pick.get('expiry_date'),
                    ignore_status_check=True)

            # ۲. کسر موجودی لوازم بسته‌بندی از انبار تولید
            for pick in packing_data['packaging_supplies_plan']:
                self._upd_stock(cur,
                    item_id=pick['item_id'], location_id=pick['location_id'],
                    qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'],
                    expiry_date=pick.get('expiry_date'),
                    ignore_status_check=True)

            # ۳. افزودن محصول نهایی بسته‌بندی شده به انبار تولید
            output = packing_data['output_product']
            self._upd_stock(cur, item_id=output['item_id'], location_id=prod_loc_id, 
                            qty_change=abs(output['qty']), batch_no=output['batch'], 
                            expiry_date=output.get('expiry_date'))
            
            # ۴. به‌روزرسانی وضعیت سفارش تولید
            self.execute_query(
                "UPDATE production_orders SET status = 'تکمیل شده' WHERE id = %s",
                (packing_data['production_order_id'],),
                cursor=cur
            )

            # ۵. ثبت لاگ حسابرسی
            log_details = json.dumps(packing_data, ensure_ascii=False, default=str)
            self._log_atomic(cur, user_id, 'EXECUTE_PACKING_PLAN', log_details)
            
# این دو متد جدید را به کلاس DB اضافه کنید

    def does_active_material_request_exist(self, production_order_id: int, item_id: int) -> bool:
        """بررسی می‌کند که آیا یک درخواست مواد فعال برای یک سفارش تولید و کالای خاص وجود دارد یا خیر."""
        notes_pattern = f"%سفارش شماره {production_order_id}%"
        query = """
            SELECT 1 FROM material_requests 
            WHERE item_id = %s AND notes LIKE %s 
            AND status = 'PENDING' 
            LIMIT 1
        """
        result = self.execute_query(query, (item_id, notes_pattern), fetch_one=True)
        return result is not None

    
# این متد تشخیصی را در کلاس DB با نسخه کامل‌تر زیر جایگزین کنید
    def debug_get_item_trace(self, item_name: str) -> str:
        """یک گزارش کامل از وضعیت یک کالا در تمام جداول مرتبط برای دیباگ برمی‌گرداند."""
        report = f"--- گزارش ردیابی برای: {item_name} ---\n"
        try:
            item_details = self.get_item_by_name(item_name)
            if not item_details:
                return f"{report}خطا: کالایی با این نام یافت نشد.\n"
            
            item_id = item_details['id']
            report += f"1. اطلاعات کاتالوگ (items):\n"
            report += f"   - ID: {item_id}, Category: {item_details.get('category')}, Parent ID: {item_details.get('parent_item_id')}\n\n"

            # --- بخش جدید و دقیق‌تر برای گزارش موجودی انبار تولید ---
            report += f"2. موجودی در انبار تولید (stock @ Production):\n"
            stock_prod_records = self.execute_query("""
                SELECT qty, status, batch_no FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE s.item_id = %s AND w.name = %s
            """, (item_id, PRODUCTION_WAREHOUSE_NAME))
            
            if not stock_prod_records:
                report += "   - هیچ رکوردی یافت نشد.\n\n"
            else:
                for rec in stock_prod_records:
                    report += f"   - بچ: {rec['batch_no']}, مقدار: {rec['qty']}, وضعیت: **{rec['status']}**\n"
                report += "\n"
            # ----------------------------------------------------

            wip_stock = self.get_wip_stock_for_item(item_id)
            report += f"3. موجودی در حال تولید (production_deliveries @ PRODUCED):\n"
            report += f"   - مجموع موجودی: {wip_stock}\n"
            report += "---------------------------------------\n"
            return report
        except Exception as e:
            return f"خطا در حین اجرای ردیابی: {e}"
        
                
# این متد جدید و بسیار مهم را به انتهای کلاس DB اضافه کنید
    def execute_packing_plan_from_production(self, packing_data: dict, user_id: int):
        """
        یک پلن بسته‌بندی کامل را که از انبار تولید تغذیه می‌شود، به صورت اتمیک اجرا می‌کند.
        این متد هم برای میزکار هوشمند و هم برای بسته‌بندی دستی استفاده می‌شود.
        """
        with self.transaction() as cur:
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # ۱. کسر موجودی تمام اجزاء (فله و لوازم بسته‌بندی) از انبار تولید
            for pick in packing_data['components_plan']:
                self._upd_stock(cur,
                    item_id=pick['item_id'], location_id=pick['location_id'],
                    qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'],
                    expiry_date=pick.get('expiry_date'),
                    ignore_status_check=True)

            # ۲. افزودن محصول نهایی بسته‌بندی شده به انبار تولید
            output = packing_data['output_product']
            self._upd_stock(cur, item_id=output['item_id'], location_id=prod_loc_id, 
                            qty_change=abs(output['qty']), batch_no=output['batch'], 
                            expiry_date=output.get('expiry_date'))
            
            production_order_id = packing_data.get('production_order_id')
            log_action = 'EXECUTE_PACKING_PLAN_FROM_PROD'
            
            # اگر از طریق سفارش تولید بود، آن را آپدیت کن
            if production_order_id:
                self.execute_query(
                    "UPDATE production_orders SET status = 'تکمیل شده', production_batch_no = %s WHERE id = %s",
                    (output['batch'], production_order_id),
                    cursor=cur
                )
            else: # اگر دستی بود، یک اکشن لاگ متفاوت ثبت کن
                log_action = 'EXECUTE_MANUAL_PACKING_PLAN'

            # ۴. ثبت لاگ حسابرسی
            log_details = json.dumps(packing_data, ensure_ascii=False, default=str)
            self._log_atomic(cur, user_id, log_action, log_details)

            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
                        
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def _get_available_stock(self, item_id: int, cursor) -> float:
        """
        موجودی کل قابل فروش یک کالا را (موجودی تمام انبارها به جز انبار تولید)
        در یک تراکنش موجود محاسبه می‌کند.
        """
        query = """
            SELECT COALESCE(SUM(s.qty), 0) as total_qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND w.name != %s
        """
        result = self.execute_query(query, (item_id, PRODUCTION_WAREHOUSE_NAME), fetch_one=True, cursor=cursor)
        return result['total_qty'] if result else 0.0
    
# این متد جدید را به کلاس DB اضافه کنید
    def get_roles_for_department(self, department_id: int):
        """لیست تمام نقش‌هایی که برای یک واحد سازمانی مشخص مجاز هستند را برمی‌گرداند."""
        if not department_id:
            return []
        query = """
            SELECT r.id, r.name
            FROM roles r
            JOIN department_roles dr ON r.id = dr.role_id
            WHERE dr.department_id = %s
            ORDER BY r.name
        """
        return self.execute_query(query, (department_id,))
    
# این دو متد جدید را به کلاس DB اضافه کنید

    def get_role_ids_for_department(self, department_id: int) -> set:
        """مجموعه‌ای از ID های نقش‌های تخصیص یافته به یک واحد را برمی‌گرداند."""
        if not department_id:
            return set()
        query = "SELECT role_id FROM department_roles WHERE department_id = %s"
        rows = self.execute_query(query, (department_id,))
        return {row['role_id'] for row in rows}

    def update_roles_for_department(self, department_id: int, role_ids: list):
        """لیست نقش‌های یک واحد را به صورت اتمیک به‌روزرسانی می‌کند."""
        with self.transaction() as cur:
            # ابتدا تمام رکوردهای قدیمی برای این واحد را حذف می‌کنیم
            self.execute_query("DELETE FROM department_roles WHERE department_id = %s", (department_id,), cursor=cur)
            
            # سپس رکوردهای جدید را اضافه می‌کنیم
            if role_ids:
                args_list = [(department_id, role_id) for role_id in role_ids]
                cur.executemany(
                    "INSERT INTO department_roles (department_id, role_id) VALUES (%s, %s)",
                    args_list
                )
                
    def get_all_packaging_supplies(self):
        """
        لیست تمام لوازم بسته‌بندی با واحد نمایشی.
        خروجی برای UI پایدار است و ستونی به نام unit برمی‌گرداند.
        """
        query = """
            SELECT i.id,
                i.sku,
                i.name,
                COALESCE(u.name, '') AS unit
            FROM items i
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE i.category = %s
            ORDER BY i.name
        """
        return self.execute_query(query, (CATEGORY_PACKAGING,))
    
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def validate_item_ids(self, item_ids: list) -> list:
        """
        بررسی می‌کند که آیا لیستی از شناسه‌های کالا در جدول 'items' وجود دارند یا خیر.
        لیستی از شناسه‌هایی که یافت نشدند را برمی‌گرداند.
        """
        if not item_ids:
            return []
        
        # برای جلوگیری از خطای SQL در صورت ارسال لیست خالی
        # این کار کوئری را امن‌تر می‌کند
        placeholders = ','.join(['%s'] * len(item_ids))
        query = f"SELECT id FROM items WHERE id IN ({placeholders})"
        
        found_records = self.execute_query(query, tuple(item_ids))
        found_ids = {rec['id'] for rec in found_records}
        
        missing_ids = [item_id for item_id in item_ids if item_id not in found_ids]
        return missing_ids
    
# این متد جدید را به کلاس DB اضافه کنید

    def fulfill_internal_request(self, request_id: int, trans_id: int, user_id: int):
        """وضعیت یک درخواست داخلی را به 'تحویل شده' تغییر داده و آن را به تراکنش خروج متناظرش متصل می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE internal_requests SET status = %s, processed_by_user_id = %s, processed_at = NOW(), related_trans_id = %s WHERE id = %s",
                (TransactionStatus.IR_FULFILLED.value, user_id, trans_id, request_id)
            )
            self._log_atomic(cur, user_id, 'FULFILL_INTERNAL_REQUEST', f"Fulfilled request ID:{request_id} via transaction ID:{trans_id}")            
                
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_quotes_for_request(self, request_id: int):
        """لیست تمام پیشنهاد قیمت‌های ثبت شده برای یک درخواست خرید را برمی‌گرداند."""
        if not request_id: return []
        query = """
            SELECT sq.id, s.name as supplier_name, sq.unit_price, sq.lead_time_days, sq.notes
            FROM supplier_quotes sq
            JOIN suppliers s ON sq.supplier_id = s.id
            WHERE sq.purchase_request_id = %s
            ORDER BY sq.unit_price ASC
        """
        return self.execute_query(query, (request_id,))

    def add_quote(self, pr_id: int, supplier_id: int, unit_price: float,
                lead_time_days: int | None = None, notes: str = "",
                user_id: int | None = None, doc_path: str | None = None,
                currency: str = "IRR") -> int:
        """
        Alias برای سازگاری عقبگرد؛ به add_supplier_quote نگاشت می‌شود.
        پارامتر doc_path در این نسخه ذخیره نمی‌شود (درصورت نیاز بعداً فایل‌گرامر اضافه کنید).
        """
        return self.add_supplier_quote(
            pr_id=pr_id,
            supplier_id=supplier_id,
            unit_price=float(unit_price),
            currency=(currency or "IRR")[:8],
            lead_time_days=lead_time_days,
            min_order_qty=None,
            notes=notes or "",
            user_id=user_id
        )

    def select_winning_quote(self, pr_id: int, quote_id: int, approver_id: int | None = None) -> None:
        """
        Alias برای سازگاری عقبگرد؛ به select_quote_winner نگاشت می‌شود.
        """
        return self.select_quote_winner(pr_id=pr_id, quote_id=quote_id, approver_id=approver_id)

            
                
    def get_approved_purchase_requests_for_sourcing(self) -> list[dict]:
        """
        منبع واحد و ساده برای «لیست آمادهٔ بازرگانی/استعلام».
        معیار ورود:
        - وضعیت کاری PR یکی از این‌ها باشد: «در انتظار تایید بازرگانی»، «آماده برای استعلام»، «تایید شده توسط مدیرعامل»
            (هم معادل‌های انگلیسی و هم فارسی)،
        - یا approval_status یکی از ('APPROVED','تایید شد') باشد،
        - و هنوز وارد PO نشده باشد.
        خروجی هر ردیف: id, group_id, item_name, requested_qty, requester_name, request_date,
                        approval_status, status_text, physical_request_no
        هیچ زیرساخت/وابستگی تازه‌ای نمی‌سازد و با state/status سازگار است.
        """
        with self.transaction() as cur:
            # ستون‌های موجود
            pr_cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            it_cols = set(self._get_existing_columns('items', cursor=cur))
            u_cols  = set(self._get_existing_columns('users', cursor=cur))
            pg_cols = set(self._get_existing_columns('purchase_request_groups', cursor=cur))
            poi_cols = set(self._get_existing_columns('purchase_order_items', cursor=cur))

            # کشف نام ستون‌ها
            status_col  = 'state' if 'state' in pr_cols else ('status' if 'status' in pr_cols else None)
            qty_col     = ('requested_qty' if 'requested_qty' in pr_cols else
                        ('quantity' if 'quantity' in pr_cols else ('qty' if 'qty' in pr_cols else None)))
            item_fk     = 'item_id' if 'item_id' in pr_cols else None
            req_date_col= next((c for c in ('request_date','created_at','created','submitted_at') if c in pr_cols), None)
            appr_col    = 'approval_status' if 'approval_status' in pr_cols else None

            poi_pr_fk   = 'pr_id' if 'pr_id' in poi_cols else ('purchase_request_id' if 'purchase_request_id' in poi_cols else None)

            # فهرست وضعیت‌های قابل قبول
            def _v(name, default):
                try:
                    return getattr(TransactionStatus, name).value
                except Exception:
                    return default
            statuses_any = [
                _v('PR_AWAITING_COMMERCE', 'در انتظار تایید بازرگانی'),
                _v('READY_FOR_SOURCING', 'آماده برای استعلام'),
                _v('PR_CEO_APPROVED', 'تایید شده توسط مدیرعامل'),
                'AWAITING_COMMERCE', 'READY_FOR_SOURCING', 'PR_AWAITING_COMMERCE', 'PR_READY_FOR_SOURCING'
            ]

            # عبارت‌های انتخاب
            item_name_expr = "i.name" if ('name' in it_cols and item_fk) else "NULL::text"
            requester_expr = "COALESCE(u.full_name, u.name, u.username, u.email, '-')"
            phys_expr = "pg.physical_request_no" if ('physical_request_no' in pg_cols) else "NULL::text"
            unit_join = ""  # در این متد لازم نیست

            # شرط PO نخورده
            not_exists_po = ""
            if poi_pr_fk:
                not_exists_po = f"AND NOT EXISTS (SELECT 1 FROM purchase_order_items poi WHERE poi.{poi_pr_fk} = pr.id)"

            # WHERE اصلی (سازگار با نبود status_col/appr_col)
            where_parts = []
            params = []

            if status_col:
                where_parts.append(f"COALESCE(pr.{status_col}, '') = ANY(%s)")
                params.append(statuses_any)
            if appr_col:
                where_parts.append("COALESCE(pr.approval_status,'') IN ('APPROVED','تایید شد')")
            if not where_parts:
                # حداقل یک شرط داشته باشیم تا لیست خالی نشود
                where_parts.append("TRUE")

            where_clause = " OR ".join(where_parts)

            # ساخت کوئری
            sql = f"""
                SELECT
                    pr.id,
                    pr.group_id,
                    {item_name_expr}           AS item_name,
                    {('pr.' + qty_col) if qty_col else 'NULL::numeric'} AS requested_qty,
                    {requester_expr}           AS requester_name,
                    COALESCE(pr.{req_date_col}, NOW()) AS request_date,
                    COALESCE(pr.{appr_col}, '') AS approval_status,
                    {('COALESCE(pr.' + status_col + ", '')") if status_col else "''"} AS status_text,
                    {phys_expr}                AS physical_request_no
                FROM purchase_requests pr
                LEFT JOIN items i ON {('i.id = pr.' + item_fk) if item_fk else '1=0'}
                LEFT JOIN users u ON {('u.id = pr.requester_id') if 'requester_id' in pr_cols and u_cols else '1=0'}
                LEFT JOIN purchase_request_groups pg ON {('pg.id = pr.group_id') if 'group_id' in pr_cols and pg_cols else '1=0'}
                WHERE ({where_clause})
                {not_exists_po}
                ORDER BY COALESCE(pr.{req_date_col}, NOW()) DESC, pr.id DESC
                LIMIT 500
            """
            rows = self.execute_query(sql, tuple(params)) or []
            return rows
    
    
    def count_prs_pending_commerce(self) -> int:
        """تعداد PRهای در انتظار تایید بازرگانی (برای تشخیص تغییر)."""
        try:
            status_val = TransactionStatus.PR_AWAITING_COMMERCE.value
        except Exception:
            status_val = 'در انتظار تایید بازرگانی'
        row = self.execute_query(
            "SELECT COUNT(*) AS c FROM purchase_requests WHERE status = %s",
            (status_val,), fetch_one=True
        ) or {"c": 0}
        return int(row.get('c', 0))
    
    def set_pr_status_awaiting_commerce(self, pr_id: int) -> None:
        """PR → «در انتظار تایید بازرگانی» (PostgreSQL)."""
        with self.transaction() as cur:
            cols = set(self._get_existing_columns('purchase_requests', cursor=cur))
            status_col = 'state' if 'state' in cols else 'status'
            from psycopg2 import sql as _sql
            cur.execute(_sql.SQL("UPDATE purchase_requests SET {c}=%s WHERE id=%s").format(
                c=_sql.Identifier(status_col)), ('در انتظار تایید بازرگانی', pr_id))
            try:
                if hasattr(self, "_log_atomic"):
                    self._log_atomic(cur, None, 'PR_STATUS_SET', f"PR#{pr_id} -> 'در انتظار تایید بازرگانی'")
            except Exception: pass
        try:
            if hasattr(self, "signals"): self.signals.dataChanged.emit("NOTIFICATIONS_CHANGED")
        except Exception: pass

    def get_requests_ready_for_po_grouped_by_supplier(self):
        """درخواست‌هایی که پیشنهاد قیمت برنده دارند را به تفکیک تامین‌کننده برای صدور PO گروه بندی می‌کند."""
        query = """
            SELECT 
                s.id as supplier_id,
                s.name as supplier_name,
                COUNT(pr.id) as request_count,
                json_agg(
                    json_build_object(
                        'pr_id', pr.id,
                        'item_name', i.name,
                        'requested_qty', pr.requested_qty
                    )
                ) as requests
            FROM purchase_requests pr
            JOIN supplier_quotes sq ON pr.selected_quote_id = sq.id
            JOIN suppliers s ON sq.supplier_id = s.id
            JOIN items i ON pr.item_id = i.id
            WHERE pr.status = 'تامین‌کننده انتخاب شد'
            GROUP BY s.id, s.name
            ORDER BY s.name;
        """
        return self.execute_query(query)

    # [FUNC: DB.create_aggregated_purchase_order] — آداپتور امن به مسیر استاندارد PO (Quote→PO)
    def create_aggregated_purchase_order(self, supplier_id: int, pr_ids: list[int], user_id: int) -> str:
        """از PRهای انتخاب‌شده، PO تجمیعی می‌سازد؛
        به‌جای درج مستقیم آیتم‌ها، به مسیر استاندارد `create_purchase_order_for_supplier` دلیگیت می‌کند.
        """
        if not pr_ids:
            raise ValueError("لیست PR خالی است.")

        # اسکیماها را (در صورت نیاز) آماده کن
        try:
            self.ensure_supplier_quotes_schema()
            self.ensure_purchase_orders_schema()
        except Exception:
            pass

        # استخراج Quoteهای برندهٔ همین تامین‌کننده برای PRهای داده‌شده
        placeholders = ','.join(['%s'] * len(pr_ids))
        rows = self.execute_query(
            f"""
            SELECT sq.id AS quote_id
            FROM purchase_requests pr
            JOIN supplier_quotes sq ON pr.selected_quote_id = sq.id
            WHERE pr.id IN ({placeholders}) AND sq.supplier_id = %s
            """,
            tuple(pr_ids) + (supplier_id,)
        ) or []

        quote_ids = [int(r['quote_id']) for r in rows if r.get('quote_id') is not None]
        if not quote_ids:
            raise ValueError("برای PRهای انتخاب‌شده، هیچ پیشنهاد برنده‌ای از این تامین‌کننده موجود نیست.")

        # مسیر استاندارد: خودش ستون‌های متغیر را کشف و ثبت می‌کند
        res = self.create_purchase_order_for_supplier(
            supplier_id=supplier_id,
            quote_ids=quote_ids,
            created_by_id=user_id,
            notes=f"Aggregated from PRs: {pr_ids}"
        )

        try:
            # لاگ نرم؛ اگر logger/registry آماده نبود، بی‌صدا عبور کن
            self._log('INFO', f"Aggregated PO via delegate: supplier={supplier_id}, PRs={len(pr_ids)}, quotes={len(quote_ids)}")
        except Exception:
            pass

        # سازگاری عقب‌رو: قبلاً این متد `po_number` (رشته) می‌داد
        if isinstance(res, dict) and 'order_no' in res:
            return res['order_no']
        if isinstance(res, dict) and 'po_id' in res:
            return f"PO-{res['po_id']}"
        return str(res)

    def _already_notified_recently(self, pi_id: int, policy_id: int | None, repeat_every: int) -> bool:
        row = self.execute_query("""
            SELECT last_notified_at FROM qa_escalation_log
            WHERE process_instance_id=%s AND (policy_id=%s OR %s IS NULL)
            ORDER BY last_notified_at DESC
            LIMIT 1
        """, (pi_id, policy_id, policy_id))
        if not row:
            return False
        last = row[0]['last_notified_at']
        # تبدیل به datetime (اگر str)
        if isinstance(last, str):
            try:
                last = dt.datetime.fromisoformat(last.replace('Z',''))
            except Exception:
                return False
        return (dt.datetime.utcnow() - last).total_seconds() < repeat_every * 60

    
        # ─────────────────────────────────────────────────────────────────────────────
    # [ADD to class DB] یابنده/سازندهٔ فرم‌های QC + Upsert امن گِیت + Seeder پیش‌فرض
    # ─────────────────────────────────────────────────────────────────────────────

    def _table_has_column(self, table: str, col: str) -> bool:
        """بررسی وجود ستون در جدول (سازگار با PostgreSQL)."""
        try:
            rows = self.execute_query("""
                SELECT 1 FROM information_schema.columns
                WHERE table_name=%s AND column_name=%s
                LIMIT 1
            """, (table, col))
            return bool(rows)
        except Exception:
            return False  # اگر دیتابیس اجازه نداد، ادامه می‌دهیم

    def get_or_create_form_def(self, code: str, name_persian: str) -> int:
        """
        یک فرم QC با code/name برمی‌گرداند؛ اگر نبود، با اسکیمای حداقلی Pass/Fail می‌سازد.
        اسکیمای حداقلی: یک فیلد 'result' (PASSED/FAILED) و یک فیلد 'score' اختیاری.
        """
        # 1) پیدا کردن اگر هست
        try:
            if self._table_has_column('form_defs', 'code'):
                row = self.execute_query("SELECT id FROM form_defs WHERE code=%s LIMIT 1", (code,))
                if row: return int(row[0]['id'])
            # fallback با name
            row = self.execute_query("SELECT id FROM form_defs WHERE LOWER(name)=LOWER(%s) LIMIT 1", (name_persian,))
            if row: return int(row[0]['id'])
        except Exception:
            pass

        # 2) اگر نبود: بساز (با چند الگوی ممکن بسته به اسکیمای جدول شما)
        schema_min = {
            "title": name_persian,
            "fields": [
                {"name": "result", "type": "enum", "choices": ["PASSED", "FAILED"], "required": True},
                {"name": "score",  "type": "number", "required": False}
            ]
        }
        payloads = []
        # الگوهای احتمالی ستون‌ها:
        if self._table_has_column('form_defs', 'code') and self._table_has_column('form_defs', 'schema_json'):
            payloads.append(("INSERT INTO form_defs (code, name, schema_json, active) VALUES (%s,%s,%s,TRUE) RETURNING id",
                            (code, name_persian, json.dumps(schema_min))))
        if self._table_has_column('form_defs', 'definition'):
            payloads.append(("INSERT INTO form_defs (name, definition, active) VALUES (%s,%s,TRUE) RETURNING id",
                            (name_persian, json.dumps(schema_min))))
        # ساده‌ترین حالت‌ها
        payloads.append(("INSERT INTO form_defs (name, active) VALUES (%s, TRUE) RETURNING id",
                        (name_persian,)))
        payloads.append(("INSERT INTO form_defs (name) VALUES (%s) RETURNING id",
                        (name_persian,)))

        for sql, args in payloads:
            try:
                with self.transaction() as cur:
                    cur.execute(sql, args)
                    new_id = cur.fetchone()['id']
                    return int(new_id)
            except Exception:
                continue

        # اگر هیچ‌کدام جواب نداد:
        raise RuntimeError("ساخت فرم QC پیش‌فرض ممکن نشد؛ لطفاً ساختار جدول form_defs را به من بگو تا فیتش کنم.")

    # Helper: اجرای بلوک SQL چندخطی
    def execute_sql_block(self, sql_block: str):
        with self.transaction() as cur:
            cur.execute(sql_block)

    # Helper: کوتیشن امن اسمی (ساده)
    def _sql_quote(self, s: str) -> str:
        return "'" + s.replace("'", "''") + "'"
    
        
    def emergency_reset_admin_password(self, new_password: str = "Admin@123"):
        """
        ریست رمز ادمین به مقدار دلخواه (پیش‌فرض: Admin@123).
        از همان کانتکست bcrypt برنامه استفاده می‌کند و فقط passhash کاربر 'admin' را به‌روزرسانی می‌کند.
        """
        if not new_password or len(new_password.strip()) < 6:
            raise ValueError("رمز جدید معتبر نیست (حداقل ۶ کاراکتر).")

        # استفاده از passlib همان پروژه
        hashed = hash_password(new_password.strip())

        with self._conn() as conn:
            with conn.cursor() as cur:
                # مطمئن شو کاربر admin وجود دارد
                cur.execute("SELECT id FROM users WHERE LOWER(username) = LOWER(%s)", ("admin",))
                row = cur.fetchone()
                if not row:
                    raise ValueError("کاربر 'admin' در دیتابیس یافت نشد.")

                cur.execute("UPDATE users SET passhash = %s WHERE LOWER(username) = LOWER(%s)", (hashed, "admin"))
            conn.commit()
        print("SUCCESS: admin password reset. You can now log in with the new password.")
        
    # داخل کلاس DB
    def prepare_item_for_save(self, payload: dict) -> dict:
        """
        قوانین سفت‌وسخت قبل از ذخیره:
        - اگر parent_item_id دارد → آیتم فرزند است:
            * is_parent_product = False
            * category = CATEGORY_FINAL_PRODUCT
            * is_two_component = inherit from parent
        - اگر is_parent_product=True → موجودی اولیه نادیده گرفته شود و واحد قفل شود.
        - آیتم معمولی → is_two_component همیشه False
        """
        p = dict(payload)  # کپی امن

        parent_id = p.get('parent_item_id')
        is_parent = bool(p.get('is_parent_product', False))

        if parent_id:
            # فرزند بسته‌بندی
            p['is_parent_product'] = False
            p['category'] = CATEGORY_FINAL_PRODUCT
            # ارث‌بری دو‌جزئی از مادر
            parent = self.get_item_by_id(parent_id)
            p['is_two_component'] = bool(parent.get('is_two_component', False))

        elif is_parent:
            # مادر: موجودی اولیه بی‌اثر
            p['initial_stock_rows'] = []    # اگر کلید دیگری دارید، همان را خالی کنید
            # واحد برای مادر عملاً مصرف ندارد؛ اما اگر فیلد لازم است، دست نزنیم
            # فقط مطمئن شو خروجی گزارش‌ها به واحد مادر اتکا نکند

        else:
            # آیتم معمولی مستقل
            p['is_two_component'] = False   # فقط مادر می‌تواند دو‌جزئی باشد

        return p
    

    def get_event_action_recipes(self) -> dict:
        raw = self.get_setting('event_action_recipes', '{}') or '{}'
        try:
            return json.loads(raw)
        except Exception:
            return {}

    def save_event_action_recipe(self, event_name: str, recipe: dict):
        data = self.get_event_action_recipes()
        data[str(event_name)] = recipe or {}
        self.set_setting('event_action_recipes', json.dumps(data, ensure_ascii=False))

    # ─── A) رجیستری امن متدها ───
    def register_event_method(self, name: str, fn):
        if not hasattr(self, '_event_method_whitelist'):
            self._event_method_whitelist = {}
        key = (name or '').strip()
        if key and callable(fn):
            self._event_method_whitelist[key] = fn

    def _resolve_event_method(self, name: str):
        key = (name or '').strip()
        if not key:
            return None
        defaults = {
            "create_internal_request": getattr(self, "create_internal_request", None),
            "submit_material_request": getattr(self, "submit_material_request", None),
            "create_purchase_request": getattr(self, "create_purchase_request", None),
            "create_sales_order":      getattr(self, "create_sales_order", None),
            "create_production_order": getattr(self, "create_production_order", None),
            "reserve_stock_for_order": getattr(self, "reserve_stock_for_order", None),
            "fulfill_request_with_fefo": getattr(self, "fulfill_request_with_fefo", None),
            # اگر بعداً متد دیگری ساختی، همین‌جا به‌سادگی اضافه می‌شود
        }
        # رجیستری دستی (در صورت وجود) بر پیش‌فرض‌ها اولویت دارد
        if hasattr(self, '_event_method_whitelist') and key in self._event_method_whitelist:
            return self._event_method_whitelist[key]
        return defaults.get(key)

    def _init_event_method_registry(self):
        # خودکار و ایمن ثبت می‌کنیم؛ هر کدام موجود بود، اضافه می‌شود
        for _name in (
            "create_internal_request", "submit_material_request", "create_purchase_request",
            "create_sales_order", "create_production_order", "reserve_stock_for_order",
            "fulfill_request_with_fefo"
        ):
            fn = getattr(self, _name, None)
            if callable(fn):
                self.register_event_method(_name, fn)

    def _eval_value(self, spec, ctx: dict, user_id: int):
        if spec is None: return None
        if isinstance(spec, (int, float, bool)): return spec
        if isinstance(spec, dict):
            if "literal" in spec: return spec["literal"]
            if "int" in spec:
                v = self._eval_value(spec["int"], ctx, user_id)
                try: return int(v)
                except Exception: return None
            if "float" in spec:
                v = self._eval_value(spec["float"], ctx, user_id)
                try: return float(v)
                except Exception: return None
            return None
        if not isinstance(spec, str): return None
        s = spec.strip()
        if s == "user_id": return user_id
        if s == "now":     return dt.datetime.now().isoformat(timespec='seconds')
        if s.startswith("context."):
            cur = ctx
            for p in s.split(".")[1:]:
                if not isinstance(cur, dict) or p not in cur: return None
                cur = cur[p]
            return cur
        return s
    
    # --- REWRITE (exclude lab flows too): DB.get_delivery_history ---
    def get_delivery_history(
        self,
        date_from=None,
        date_to=None,
        limit: int = 1000,
        warehouse_name: str = None,
    ):
        """
        تاریخچه‌ی تراکنش‌ها برای «تاریخچه تحویل‌ها» و مصرف‌های مشابه.
        حذف از خروجی:
        - اسناد تبدیل (t_no شبیه CNV-... یا t_type های تبدیل)
        - رفت‌وآمد آزمایشگاه (t_no شبیه LAB-... یا t_type های آزمایشگاه)
        خروجی کلیدها مطابق UI: date, t_no, t_type, batch_no, src_wh, dest_wh, qty, item_name
        """
        from datetime import datetime, timedelta

        # بازه پیش‌فرض
        today = datetime.now().date()
        if not date_from:
            date_from = today.replace(day=1)
        if not date_to:
            date_to = today + timedelta(days=1)

        # تشخیص ستون‌های موجود
        try:
            trans_cols = set(self._get_existing_columns("trans"))
        except Exception:
            trans_cols = set()

        # تاریخ
        if "t_date" in trans_cols:
            date_col = "t.t_date"
        elif "tt_date" in trans_cols:
            date_col = "t.tt_date"
        else:
            date_col = "NOW()"
        date_expr = f"COALESCE({date_col}, NOW())"

        # SELECT پایه
        select_parts = [
            f"DATE({date_expr}) AS date",
            "COALESCE(t.t_no,'')     AS t_no",
            "COALESCE(t.t_type,'')   AS t_type",
            "COALESCE(t.batch_no,'') AS batch_no",
            "COALESCE(t.qty,0)       AS qty",
            "COALESCE(i.name,'')     AS item_name",
        ]
        joins = ["JOIN items i ON i.id = t.item_id"]

        # نام انبارها
        src_dest_filterable = False
        if {"src_loc", "dest_loc"}.issubset(trans_cols):
            joins += [
                "LEFT JOIN locations sl ON sl.id = t.src_loc",
                "LEFT JOIN warehouses sw ON sw.id = sl.warehouse_id",
                "LEFT JOIN locations dl ON dl.id = t.dest_loc",
                "LEFT JOIN warehouses dw ON dw.id = dl.warehouse_id",
            ]
            select_parts += [
                "COALESCE(sw.name,'') AS src_wh",
                "COALESCE(dw.name,'') AS dest_wh",
            ]
            src_dest_filterable = True
        elif {"src_wh", "dest_wh"}.issubset(trans_cols):
            joins += [
                "LEFT JOIN warehouses sw ON sw.id = t.src_wh",
                "LEFT JOIN warehouses dw ON dw.id = t.dest_wh",
            ]
            select_parts += [
                "COALESCE(sw.name,'') AS src_wh",
                "COALESCE(dw.name,'') AS dest_wh",
            ]
            src_dest_filterable = True
        else:
            sel_src = "COALESCE(t.src_wh::text,'')" if "src_wh" in trans_cols else "''"
            sel_dst = "COALESCE(t.dest_wh::text,'')" if "dest_wh" in trans_cols else "''"
            select_parts += [f"{sel_src} AS src_wh", f"{sel_dst} AS dest_wh"]

        # WHERE پارامتری
        where = [f"DATE({date_expr}) BETWEEN %s AND %s"]
        params = [date_from, date_to]

        # نوع‌های حذف‌شونده
        conv_types = ['ورود از تبدیل', 'خروج به تبدیل', 'ورود (تبدیل)', 'خروج (تبدیل)']
        lab_types  = ['خروج به آزمایشگاه', 'ارسال به آزمایشگاه', 'ورود از آزمایشگاه', 'بازگشت از آزمایشگاه']
        drop_types = conv_types + lab_types

        # حذف تبدیل‌ها و آزمایشگاه: هم بر اساس t_no pattern و هم نوع
        where.append(
            "NOT (COALESCE(t.t_no,'') LIKE %s OR COALESCE(t.t_no,'') LIKE %s OR COALESCE(t.t_type,'') = ANY(%s))"
        )
        params += ['CNV-%', 'LAB-%', drop_types]

        # فیلتر اختیاری نام انبار
        if warehouse_name and src_dest_filterable:
            where.append("(LOWER(sw.name)=LOWER(%s) OR LOWER(dw.name)=LOWER(%s))")
            params += [warehouse_name, warehouse_name]

        # بستن SQL
        sql  = "SELECT " + ", ".join(select_parts) + " FROM trans t " + " ".join(joins)
        sql += " WHERE " + " AND ".join(where)
        sql += f" ORDER BY {date_expr} DESC, t.id DESC"
        if isinstance(limit, int) and limit > 0:
            sql += " LIMIT %s"
            params.append(limit)

        rows = self.execute_query(sql, tuple(params)) or []
        return rows
    # --- END REWRITE ---
    
        # ================== Main Tx: helper to hide conversions (safe filter) ==================
    def _is_conversion_row_dict(r: dict) -> bool:
        ttype = (r.get('t_type') or '').strip()
        tno   = (r.get('t_no') or '')
        return (ttype in ('خروج به تبدیل', 'ورود از تبدیل')) or (isinstance(tno, str) and tno.startswith('CNV-'))

    def filter_out_conversion_rows(rows, prod_loc_id=None):
        """
        rows: list of dict-like rows (خروجی execute_query در همین پروژه)
        فقط برای «نمایش» فیلتر می‌کند؛ داده‌ای را حذف/تغییر نمی‌دهد.
        """
        kept, removed = [], 0
        for r in rows or []:
            if isinstance(r, dict) and _is_conversion_row_dict(r):
                # اگر خواستی علاوه بر نوع، لوکیشن تولید را هم لحاظ کن:
                if prod_loc_id:
                    src_ok = (r.get('src_loc') == prod_loc_id)
                    dst_ok = (r.get('dest_loc') == prod_loc_id)
                    if src_ok or dst_ok:
                        removed += 1
                        continue
                else:
                    removed += 1
                    continue
            kept.append(r)
        if DEBUG_TRACE:
            print(f"[TRACE:MAIN] removed_conversion={removed} kept={len(kept)}")
        return kept
    # ================== /Main Tx helper ==================

    
    # Production Conversions: replace get_production_conversions()
    def get_production_conversions(self, limit: int = 500, offset: int = 0):
        """
        خروجی دقیقاً مطابق انتظار UI:
        d, a, b, qty, b_batch, username, t_no, note
        منطق: اسناد با t_type در {'ورود از تبدیل','خروج به تبدیل'} را بر اساس t_no جمع‌بندی می‌کنیم.
        """
        DEBUG_TRACE = globals().get("DEBUG_TRACE", False)
        IN_CONV  = 'ورود از تبدیل'
        OUT_CONV = 'خروج به تبدیل'

        sql = """
            WITH tx AS (
                SELECT
                    t_no, t_date, t_type, item_id, qty, batch_no, user_id, notes
                FROM trans
                WHERE t_type IN (%s, %s)
            ),
            per_doc AS (
                SELECT
                    tx.t_no,
                    COALESCE(MAX(tx.t_date), MIN(tx.t_date)) AS d,
                    MAX(CASE WHEN tx.t_type = %s THEN i.name END)     AS a,       -- from OUT
                    MAX(CASE WHEN tx.t_type = %s THEN i.name END)     AS b,       -- from IN
                    MAX(CASE WHEN tx.t_type = %s THEN tx.qty END)     AS qty,     -- qty of IN
                    MAX(CASE WHEN tx.t_type = %s THEN tx.batch_no END) AS b_batch, -- batch of IN
                    MAX(tx.user_id)                                    AS any_user_id,
                    MAX(tx.notes)                                      AS note
                FROM tx
                JOIN items i ON i.id = tx.item_id
                GROUP BY tx.t_no
            )
            SELECT
                p.d,
                p.a,
                p.b,
                COALESCE(p.qty, 0) AS qty,
                p.b_batch,
                COALESCE(u.username, CAST(u.id AS TEXT)) AS username,
                p.t_no,
                p.note
            FROM per_doc p
            LEFT JOIN users u ON u.id = p.any_user_id
            ORDER BY p.d DESC NULLS LAST, p.t_no DESC
            LIMIT %s OFFSET %s
        """
        params = (IN_CONV, OUT_CONV, OUT_CONV, IN_CONV, IN_CONV, IN_CONV, limit, offset)

        if DEBUG_TRACE:
            print("[TRACE:CONV:sql] cols=[d,a,b,qty,b_batch,username,t_no,note] "
                f"filters={{types:['{IN_CONV}','{OUT_CONV}']}}")

        try:
            rows = self.execute_query(sql, params) or []
        except Exception as e:
            # کمک برای دیباگ اگر باز هم خطای SQL رخ داد
            if DEBUG_TRACE:
                print("[TRACE:CONV:sql-error]", e)
            raise

        if DEBUG_TRACE:
            import sys
            print(f"[TRACE:CONV:rows] total={len(rows)} sample_row={(rows[0] if rows else {})}")
            sys.stdout.flush()

        return rows
            
  
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class ReturnMaterialDialog(QtWidgets.QDialog):
    """پنجره‌ای برای ثبت درخواست برگشت مواد اولیه از کف کارگاه به انبار اصلی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت درخواست برگشت مواد اولیه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("0.0")
        self.reason_edit = QtWidgets.QLineEdit(placeholderText="مثال: مواد اضافه از تولید بچ X")

        layout.addRow("انتخاب کالا و بچ برای برگشت:", self.item_combo)
        layout.addRow("مقدار برگشتی:", self.qty_edit)
        layout.addRow("دلیل برگشت:", self.reason_edit)

        self.item_combo.currentIndexChanged.connect(self._on_item_selected)

        self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        layout.addRow(self.buttons)

        self._load_items_in_production()

    def _load_items_in_production(self):
        items = self.db.get_stock_for_warehouse('Production')
        raw_materials = [item for item in items if item.get('category') == 'مواد اولیه']
        
        if not raw_materials:
            self.item_combo.addItem("هیچ ماده اولیه‌ای برای برگشت یافت نشد.", None)
            self.item_combo.setEnabled(False)
            self.buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
        else:
            for item in raw_materials:
                # --- اصلاح ۱: استفاده از 'total_qty' ---
                display_text = f"{item['name']} (بچ: {item['batch_no']}, موجودی: {item['total_qty']})"
                self.item_combo.addItem(display_text, item)
    
    def _on_item_selected(self):
        data = self.item_combo.currentData()
        if data:
            # --- اصلاح ۲: استفاده از 'total_qty' ---
            max_qty = data.get('total_qty', 0.0)
            self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, max_qty, 3))
            self.qty_edit.setText(str(max_qty))

    def get_data(self):
        try:
            component = self.item_combo.currentData()
            qty = float(self.qty_edit.text())
            reason = self.reason_edit.text().strip()
            if component and qty > 0 and reason:
                # --- اصلاح ۳: استفاده از 'total_qty' ---
                if qty > component['total_qty']:
                    QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "مقدار برگشتی نمی‌تواند از موجودی بچ بیشتر باشد.")
                    return None
                return {"component": component, "qty": qty, "reason": reason}
        except (ValueError, TypeError):
            pass
        return None
            
class FefoPickDialog(QtWidgets.QDialog):
    """
    نسخه 2.0 (بهبود UI/UX):
    پنجره‌ای برای نمایش لیست برداشت پیشنهادی FEFO با ظاهر گرافیکی بهتر و تفکیک اطلاعات.
    """
    def __init__(self, pick_list, item_name, qty_needed, parent=None):
        super().__init__(parent)
        self.setWindowTitle("پیشنهاد برداشت هوشمند (FEFO)")
        self.setMinimumSize(650, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.manual_override = False

        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(15)

        # بخش 1: مشخصات درخواست
        request_group = QtWidgets.QGroupBox("مشخصات درخواست")
        request_group.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        request_layout = QtWidgets.QFormLayout(request_group)
        request_layout.setSpacing(10)
        
        req_item_label = QtWidgets.QLabel(f"<b>{item_name}</b>")
        req_qty_label = QtWidgets.QLabel(f"<b>{qty_needed}</b> واحد")
        
        request_layout.addRow("کالای درخواستی:", req_item_label)
        request_layout.addRow("مقدار مورد نیاز:", req_qty_label)
        layout.addWidget(request_group)

        # بخش 2: پیشنهاد سیستم
        suggestion_group = QtWidgets.QGroupBox("پیشنهاد سیستم (بر اساس اولین انقضا)")
        suggestion_group.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        suggestion_layout = QtWidgets.QVBoxLayout(suggestion_group)
        
        self.table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'): # اعمال استایل استاندارد برنامه
            parent._style_table(self.table)
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(['مقدار برداشت', 'بچ نامبر', 'تاریخ انقضا', 'محل'])
        self.table.setRowCount(len(pick_list))

        for row, pick in enumerate(pick_list):
            self.table.setItem(row, 0, NumericTableWidgetItem(str(pick['pick_qty'])))
            self.table.setItem(row, 1, QtWidgets.QTableWidgetItem(pick['batch_no']))
            expiry_str = to_shamsi(pick.get('expiry_date')) or 'ندارد'
            self.table.setItem(row, 2, QtWidgets.QTableWidgetItem(expiry_str))
            loc_label = parent.db.loc_label(pick['location_id'])
            self.table.setItem(row, 3, QtWidgets.QTableWidgetItem(loc_label))
        
        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
        suggestion_layout.addWidget(self.table)
        layout.addWidget(suggestion_group)

        # بخش 3: دکمه‌های عملیات
        button_box = QtWidgets.QDialogButtonBox()
        confirm_button = button_box.addButton("✔ تایید پیشنهاد و ادامه", QtWidgets.QDialogButtonBox.AcceptRole)
        manual_button = button_box.addButton("انتخاب دستی بچ...", QtWidgets.QDialogButtonBox.RejectRole)
        
        confirm_button.setProperty("class", "primary")
        confirm_button.setIcon(QtGui.QIcon.fromTheme("emblem-ok"))
        manual_button.setIcon(QtGui.QIcon.fromTheme("preferences-system"))

        button_box.accepted.connect(self.accept)
        manual_button.clicked.connect(self.request_manual_override)
        
        layout.addWidget(button_box)

    def request_manual_override(self):
        self.manual_override = True
        self.reject()
        
            
            
class StartCountDialog(QtWidgets.QDialog):
    """دیالوگی برای دریافت اطلاعات اولیه جهت شروع یک انبارگردانی جدید."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("شروع انبارگردانی جدید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.type_combo = QtWidgets.QComboBox()
        # در فاز اول فقط شمارش کامل را داریم
        self.type_combo.addItems(["شمارش کامل انبار (دوره ای)"])
        
        self.notes_edit = QtWidgets.QTextEdit()
        self.notes_edit.setPlaceholderText("اختیاری: هرگونه توضیح لازم در مورد این شمارش را اینجا بنویسید.")

        layout.addRow("نوع انبارگردانی:", self.type_combo)
        layout.addRow("یادداشت:", self.notes_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ایجاد سند و شروع")
        buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        return self.type_combo.currentText(), self.notes_edit.toPlainText()
                
# کل کلاس DeliverToWarehouseDialog را با این نسخه جایگزین کنید

class DeliverToWarehouseDialog(QtWidgets.QDialog):
    """پنجره‌ای برای انتخاب محصول تولید شده و ارسال درخواست تحویل آن به انبار."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.selected_delivery_id = None

        self.setWindowTitle("ارسال محصول تولید شده به انبار")
        self.setMinimumSize(600, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addWidget(QtWidgets.QLabel("لطفا محصولی که می‌خواهید به انبار تحویل دهید را از لیست زیر انتخاب کنید:"))

        self.products_table = QtWidgets.QTableWidget()
        self._setup_table()
        main_layout.addWidget(self.products_table, 1)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ارسال برای تایید انبار")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        main_layout.addWidget(buttons)
        
        self._load_producible_items()

    def _setup_table(self):
        self.products_table.setColumnCount(4)
        self.products_table.setHorizontalHeaderLabels(['ID', 'نام محصول', 'شماره بچ', 'مقدار تولید شده'])
        self.products_table.setColumnHidden(0, True)
        self.products_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.products_table.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.products_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.products_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _load_producible_items(self):
        items = self.db.list_producible_items()
        self.products_table.setRowCount(len(items))
        for r, item in enumerate(items):
            self.products_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.products_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['product_name']))
            self.products_table.setItem(r, 2, QtWidgets.QTableWidgetItem(item['production_batch_no']))
            self.products_table.setItem(r, 3, NumericTableWidgetItem(str(item['quantity'])))
        
        if not items:
            set_empty_placeholder(self.products_table, 'هیچ محصول جدیدی برای تحویل به انبار وجود ندارد؛ برای ثبت، از دکمه "ثبت تولید جدید" استفاده کنید.')

    def get_data(self):
        selected_rows = self.products_table.selectionModel().selectedRows()
        if not selected_rows:
            return None
        return int(self.products_table.item(selected_rows[0].row(), 0).text())
    
# کل کلاس ReportProductionDialog را با این نسخه نهایی جایگزین کنید
class ReportProductionDialog(QtWidgets.QDialog):
    """
    نسخه 6.0 (نهایی و قطعی):
    - با خواندن part_type از دیتابیس، پیشوند صحیح (R/H/P) را به تابع تولید بچ‌نامبر ارسال می‌کند.
    - قابلیت دریافت داده‌های اولیه برای پر کردن خودکار فرم را دارد.
    """
    def __init__(self, db: DB, parent=None, prefill_data=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.consumption_plans = {}
        self.prefill_data = prefill_data or {}

        self.setWindowTitle("ثبت گزارش تولید")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        main_layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout(); form_layout.setSpacing(15)

        self.recipe_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit(); self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, 1e9, 3))
        self.batch_edit = QtWidgets.QLineEdit(); self.batch_edit.setPlaceholderText("ابتدا یک فرمول انتخاب کنید...")

        form_layout.addRow("انتخاب محصول (از روی فرمول):", self.recipe_combo)
        form_layout.addRow("مقدار تولید:", self.qty_edit)
        form_layout.addRow("شماره بچ محصول:", self.batch_edit)
        main_layout.addLayout(form_layout)

        self.materials_table = QtWidgets.QTableWidget(); self.materials_table.setColumnCount(3)
        self.materials_table.setHorizontalHeaderLabels(["ماده اولیه مورد نیاز", "مقدار لازم", "وضعیت تخصیص بچ"])
        self.materials_table.verticalHeader().setDefaultSectionSize(70)
        header = self.materials_table.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        main_layout.addWidget(self.materials_table)

        self.status_label = QtWidgets.QLabel("یک فرمول و مقدار تولید را مشخص کنید.")
        main_layout.addWidget(self.status_label)

        button_layout = QtWidgets.QHBoxLayout()
        self.ok_button = QtWidgets.QPushButton("ثبت گزارش تولید"); self.ok_button.setProperty("class", "primary"); self.ok_button.setEnabled(False)
        button_layout.addStretch(); button_layout.addWidget(self.ok_button)
        main_layout.addLayout(button_layout)

        self.recipe_combo.currentIndexChanged.connect(self._on_recipe_change)
        self.qty_edit.textChanged.connect(self._update_ui_from_inputs)
        self.ok_button.clicked.connect(self._validate_and_accept)

        self._populate_recipes()

        # --- *** بخش جدید برای اعمال داده‌های پیش‌فرض *** ---
        if self.prefill_data:
            self.recipe_combo.blockSignals(True)
            self.qty_edit.blockSignals(True)

            product_name_to_select = self.prefill_data.get('product_name')
            quantity_to_set = self.prefill_data.get('quantity')

            if product_name_to_select:
                index = self.recipe_combo.findText(product_name_to_select)
                if index != -1:
                    self.recipe_combo.setCurrentIndex(index)
                    self.recipe_combo.setEnabled(False) # غیرفعال کردن برای جلوگیری از تغییر

            if quantity_to_set:
                self.qty_edit.setText(f"{quantity_to_set:.3f}")

            self.recipe_combo.blockSignals(False)
            self.qty_edit.blockSignals(False)

            # فراخوانی دستی توابع آپدیت پس از تنظیم مقادیر
            self._on_recipe_change()
            self._update_ui_from_inputs()
        # --- ****************************************** ---

    # BEGIN REWRITE: ReportProductionDialog._populate_recipes
    def _populate_recipes(self):
        """
        پر کردن کمبوی انتخاب فرمول برای «ثبت تولید»:
        - فقط فرمول‌های ACTIVE با part_type در ('A','B') را می‌آورد.
        - برچسب هر گزینه = فقط «recipe_code» (کد فرمول).
        * اگر recipe_code نبود، از نام محصول یک برچسب مینیمال می‌سازد.
        """
        import json
        from PyQt5 import QtWidgets

        self.recipe_combo.blockSignals(True)
        try:
            self.recipe_combo.clear()

            rows = self.db.execute_query(
                """
                SELECT r.id, r.product_name, r.part_type, r.properties,
                    COALESCE(pi.name, r.product_name) AS produced_name
                FROM recipes r
                LEFT JOIN items pi ON pi.id = r.produces_item_id
                WHERE r.status = 'ACTIVE' AND r.part_type IN ('A','B')
                ORDER BY produced_name ASC, r.part_type ASC, r.version DESC
                """
            ) or []

            for rec in rows:
                # خواندن کُد فرمول از properties
                code = ""
                props = rec.get('properties')
                if props:
                    try:
                        if isinstance(props, str):
                            props = json.loads(props or "{}")
                        if isinstance(props, dict):
                            code = props.get('recipe_code') or ""
                    except Exception:
                        code = ""

                # اگر کُد نبود، یک برچسب ساده از نام محصول بساز
                label = (code or (rec.get('produced_name') or rec.get('product_name') or "").strip() or f"ID#{rec.get('id')}")

                # دادهٔ پشت آیتم: کل رکورد فرمول
                self.recipe_combo.addItem(label, dict(rec))

            # اگر هیچ فرمولی نبود، یک پیام مختصر بده (بدون آیتم اضافی در کمبو)
            if self.recipe_combo.count() == 0 and hasattr(self, "status_label"):
                self.status_label.setText("هیچ فرمول فعالی برای تولید یافت نشد.")
        finally:
            self.recipe_combo.blockSignals(False)

        # پس از پر کردن، UI را آپدیت کن
        self._on_recipe_change()
    # END REWRITE: ReportProductionDialog._populate_recipes

    def _on_recipe_change(self):
        self.batch_edit.setReadOnly(False)
        self.batch_edit.clear()

        recipe_data = self.recipe_combo.currentData()
        if not isinstance(recipe_data, dict):
            self.batch_edit.setPlaceholderText("ابتدا یک فرمول انتخاب کنید...")
            self._update_ui_from_inputs()
            return

        part_type = recipe_data.get('part_type')
        part_to_prefix_map = {'A': 'R', 'B': 'H', 'P': 'P'}
        batch_prefix = part_to_prefix_map.get(part_type)

        if batch_prefix:
            try:
                next_batch_no = self.db.get_next_bulk_batch_no(batch_prefix)
                self.batch_edit.setText(next_batch_no)
                self.batch_edit.setReadOnly(True)
            except Exception as e:
                if self.toast: self.toast.show_message(f"خطا در تولید بچ نامبر: {e}", "critical")
                self.batch_edit.setPlaceholderText("خطا در تولید کد!")
        else:
            self.batch_edit.setPlaceholderText("بچ نامبر محصول را دستی وارد کنید...")
            self.batch_edit.setReadOnly(False)

        self._update_ui_from_inputs()

    # BEGIN REWRITE: ReportProductionDialog._update_ui_from_inputs
    def _update_ui_from_inputs(self):
        """
        پر کردن جدول مواد «ثبت تولید» با تحمل‌پذیری بالا:
        - نام هر ماده را این‌طور پیدا می‌کند: ing['name'] ← ing['item_name'] ← lookup با item_id
        - درصد هر ماده را امن می‌خواند (fallback به 0)
        - مقدار لازم = مقدار تولید × (درصد/100)
        - جدول را بدون خطا می‌سازد و وضعیت کلی را به‌روزرسانی می‌کند.
        """
        from PyQt5 import QtWidgets, QtCore

        # پاک‌سازی وضعیت قبلی
        self.consumption_plans.clear()
        self.materials_table.setRowCount(0)

        # ورودی‌های پایه
        recipe_data = self.recipe_combo.currentData()
        if not isinstance(recipe_data, dict):
            if hasattr(self, "status_label"):
                self.status_label.setText("یک فرمول انتخاب کنید.")
            if hasattr(self, "ok_button"):
                self.ok_button.setEnabled(False)
            return

        try:
            quantity = float(self.qty_edit.text())
            if quantity <= 0:
                if hasattr(self, "ok_button"):
                    self.ok_button.setEnabled(False)
                return
        except (ValueError, TypeError):
            if hasattr(self, "ok_button"):
                self.ok_button.setEnabled(False)
            return

        # واکشی مواد از DB
        details = self.db.get_recipe_details(recipe_data['id']) or {}
        ingredients = details.get('ingredients') or []

        # کش نام کالاها برای lookup با id
        if not hasattr(self, "_item_name_cache"):
            self._item_name_cache = {}

        def _resolve_item_id(ing: dict):
            for k in ("raw_material_item_id", "item_id", "material_item_id"):
                if k in ing and ing[k] is not None:
                    try:
                        return int(ing[k])
                    except Exception:
                        pass
            return None

        def _resolve_item_name(ing: dict) -> str:
            # 1) مستقیم از کلیدهای متعارف
            name = ing.get("name") or ing.get("item_name")
            if name:
                return str(name).strip()
            # 2) تلاش با شناسه
            iid = _resolve_item_id(ing)
            if iid:
                if iid not in self._item_name_cache:
                    row = self.db.execute_query(
                        "SELECT name FROM items WHERE id=%s LIMIT 1", (iid,), fetch_one=True
                    )
                    self._item_name_cache[iid] = (row or {}).get("name")
                cached = self._item_name_cache.get(iid)
                if cached:
                    return str(cached).strip()
                return f"(کالای #{iid})"
            # 3) آخرینFallback
            return "(نام نامشخص)"

        def _resolve_percent(ing: dict) -> float:
            for k in ("percentage", "percent", "qty_percent"):
                if k in ing and ing[k] is not None:
                    try:
                        return float(ing[k])
                    except Exception:
                        pass
            return 0.0

        # ساخت جدول
        self.materials_table.setRowCount(len(ingredients))
        for i, ing in enumerate(ingredients):
            item_name = _resolve_item_name(ing)
            percent = _resolve_percent(ing)
            needed_qty = quantity * (percent / 100.0)

            # ستون 0: نام ماده
            self.materials_table.setItem(i, 0, QtWidgets.QTableWidgetItem(item_name))
            # ستون 1: مقدار لازم
            try:
                self.materials_table.setItem(i, 1, NumericTableWidgetItem(f"{needed_qty:.3f}"))
            except Exception:
                # اگر کلاس NumericTableWidgetItem نبود، با آیتم معمولی ادامه بده
                self.materials_table.setItem(i, 1, QtWidgets.QTableWidgetItem(f"{needed_qty:.3f}"))

            # ستون 2: وضعیت تخصیص بچ + دکمه انتخاب
            status_widget = QtWidgets.QWidget()
            status_layout = QtWidgets.QHBoxLayout(status_widget)
            status_layout.setContentsMargins(0, 0, 0, 0)
            status_layout.setSpacing(6)

            status_label = QtWidgets.QLabel("❌ تخصیص نیافته")
            status_label.setStyleSheet("color: red;")

            select_btn = QtWidgets.QPushButton("انتخاب بچ‌ها...")
            select_btn.clicked.connect(lambda _, row=i: self._open_multi_batch_selector(row))

            status_layout.addWidget(status_label, 1, QtCore.Qt.AlignCenter)
            status_layout.addWidget(select_btn, 0)
            self.materials_table.setCellWidget(i, 2, status_widget)

        # به‌روزرسانی وضعیت کلی
        if hasattr(self, "_check_overall_status"):
            self._check_overall_status()
    # END REWRITE: ReportProductionDialog._update_ui_from_inputs

    def _open_multi_batch_selector(self, row):
        item_name = self.materials_table.item(row, 0).text()
        needed_qty = float(self.materials_table.item(row, 1).text())
        item_data = self.db.get_item_by_name(item_name)
        if not item_data: return
        prod_loc_id = self.db.get_production_floor_location()
        available_batches = self.db.get_available_batches_for_item(item_data['id'], prod_loc_id)
        if not available_batches: QtWidgets.QMessageBox.warning(self, "موجودی نیست", f"هیچ بچی از کالای «{item_name}» در انبار تولید یافت نشد."); return
        dialog = MultiBatchSelectionDialog(item_name, needed_qty, available_batches, self)
        if dialog.exec_():
            self.consumption_plans[item_name] = dialog.pick_plan
            status_label = self.materials_table.cellWidget(row, 2).findChild(QtWidgets.QLabel)
            status_label.setText("✔ تخصیص داده شد"); status_label.setStyleSheet("color: green; font-weight: bold;")
            self._check_overall_status()

    def _check_overall_status(self):
        all_ok = self.materials_table.rowCount() > 0
        for i in range(self.materials_table.rowCount()):
            if "❌" in self.materials_table.cellWidget(i, 2).findChild(QtWidgets.QLabel).text(): all_ok = False; break
        self.ok_button.setEnabled(all_ok)
        self.status_label.setText("آماده ثبت گزارش" if all_ok else "بچ‌های مورد نیاز برای تمام مواد اولیه باید تخصیص داده شوند.")

    def _validate_and_accept(self):
        if not self.batch_edit.text().strip(): QtWidgets.QMessageBox.warning(self, "خطای ورودی", "وارد کردن «شماره بچ محصول» اجباری است."); return
        self.accept()

    def get_data(self):
        if not self.ok_button.isEnabled(): return None
        final_plan = {name: plan_list for name, plan_list in self.consumption_plans.items()}
        recipe_data = self.recipe_combo.currentData()

        return { 
            'recipe_id': recipe_data['id'], 
            'product_name': recipe_data['product_name'], 
            'quantity': float(self.qty_edit.text()), 
            'batch_no': self.batch_edit.text().strip(), 
            'consumption_plan': final_plan 
        }
                        
                                
class AttachDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, trans_id: int, parent=None):
        super().__init__(parent)
        self.db, self.tid = db, trans_id
        self.setWindowTitle('پیوست‌ها')
        self.resize(380, 320)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        v = QtWidgets.QVBoxLayout(self)
        self.lst = QtWidgets.QListWidget(); v.addWidget(self.lst)

        btn_row = QtWidgets.QHBoxLayout(); v.addLayout(btn_row)
        # **اصلاح کلیدی:** افزودن دکمه اسکن
        btn_scan = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("scanner"), " اسکن"); btn_row.addWidget(btn_scan)
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("add"), " افزودن فایل"); btn_row.addWidget(btn_add)
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("delete"), " حذف");   btn_row.addWidget(btn_del)
        btn_row.addStretch(); btn_close = QtWidgets.QPushButton('بستن'); btn_row.addWidget(btn_close)

        self.lst.itemDoubleClicked.connect(
            lambda itm: QtGui.QDesktopServices.openUrl(
                QtCore.QUrl.fromLocalFile(itm.data(Qt.UserRole))))
        
        btn_scan.clicked.connect(self._scan_and_add)
        btn_add.clicked.connect(self._add)
        btn_del.clicked.connect(self._delete)
        btn_close.clicked.connect(self.accept)

        self._load()

    def _load(self):
        self.lst.clear()
        for rec in self.db.list_files(self.tid):
            itm = QtWidgets.QListWidgetItem(Path(rec['path']).name)
            itm.setData(Qt.UserRole, rec['path'])
            itm.setData(Qt.UserRole+1, rec['id'])
            self.lst.addItem(itm)

    def _add(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if path:
            self.db.add_file(self.tid, path); self._load()
    
    def _scan_and_add(self):
        # **متد جدید:** فراخوانی تابع اسکن و افزودن فایل
        scanned_file_path = scan_document(self)
        if scanned_file_path:
            self.db.add_file(self.tid, scanned_file_path)
            self._load()

    def _delete(self):
        itm = self.lst.currentItem()
        if not itm: return
        fid = itm.data(Qt.UserRole+1)
        if QtWidgets.QMessageBox.question(self, 'حذف', 'مطمئن؟') != QtWidgets.QMessageBox.Yes:
            return
        self.db.delete_file(fid); self._load()
        
# Add this new class to your code
class CanvasFrame(QtWidgets.QFrame):
    """A custom QFrame that correctly handles drop events for the form builder."""
    itemDropped = QtCore.pyqtSignal(str, str) # Emits the item text and its data key

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setObjectName("formCanvas")
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setStyleSheet("#formCanvas { background-color: #ffffff; border: 1px solid #dfe4ea; }")

    def dragEnterEvent(self, event: QtGui.QDragEnterEvent):
        # We accept the event if the source is a QListWidget.
        if isinstance(event.source(), QtWidgets.QListWidget):
            event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event: QtGui.QDropEvent):
        # When the item is dropped, emit a signal with the necessary data.
        source_widget = event.source()
        item_text = source_widget.currentItem().text()
        item_data_key = source_widget.currentItem().data(Qt.UserRole)
        self.itemDropped.emit(item_text, item_data_key)
        event.acceptProposedAction()
                    
            
# کلاس AdvancedFormBuilderDialog را به طور کامل با این نسخه جایگزین کنید
class AdvancedFormBuilderDialog(QtWidgets.QDialog):
    """ویرایشگر فرم پیشرفته (نسخه نهایی با فرمول‌ساز بصری و UI اصلاح شده)."""
    def __init__(self, db: DB, user_id: int, form_id=None, default_form_type='GENERAL', process_type_key=None, parent=None):
        super().__init__(parent)
        self.db = db; self.user_id = user_id; self.form_id = form_id
        self.form_data = self.db.execute_query("SELECT * FROM form_defs WHERE id = %s", (form_id,), fetch_one=True) if form_id else None
        self.selected_field_widget = None; self.toast = getattr(parent, 'toast', None)
        self.default_form_type = default_form_type
        self.process_type_key = process_type_key

        title = "ویرایشگر فرم پیشرفته" if not self.form_data else f"ویرایش فرم: {self.form_data['name']}"
        self.setWindowTitle(title); self.setMinimumSize(1200, 700)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        main_layout = QtWidgets.QHBoxLayout(self); splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal); main_layout.addWidget(splitter)
        left_panel = QtWidgets.QWidget(); left_panel.setFixedWidth(280); left_layout = QtWidgets.QVBoxLayout(left_panel)
        form_details_group = QtWidgets.QGroupBox("مشخصات کلی فرم"); form_details_layout = QtWidgets.QFormLayout(form_details_group)
        self.form_name_edit = QtWidgets.QLineEdit(self.form_data['name'] if self.form_data else ""); form_details_layout.addRow("نام فرم:", self.form_name_edit)
        left_layout.addWidget(form_details_group)
        toolbox_group = QtWidgets.QGroupBox("جعبه ابزار (بکشید و رها کنید)"); toolbox_layout = QtWidgets.QVBoxLayout(toolbox_group)
        self.toolbox = QtWidgets.QListWidget(); self.toolbox.setDragEnabled(True)
        toolbox_items = {"فیلد متنی": "text", "فیلد عددی": "number", "فیلد تاریخ": "date", "چک‌باکس": "checkbox", "لیست کشویی": "dropdown", "لیست کالاها": "item_list", "لیست کاربران": "user_list", "لیست تامین‌کنندگان": "supplier_list", "لیست واحدها (سازمانی)": "department_list"}
        for text, key in toolbox_items.items():
            item = QtWidgets.QListWidgetItem(text, self.toolbox); item.setData(Qt.UserRole, key)
        toolbox_layout.addWidget(self.toolbox); left_layout.addWidget(toolbox_group)
        canvas_panel = QtWidgets.QWidget(); canvas_layout = QtWidgets.QVBoxLayout(canvas_panel)
        self.form_canvas = CanvasFrame(); self.form_canvas.itemDropped.connect(self.canvas_drop_event) 
        self.canvas_layout = QtWidgets.QVBoxLayout(self.form_canvas); self.canvas_layout.setAlignment(Qt.AlignTop)
        scroll_area = QtWidgets.QScrollArea(); scroll_area.setWidgetResizable(True); scroll_area.setWidget(self.form_canvas)
        canvas_layout.addWidget(scroll_area)
        self.properties_panel = QtWidgets.QGroupBox("تنظیمات فیلد"); self.properties_panel.setFixedWidth(380)
        self.properties_stack = QtWidgets.QStackedWidget(self.properties_panel)
        self.prop_placeholder = QtWidgets.QLabel("برای ویرایش، یک فیلد را از بوم انتخاب کنید."); self.prop_placeholder.setAlignment(Qt.AlignCenter); self.prop_placeholder.setWordWrap(True)
        self.properties_stack.addWidget(self.prop_placeholder)
        prop_main_layout = QtWidgets.QVBoxLayout(self.properties_panel); prop_main_layout.addWidget(self.properties_stack)
        splitter.addWidget(left_panel); splitter.addWidget(canvas_panel); splitter.addWidget(self.properties_panel); splitter.setSizes([280, 520, 380])
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره نهایی فرم"); btn_save.setProperty("class", "primary"); btn_save.clicked.connect(self._save_form_definition)
        left_layout.addWidget(btn_save)
        if self.form_data and self.form_data.get('fields'): self._load_form_from_data(self.form_data['fields'])

    def _build_properties_ui(self, field_widget):
        """پنل تنظیمات را برای فیلد انتخاب شده می‌سازد (با اتصال داده گروه‌بندی‌شده‌ی بهتر)."""
        prop_widget = QtWidgets.QWidget()
        scroll_prop = QtWidgets.QScrollArea()
        scroll_prop.setWidgetResizable(True)
        scroll_prop.setWidget(prop_widget)
        scroll_prop.setStyleSheet("border:none;")

        layout = QtWidgets.QFormLayout(prop_widget)

        label_edit = QtWidgets.QLineEdit(field_widget.properties.get('label', ''))
        required_check = QtWidgets.QCheckBox()
        required_check.setChecked(bool(field_widget.properties.get('required', False)))

        # ـــــ گروه‌نام‌های دوستانه برای همهٔ گروه‌های شناخته‌شده
        GROUP_TITLES = {
            "SALES": "داده‌های فروش",
            "SALES_ITEMS": "اقلام سفارش فروش",
            "PURCHASING": "داده‌های خرید",
            "PRODUCTION": "داده‌های تولید",
            "INVENTORY": "داده‌های انبار",
            "HR": "منابع انسانی",
            "FINANCE": "مالی",
            "ENGINEERING": "فنی/مهندسی",
            "QUALITY_CONTROL": "کنترل کیفیت",
            "GENERIC": "عمومی",
        }

        # کمبو اتصال داده با گروه‌بندی
        self.data_mapping_combo = QtWidgets.QComboBox()
        model = QtGui.QStandardItemModel()
        placeholder_item = QtGui.QStandardItem("--- (بدون اتصال) ---")
        placeholder_item.setData(None, Qt.UserRole)
        model.appendRow(placeholder_item)

        for group_key, items in SYSTEM_DATA_CATALOG.items():
            group_name = GROUP_TITLES.get(group_key, group_key)
            group_header = QtGui.QStandardItem(f"— {group_name} —")
            # غیر انتخاب‌پذیر برای تیتر
            group_header.setFlags(QtCore.Qt.NoItemFlags)
            model.appendRow(group_header)

            for code, fa_label in items.items():
                it = QtGui.QStandardItem(fa_label)
                it.setData(code, Qt.UserRole)
                model.appendRow(it)

        self.data_mapping_combo.setModel(model)

        # مقدار فعلی فیلد
        current_map = field_widget.properties.get('data_map')
        if current_map:
            # تلاش برای پیدا کردن آیتم متناظر
            for i in range(model.rowCount()):
                idx = model.index(i, 0)
                if model.itemFromIndex(idx).data(Qt.UserRole) == current_map:
                    self.data_mapping_combo.setCurrentIndex(i)
                    break

        # رویداد تغییر
        def on_data_map_changed(idx):
            value = self.data_mapping_combo.model().item(idx).data(Qt.UserRole)
            # ذخیره None برای «بدون اتصال»
            field_widget.properties['data_map'] = value if value else None

        self.data_mapping_combo.currentIndexChanged.connect(on_data_map_changed)

        # فیلدهای خاص هر تایپ
        layout.addRow("برچسب نمایشی:", label_edit)
        layout.addRow("اجباری؟", required_check)
        layout.addRow("اتصال به دادهٔ سیستمی:", self.data_mapping_combo)

        # تایپ خاص: محدوده عدد/طول و ... (مانند نسخه قبل)
        if field_widget.properties.get('type') == 'number':
            min_edit = QtWidgets.QLineEdit(str(field_widget.properties.get('min', '')))
            max_edit = QtWidgets.QLineEdit(str(field_widget.properties.get('max', '')))
            min_edit.textChanged.connect(lambda v, w=field_widget: self._update_property(w, 'min', v))
            max_edit.textChanged.connect(lambda v, w=field_widget: self._update_property(w, 'max', v))
            layout.addRow("حداقل مقدار:", min_edit)
            layout.addRow("حداکثر مقدار:", max_edit)

        if field_widget.properties.get('type') == 'text':
            minlen_edit = QtWidgets.QLineEdit(str(field_widget.properties.get('min_length', '')))
            maxlen_edit = QtWidgets.QLineEdit(str(field_widget.properties.get('max_length', '')))
            minlen_edit.textChanged.connect(lambda v, w=field_widget: self._update_property(w, 'min_length', v))
            maxlen_edit.textChanged.connect(lambda v, w=field_widget: self._update_property(w, 'max_length', v))
            layout.addRow("حداقل طول:", minlen_edit)
            layout.addRow("حداکثر طول:", maxlen_edit)

        if field_widget.properties.get('type') == 'dropdown':
            options_edit = QtWidgets.QPlainTextEdit("\n".join(field_widget.properties.get('options', [])))
            options_edit.textChanged.connect(lambda: self._update_property(field_widget, 'options', options_edit.toPlainText().splitlines()))
            layout.addRow("گزینه‌ها (هر خط یک مورد):", options_edit)

        if field_widget.properties.get('type') == 'item_list':
            category_combo = QtWidgets.QComboBox()
            category_combo.addItem("همه دسته‌بندی‌ها", None)
            categories = self.db.get_distinct_item_categories()
            for cat in categories:
                category_combo.addItem(cat, cat)
            current_filter = field_widget.properties.get('category_filter')
            if current_filter:
                category_combo.setCurrentText(current_filter)
            category_combo.currentTextChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'category_filter', txt if txt != "همه دسته‌بندی‌ها" else None))
            layout.addRow("فیلتر دسته‌بندی کالا:", category_combo)

        # منطق شرطی
        layout.addRow(QtWidgets.QLabel("---"))
        btn_logic = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-sort-descending"), "مدیریت منطق شرطی نمایش")
        btn_logic.clicked.connect(lambda: self._open_conditional_logic_editor(field_widget))
        layout.addRow(btn_logic)

        # حذف فیلد
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف این فیلد")
        btn_delete.setProperty("class", "danger")
        btn_delete.clicked.connect(self._delete_selected_field)
        layout.addRow(btn_delete)

        # سویچ پنل
        current_prop_widget = self.properties_stack.currentWidget()
        if current_prop_widget != self.prop_placeholder:
            self.properties_stack.removeWidget(current_prop_widget)
            current_prop_widget.deleteLater()
        self.properties_stack.addWidget(scroll_prop)
        self.properties_stack.setCurrentWidget(scroll_prop)

        # رویدادهای عمومی
        label_edit.textChanged.connect(lambda v, w=field_widget: self._update_property(w, 'label', v))
        required_check.stateChanged.connect(lambda s, w=field_widget: self._update_property(w, 'required', s == QtCore.Qt.Checked))
                                            
    
    def canvas_drop_event(self, field_type_text, field_type_key):
        field_id = f"field_{int(time.time() * 1000)}"
        new_widget = FormFieldWidget(field_id, field_type_text, field_type_key, "برچسب جدید")
        new_widget.selected.connect(self._on_field_selected)
        self.canvas_layout.addWidget(new_widget)
        new_widget.selected.emit(new_widget)

    def _on_field_selected(self, field_widget):
        if self.selected_field_widget: self.selected_field_widget.set_selected(False)
        self.selected_field_widget = field_widget
        if self.selected_field_widget:
            self.selected_field_widget.set_selected(True)
            self._build_properties_ui(field_widget)
            
    def _delete_selected_field(self):
        """فیلد انتخاب شده فعلی را از بوم طراحی حذف می‌کند."""
        if self.selected_field_widget:
            reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف فیلد «{self.selected_field_widget.properties['label']}» مطمئنید؟")
            if reply == QtWidgets.QMessageBox.Yes:
                self.selected_field_widget.deleteLater()
                self.selected_field_widget = None
                self.properties_stack.setCurrentWidget(self.prop_placeholder)

# در کلاس AdvancedFormBuilderDialog، این متد را به طور کامل جایگزین کنید

                        
        
# در کلاس AdvancedFormBuilderDialog، این متد را به طور کامل جایگزین کنید

    def _open_conditional_logic_editor(self, field_widget):
        all_fields = []
        for i in range(self.canvas_layout.count()):
            widget = self.canvas_layout.itemAt(i).widget()
            if isinstance(widget, FormFieldWidget):
                # فقط فیلدهایی که از نوع checkbox, dropdown, یا text هستند می‌توانند محرک باشند
                if widget.properties['type'] in ['checkbox', 'dropdown', 'text', 'number']:
                    all_fields.append({'id': widget.field_id, 'label': widget.properties['label'], 'type': widget.properties['type']})
        
        existing_logic = field_widget.properties.get('conditional_logic')
        
        # --- *** اصلاح کلیدی: فراخوانی با آرگومان‌های صحیح و بدون موارد اضافه *** ---
        dlg = ConditionalLogicDialog(
            all_fields=all_fields, 
            current_field_id=field_widget.field_id, 
            existing_logic=existing_logic, 
            parent=self
        )
        
        if dlg.exec_():
            logic_data = dlg.get_data()
            self._update_property(field_widget, 'conditional_logic', logic_data)
            if self.toast:
                if logic_data: 
                    self.toast.show_message("✔ منطق شرطی برای فیلد ذخیره شد.", "success")
                else: 
                    self.toast.show_message("منطق شرطی حذف شد.", "info")
                    
                    
    def _update_property(self, widget, key, value):
        if key in ['min', 'max']:
            try: value = float(value) if value else None
            except (ValueError, TypeError): value = None
        elif key in ['min_length', 'max_length']:
            try: value = int(value) if value else None
            except (ValueError, TypeError): value = None
            
        widget.properties[key] = value
        widget.update_display()

    def _load_form_from_data(self, fields_json):
        if isinstance(fields_json, str):
            try: fields_json = json.loads(fields_json)
            except json.JSONDecodeError: return

        if not isinstance(fields_json, list) or not fields_json: return
        
        is_new_format = isinstance(fields_json[0], dict)
        
        type_map_reverse = {
            "text": "فیلد متنی", "number": "فیلد عددی", "date": "فیلد تاریخ", "checkbox": "چک‌باکس",
            "dropdown": "لیست کشویی", "item_list": "لیست کالاها", "user_list": "لیست کاربران",
            "supplier_list": "لیست تامین‌کنندگان", "department_list": "لیست واحدها (سازمانی)"
        }

        for i, field_data in enumerate(fields_json):
            if is_new_format:
                field_id = field_data.get('id', f"new_field_{i}"); field_label = field_data.get('label', 'بدون برچسب')
                field_type_key = field_data.get('type', 'text'); properties = field_data
            else:
                field_id = f"legacy_field_{i}"; field_label = field_data[0]; field_type_key = field_data[1]
                properties = {'type': field_type_key, 'label': field_label, 'required': False}

            field_type_text = type_map_reverse.get(field_type_key, "فیلد متنی")
            
            widget = FormFieldWidget(field_id, field_type_text, field_type_key, field_label)
            widget.properties = properties
            widget.update_display()
            widget.selected.connect(self._on_field_selected)
            self.canvas_layout.addWidget(widget)
    
    def _save_form_definition(self):
        form_name = self.form_name_edit.text().strip()
        if not form_name:
            QtWidgets.QMessageBox.warning(self, "Error", "نام فرم نمی‌تواند خالی باشد.")
            return

        if self.db.form_name_exists(form_name, self.user_id, exclude_form_id=self.form_id):
            QtWidgets.QMessageBox.warning(self, "نام تکراری", f"شما قبلاً فرمی با نام «{form_name}» ایجاد کرده‌اید. لطفاً نام دیگری انتخاب کنید.")
            return

        final_fields_json = []
        for i in range(self.canvas_layout.count()):
            widget = self.canvas_layout.itemAt(i).widget()
            if isinstance(widget, FormFieldWidget):
                final_fields_json.append(widget.get_data_for_json())
        
        form_type = self.form_data.get('form_type') if self.form_data else self.default_form_type
        form_data_dict = {
            'id': self.form_id,
            'name': form_name,
            'type': form_type,
            'fields': final_fields_json
        }

        try:
            self.db.save_advanced_form_def(form_data_dict, self.user_id)
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"خطا در هنگام ذخیره فرم:\n{e}")
            
                                    
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید

class LoginDialog(QtWidgets.QDialog):
    def __init__(self, db: DB):
        super().__init__()
        self.db = db
        self.user_info = None
        self.prefs_path = BASE_DIR / 'user_prefs.json'
        
        self.setWindowTitle('ورود')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        form = QtWidgets.QFormLayout(self)
        self.e_user = QtWidgets.QLineEdit()
        self.e_pass = QtWidgets.QLineEdit(); self.e_pass.setEchoMode(self.e_pass.Password)
        
        # --- *** بخش جدید: چک‌باکس "مرا به خاطر بسپار" *** ---
        self.remember_me_check = QtWidgets.QCheckBox("مرا به خاطر بسپار")
        
        form.addRow('نام کاربری', self.e_user)
        form.addRow('کلمه عبور', self.e_pass)
        form.addRow('', self.remember_me_check)
        
        btn = QtWidgets.QPushButton('ورود')
        form.addRow(btn)
        btn.clicked.connect(self._login)
        
        self._load_preferences()

    def _load_preferences(self):
        """اگر نام کاربری ذخیره شده بود، آن را در فیلد مربوطه قرار می‌دهد."""
        try:
            if self.prefs_path.exists():
                with open(self.prefs_path, 'r', encoding='utf-8') as f:
                    prefs = json.load(f)
                    saved_user = prefs.get('saved_username')
                    if saved_user:
                        self.e_user.setText(saved_user)
                        self.remember_me_check.setChecked(True)
                        self.e_pass.setFocus() # فوکوس را به فیلد رمز عبور منتقل می‌کند
        except Exception as e:
            print(f"Could not load user preferences: {e}")

    def _save_preferences(self):
        """نام کاربری را در صورت انتخاب، در فایل تنظیمات ذخیره یا حذف می‌کند."""
        try:
            if self.remember_me_check.isChecked():
                prefs = {'saved_username': self.e_user.text().strip()}
                with open(self.prefs_path, 'w', encoding='utf-8') as f:
                    json.dump(prefs, f)
            elif self.prefs_path.exists():
                # اگر تیک برداشته شده بود، فایل را حذف می‌کنیم
                os.remove(self.prefs_path)
        except Exception as e:
            print(f"Could not save user preferences: {e}")

    def _login(self):
        self.user_info = self.db.verify(self.e_user.text().strip(), self.e_pass.text())
        if self.user_info:
            self._save_preferences() # ذخیره تنظیمات پس از ورود موفق
            self.accept()
        else:
            QtWidgets.QMessageBox.warning(self, 'خطا', 'نام کاربری یا رمز اشتباه است')
                        

# کلاس Toast نسخه 3.1 (Final Polish)

class Toast(QtWidgets.QFrame):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowFlags(QtCore.Qt.ToolTip | QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
        self.setAttribute(QtCore.Qt.WA_StyledBackground, True)

        shadow = QtWidgets.QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(30); shadow.setOffset(4, 4)
        shadow.setColor(QtGui.QColor(0, 0, 0, 40))
        self.setGraphicsEffect(shadow)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.indicator_bar = QtWidgets.QFrame()
        self.indicator_bar.setFixedWidth(6)
        
        self.container_widget = QtWidgets.QFrame()
        self.container_widget.setObjectName("toastContainer")

        main_layout.addWidget(self.container_widget, 1)
        main_layout.addWidget(self.indicator_bar)

        # --- چیدمان اصلی داخلی ---
        container_main_layout = QtWidgets.QVBoxLayout(self.container_widget)
        container_main_layout.setContentsMargins(15, 10, 20, 15)
        container_main_layout.setSpacing(8)

        # --- چیدمان ردیف بالا (هدر) شامل عنوان و دکمه بستن ---
        header_layout = QtWidgets.QHBoxLayout()
        header_layout.setContentsMargins(0, 0, 0, 0)
        
        self.title_label = QtWidgets.QLabel()
        self.title_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        
        self.close_button = QtWidgets.QPushButton("×")
        self.close_button.setFixedSize(22, 22)
        self.close_button.setCursor(Qt.PointingHandCursor)
        self.close_button.clicked.connect(self.hide_animated)

        header_layout.addWidget(self.title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.close_button)
        
        # --- لیبل آیکون و متن اصلی ---
        body_layout = QtWidgets.QHBoxLayout(); body_layout.setSpacing(15)
        self.icon_label = QtWidgets.QLabel()
        self.icon_label.setFixedSize(28, 28)

        self.message_label = QtWidgets.QLabel()
        self.message_label.setFont(QFont(FONT_FAMILY, 10))
        self.message_label.setWordWrap(True)
        
        body_layout.addWidget(self.icon_label, 0, QtCore.Qt.AlignTop)
        body_layout.addWidget(self.message_label, 1)

        container_main_layout.addLayout(header_layout)
        container_main_layout.addLayout(body_layout)
        
        # --- انیمیشن‌ها و تایمر ---
        self.pos_animation = QtCore.QPropertyAnimation(self, b"pos")
        self.opacity_animation = QtCore.QPropertyAnimation(self, b"windowOpacity")
        
        self.show_animation = QtCore.QParallelAnimationGroup(self)
        self.show_animation.addAnimation(self.pos_animation)
        self.show_animation.addAnimation(self.opacity_animation)
        
        self.hide_timer = QtCore.QTimer(self)
        self.hide_timer.setSingleShot(True)
        self.hide_timer.timeout.connect(self.hide_animated)
        
        self.hide()

    def show_message(self, text: str, level: str = 'info', msec: int = 8000):
        if not self.parent(): return
        
        style_map = {
            'info':     ("اطلاع", "dialog-information", "#eaf2f8", "#3498db"),
            'success':  ("موفقیت", "emblem-ok", "#e8f8f5", "#27ae60"),
            'warning':  ("هشدار", "dialog-warning", "#fef9e7", "#f39c12"),
            'critical': ("خطا", "dialog-error", "#fdedec", "#c0392b"),
        }
        title, icon_name, bg_color, bar_color = style_map.get(level, style_map['info'])
        
        self.title_label.setText(title)
        self.message_label.setText(text)
        self.icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(28, 28))
        
        self.indicator_bar.setStyleSheet(f"background-color: {bar_color}; border-top-right-radius: 5px; border-bottom-right-radius: 5px;")
        self.container_widget.setStyleSheet(f"""
            #toastContainer {{ background-color: {bg_color}; border-top-left-radius: 5px; border-bottom-left-radius: 5px; }}
            QLabel {{ background: transparent; color: #2c3e50; }}
        """)
        self.close_button.setStyleSheet("""
            QPushButton {
                background-color: #0000001A; color: #555; border: none;
                border-radius: 11px; font-size: 14pt;
            }
            QPushButton:hover { background-color: #00000033; }
        """)

        # --- اصلاح نهایی ابعاد ---
        self.message_label.setMaximumWidth(550)
        self.adjustSize()

        parent_geo = self.parent().geometry()
        top_margin = 45
        final_pos = QtCore.QPoint(parent_geo.width() - self.width() - 25, top_margin)
        start_pos = QtCore.QPoint(final_pos.x(), top_margin - 20)
        
        self.move(final_pos.x(), 0)
        self.setWindowOpacity(0.0)
        self.show()

        pos_anim_show = QtCore.QPropertyAnimation(self, b"pos", self)
        pos_anim_show.setStartValue(start_pos); pos_anim_show.setEndValue(final_pos)
        pos_anim_show.setEasingCurve(QtCore.QEasingCurve.OutCubic); pos_anim_show.setDuration(350)

        opacity_anim_show = QtCore.QPropertyAnimation(self, b"windowOpacity", self)
        opacity_anim_show.setStartValue(0.0); opacity_anim_show.setEndValue(1.0)
        opacity_anim_show.setDuration(300)
        
        self.show_animation.clear()
        self.show_animation.addAnimation(pos_anim_show)
        self.show_animation.addAnimation(opacity_anim_show)
        self.show_animation.start()
        
        self.hide_timer.start(msec)

    def hide_animated(self):
        self.show_animation.stop()
        self.hide_timer.stop()
        
        anim = QtCore.QPropertyAnimation(self, b"windowOpacity", self)
        anim.setStartValue(self.windowOpacity()); anim.setEndValue(0.0)
        anim.setDuration(300)
        anim.finished.connect(self.hide)
        anim.start()        
                                                                                                                                        
class Splash(QtWidgets.QSplashScreen):
    def __init__(self):
        pix = QtGui.QPixmap(240, 160)
        pix.fill(Qt.transparent)

        p = QtGui.QPainter(pix); p.setRenderHint(p.Antialiasing)
        p.setBrush(QtGui.QColor('#283593'))
        p.drawRoundedRect(0, 0, 240, 160, 20, 20)
        p.setPen(Qt.white)
        p.setFont(QFont('B Titr', 28, QFont.Bold))      # ← فونت تیتر فارسی
        p.drawText(pix.rect(), Qt.AlignCenter, "MEGATITE")
        p.end()

        super().__init__(pix)
        self.show(); QtWidgets.qApp.processEvents()

# ────────────────── Toolbar ساز ────────────────────

# ────────────────── KPI Label ساز ──────────────────
def kpi_label(color: str, text: str) -> QtWidgets.QLabel:
    lbl = QtWidgets.QLabel(text, alignment=Qt.AlignCenter)
    lbl.setStyleSheet(f"background:{color};color:#fff;padding:8px;border-radius:6px;font-weight:bold;")
    return lbl

# این تابع را با نسخه جدید و هوشمند زیر جایگزین کنید

# BEGIN REWRITE: set_empty_placeholder
def set_empty_placeholder(widget: QtWidgets.QWidget, text: str):
    """
    پیام «لیست خالی» را فقط وقتی واقعاً لیست خالی است نشان می‌دهد.
    - روی QTableWidget/QTreeWidget کار می‌کند.
    - اگر قبل از پرشدن ویجت صدا زده شود، با یک Singleshot کوتاه دوباره بررسی می‌کند و در صورت پر شدن، خودش مخفی می‌شود.
    - روی کلیک‌ها اثر نمی‌گذارد (TransparentForMouseEvents).
    """
    from PyQt5.QtCore import Qt, QTimer

    # 1) شمارش آیتم‌ها بسته به نوع ویجت
    def _count_items(w):
        try:
            if isinstance(w, QtWidgets.QTableWidget):
                return w.rowCount()
            elif isinstance(w, QtWidgets.QTreeWidget):
                return w.topLevelItemCount()
        except Exception:
            pass
        return 0

    count = _count_items(widget)

    # 2) اگر آیتم داریم → هر لیبل قبلی را مخفی کن و برگرد
    if count > 0:
        if hasattr(widget, '_empty_lbl') and widget._empty_lbl is not None:
            try:
                widget._empty_lbl.hide()
            except Exception:
                pass
        return

    # 3) ساخت/به‌روزرسانی لیبل روی viewport (نه خود ویجت)
    parent = widget.viewport() if hasattr(widget, 'viewport') else widget
    if not hasattr(widget, '_empty_lbl') or widget._empty_lbl is None or widget._empty_lbl.parent() is not parent:
        lbl = QtWidgets.QLabel(text, parent)
        lbl.setAlignment(Qt.AlignCenter)
        lbl.setStyleSheet("color:#9e9e9e; font-style:italic; background-color: transparent;")
        lbl.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        widget._empty_lbl = lbl
    else:
        widget._empty_lbl.setText(text)

    # اندازه و نمایش
    try:
        widget._empty_lbl.setGeometry(parent.rect())
    except Exception:
        try:
            widget._empty_lbl.resize(parent.size())
        except Exception:
            pass
    widget._empty_lbl.show()

    # 4) بازبررسی در چرخهٔ بعدی رویدادها؛ اگر در این فاصله آیتم اضافه شد، لیبل پنهان می‌شود
    def _recheck():
        if _count_items(widget) > 0 and hasattr(widget, '_empty_lbl') and widget._empty_lbl is not None:
            try:
                widget._empty_lbl.hide()
            except Exception:
                pass
    QTimer.singleShot(0, _recheck)
# END REWRITE: set_empty_placeholder
    

# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید

class PinnedTable(QtWidgets.QTableWidget):
    """آخرین تراکنش‌ها با قابلیت نمایش موارد جدید پس از پاکسازی"""
    def __init__(self, db: DB, limit=15):
        super().__init__(0, 5)
        self.db, self.limit = db, limit
        
        self.setHorizontalHeaderLabels(['ID', 'کالا', 'نوع', 'مقدار', 'تاریخ'])
        self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.setAlternatingRowColors(True)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.verticalHeader().hide()
        self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers) # دابل کلیک غیرفعال است

    def refresh(self, since_id: int = 0):
        self.setRowCount(0)
        query = """
            SELECT t.id, i.name, t.t_type, t.qty, t.t_date
            FROM trans t JOIN items i ON t.item_id=i.id
            WHERE t.id > %s
            ORDER BY t.id DESC LIMIT %s
        """
        rows = self.db.execute_query(query, (since_id, self.limit))
        self.setRowCount(len(rows))
        
        for r, row_data in enumerate(rows):
            values = (
                row_data['id'], row_data['name'], row_data['t_type'],
                row_data['qty'], to_shamsi(row_data['t_date'])
            )
            for c, val in enumerate(values):
                item = QtWidgets.QTableWidgetItem(str(val))
                if c in [0, 3]: item.setTextAlignment(Qt.AlignCenter)
                else: item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                self.setItem(r, c, item)
        self.setColumnHidden(0, True)        
                
        
class ItemDialog(QtWidgets.QDialog):
    """
    نسخه 7.2 (یکپارچه‌سازی دسته‌بندی):
    - لیست دسته‌بندی‌ها در فرم با تب‌های صفحه اصلی هماهنگ شد.
    """
    # در کلاس ItemDialog، متد __init__ را جایگزین کنید

    def __init__(self, db: DB, user_id: int, role: str, item_id=None, parent_id=None, parent_name=None):
        super().__init__()
        self.db, self.user_id, self.role, self.item_id = db, user_id, role, item_id
        self.parent_id = parent_id

        # ── بارگذاری آیتم در حالت ویرایش
        self.item_data = self.db.get_item_details(self.item_id) if self.item_id else {}

        # ── عنوان پنجره بر اساس حالت
        if self.parent_id:
            # اگر نام مادر پاس داده نشده بود، از دیتابیس بیار
            if not parent_name:
                p = self.db.get_item_details(self.parent_id) or {}
                parent_name = p.get('name') or ''
            title = f"افزودن پک جدید برای: {parent_name}"
        else:
            title = ('افزودن کالا' if not self.item_id else f"ویرایش: {self.item_data.get('name')}")
        self.setWindowTitle(title)

        # ── اسکلت کلی UI
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 850)
        main_lay = QtWidgets.QVBoxLayout(self)
        self.tabs = QtWidgets.QTabWidget()
        main_lay.addWidget(self.tabs)

        # ── تب «مشخصات اصلی»
        props_page = QtWidgets.QWidget()
        self.form = QtWidgets.QFormLayout(props_page); self.form.setSpacing(10)
        self.tabs.addTab(props_page, "مشخصات اصلی کالا")

        self.e_name = QtWidgets.QLineEdit()
        self.e_sku  = QtWidgets.QLineEdit()

        self.c_cat = QtWidgets.QComboBox()
        # توجه: این مقادیر از قبل به‌صورت رشته‌های دسته‌ها تعریف شده‌اند
        self.c_cat.addItems([
            CATEGORY_RAW_MATERIAL, CATEGORY_FINAL_PRODUCT, CATEGORY_PACKAGING, CATEGORY_CONSUMABLES, 'محصول فله'
        ])

        self.c_unit = QtWidgets.QComboBox()
        self.populate_units_combo()

        self.e_net_weight = QtWidgets.QDoubleSpinBox()
        self.e_net_weight.setRange(0, 10000)
        self.e_net_weight.setDecimals(3)
        self.e_net_weight.setSuffix(" Kg")
        self.net_weight_label = QtWidgets.QLabel("وزن خالص (برای پک‌ها):")

        self.e_supp = QtWidgets.QLineEdit()
        self.e_note = QtWidgets.QTextEdit(); self.e_note.setFixedHeight(60)

        self.e_cost = QtWidgets.QDoubleSpinBox()
        self.e_cost.setRange(0, 1e12); self.e_cost.setDecimals(0); self.e_cost.setGroupSeparatorShown(True)

        self.e_min  = QtWidgets.QDoubleSpinBox(); self.e_min.setRange(0, 1e9); self.e_min.setDecimals(3)
        self.e_max  = QtWidgets.QDoubleSpinBox(); self.e_max.setRange(0, 1e9); self.e_max.setDecimals(3)

        self.is_parent_check = QtWidgets.QCheckBox("این یک محصول مادر است (برای تعریف بسته‌بندی‌های مختلف)")
        self.is_two_component_check = QtWidgets.QCheckBox("این محصول دوجزئی است (نیازمند پارت A و B)")
        self.is_two_component_check.setChecked(True)

        # QC
        self.requires_qc_check = QtWidgets.QCheckBox("این کالا هنگام ورود نیازمند بازرسی QC است")
        self.requires_qc_check.setChecked(True)

        # چیدمان فرم مشخصات
        self.form.addRow("نام کالا (*):", self.e_name)
        self.form.addRow("شناسه کالا (SKU):", self.e_sku)
        self.form.addRow("دسته:", self.c_cat)
        self.form.addRow("واحد شمارش (*):", self.c_unit)
        self.form.addRow(self.net_weight_label, self.e_net_weight)

        self.cost_label = QtWidgets.QLabel("ارزش واحد (ریال):")
        self.form.addRow(self.cost_label, self.e_cost)

        min_max_layout = QtWidgets.QHBoxLayout()
        min_max_layout.addWidget(QtWidgets.QLabel("حداقل موجودی:"));   min_max_layout.addWidget(self.e_min)
        min_max_layout.addSpacing(20)
        min_max_layout.addWidget(QtWidgets.QLabel("حداکثر موجودی:"));  min_max_layout.addWidget(self.e_max)
        self.form.addRow(min_max_layout)

        self.form.addRow("تأمین‌کننده:", self.e_supp)
        self.form.addRow("توضیحات:", self.e_note)

        self.form.addRow(self.is_parent_check)
        self.form.addRow(self.is_two_component_check)
        self.form.addRow(self.requires_qc_check)

        if self.role not in ['Admin', 'Finance']:
            self.cost_label.hide(); self.e_cost.hide()

        # ── تب «بسته‌بندی‌ها»
        self.packaging_page = QtWidgets.QWidget()
        packaging_layout = QtWidgets.QVBoxLayout(self.packaging_page)
        packaging_layout.addWidget(QtWidgets.QLabel("لیست پک‌های تعریف شده برای این محصول:"))

        self.tbl_child_items = QtWidgets.QTableWidget(0, 4)
        self.tbl_child_items.setHorizontalHeaderLabels(["ID", "SKU", "نام پک", "واحد"])
        self.tbl_child_items.setColumnHidden(0, True)
        self.tbl_child_items.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_child_items.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.tbl_child_items.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        packaging_layout.addWidget(self.tbl_child_items)

        pack_btn_layout = QtWidgets.QHBoxLayout()
        btn_add_pack  = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "تعریف پک جدید")
        btn_edit_pack = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), "ویرایش پک انتخابی")
        self.btn_manage_bom = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-properties"), "مدیریت لوازم این پک")
        self.btn_manage_bom.setEnabled(False)

        pack_btn_layout.addWidget(btn_add_pack); pack_btn_layout.addWidget(btn_edit_pack)
        pack_btn_layout.addStretch(); pack_btn_layout.addWidget(self.btn_manage_bom)
        packaging_layout.addLayout(pack_btn_layout)

        self.tabs.addTab(self.packaging_page, "بسته‌بندی‌ها (SKU)")

        # ── گروه «موجودی اولیه»
        self.stock_group = QtWidgets.QGroupBox("ثبت موجودی اولیه (فقط برای کالای جدید)")
        main_lay.addWidget(self.stock_group, 1)

        stock_layout = QtWidgets.QVBoxLayout(self.stock_group)
        self.stock_table = QtWidgets.QTableWidget(0, 4)
        self.stock_table.setHorizontalHeaderLabels(["لوکیشن", "شماره بچ", "تاریخ انقضا", "مقدار"])
        self.stock_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.stock_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        stock_layout.addWidget(self.stock_table)

        stock_btn_layout = QtWidgets.QHBoxLayout()
        btn_add_stock    = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن ردیف موجودی")
        btn_remove_stock = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف ردیف انتخاب شده")
        stock_btn_layout.addWidget(btn_add_stock); stock_btn_layout.addWidget(btn_remove_stock)
        stock_btn_layout.addStretch(); stock_layout.addLayout(stock_btn_layout)

        # ── دکمه‌های پایین
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Save | QtWidgets.QDialogButtonBox.Cancel)
        self.save_button = buttons.button(QtWidgets.QDialogButtonBox.Save)
        self.save_button.setText("ذخیره مشخصات کالا")
        buttons.accepted.connect(self._save_main_item)
        buttons.rejected.connect(self.reject)
        main_lay.addWidget(buttons)

        # ── اتصال‌ها
        self.e_name.textChanged.connect(self._update_save_button_state)
        self.c_unit.currentIndexChanged.connect(self._update_save_button_state)
        self.is_parent_check.toggled.connect(self._update_save_button_state)

        self.is_parent_check.toggled.connect(self._update_field_visibility)
        self.c_cat.currentIndexChanged.connect(self._update_field_visibility)

        self.tbl_child_items.itemSelectionChanged.connect(lambda: self.btn_manage_bom.setEnabled(True))
        self.btn_manage_bom.clicked.connect(self._open_packaging_bom_editor)
        btn_add_pack.clicked.connect(self._add_child_item)
        btn_edit_pack.clicked.connect(self._edit_child_item)
        btn_add_stock.clicked.connect(self._add_stock_row)
        btn_remove_stock.clicked.connect(self._remove_stock_row)

        # ─────────────────────────────────────────────────────────────
        # 🧠 قوانین حالت‌ها (کلیدِ رفع باگ A): یک تابع داخلی و رویدادها
        # این تابع را روی self می‌نشانیم تا جاهای دیگر هم در صورت نیاز بتوانند صدا بزنند.
        def _apply_item_type_rules():
            """
            حالت‌ها:
            - فرزند: parent_id موجود یا آیتم در حال ویرایش parent_item_id دارد.
            - مادر: تیک مادر خورده و فرزند نیست.
            - معمولی: نه فرزند، نه مادر.
            """
            # تشخیص فرزند حتی در حالت ویرایش
            is_child_mode = bool(self.parent_id) or bool(self.item_data.get('parent_item_id')) if self.item_id else bool(self.parent_id)
            is_parent_checked = self.is_parent_check.isChecked()

            # ارث دو‌جزئی از مادر در حالت فرزند
            parent_two_comp = False
            if is_child_mode:
                pid = self.parent_id or self.item_data.get('parent_item_id')
                p = self.db.get_item_details(pid) if pid else {}
                parent_two_comp = bool(p.get('is_two_component', False))
                # قفل تیک مادر و دو‌جزئی
                self.is_parent_check.blockSignals(True)
                self.is_parent_check.setChecked(False)
                self.is_parent_check.setEnabled(False)
                self.is_parent_check.blockSignals(False)

                self.is_two_component_check.blockSignals(True)
                self.is_two_component_check.setChecked(parent_two_comp)
                self.is_two_component_check.setEnabled(False)
                self.is_two_component_check.blockSignals(False)

                # دسته = محصول نهایی و قفل
                idx = self.c_cat.findText(CATEGORY_FINAL_PRODUCT)
                if idx >= 0:
                    self.c_cat.setCurrentIndex(idx)
                self.c_cat.setEnabled(False)

                # واحد و موجودی اولیه برای فرزند فعال
                self.c_unit.setEnabled(True)
                self.stock_group.setEnabled(True)

                # تب بسته‌بندی برای فرزند بی‌معناست
                i_tab = self.tabs.indexOf(self.packaging_page)
                if i_tab != -1:
                    self.tabs.setTabEnabled(i_tab, False)

                # وزن خالص برای پک نمایش داده شود
                self.net_weight_label.setVisible(True); self.e_net_weight.setVisible(True)

            else:
                # حالت مادر یا معمولی
                # وزن خالص: فقط اگر «محصول نهایی» و مادر نیست
                is_final_cat = (self.c_cat.currentText() == CATEGORY_FINAL_PRODUCT)

                if is_parent_checked:
                    # مادر
                    self.is_parent_check.setEnabled(True)
                    self.is_two_component_check.setEnabled(True)   # مادر مجاز است دو‌جزئی باشد
                    self.c_unit.setEnabled(False)                  # مادر واحد عملیاتی ندارد
                    # موجودی اولیه برای مادر بی‌معنا
                    self.stock_group.setEnabled(False)

                    # تب بسته‌بندی‌ها فقط وقتی فعال که آیتم قبلاً ذخیره شده (ویرایش)
                    i_tab = self.tabs.indexOf(self.packaging_page)
                    if i_tab != -1:
                        self.tabs.setTabEnabled(i_tab, bool(self.item_id))

                    # وزن خالص برای مادر پنهان
                    self.net_weight_label.setVisible(False); self.e_net_weight.setVisible(False)
                else:
                    # معمولی
                    self.is_parent_check.setEnabled(True)
                    # دو‌جزئی فقط برای مادر ⇒ اینجا قفل و خاموش
                    self.is_two_component_check.blockSignals(True)
                    self.is_two_component_check.setChecked(False)
                    self.is_two_component_check.setEnabled(False)
                    self.is_two_component_check.blockSignals(False)

                    self.c_unit.setEnabled(True)
                    # موجودی اولیه فقط در حالت «آیتم جدید» فعال
                    self.stock_group.setEnabled(self.item_id is None)

                    # تب بسته‌بندی‌ها بی‌معنا
                    i_tab = self.tabs.indexOf(self.packaging_page)
                    if i_tab != -1:
                        self.tabs.setTabEnabled(i_tab, False)

                    # وزن خالص: اگر خودش «محصول نهایی» است، نمایش بده
                    self.net_weight_label.setVisible(is_final_cat)
                    self.e_net_weight.setVisible(is_final_cat)

        # متد را روی self ست می‌کنیم تا بیرون از این اسکوپ هم قابل فراخوانی باشد
        self._apply_item_type_rules = _apply_item_type_rules

        # هر تغییری که روی حالت تأثیر دارد، این قوانین را دوباره اعمال کند
        self.is_parent_check.toggled.connect(self._apply_item_type_rules)
        self.c_cat.currentIndexChanged.connect(self._apply_item_type_rules)

        # ── بارگذاری اولیهٔ محتوا و سپس اعمال قوانین حالت‌ها
        if self.item_id:
            self._load_data_for_edit()
        elif self.parent_id:
            self._setup_for_new_child()
        else:
            self._update_field_visibility()

        # حتماً پس از بارگذاری اولیه، قوانین را اعمال کن
        self._apply_item_type_rules()
        self._update_save_button_state()
        
    # داخل کلاس ItemDialog
    def _apply_item_type_rules(self):
        """
        قوانین نمایش/قفل‌کردن فیلدها بر اساس حالت‌ها:
        - حالت فرزند (self.parent_item_id != None)
        - حالت مادر (self.chk_parent.isChecked())
        - حالت معمولی (بدون والد و بدون تیک مادر)
        """
        is_child  = getattr(self, 'parent_item_id', None) is not None
        is_parent = bool(self.chk_parent.isChecked())

        if is_child:
            # از مادر ارث بگیر
            parent = self.db.get_item_by_id(self.parent_item_id)
            parent_two_comp = bool(parent.get('is_two_component', False))

            # قفل‌های ضروری
            self.chk_parent.setChecked(False)
            self.chk_parent.setEnabled(False)

            self.chk_two_comp.setChecked(parent_two_comp)
            self.chk_two_comp.setEnabled(False)

            # دسته‌بندی = محصول نهایی (Final Product)
            idx = self.cmb_category.findData(CATEGORY_FINAL_PRODUCT)
            if idx >= 0:
                self.cmb_category.setCurrentIndex(idx)
            self.cmb_category.setEnabled(False)

            # موجودی اولیه/واحد برای فرزند فعال است
            self.grp_initial_stock.setEnabled(True)
            self.cmb_unit.setEnabled(True)

            # تبِ «بسته‌بندی‌ها» برای فرزند بی‌معنی است
            if hasattr(self, 'tab_packages'):
                self.tab_packages.setEnabled(False)

        elif is_parent:
            # مادر: واحد/موجودی اولیه معنی ندارد
            self.cmb_unit.setEnabled(False)
            self.grp_initial_stock.setEnabled(False)

            # مادر می‌تواند دو‌جزئی باشد؛ این گزینه فعال بماند
            self.chk_two_comp.setEnabled(True)

            # تب بسته‌بندی‌ها بعد از ذخیره فعال می‌شود (اینجا دست‌نزن)
            if hasattr(self, 'tab_packages'):
                self.tab_packages.setEnabled(True)

            # دسته‌بندی مادر معمولاً «محصول مادر/چتری» یا «بدون دسته نهایی» است
            # اگر سیاست شما دستهٔ خاصی برای مادر دارد، اینجا ست کنید (اختیاری)

        else:
            # حالت کالای معمولی (نه والد دارد نه تیک مادر)
            self.chk_parent.setEnabled(True)
            # دو‌جزئی فقط مخصوص مادر است؛ برای آیتم معمولی خاموش و قفل
            self.chk_two_comp.setChecked(False)
            self.chk_two_comp.setEnabled(False)

            # موجودی اولیه/واحد برای معمولی فعال است
            self.grp_initial_stock.setEnabled(True)
            self.cmb_unit.setEnabled(True)

            # تب بسته‌بندی‌ها بی‌معنی
            if hasattr(self, 'tab_packages'):
                self.tab_packages.setEnabled(False)

                        
    def _update_save_button_state(self):
        is_name_valid = bool(self.e_name.text().strip())
        is_parent = self.is_parent_check.isChecked()
        is_child = self.parent_id is not None
        is_unit_valid = self.c_unit.currentData() is not None or is_parent or is_child
        self.save_button.setEnabled(is_name_valid and is_unit_valid)

# در کلاس ItemDialog، متد _save_main_item را جایگزین کنید

    def _save_main_item(self):
        # --- خواندن اولیه از فرم ---
        name = self.e_name.text().strip()
        unit_id = self.c_unit.currentData()
        category = self.c_cat.currentText()
        is_parent = self.is_parent_check.isChecked()
        is_two_comp = self.is_two_component_check.isChecked()
        is_packed_value = (category == CATEGORY_FINAL_PRODUCT)

        # --- خودکارسازی پیشوند SKU برای پکِ زیرمجموعه ---
        # اگر این آیتم زیرمجموعهٔ مادر است، SKU را اجباری با «SKU مادر-» شروع می‌کنیم (به‌صورت خودکار)
        if getattr(self, "parent_id", None):
            fixed_sku = self._ensure_pack_sku_prefix(int(self.parent_id), self.e_sku.text())
        else:
            fixed_sku = (self.e_sku.text() or "").strip()

        # --- اعتبارسنجی وزن خالص > 0 برای پک ---
        try:
            net_w = float(self.e_net_weight.value() if hasattr(self.e_net_weight, "value") else self.e_net_weight.text())
        except Exception:
            net_w = 0.0
        if getattr(self, "parent_id", None) and net_w <= 0:
            QtWidgets.QMessageBox.warning(self, "اعتبارسنجی پک", "وزن خالص پک باید بزرگ‌تر از صفر باشد.")
            return

        # --- ساخت دیکشنری داده مثل قبل (فیلدهای موجود پروژه را حفظ کنید) ---
        item_master_data = {
            'name': name,
            'sku': fixed_sku,
            'category': category,
            'unit_id': unit_id,
            'cost': self.e_cost.value(),
            'min_qty': self.e_min.value(),
            'max_qty': self.e_max.value(),
            'supplier': self.e_supp.text().strip(),
            'notes': self.e_note.toPlainText().strip(),
            'is_parent_product': is_parent,
            'is_two_component': is_two_comp,
            'is_packed': is_packed_value,
            'default_loc': self.item_data.get('default_loc'),
            'expiry_lead_days': self.item_data.get('expiry_lead_days', 30),
            'reporting_group': self.item_data.get('reporting_group', ''),
            'parent_item_id': self.parent_id,      # اگر پک است، مقدار دارد
            'net_weight': net_w,
            'requires_qc': self.requires_qc_check.isChecked()
        }

        # موجودی اولیه فقط برای آیتم مادر (مثل قبل)
        initial_stock_data = []
        if not is_parent:
            try:
                initial_stock_data = [
                    self.stock_table.item(r, 0).data(Qt.UserRole)
                    for r in range(self.stock_table.rowCount())
                    if self.stock_table.item(r, 0)
                ]
            except Exception:
                initial_stock_data = []

        # --- ذخیره مثل گذشته ---
        try:
            if self.item_id:
                self.db.update_item_with_locations(self.item_id, item_master_data, self.user_id)
            else:
                self.db.add_item_with_locations(item_master_data, initial_stock_data, self.user_id)
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, 'خطا در ذخیره‌سازی', f"مشکلی در هنگام ذخیره پیش آمد:\n{e}")
            import traceback; print(traceback.format_exc())
            
    def _update_pack_sku_hint(self):
        """
        زیر فیلد SKU به کاربر نشان می‌دهد که پیشوند «SKU مادر + '-'» خودکار اعمال می‌شود.
        همچنین placeholder فیلد SKU را هم با همین پیشوند تنظیم می‌کند.
        """
        try:
            # اگر پک زیرمجموعه نیست، چیزی نمایش نده
            if not getattr(self, "parent_id", None):
                if hasattr(self, "lbl_sku_hint") and self.lbl_sku_hint:
                    self.lbl_sku_hint.setVisible(False)
                return

            # خواندن SKU مادر
            row = self.db.execute_query(
                "SELECT sku FROM items WHERE id=%s LIMIT 1",
                (int(self.parent_id),),
                fetch_one=True
            ) or {}
            parent_sku = (row.get('sku') or "").strip()
            if not parent_sku:
                if hasattr(self, "lbl_sku_hint") and self.lbl_sku_hint:
                    self.lbl_sku_hint.setVisible(False)
                return

            prefix = f"{parent_sku}-"

            # ساخت/نمایش برچسب توضیح (اگر قبلاً ساخته نشده)
            if not hasattr(self, "lbl_sku_hint") or self.lbl_sku_hint is None:
                from PyQt5 import QtWidgets, QtCore
                self.lbl_sku_hint = QtWidgets.QLabel(self)
                self.lbl_sku_hint.setObjectName("lbl_sku_hint")
                self.lbl_sku_hint.setStyleSheet("color: #666; font-size: 11px;")
                self.lbl_sku_hint.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)

                # تلاش برای قرار دادن درست زیر فیلد SKU
                # اگر layout مستقیم در دسترس است، در همان layout درج می‌کنیم
                sku_parent = self.e_sku.parentWidget()
                lay = sku_parent.layout() if sku_parent else None
                if lay:
                    # ردیف/ستون بعد از e_sku را پیدا کنیم (اگر Grid باشد ممکن است متفاوت باشد)
                    try:
                        idx = lay.indexOf(self.e_sku)
                        if idx != -1:
                            row, col, rowSpan, colSpan = lay.getItemPosition(idx)  # برای GridLayout
                            lay.addWidget(self.lbl_sku_hint, row+1, col, 1, colSpan)
                        else:
                            lay.addWidget(self.lbl_sku_hint)
                    except Exception:
                        lay.addWidget(self.lbl_sku_hint)
                else:
                    # در صورت نبود layout، موقتاً مخفی می‌ماند (مشکل‌زا نیست)
                    pass

            # متنِ راهنما و placeholder
            self.lbl_sku_hint.setText(f"ℹ️ کد SKU پک به‌صورت خودکار با «{prefix}» شروع می‌شود.")
            self.lbl_sku_hint.setVisible(True)
            try:
                cur = (self.e_sku.text() or "").strip()
                if not cur:
                    self.e_sku.setPlaceholderText(prefix + "...")
            except Exception:
                pass

        except Exception:
            # اگر هر مشکلی در UI پیش آمد، راهنما اختیاری است و می‌توان نادیده گرفت
            pass
        
    def showEvent(self, event):
        """
        هنگام باز شدن دیالوگ، راهنمای پیشوند SKU را به‌روز کن
        تا کاربر قبل از تایپ، از پیشوند خودکار آگاه باشد.
        """
        try:
            super(ItemDialog, self).showEvent(event)
        except Exception:
            try:
                super().showEvent(event)
            except Exception:
                pass
        # به‌روزرسانی راهنما
        try:
            self._update_pack_sku_hint()
        except Exception:
            pass

            
    def _ensure_pack_sku_prefix(self, parent_item_id: int, pack_sku: str) -> str:
        """
        اگر پک زیرمجموعهٔ یک مادر باشد و کاربر SKU را بدون پیشوند بنویسد،
        این تابع به‌طور خودکار پیشوند «SKU مادر + '-'» را اضافه می‌کند.
        مقدار اصلاح‌شده فوراً داخل فیلد فرم (self.e_sku) هم ست می‌شود.
        """
        try:
            if not parent_item_id:
                return (pack_sku or "").strip()

            parent_row = self.db.execute_query(
                "SELECT sku FROM items WHERE id=%s LIMIT 1", (int(parent_item_id),), fetch_one=True
            ) or {}
            parent_sku = (parent_row.get('sku') or "").strip()
            if not parent_sku:
                return (pack_sku or "").strip()

            expected_prefix = f"{parent_sku}-"
            raw = (pack_sku or "").strip()

            # اگر کاربر خودِ parent_sku را بدون خط تیره اول نوشته، تمیزش کنیم
            if raw.startswith(parent_sku) and not raw.startswith(expected_prefix):
                raw = raw[len(parent_sku):].lstrip("- _")

            if not raw.startswith(expected_prefix):
                raw = expected_prefix + raw

            # نمایش در فرم
            try:
                self.e_sku.setText(raw)
            except Exception:
                pass
            return raw
        except Exception:
            return (pack_sku or "").strip()

                        
    def _update_field_visibility(self):
        """
        قوانین UI:
        - فقط وقتی دسته = 'محصول نهایی' باشد، امکان 'محصول مادر' و 'دو جزئی' فعال است.
        - اگر این فرم برای 'پکِ فرزند' باز شده باشد (parent_id دارد)، همه چیز از مادر ارث می‌آید و قفل است.
        - تب 'بسته‌بندی‌ها' فقط وقتی آیتم مادر و ذخیره‌شده باشد فعال می‌شود.
        """
        final_cat = CATEGORY_FINAL_PRODUCT
        current_cat = self.c_cat.currentText()
        is_child_mode = bool(self.parent_id) or (bool(self.item_id) and bool(self.item_data.get('parent_item_id')))
        i_tab = self.tabs.indexOf(self.packaging_page)

        # پیش‌فرض‌ها: تب بسته‌بندی غیرفعال (اگر هست)
        if i_tab != -1:
            self.tabs.setTabEnabled(i_tab, False)

        # حالت فرزند: از مادر ارث و قفل
        if is_child_mode:
            # قفل 'مادر' و 'دو جزئی'
            self.is_parent_check.blockSignals(True)
            self.is_parent_check.setChecked(False)
            self.is_parent_check.setEnabled(False)
            self.is_parent_check.blockSignals(False)

            # ارث دو جزئی از مادر و قفل
            parent_two_comp = False
            pid = self.parent_id or (self.item_data.get('parent_item_id') if self.item_id else None)
            if pid:
                p = self.db.get_item_details(pid) or {}
                parent_two_comp = bool(p.get('is_two_component', False))
            self.is_two_component_check.blockSignals(True)
            self.is_two_component_check.setChecked(parent_two_comp)
            self.is_two_component_check.setEnabled(False)
            self.is_two_component_check.blockSignals(False)

            # دسته = محصول نهایی و قفل
            idx = self.c_cat.findText(final_cat)
            if idx >= 0:
                self.c_cat.setCurrentIndex(idx)
            self.c_cat.setEnabled(False)

            # واحد/موجودی اولیه برای فرزند
            self.c_unit.setEnabled(True)
            # ✅ فقط برای کالای جدید اجازه ثبت موجودی اولیه
            self.stock_group.setEnabled(self.item_id is None)

            # ✅ وزن خالص فقط برای پک‌ها (حالت فرزند)
            self.net_weight_label.setVisible(True)
            self.e_net_weight.setVisible(True)
            return  # حالت فرزند تمام

        # از اینجا به بعد: مادر/معمولی
        is_final_category = (current_cat == final_cat)

        # فقط در محصول نهایی اجازه‌ی مادر/دو‌جزئی بده
        if not is_final_category:
            # هر چی تیک خورده بود خاموش و قفل
            self.is_parent_check.blockSignals(True)
            self.is_parent_check.setChecked(False)
            self.is_parent_check.setEnabled(False)
            self.is_parent_check.blockSignals(False)

            self.is_two_component_check.blockSignals(True)
            self.is_two_component_check.setChecked(False)
            self.is_two_component_check.setEnabled(False)
            self.is_two_component_check.blockSignals(False)

            # تب بسته‌بندی بی‌معنا
            if i_tab != -1:
                self.tabs.setTabEnabled(i_tab, False)

            # واحد/موجودی اولیه فعال (غیرمادر)
            self.c_unit.setEnabled(True)
            self.stock_group.setEnabled(self.item_id is None)

            # ✅ وزن خالص برای پک‌هاست؛ اینجا پنهان
            self.net_weight_label.setVisible(False)
            self.e_net_weight.setVisible(False)
            return

        # دسته = محصول نهایی
        self.is_parent_check.setEnabled(True)

        if self.is_parent_check.isChecked():
            # مادر: دو‌جزئی فقط اینجا مجاز
            self.is_two_component_check.setEnabled(True)
            # مادر واحد عملیاتی و موجودی اولیه ندارد
            self.c_unit.setEnabled(False)
            self.stock_group.setEnabled(False)
            # تب بسته‌بندی‌ها فقط بعد از ذخیره‌بودن آیتم فعال شود
            if i_tab != -1:
                self.tabs.setTabEnabled(i_tab, bool(self.item_id))
            # ✅ وزن خالصِ مادر پنهان
            self.net_weight_label.setVisible(False)
            self.e_net_weight.setVisible(False)
        else:
            # کالای معمولیِ محصول نهایی (نه مادر، نه فرزند)
            self.is_two_component_check.blockSignals(True)
            self.is_two_component_check.setChecked(False)
            self.is_two_component_check.setEnabled(False)
            self.is_two_component_check.blockSignals(False)

            self.c_unit.setEnabled(True)
            self.stock_group.setEnabled(self.item_id is None)

            if i_tab != -1:
                self.tabs.setTabEnabled(i_tab, False)

            # ✅ وزن خالص فقط برای پک‌هاست؛ اینجا (نه مادر و نه فرزند) پنهان
            self.net_weight_label.setVisible(False)
            self.e_net_weight.setVisible(False)

# در کلاس ItemDialog، این متد را به طور کامل جایگزین کنید
    def _load_data_for_edit(self):
        rec = self.item_data
        if not rec: self.close(); return
        
        self.e_name.setText(rec.get('name', '')); self.e_sku.setText(rec.get('sku', '')); self.c_cat.setCurrentText(rec.get('category', ''))
        unit_id = rec.get('unit_id');
        if unit_id:
            index = self.c_unit.findData(unit_id)
            if index != -1: self.c_unit.setCurrentIndex(index)
        
        self.e_net_weight.setValue(rec.get('net_weight', 0))
        self.e_cost.setValue(rec.get('cost', 0)); self.e_min.setValue(rec.get('min_qty', 0)); self.e_max.setValue(rec.get('max_qty', 0)); self.e_supp.setText(rec.get('supplier', '')); self.e_note.setPlainText(rec.get('notes', ''))
        
        is_parent = rec.get('is_parent_product', False)
        self.is_parent_check.setChecked(is_parent)
        
        # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
        # این خط فراموش شده بود و باعث می‌شد وضعیت چک‌باکس از دیتابیس خوانده نشود.
        self.is_two_component_check.setChecked(rec.get('is_two_component', False))
        # --- ************************************* ---

        self.requires_qc_check.setChecked(rec.get('requires_qc', True))
        
        self._update_field_visibility() 
        self._update_save_button_state()
        
        if is_parent:
            self._load_child_items()
                        
    def _load_child_items(self):
        self.tbl_child_items.setRowCount(0)
        if not self.item_id: return
        children = self.db.get_child_items(self.item_id)
        self.tbl_child_items.setRowCount(len(children))
        for r, child in enumerate(children):
            self.tbl_child_items.setItem(r, 0, QtWidgets.QTableWidgetItem(str(child['id'])))
            self.tbl_child_items.setItem(r, 1, QtWidgets.QTableWidgetItem(child['sku']))
            self.tbl_child_items.setItem(r, 2, QtWidgets.QTableWidgetItem(child['name']))
            self.tbl_child_items.setItem(r, 3, QtWidgets.QTableWidgetItem(child.get('unit') or ''))

    def _add_child_item(self):
        if not self.item_id: return
        dlg = ItemDialog(self.db, self.user_id, self.role, parent_id=self.item_id, parent_name=self.item_data.get('name'))
        if dlg.exec_(): self._load_child_items()

    def _edit_child_item(self):
        selected = self.tbl_child_items.selectedItems();
        if not selected: QtWidgets.QMessageBox.warning(self, "انتخاب پک", "لطفاً یک پک را برای ویرایش از جدول انتخاب کنید."); return
        child_id = int(self.tbl_child_items.item(selected[0].row(), 0).text())
        dlg = ItemDialog(self.db, self.user_id, self.role, item_id=child_id, parent_id=self.item_id)
        if dlg.exec_(): self._load_child_items()

    def populate_units_combo(self):
        self.c_unit.clear(); units = self.db.get_all_units()
        for unit in units: self.c_unit.addItem(unit['name'], unit['id'])
        self.c_unit.insertItem(0, "--- انتخاب کنید ---", None); self.c_unit.setCurrentIndex(0)
    
    def _setup_for_new_child(self):
        self.is_parent_check.setChecked(False); self.is_parent_check.setDisabled(True)
        self.c_cat.setCurrentText("محصول نهایی"); self.c_cat.setEnabled(False)
        self.tabs.setTabVisible(1, False)
        unit_index = self.c_unit.findText("عدد")
        if unit_index != -1: self.c_unit.setCurrentIndex(unit_index)
        self.c_unit.setEnabled(False)

    def _add_stock_row(self):
        dlg = AddStockRowDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                row_pos = self.stock_table.rowCount(); self.stock_table.insertRow(row_pos); self.stock_table.setItem(row_pos, 0, QtWidgets.QTableWidgetItem(data['loc_label'])); self.stock_table.setItem(row_pos, 1, QtWidgets.QTableWidgetItem(data['batch_no'])); self.stock_table.setItem(row_pos, 2, QtWidgets.QTableWidgetItem(to_shamsi(data['expiry_date']))); self.stock_table.setItem(row_pos, 3, QtWidgets.QTableWidgetItem(str(data['qty']))); self.stock_table.item(row_pos, 0).setData(Qt.UserRole, data)
    
    def _remove_stock_row(self):
        current_row = self.stock_table.currentRow();
        if current_row >= 0: self.stock_table.removeRow(current_row)

    def _open_packaging_bom_editor(self):
        selected = self.tbl_child_items.selectedItems()
        if not selected: return
        pack_item_id = int(self.tbl_child_items.item(selected[0].row(), 0).text())
        pack_item_data = self.db.get_item_details(pack_item_id)
        if not pack_item_data: return
        dlg = PackagingBomDialog(self.db, dict(pack_item_data), self)
        dlg.exec_()
                
                                    
class TransferDialog(QtWidgets.QDialog):
    """
    نسخه نهایی (V3.0): این دیالوگ برای انتقال کالا بین لوکیشن‌های غیرتولیدی عمل می‌کند
    و حالا از انتخاب دقیق بچ/انقضا پشتیبانی می‌کند.
    """
    def __init__(self, db:DB, user_id:int, parent=None):
        super().__init__(parent)
        self.db, self.user_id = db, user_id
        
        self.setWindowTitle("انتقال داخلی بین انبارها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(550) # کمی عرض بیشتر برای نمایش اطلاعات بچ
        
        f = QtWidgets.QFormLayout(self)
        f.setSpacing(15)
        
        self.c_item = QtWidgets.QComboBox(); self.c_item.setEditable(True)
        self.c_item.setCompleter(QtWidgets.QCompleter(self.c_item.model()))
        
        self.c_src = QtWidgets.QComboBox()
        self.c_batch = QtWidgets.QComboBox() # <<< فیلد جدید برای انتخاب بچ
        self.c_dst = QtWidgets.QComboBox()
        self.e_qty = QtWidgets.QLineEdit()
        self.e_qty.setValidator(QtGui.QDoubleValidator(0.001, 1e9, 3))
        self.e_notes = QtWidgets.QLineEdit()

        f.addRow('کالا:', self.c_item)
        f.addRow('از لوکیشن:', self.c_src)
        f.addRow('انتخاب بچ/انقضا:', self.c_batch) # <<< فیلد جدید
        f.addRow('به لوکیشن:', self.c_dst)
        f.addRow('مقدار:', self.e_qty)
        f.addRow('یادداشت (اختیاری):', self.e_notes)
        
        btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " ثبت انتقال")
        btn.setProperty("class", "primary"); f.addRow(btn)
        
        self.c_item.currentIndexChanged.connect(self._refresh_source_locations)
        self.c_src.currentIndexChanged.connect(self._refresh_batches_and_destinations)
        btn.clicked.connect(self._do_transfer)
        
        self._populate_items()
        self._refresh_source_locations()

    def _g2j(self, greg_date: dt.date | None) -> str:
        if greg_date is None: return "نامشخص"
        return jd.fromgregorian(date=greg_date).strftime('%Y/%m/%d')

    # BEGIN REWRITE: TransferDialog._populate_items
    def _populate_items(self):
        """فقط کالاهایی که در انبارهای غیرتولیدی موجودی دارند را لیست می‌کند (سازگار با زیرساخت فعلی DB)."""
        from PyQt5 import QtWidgets
        self.c_item.clear()

        try:
            if hasattr(self.db, 'get_all_items_for_selection'):
                # خروجی انتظار می‌رود: [{id,name,category,unit,non_prod_qty,...}]
                all_items = self.db.get_all_items_for_selection() or []
            else:
                # اگر متد بالا نبود، از items_brief با آرگومان‌های صحیح استفاده می‌کنیم
                # (دسته‌ها از ثابت‌های موجود پروژه؛ اگر نبودند، fallback فارسی داریم)
                cats = []
                try:
                    cats = [
                        CATEGORY_FINAL_PRODUCT,
                        CATEGORY_BULK_PRODUCT,
                        CATEGORY_RAW_MATERIAL,
                        CATEGORY_PACKAGING,
                        CATEGORY_CONSUMABLES,
                    ]
                except Exception:
                    cats = ['مواد اولیه', 'محصول نهایی', 'محصول فله', 'لوازم بسته‌بندی', 'لوازم مصرفی']

                all_items = []
                for c in dict.fromkeys([x for x in cats if x]):  # یکتا نگه‌داشتن دسته‌ها
                    try:
                        # ✅ نکتهٔ اصلی اصلاح: ارسال آرگومان‌های لازم به items_brief
                        # استفاده از نام‌گذاری کلیدی برای سازگاری ایمن‌تر با امضا
                        chunk = self.db.items_brief(category_filter=c, limit=10000, offset=0) or []
                        all_items.extend(chunk)
                    except Exception:
                        # اگر یکی از دسته‌ها خطا داد، بقیه ادامه پیدا کنند
                        pass
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خواندن لیست کالاها ناموفق بود:\n{e}")
            return

        # فقط کالاهایی که واقعاً در انبارهای غیرتولیدی موجودی دارند
        for rec in all_items:
            try:
                non_prod_qty = rec.get('non_prod_qty', 0) or 0
            except Exception:
                non_prod_qty = 0
            if non_prod_qty > 0:
                name = rec.get('name', '')
                disp = f"{name} (موجودی غیرتولید: {non_prod_qty})"
                self.c_item.addItem(disp, dict(rec))
    # END REWRITE: TransferDialog._populate_items

    # BEGIN REWRITE: TransferDialog._refresh_source_locations
    def _refresh_source_locations(self):
        """
        کمبوی «از لوکیشن» را فقط با لوکیشن‌هایی پر می‌کند که کالای انتخاب‌شده در آن‌ها موجودی > 0 دارند.
        سپس به‌محض انتخاب/تغییر مبدا، بچ‌های همان مبدا و مقصدها رفرش می‌شوند.
        """
        # ایمن‌سازی اولیه
        try:
            if hasattr(self.c_src, "setEditable"):
                self.c_src.setEditable(False)
            if hasattr(self.c_batch, "setEditable"):
                self.c_batch.setEditable(False)
        except Exception:
            pass

        # پاکسازی
        self.c_src.blockSignals(True)
        self.c_src.clear()
        try:
            self.c_batch.clear()
        except Exception:
            pass

        # گرفتن آیتم انتخاب‌شده
        item_data = self.c_item.currentData()
        item_id = item_data.get('id') if isinstance(item_data, dict) else None
        if not item_id:
            self.c_src.blockSignals(False)
            return

        # 1) تلاش اصلی: API صریح آیتم→لوکیشن (با حذف Production)
        locations = None
        try:
            # اگر این امضا وجود دارد (طبق لاگ قبلی)، مستقیم استفاده کن
            locations = self.db.get_item_locations_excluding_warehouse(
                item_id=item_id, warehouse_to_exclude='Production'
            )
        except Exception:
            locations = None

        # 2) اگر نشد: APIهای مشابه (نام‌های رایج) بدون حذف Production، بعداً فیلتر می‌کنیم
        if not locations:
            for fname in ("get_item_locations", "list_item_locations", "get_locations_for_item"):
                try:
                    fn = getattr(self.db, fname, None)
                    if fn:
                        locations = fn(item_id) or []
                        break
                except Exception:
                    continue

        # 3) اگر هنوز هیچ: همهٔ لوکیشن‌ها را بگیر و بعداً با موجودی آیتم فیلتر کن
        if not locations:
            try:
                # اگر امکانش بود، Production را همین‌جا حذف کن
                if hasattr(self.db, "list_locations"):
                    locations = self.db.list_locations(exclude_warehouses=['Production']) or []
                else:
                    locations = self.db.list_locations_excluding_warehouse(
                        item_id=item_id, warehouse_to_exclude='Production'
                    ) or []
            except Exception:
                locations = []

        # فیلتر بر اساس «واقعاً موجود بودن آیتم» و محاسبه مجموع موجودی هر لوکیشن
        filtered_locs = []
        seen = set()
        for loc in locations or []:
            try:
                loc_id = loc.get('id')
                if not loc_id or loc_id in seen:
                    continue

                total_qty = 0
                batches = None

                # ترجیح: API مستقیمِ بچ‌های آیتم در لوکیشن
                for bfn in ("get_batches_in_location", "get_item_batches_in_location", "list_batches_in_location"):
                    try:
                        fn = getattr(self.db, bfn, None)
                        if fn:
                            batches = fn(item_id, loc_id) or []
                            break
                    except Exception:
                        batches = None

                # اگر API بالا نبود، یک API موجودی لوکیشن-آیتم را امتحان کن
                if batches is None:
                    for sfn in ("get_item_stock_by_location", "get_item_location_balance"):
                        try:
                            fn = getattr(self.db, sfn, None)
                            if fn:
                                bal = fn(item_id, loc_id)
                                # می‌تواند عدد برگرداند یا دیکشنری
                                if isinstance(bal, dict):
                                    total_qty = bal.get('qty', 0) or 0
                                else:
                                    total_qty = bal or 0
                                break
                        except Exception:
                            continue

                # اگر batches داشتیم، از روی batches جمع بزنیم
                if batches is not None:
                    for b in batches:
                        try:
                            total_qty += (b.get('qty', 0) or 0)
                        except Exception:
                            continue

                if total_qty > 0:
                    filtered_locs.append((loc, total_qty))
                    seen.add(loc_id)
            except Exception:
                continue

        # مرتب‌سازی: بیشترین موجودی اول (اختیاری)
        try:
            filtered_locs.sort(key=lambda x: x[1], reverse=True)
        except Exception:
            pass

        # پر کردن کمبو
        for loc, tot in filtered_locs:
            try:
                label = loc.get('loc_label') or loc.get('name') or f"Loc-{loc.get('id')}"
                self.c_src.addItem(f"{label}  (موجودی کل: {tot})", loc.get('id'))
            except Exception:
                continue

        # بستن بلاک سیگنال و اتصال تغییر مبدا → رفرش بچ‌ها و مقصدها
        try:
            # قطع اتصال قبلی در صورت وجود
            try:
                if hasattr(self, "_csrc_changed_handler"):
                    self.c_src.currentIndexChanged.disconnect(self._csrc_changed_handler)
            except Exception:
                pass

            def _on_src_changed(_idx):
                self._refresh_batches_and_destinations()

            self._csrc_changed_handler = _on_src_changed
            self.c_src.currentIndexChanged.connect(self._csrc_changed_handler)
        except Exception:
            pass

        self.c_src.blockSignals(False)

        # اگر حداقل یک مبدا داریم، همان لحظه بچ‌ها را برای مبدای فعلی لود کن
        if self.c_src.count() > 0:
            self._refresh_batches_and_destinations()
    # END REWRITE: TransferDialog._refresh_source_locations

    # BEGIN REWRITE: TransferDialog._refresh_batches_and_destinations
    def _refresh_batches_and_destinations(self):
        """
        1) کمبوی بچ‌ها را فقط با موجودی‌های واقعیِ کالای انتخاب‌شده در 'لوکیشن مبدا' پر می‌کند.
        2) کمبوی مقصد را از همهٔ لوکیشن‌ها به‌جز Production می‌چیند (و مبدا را حذف می‌کند).
        """
        # --------- بخش بچ‌ها (فقط موجودهای واقعی در مبدا) ---------
        self.c_batch.blockSignals(True)
        self.c_batch.clear()
        try:
            # کمبو ویرایش‌پذیر نباشد تا کاربر نتواند مقدار دلخواه تایپ کند
            if hasattr(self.c_batch, "setEditable"):
                self.c_batch.setEditable(False)
        except Exception:
            pass

        item_data = self.c_item.currentData()
        src_loc_id = self.c_src.currentData()

        if isinstance(item_data, dict) and src_loc_id not in (None, -1):
            item_id = item_data.get('id')
            # خواندن بچ‌های همان کالا در همان مبدا
            try:
                batches = self.db.get_batches_in_location(item_id, src_loc_id) or []
            except Exception:
                batches = []

            # فقط بچ‌هایی که موجودی‌شان > 0 است
            filtered = []
            for b in batches:
                try:
                    q = b.get('qty', 0) or 0
                except Exception:
                    q = 0
                if q > 0:
                    filtered.append(b)

            # مرتب‌سازی ملایم بر اساس تاریخ انقضا (اگر بود)
            def _key(b):
                return (b.get('expiry_date') is None, b.get('expiry_date'))
            try:
                filtered.sort(key=_key)
            except Exception:
                pass

            # پر کردن کمبو با نمایش: «بچ | انقضا | موجودی»
            for b in filtered:
                batch_no   = b.get('batch_no', '-') or '-'
                expiry_raw = b.get('expiry_date', None)
                try:
                    expiry_str = self._g2j(expiry_raw) if expiry_raw else '—'
                except Exception:
                    expiry_str = str(expiry_raw) if expiry_raw else '—'
                qty = b.get('qty', 0) or 0

                display_text = f"بچ {batch_no} | انقضا: {expiry_str} | موجودی: {qty}"
                # دادهٔ کامل برای مصرف مرحلهٔ ثبت
                payload = {
                    'item_id': item_id,
                    'location_id': src_loc_id,
                    'batch_id': b.get('id') or b.get('batch_id'),
                    'batch_no': batch_no,
                    'expiry_date': expiry_raw,
                    'qty': qty,
                }
                self.c_batch.addItem(display_text, payload)

            # راهنمای مقدارِ مجاز (حداکثر موجودی بچ انتخاب‌شده)
            try:
                def _on_batch_changed(_idx):
                    rec = self.c_batch.currentData() or {}
                    max_q = rec.get('qty', 0) or 0
                    if hasattr(self.e_qty, "setPlaceholderText"):
                        self.e_qty.setPlaceholderText(f"حداکثر: {max_q}")
                # قطع اتصال قبلی اگر وجود داشته
                try:
                    if hasattr(self, "_cbatch_changed_handler"):
                        self.c_batch.currentIndexChanged.disconnect(self._cbatch_changed_handler)
                except Exception:
                    pass
                self._cbatch_changed_handler = _on_batch_changed
                self.c_batch.currentIndexChanged.connect(self._cbatch_changed_handler)
                _on_batch_changed(self.c_batch.currentIndex())
            except Exception:
                pass

        self.c_batch.blockSignals(False)

        # --------- بخش مقصدها (حذف Production و خودِ مبدا) ---------
        self.c_dst.clear()
        try:
            all_locations = self.db.list_locations(exclude_warehouses=['Production'])
        except Exception:
            # سازگارسازی با نسخهٔ قدیمی DB
            try:
                all_locations = self.db.list_locations_excluding_warehouse(
                    item_id=item_data.get('id') if isinstance(item_data, dict) else None,
                    warehouse_to_exclude='Production'
                )
            except Exception as e:
                from PyQt5 import QtWidgets
                QtWidgets.QMessageBox.critical(self, "خطا", f"بارگذاری مقصدها ناموفق بود:\n{e}")
                return

        for loc in all_locations or []:
            try:
                if loc.get('id') != src_loc_id:
                    self.c_dst.addItem(loc.get('loc_label', ''), loc.get('id'))
            except Exception:
                continue
    # END REWRITE: TransferDialog._refresh_batches_and_destinations

    def _do_transfer(self):
        """عملیات انتقال را با اطلاعات کامل بچ و تاریخ انقضا انجام می‌دهد."""
        try:
            qty = float(self.e_qty.text())
            if qty <= 0: raise ValueError
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, 'خطا', 'مقدار وارد شده صحیح نیست.'); return

        item_data = self.c_item.currentData()
        src_id = self.c_src.currentData()
        dst_id = self.c_dst.currentData()
        batch_data = self.c_batch.currentData()

        if not isinstance(item_data, dict) or src_id in [None, -1] or dst_id is None or not isinstance(batch_data, dict):
            QtWidgets.QMessageBox.warning(self, 'خطا', 'لطفاً تمام فیلدها (کالا، مبدا، بچ و مقصد) را به درستی انتخاب کنید.'); return

        if src_id == dst_id:
            QtWidgets.QMessageBox.warning(self, 'خطا', 'مبدا و مقصد نمی‌توانند یکسان باشند.'); return

        if qty > batch_data.get('qty', 0):
            QtWidgets.QMessageBox.warning(self, 'خطای موجودی', f"مقدار درخواستی ({qty}) از موجودی این بچ ({batch_data.get('qty', 0)}) بیشتر است."); return
            
        try:
            # فراخوانی تابع transfer با تمام پارامترهای لازم
            self.db.transfer(
                item_id=item_data['id'], 
                qty=qty,
                src_loc_id=src_id, 
                dest_loc_id=dst_id, 
                user_id=self.user_id, 
                notes=self.e_notes.text().strip(), 
                batch_no=batch_data['batch_no'],
                expiry_date=batch_data.get('expiry_date')
            )
            
            toast = getattr(self.parent(), 'toast', None)
            if toast:
                toast.show_message("✔ انتقال داخلی با موفقیت ثبت شد.", "success")
            self.accept()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای پیش‌بینی نشده", f"خطا در هنگام ثبت انتقال:\n{e}")
            
                                                
# کل کلاس TransactionDialog را با این نسخه نهایی جایگزین کنید

class TransactionDialog(QtWidgets.QDialog):
    """
    نسخه نهایی و یکپارچه (V4.4)
    - در حالت ورود، به انباردار اجازه می‌دهد برای کالا وضعیت اولیه (تایید شده یا قرنطینه) را تعیین کند.
    """
    transaction_data_ready = QtCore.pyqtSignal(dict)

    def __init__(self, db: DB, user_id: int, t_type: str, parent=None, item_id=None):
        super().__init__(parent)
        self.db, self.user_id, self.t_type = db, user_id, t_type

        self.setWindowTitle(f'ثبت {self.t_type}')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(600)

        form = QtWidgets.QFormLayout(self); form.setSpacing(10)

        self.c_item = QtWidgets.QComboBox(); self.c_item.setEditable(True); self.c_item.setCompleter(QtWidgets.QCompleter(self.c_item.model()))
        form.addRow('کالا:', self.c_item)

        self.mode_stack = QtWidgets.QStackedWidget()
        form.addRow(self.mode_stack)

        # --- پنل خروج (بدون تغییر) ---
        exit_widget = QtWidgets.QWidget(); exit_layout = QtWidgets.QFormLayout(exit_widget); exit_layout.setContentsMargins(0,0,0,0)
        self.c_stock_record = QtWidgets.QComboBox()
        self.c_stock_record.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        exit_layout.addRow("انتخاب موجودی (انبار/بچ/انقضا):", self.c_stock_record)
        self.mode_stack.addWidget(exit_widget)

        # --- پنل ورود (با فیلد جدید) ---
        entry_widget = QtWidgets.QWidget(); entry_layout = QtWidgets.QFormLayout(entry_widget); entry_layout.setContentsMargins(0,0,0,0)
        self.c_loc_entry = QtWidgets.QComboBox()
        self.c_batch_entry = QtWidgets.QComboBox(); self.c_batch_entry.setEditable(True); self.c_batch_entry.setCompleter(None)
        self.expiry_date_edit = QtWidgets.QLineEdit(); self.expiry_date_edit.setInputMask("0000/00/00;_"); self.expiry_date_edit.setPlaceholderText("اختیاری")

        # --- ویجت جدید و کلیدی برای تصمیم‌گیری QC ---
        self.requires_qc_check = QtWidgets.QCheckBox("ارسال به کنترل کیفی (قرنطینه شود)")

        entry_layout.addRow("به لوکیشن:", self.c_loc_entry)
        entry_layout.addRow("شماره بچ:", self.c_batch_entry)
        entry_layout.addRow("تاریخ انقضا:", self.expiry_date_edit)
        entry_layout.addRow("", self.requires_qc_check) # <<-- اضافه شده به فرم
        self.mode_stack.addWidget(entry_widget)

        self.e_no = QtWidgets.QLineEdit(); self.e_qty = QtWidgets.QLineEdit(); self.e_qty.setValidator(QtGui.QDoubleValidator(0.001, 1e12, 3)); self.e_note = QtWidgets.QLineEdit()
        form.addRow('شماره سند:', self.e_no); form.addRow('مقدار:', self.e_qty); form.addRow('توضیحات:', self.e_note)

        self.btn_ok = QtWidgets.QPushButton(f'ثبت {self.t_type}'); self.btn_ok.setProperty("class", "primary")
        form.addRow(self.btn_ok)

        self.c_item.currentIndexChanged.connect(self._refresh_data_for_item)
        self.c_loc_entry.currentIndexChanged.connect(self._refresh_entry_batches)
        self.c_stock_record.currentIndexChanged.connect(self._on_stock_record_change)
        self.btn_ok.clicked.connect(self._save)

        self._populate_items()
        if item_id: self._select_preselected_item(item_id)

    def _refresh_data_for_item(self):
        is_entry = self.t_type.startswith('ورود') or self.t_type == 'برگشت'
        self.mode_stack.setCurrentIndex(1 if is_entry else 0)
        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict): self.btn_ok.setEnabled(False); return
        item_id = item_data.get('id');
        if not item_id: self.btn_ok.setEnabled(False); return

        # --- بخش جدید و کلیدی برای تنظیم پیش‌فرض چک‌باکس QC ---
        if is_entry:
            item_details = self.db.get_item_details(item_id)
            if item_details:
                self.requires_qc_check.setChecked(item_details.get('requires_qc', True))

        self.c_stock_record.blockSignals(True); self.c_stock_record.clear(); stock_records = self.db.stock_breakdown(item_id)
        if not stock_records: self.c_stock_record.addItem("این کالا در انبار موجودی ندارد!", None)
        else:
            for rec in stock_records:
                expiry_str = to_shamsi(rec['expiry_date']) if rec['expiry_date'] else 'ندارد'
                display_text = f"{rec['loc']} | بچ: {rec['batch_no']} | انقضا: {expiry_str} (موجودی: {rec['qty']})"; self.c_stock_record.addItem(display_text, rec)
        self.c_stock_record.blockSignals(False)

        self.c_loc_entry.blockSignals(True); self.c_loc_entry.clear(); locations = self.db.list_locations(exclude_warehouses=['Production'])
        for loc in locations: self.c_loc_entry.addItem(loc['loc_label'], loc['id'])
        self.c_loc_entry.blockSignals(False)

        if is_entry: self._refresh_entry_batches(); self.btn_ok.setEnabled(True)
        else: self._on_stock_record_change()

    # BEGIN REWRITE: TransactionDialog._save
    def _save(self):
        # 1) شماره سند
        doc_no = self.e_no.text().strip()
        if not doc_no:
            QtWidgets.QMessageBox.warning(self, 'اطلاعات ناقص', 'وارد کردن «شماره سند» اجباری است.')
            return

        # 2) مقدار
        try:
            qty = float(self.e_qty.text().strip())
            if qty <= 0:
                raise ValueError
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, 'خطا', 'مقدار وارد شده صحیح نیست.')
            return

        # 3) کالای انتخابی
        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict):
            QtWidgets.QMessageBox.warning(self, 'خطا', 'کالای انتخاب شده معتبر نیست.')
            return

        is_entry = self.t_type.startswith('ورود') or self.t_type == 'برگشت'
        expiry_date_obj = None

        if is_entry:
            # حالت ورود/برگشت: از فیلدهای ورود بخوان
            loc_id = self.c_loc_entry.currentData()
            batch_no = self.c_batch_entry.currentText().strip()
            expiry_date_str = self.expiry_date_edit.text().strip()

            if expiry_date_str and '_' not in expiry_date_str:
                try:
                    expiry_date_obj = jd.date(*map(int, expiry_date_str.split('/'))).togregorian()
                except Exception:
                    QtWidgets.QMessageBox.warning(self, 'خطا', 'فرمت تاریخ انقضا نامعتبر است.')
                    return

            # یکپارچگی تاریخ انقضا برای همان بچ
            is_consistent, existing_date = self.db.check_batch_expiry_consistency(
                item_data.get('id'), batch_no, expiry_date_obj
            )
            if not is_consistent:
                QtWidgets.QMessageBox.critical(
                    self, "خطای یکپارچگی داده",
                    f"<b>مغایرت در تاریخ انقضا!</b><br><br>بچ «{batch_no}» قبلاً با تاریخ <b>{to_shamsi(existing_date)}</b> ثبت شده است."
                )
                return
        else:
            # حالت خروج/ضایعات: از ردیفِ موجودی انتخاب‌شده بخوان
            stock_data = self.c_stock_record.currentData()
            if stock_data is None:
                QtWidgets.QMessageBox.warning(self, 'خطا', 'لطفاً یک ردیف موجودی معتبر برای خروج انتخاب کنید.')
                return

            # مقدار نباید از موجودی ردیف بیشتر باشد
            if qty > stock_data.get('qty', 0):
                QtWidgets.QMessageBox.warning(
                    self, 'خطای موجودی',
                    f"مقدار درخواستی ({qty}) از موجودی بچ انتخابی ({stock_data.get('qty', 0)}) بیشتر است."
                )
                return

            # ⚠️ نکتهٔ کلیدی: شناسهٔ لوکیشن را به‌صورت امن از چند نامِ ممکن استخراج کن
            loc_id = (
                stock_data.get('loc_id') or
                stock_data.get('location_id') or
                stock_data.get('locId')
            )
            # تبدیل رشته‌ای که عدد است به int
            if isinstance(loc_id, str):
                loc_id = loc_id.strip() or None
                if loc_id and loc_id.isdigit():
                    loc_id = int(loc_id)

            batch_no = stock_data.get('batch_no') or stock_data.get('batch') or stock_data.get('lot')
            expiry_date_obj = stock_data.get('expiry_date')

        # اعتبارسنجی نهایی
        if not batch_no:
            QtWidgets.QMessageBox.warning(self, 'خطا', 'شماره بچ نمی‌تواند خالی باشد.')
            return
        if not loc_id:
            QtWidgets.QMessageBox.warning(self, 'خطا', 'لوکیشن معتبر نیست.')
            return

        # 4) ارسال برای ثبت
        data_to_emit = {
            't_type': self.t_type,
            'item_id': item_data.get('id'),
            'loc_id': loc_id,
            'qty': qty,
            'batch_no': batch_no,
            'expiry_date': expiry_date_obj,
            'doc_no': doc_no,
            'notes': self.e_note.text().strip(),
            'requires_qc': self.requires_qc_check.isChecked() if is_entry else False,
        }
        self.transaction_data_ready.emit(data_to_emit)
        self.accept()
    # END REWRITE: TransactionDialog._save

    def _on_stock_record_change(self):
        """با تغییر انتخاب در لیست موجودی، دکمه ثبت را فعال/غیرفعال می‌کند."""
        # --- FIX: روش ساده و مطمئن برای فعال‌سازی دکمه ---
        # اگر متن آیتم انتخاب شده شامل عبارت "موجودی ندارد" باشد، یعنی آیتم نامعتبر است
        is_placeholder = "موجودی ندارد" in self.c_stock_record.currentText()
        self.btn_ok.setEnabled(not is_placeholder)

# در کلاس TransactionDialog، این متد را جایگزین کنید

    def _populate_items(self):
        self.c_item.blockSignals(True)
        self.c_item.clear()

        model = QtGui.QStandardItemModel()
        
        # --- اصلاح کلیدی: فراخوانی متد جدید و صحیح ---
        all_items = self.db.get_all_items_for_selection()

        items_by_id = {item['id']: dict(item) for item in all_items}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id:
                if parent_id not in child_map:
                    child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)

        root_node = model.invisibleRootItem()
        for item_data in top_level_items:
            parent_node = QtGui.QStandardItem(item_data.get('name', ''))
            parent_node.setData(item_data, Qt.UserRole)
            is_parent = item_data.get('is_parent_product')
            parent_node.setFlags(parent_node.flags() & ~Qt.ItemIsSelectable if is_parent else parent_node.flags())
            root_node.appendRow(parent_node)

            if item_data['id'] in child_map:
                for child_data in child_map[item_data['id']]:
                    child_node = QtGui.QStandardItem(f"  └ {child_data.get('name', '')}")
                    child_node.setData(child_data, Qt.UserRole)
                    parent_node.appendRow(child_node)

        self.c_item.setModel(model)
        self.c_item.setView(QtWidgets.QTreeView())
        
        self.c_item.blockSignals(False)
        self._refresh_data_for_item()
                
    def _select_preselected_item(self, item_id):
        for i in range(self.c_item.count()):
            if self.c_item.itemData(i).get('id') == item_id:
                self.c_item.setCurrentIndex(i); return

    def _refresh_data_for_item(self):
        is_entry = self.t_type.startswith('ورود') or self.t_type == 'برگشت'
        self.mode_stack.setCurrentIndex(1 if is_entry else 0)

        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict): 
            self.btn_ok.setEnabled(False) # اگر آیتم معتبر نیست دکمه غیرفعال شود
            return
        item_id = item_data.get('id')
        if not item_id: 
            self.btn_ok.setEnabled(False)
            return

        # حالت خروج
        self.c_stock_record.blockSignals(True)
        self.c_stock_record.clear()
        stock_records = self.db.stock_breakdown(item_id)
        if not stock_records:
            self.c_stock_record.addItem("این کالا در انبار موجودی ندارد!", None)
        else:
            for rec in stock_records:
                expiry_str = to_shamsi(rec['expiry_date']) if rec['expiry_date'] else 'ندارد'
                display_text = f"{rec['loc']} | بچ: {rec['batch_no']} | انقضا: {expiry_str} (موجودی: {rec['qty']})"
                self.c_stock_record.addItem(display_text, rec)
        self.c_stock_record.blockSignals(False)
        
        # حالت ورود
        self.c_loc_entry.blockSignals(True)
        self.c_loc_entry.clear()
        locations = self.db.list_locations(exclude_warehouses=['Production'])
        for loc in locations: self.c_loc_entry.addItem(loc['loc_label'], loc['id'])
        self.c_loc_entry.blockSignals(False)
        
        # فراخوانی متدهای آپدیت ثانویه
        if is_entry:
            self._refresh_entry_batches()
            self.btn_ok.setEnabled(True) # در حالت ورود دکمه همیشه فعال است
        else:
            self._on_stock_record_change()

    def _refresh_entry_batches(self):
        self.c_batch_entry.clear()
        item_data = self.c_item.currentData()
        loc_id = self.c_loc_entry.currentData()
        if not isinstance(item_data, dict) or loc_id is None: return

        item_id = item_data.get('id')
        query = "SELECT DISTINCT batch_no FROM stock WHERE item_id = %s AND location_id = %s AND qty > 0"
        batches_in_loc = self.db.execute_query(query, (item_id, loc_id))
        for batch in batches_in_loc:
            self.c_batch_entry.addItem(batch['batch_no'])
            

                                        
# این کلاس کاملاً جدید را به فایل کد خود اضافه کنید

class AddStockRowDialog(QtWidgets.QDialog):
    """یک دیالوگ کمکی برای افزودن ردیف موجودی اولیه به پنجره تعریف کالا."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن ردیف موجودی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.loc_combo = QtWidgets.QComboBox()
        self.batch_edit = QtWidgets.QLineEdit()
        self.qty_edit = QtWidgets.QLineEdit()
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 1e9, 3))
        self.expiry_edit = QtWidgets.QLineEdit()
        self.expiry_edit.setInputMask("0000/00/00;_")
        self.expiry_edit.setPlaceholderText("اختیاری: 1404/01/20")

        layout.addRow("لوکیشن:", self.loc_combo)
        layout.addRow("شماره بچ:", self.batch_edit)
        layout.addRow("مقدار:", self.qty_edit)
        layout.addRow("تاریخ انقضا:", self.expiry_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

        # پر کردن لیست لوکیشن‌ها
        for loc in self.db.list_locations(exclude_warehouses=['Production']):
            self.loc_combo.addItem(loc['loc_label'], loc['id'])

    def get_data(self):
        """داده‌های وارد شده توسط کاربر را برمی‌گرداند."""
        if not all([self.loc_combo.currentData(), self.batch_edit.text().strip(), self.qty_edit.text()]):
            return None
            
        try:
            qty = float(self.qty_edit.text())
            if qty <= 0: return None

            expiry_date = None
            date_str = self.expiry_edit.text().strip()
            if date_str and '_' not in date_str:
                y, m, d = map(int, date_str.split('/'))
                expiry_date = jd.date(y, m, d).togregorian()

            return {
                "loc_id": self.loc_combo.currentData(),
                "loc_label": self.loc_combo.currentText(),
                "batch_no": self.batch_edit.text().strip(),
                "qty": qty,
                "expiry_date": expiry_date
            }
        except (ValueError, TypeError):
            return None
        
        
                                                

        
# ------------------------------------------------------------
# کلاس LocationDialog  (اصلاح شده)
# ------------------------------------------------------------
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QTableWidget, QTableWidgetItem,
    QPushButton, QHBoxLayout, QMessageBox, QHeaderView
)
from PyQt5.QtGui import QFont
from PyQt5.QtCore import Qt

import psycopg2.errors # این ایمپورت را در بالای فایل خود اضافه کنید

# کلاس LocationDialog را به طور کامل با این نسخه ساده جایگزین کنید
class LocationDialog(QtWidgets.QDialog):
    """
    مدیریت ساده لوکیشن‌های انبار.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle("مدیریت مکان‌ها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(600, 500)
        main = QtWidgets.QVBoxLayout(self)

        self.tbl = QtWidgets.QTableWidget(0, 5)
        self.tbl.setHorizontalHeaderLabels(["ID", "انبار", "راهرو (Rack)", "قفسه (Shelf)", "طبقه (Bin)"])
        self.tbl.setColumnHidden(0, True)
        self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl.setAlternatingRowColors(True)
        self.tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        main.addWidget(self.tbl, 1)

        form_group = QtWidgets.QGroupBox("افزودن لوکیشن جدید")
        f = QtWidgets.QFormLayout(form_group)
        self.e_wh   = QtWidgets.QLineEdit("Main")
        self.e_rack = QtWidgets.QLineEdit()
        self.e_shelf = QtWidgets.QLineEdit()
        self.e_bin  = QtWidgets.QLineEdit()
        f.addRow("انبار:",  self.e_wh)
        f.addRow("راهرو (Rack):",  self.e_rack)
        f.addRow("قفسه (Shelf):",   self.e_shelf)
        f.addRow("طبقه (Bin):",   self.e_bin)
        main.addWidget(form_group)

        h = QtWidgets.QHBoxLayout()
        btn_add   = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن")
        btn_del   = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف")
        btn_show  = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-information"), " نمایش اقلام")
        h.addWidget(btn_add); h.addWidget(btn_del); h.addWidget(btn_show); h.addStretch()
        main.addLayout(h)

        btn_add.clicked.connect(self._add_loc)
        btn_del.clicked.connect(self._del_loc)
        btn_show.clicked.connect(self._show_items)
        
        self._load()
        
    # BEGIN REWRITE: LocationDialog._load  [REF-TAG: LocationDialog._load#2]
    def _load(self):
        """
        نوسازی لیست لوکیشن‌ها در جدول:
        - ستون «نام» (label) از فیلد loc_label پر می‌شود تا بلافاصله بعد از افزودن قابل‌دیدن باشد.
        - لوکیشن‌های مربوط به انبار تولید (Production و Production_*) در این نما نمایش داده نمی‌شوند.
        """
        # جلوگیری از پرش و ترتیب‌گیری هنگام پرکردن
        try:
            self.tbl.setSortingEnabled(False)
        except Exception:
            pass

        # جدول را تمیز بچینیم (ID مخفی + «نام» + سایر ستون‌ها)
        self.tbl.clear()
        self.tbl.setColumnCount(6)
        self.tbl.setHorizontalHeaderLabels(["ID", "نام", "انبار", "راهرو (Rack)", "قفسه (Shelf)", "طبقه (Bin)"])
        self.tbl.setColumnHidden(0, True)
        self.tbl.setRowCount(0)

        rows = self.db.list_locations() or []
        for rec in rows:
            wh = str(rec.get("wh", "") or "")
            # انبار تولید مستقل است و در این لیست نمایش داده نمی‌شود
            if wh == "Production" or wh.startswith("Production_"):
                continue

            r = self.tbl.rowCount()
            self.tbl.insertRow(r)

            # برچسب خوانا؛ اگر نبود، از اجزاء بسازیم
            lbl = rec.get("loc_label") or f"{wh}|{rec.get('rack','')}-{rec.get('shelf','')}-{rec.get('bin','')}"
            self.tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(str(rec.get("id", ""))))
            self.tbl.setItem(r, 1, QtWidgets.QTableWidgetItem(lbl))
            self.tbl.setItem(r, 2, QtWidgets.QTableWidgetItem(wh))
            self.tbl.setItem(r, 3, QtWidgets.QTableWidgetItem(str(rec.get("rack", ""))))
            self.tbl.setItem(r, 4, QtWidgets.QTableWidgetItem(str(rec.get("shelf", ""))))
            self.tbl.setItem(r, 5, QtWidgets.QTableWidgetItem(str(rec.get("bin", ""))))

        # بهبود ظاهر/کاربری
        try:
            self.tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
            self.tbl.resizeRowsToContents()
            self.tbl.setAlternatingRowColors(True)
            self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            self.tbl.setSortingEnabled(True)
        except Exception:
            pass
    # END REWRITE: LocationDialog._load

    # BEGIN REWRITE: LocationDialog._add_loc  [REF-TAG: LocationDialog._add_loc#4]
    def _add_loc(self):
        wh    = self.e_wh.text().strip()
        rack  = self.e_rack.text().strip()
        shelf = self.e_shelf.text().strip()
        bin_  = (self.e_bin.text().strip() or "1")  # پیش‌فرض امن برای Bin

        # اعتبارسنجی حداقلی
        if not (wh and rack and shelf):
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", "نام انبار، راهرو و قفسه اجباری است.")
            return

        # درج در DB با اتکا به زیرساخت موجود
        try:
            wh_id  = self.db.add_warehouse(wh)
            new_id = self.db.add_location(wh_id, rack, shelf, bin_)  # ← ID رکورد تازه
            if self.toast:
                self.toast.show_message("✔ لوکیشن جدید با موفقیت ثبت شد.", "success")
        except ValueError as ve:
            # خطای تکراری‌بودن یا پیام‌های خوانا از لایه DB
            QtWidgets.QMessageBox.warning(self, "خطا", str(ve))
            return
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت لوکیشن:\n{e}")
            return

        # رفرش و آوردن ردیف تازه در دید (حتی با سورت روشن)
        prev_sort = False
        try:
            prev_sort = self.tbl.isSortingEnabled()
            if prev_sort:
                self.tbl.setSortingEnabled(False)
        except Exception:
            pass

        self._load()

        try:
            if new_id is not None:
                for r in range(self.tbl.rowCount()):
                    it_id = self.tbl.item(r, 0)  # ستون ID (مخفی یا قابل‌مشاهده)
                    if it_id and it_id.text() == str(new_id):
                        self.tbl.selectRow(r)
                        try:
                            self.tbl.scrollToItem(it_id, QtWidgets.QAbstractItemView.PositionAtCenter)
                        except Exception:
                            pass
                        break
        finally:
            try:
                if prev_sort:
                    self.tbl.setSortingEnabled(True)
            except Exception:
                pass

        # پاک‌سازی فرم
        self.e_rack.clear(); self.e_shelf.clear(); self.e_bin.clear()
        self.e_rack.setFocus()
    # END REWRITE: LocationDialog._add_loc

    # BEGIN REWRITE: LocationDialog._del_loc  [REF-TAG: LocationDialog._del_loc#1]
    def _del_loc(self):
        row = self.tbl.currentRow()
        if row < 0:
            return

        loc_id_item = self.tbl.item(row, 0)
        if not loc_id_item:
            return

        loc_id = int(loc_id_item.text())

        # جلوگیری از حذف لوکیشن دارای موجودی
        try:
            if len(self.db.items_in_location(loc_id)) > 0:
                QtWidgets.QMessageBox.warning(self, "خطا", "این مکان حاوی کالا است و قابل حذف نیست.")
                return
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"عدم دسترسی به موجودی این مکان:\n{e}")
            return

        if QtWidgets.QMessageBox.question(self, "تایید حذف", "آیا از حذف مطمئنید؟") != QtWidgets.QMessageBox.Yes:
            return

        try:
            # بدون افزودن متد جدید در DB؛ با همان زیرساخت موجود:
            self.db.execute_query("DELETE FROM locations WHERE id = %s", (loc_id,))
            if self.toast:
                self.toast.show_message("✔ لوکیشن با موفقیت حذف شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در حذف لوکیشن:\n{e}")
            return

        # نوسازی جدول
        self._load()
    # END REWRITE: LocationDialog._del_loc

    def _show_items(self):
        row = self.tbl.currentRow()
        if row < 0: return
        loc_id = int(self.tbl.item(row, 0).text())
        StockAtLocationDialog(self.db, loc_id).exec_()
                

        


class StockAtLocationDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, loc_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.loc_id = loc_id
        self.setWindowTitle('Stock at Location')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(480, 360)

        v = QtWidgets.QVBoxLayout(self)

        loc_lbl = (db.loc_label(loc_id) or '').strip()
        header = QtWidgets.QLabel(loc_lbl or f'Location ID: {loc_id}')
        header.setStyleSheet('font-weight:600; padding:6px 0;')
        header.setAlignment(Qt.AlignCenter)
        v.addWidget(header)

        self.tbl = QtWidgets.QTableWidget(0, 3)
        self.tbl.setHorizontalHeaderLabels(['Item', 'Qty', 'Unit'])
        self.tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.tbl.horizontalHeader().setDefaultAlignment(Qt.AlignCenter)
        self.tbl.verticalHeader().setVisible(False)
        self.tbl.setAlternatingRowColors(True)
        self.tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        v.addWidget(self.tbl, 1)

        self._populate()

    def _populate(self):
        rows = self.db.items_in_location(self.loc_id) or []
        self.tbl.setRowCount(len(rows))
        for r, rec in enumerate(rows):
            name_item = QtWidgets.QTableWidgetItem(str(rec.get('name', '')))
            qty_item = QtWidgets.QTableWidgetItem(str(rec.get('qty', '')))
            unit_item = QtWidgets.QTableWidgetItem(str(rec.get('unit', '')))
            qty_item.setTextAlignment(Qt.AlignCenter)
            unit_item.setTextAlignment(Qt.AlignCenter)
            self.tbl.setItem(r, 0, name_item)
            self.tbl.setItem(r, 1, qty_item)
            self.tbl.setItem(r, 2, unit_item)
        self.tbl.resizeColumnsToContents()

class HeatMapDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent); self.db = db
        self.setWindowTitle('Heat-Map ظرفیت رک‌ها')
        self.resize(420, 320)

        loads = db.rack_loads()
        if not loads:
            QtWidgets.QLabel('داده‌ای نیست', self).show(); return

        v = QtWidgets.QVBoxLayout(self)

        # ـــــــ آماده‌سازی داده ـــــــ
        labels = [fa(l['loc']) for l in loads]     # ← عبور از تابع rtl
        vals   = [l['load'] for l in loads]
        colors = ['#c62828' if v > 80 else '#f9a825' if v > 50 else '#2e7d32'
                  for v in vals]

        # ـــــــ نمودار ـــــــ
        fig, ax = plt.subplots(figsize=(4, 3), dpi=100)
        ax.barh(labels, vals, color=colors)
        ax.set_xlabel(fa('واحد'))
        ax.set_title(fa('بار رک‌ها (ظرفیت فرضی ۱۰۰)'))
        ax.tick_params(axis='y', labelsize=9)

        fig.tight_layout()
        v.addWidget(Canvas(fig))
        
# این کلاس جدید را به ابتدای فایل اضافه کنید
class ClickableFrame(QtWidgets.QFrame):
    """یک QFrame که سیگنال کلیک شدن دارد"""
    clicked = QtCore.pyqtSignal()
    def mouseReleaseEvent(self, event):
        if self.rect().contains(event.pos()):
            self.clicked.emit()
        super().mouseReleaseEvent(event)

    
# کل کلاس Pie را با این نسخه جایگزین کنید
class Pie(Canvas):
    """Pie chart فارسی‌شده با ظاهر بهبودیافته و خوانایی بالا"""
    def __init__(self, data, click_cb):
        fig, ax = plt.subplots(figsize=(5, 5), dpi=90, constrained_layout=True)

        labels = [fa(d[0]) for d in data]
        sizes  = [d[1] for d in data]
        colors = plt.cm.Pastel2(range(len(sizes)))

        wedges, texts, autotexts = ax.pie(
            sizes,
            labels=labels,
            autopct='%1.1f%%',
            startangle=90,
            pctdistance=0.85,
            colors=colors,
            wedgeprops=dict(width=0.4, edgecolor='w')
        )
        
        plt.setp(texts, size=10, weight="bold", color="#34495e")
        # اصلاح‌شده: تغییر رنگ و اندازه فونت درصدها
        plt.setp(autotexts, size=10, weight="bold", color="#2c3e50")

        ax.axis('equal')
        
        for w in wedges:
            w.set_picker(True)

        super().__init__(fig)
        self.mpl_connect('pick_event', lambda ev: click_cb(ev.artist.get_label()) if ev.artist else None)
        
class AttachMultipleFilesDialog(QtWidgets.QDialog):
    """دیالوگی برای مدیریت (افزودن/حذف/مشاهده) چندین فایل پیوست."""
    def __init__(self, initial_files: list, parent=None):
        super().__init__(parent)
        self.setWindowTitle("مدیریت پیوست‌ها")
        self.setMinimumSize(450, 300)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        self.file_list = initial_files.copy() if initial_files else []

        layout = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.itemDoubleClicked.connect(lambda item: QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(item.data(Qt.UserRole))))
        layout.addWidget(self.list_widget)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن فایل")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف فایل انتخاب شده")
        btn_layout.addWidget(btn_add)
        btn_layout.addWidget(btn_del)
        layout.addLayout(btn_layout)

        dialog_buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        dialog_buttons.accepted.connect(self.accept)
        dialog_buttons.rejected.connect(self.reject)
        layout.addWidget(dialog_buttons)

        btn_add.clicked.connect(self._add_files)
        btn_del.clicked.connect(self._remove_file)
        
        self._refresh_list()

    def _refresh_list(self):
        self.list_widget.clear()
        for f_path in self.file_list:
            item = QtWidgets.QListWidgetItem(QtGui.QIcon.fromTheme("document-properties"), Path(f_path).name)
            item.setData(Qt.UserRole, f_path)
            self.list_widget.addItem(item)
    
    def _add_files(self):
        paths, _ = QtWidgets.QFileDialog.getOpenFileNames(self, "انتخاب یک یا چند فایل")
        if paths:
            for path in paths:
                if path not in self.file_list:
                    self.file_list.append(path)
            self._refresh_list()

    def _remove_file(self):
        selected_items = self.list_widget.selectedItems()
        if not selected_items: return
        
        file_to_remove = selected_items[0].data(Qt.UserRole)
        if file_to_remove in self.file_list:
            self.file_list.remove(file_to_remove)
        self._refresh_list()

    def get_final_files(self):
        return self.file_list
                        
class FormsPage(QtWidgets.QWidget):
    """
    نسخه نهایی (V12.0): این صفحه حالا فقط فرم‌های عمومی (GENERAL) را مدیریت می‌کند.
    """
    def __init__(self, db: DB, usr: str, viewer: bool, main_window, parent=None):
        super().__init__(parent)
        self.db, self.usr, self.viewer, self.main_window = db, usr, viewer, main_window
        self.user_id = self.main_window.user_id
        self.user_role = self.main_window.role
        self._is_programmatically_changing = False
        self.last_edited_row = -1

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.addWidget(QtWidgets.QLabel("فرم‌های عمومی شما", objectName="subtitleLabel"))
        self.lst_defs = QtWidgets.QListWidget()
        self.lst_defs.itemSelectionChanged.connect(self._on_form_selected)
        right_layout.addWidget(self.lst_defs)
        form_actions_layout = QtWidgets.QHBoxLayout()
        btn_new_def = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " فرم جدید"); btn_new_def.setProperty("class", "primary")
        btn_del_def = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف فرم"); btn_del_def.setProperty("class", "danger")
        btn_new_def.clicked.connect(self._add_form_def)
        btn_del_def.clicked.connect(self._delete_form_def)
        form_actions_layout.addWidget(btn_new_def); form_actions_layout.addWidget(btn_del_def)
        right_layout.addLayout(form_actions_layout)
        splitter.addWidget(right_panel)

        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.entries_title = QtWidgets.QLabel("رکوردهای ثبت شده", objectName="subtitleLabel"); left_layout.addWidget(self.entries_title)
        action_bar = QtWidgets.QHBoxLayout()
        self.btn_new_entry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " ثبت رکورد جدید"); self.btn_new_entry.clicked.connect(self._new_entry)
        btn_del_entry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف رکوردهای انتخابی"); btn_del_entry.clicked.connect(self._delete_entry)
        action_bar.addWidget(self.btn_new_entry)
        action_bar.addStretch()
        action_bar.addWidget(btn_del_entry)
        left_layout.addLayout(action_bar)

        self.tbl_entries = QtWidgets.QTableWidget()
        self.tbl_entries.currentItemChanged.connect(self._on_current_item_changed)
        add_filter_export_tools(self.tbl_entries, left_layout)
        left_layout.addWidget(self.tbl_entries, 1)
        splitter.addWidget(left_panel)
        splitter.setSizes([250, 750])
        self._refresh_form_defs()

    def _refresh_form_defs(self):
        self.lst_defs.clear(); self.tbl_entries.setRowCount(0); self.btn_new_entry.setDisabled(False)
        forms = self.db.list_form_defs_by_type(form_type='GENERAL', user_id=self.user_id, is_admin=(self.user_role == 'Admin'))
        for fd in forms:
            item = QtWidgets.QListWidgetItem(fd['name'])
            item.setData(Qt.UserRole, fd['id'])
            self.lst_defs.addItem(item)
        if self.lst_defs.count() > 0:
            self.lst_defs.setCurrentRow(0)
        else:
            self.entries_title.setText("رکوردهای ثبت شده")
    
    # <<< FIX
    def _add_form_def(self):
        # دسترسی: ساخت فرم فقط برای کاربرانی که مجوز صفحهٔ فرم‌ها را دارند
        if not self.main_window.has_permission('page:view:forms'):
            self.main_window.toast.show_message("شما دسترسی لازم برای ایجاد فرم جدید را ندارید.", "error")
            return

        # نکته مهم: نوع پیش‌فرض باید GENERAL باشد
        dlg = AdvancedFormBuilderDialog(
            self.db,
            self.user_id,
            form_id=None,
            default_form_type='GENERAL',
            parent=self.main_window  # برای اینکه toast داخل دیالوگ هم کار کند
        )

        if dlg.exec_():
            # قبلاً self.toast بود که در این کلاس تعریف نشده و خطا می‌داد
            self.main_window.toast.show_message("✔ فرم عمومی جدید با موفقیت تعریف شد.", "success")
            self._refresh_form_defs()
                                        
    def _load_entries(self):
        # این متد از قبل اصلاح شده و صحیح است
        selected = self.lst_defs.selectedItems()
        self.tbl_entries.blockSignals(True)
        self.tbl_entries.clear(); self.tbl_entries.setRowCount(0)
        if not selected:
            self.entries_title.setText("رکوردهای ثبت شده"); self.tbl_entries.setColumnCount(0); self.tbl_entries.blockSignals(False); return
        form_id = selected[0].data(Qt.UserRole); form_name = selected[0].text()
        self.entries_title.setText(f"رکوردهای فرم: {form_name}")
        flds = self.db.get_form_fields(form_id)
        base_query = "SELECT e.*, u.username FROM form_entries e LEFT JOIN users u ON e.user_id = u.id WHERE e.form_id=%s"
        params = [form_id]
        if self.user_role != 'Admin':
            base_query += " AND e.user_id = %s"
            params.append(self.user_id)
        base_query += " ORDER BY e.id DESC"
        entries = self.db.execute_query(base_query, tuple(params))
        headers = [f['label'] for f in flds] + ['عملیات / کاربر', 'تاریخ ثبت', 'ID']
        self.tbl_entries.setColumnCount(len(headers)); self.tbl_entries.setHorizontalHeaderLabels(headers)
        self.tbl_entries.setColumnHidden(len(headers) - 1, True); self.tbl_entries.setRowCount(len(entries))
        for r, rec in enumerate(entries):
            raw_data = rec.get('data'); data_dict = json.loads(raw_data) if isinstance(raw_data, str) else (raw_data or {});
            data_dict['username'] = rec.get('username', 'نامشخص'); data_dict['timestamp'] = to_shamsi(rec['ts']); data_dict['entry_id'] = rec['id']
            self._populate_row(r, flds, data_dict, is_new_unsaved_row=False)
        header = self.tbl_entries.horizontalHeader();
        for i in range(len(headers)): header.setSectionResizeMode(i, QtWidgets.QHeaderView.Stretch if i < len(flds) else QtWidgets.QHeaderView.ResizeToContents)
        self.tbl_entries.resizeRowsToContents(); self.tbl_entries.blockSignals(False)

    def _populate_row(self, row_idx, flds, data_dict={}, is_new_unsaved_row=False):
            """
            نسخه نهایی: با استفاده از functools.partial مشکل اتصال دکمه پیوست را حل می‌کند.
            و سیگنال ذخیره‌سازی را برای فیلد تاریخ مجدداً فعال می‌کند.
            """
            from functools import partial

            self._is_programmatically_changing = True
            
            for c, fld in enumerate(flds):
                field_type, field_label = fld.get('type'), fld.get('label')
                value = data_dict.get(field_label, '')
                if field_type in ['date', 'file']:
                    container = QtWidgets.QWidget(); layout = QtWidgets.QHBoxLayout(container); layout.setContentsMargins(0,0,0,0)
                    if field_type == 'date':
                        widget = QtWidgets.QLineEdit(str(value)); widget.setInputMask("0000/00/00;_"); widget.setAlignment(Qt.AlignCenter)
                        # --- اصلاح کلیدی: اتصال مجدد سیگنال برای ذخیره تاریخ ---
                        widget.editingFinished.connect(partial(self._commit_row_data, row_idx))
                    elif field_type == 'file':
                        file_list = value if isinstance(value, list) else []; btn_text = f"پیوست‌ها ({len(file_list)})"
                        widget = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-attachment"), btn_text)
                        widget.setProperty("file_paths", file_list); widget.setProperty("class", "cell-button")
                        # --- اصلاح کلیدی: استفاده از partial برای اتصال ۱۰۰٪ صحیح ---
                        widget.clicked.connect(partial(self._open_multi_file_dialog, row_idx, c))
                    layout.addWidget(widget); self.tbl_entries.setCellWidget(row_idx, c, container)
                else:
                    self.tbl_entries.setItem(row_idx, c, QtWidgets.QTableWidgetItem(str(value)))
            
            user_col_idx = len(flds)
            if is_new_unsaved_row:
                container = QtWidgets.QWidget(); layout = QtWidgets.QHBoxLayout(container)
                layout.setContentsMargins(2, 2, 2, 2); layout.setAlignment(QtCore.Qt.AlignCenter)
                btn_commit = QtWidgets.QPushButton("✔ ثبت"); btn_commit.setProperty("class", "primary")
                btn_commit.setStyleSheet("font-size: 9pt; padding: 2px 6px;");
                btn_commit.clicked.connect(partial(self._commit_row_data, row_idx))
                layout.addWidget(btn_commit); self.tbl_entries.setCellWidget(row_idx, user_col_idx, container)
                self.tbl_entries.setItem(row_idx, user_col_idx + 1, QtWidgets.QTableWidgetItem("")); self.tbl_entries.setItem(row_idx, user_col_idx + 2, QtWidgets.QTableWidgetItem(""))
            else:
                self.tbl_entries.removeCellWidget(row_idx, user_col_idx)
                self.tbl_entries.setItem(row_idx, user_col_idx, QtWidgets.QTableWidgetItem(data_dict.get('username', '')))
                self.tbl_entries.setItem(row_idx, user_col_idx + 1, QtWidgets.QTableWidgetItem(data_dict.get('timestamp', '')))
                self.tbl_entries.setItem(row_idx, user_col_idx + 2, QtWidgets.QTableWidgetItem(str(data_dict.get('entry_id', ''))))

            self._is_programmatically_changing = False
        
    def _on_current_item_changed(self, current, previous):
        if self._is_programmatically_changing or not previous:
            return
        id_col_idx = self.tbl_entries.columnCount() - 1
        id_item = self.tbl_entries.item(previous.row(), id_col_idx)
        if id_item and id_item.text() == "":
             return
        if current is None or previous.row() != current.row():
            self._commit_row_data(previous.row())

    def _on_form_selected(self):
        if self.last_edited_row != -1:
            self._commit_row_data(self.last_edited_row)
            self.last_edited_row = -1
        self._load_entries()
        
    def _commit_row_data(self, row):
        if row < 0: return
        try:
            form_id_item = self.lst_defs.currentItem()
            if not form_id_item: return
            form_id = form_id_item.data(Qt.UserRole)
            
            flds = self.db.get_form_fields(form_id)
            if self.tbl_entries.columnCount() == 0: return

            id_col_idx = len(flds) + 2
            id_item = self.tbl_entries.item(row, id_col_idx)
            entry_id = int(id_item.text()) if id_item and id_item.text().isdigit() else None
            
            data_to_save = {}
            is_row_empty = True
            for c, fld in enumerate(flds):
                field_label, field_type, value = fld['label'], fld['type'], ""
                widget = self.tbl_entries.cellWidget(row, c)
                if widget:
                    inner_widget = widget.layout().itemAt(0).widget()
                    value = inner_widget.property("file_paths") or [] if field_type == 'file' else inner_widget.text()
                else:
                    item = self.tbl_entries.item(row, c)
                    value = item.text() if item else ""
                
                data_to_save[field_label] = value
                if value or value == 0:
                    if str(value).strip() and value != []:
                        is_row_empty = False
            
            if is_row_empty and not entry_id:
                return

            json_data = json.dumps(data_to_save, ensure_ascii=False)
            new_id = self.db.add_or_update_form_entry(form_id, self.user_id, json_data, entry_id)
            
            if not entry_id and new_id:
                rec = self.db.execute_query("SELECT e.*, u.username FROM form_entries e LEFT JOIN users u ON e.user_id = u.id WHERE e.id=%s", (new_id,), fetch_one=True)
                data_dict = rec.get('data') or {}
                data_dict['username'] = rec.get('username', 'نامشخص'); data_dict['timestamp'] = to_shamsi(rec['ts']); data_dict['entry_id'] = rec['id']
                self._populate_row(row, flds, data_dict, is_new_unsaved_row=False)
            
            self.btn_new_entry.setDisabled(False)

        except Exception as e:
            self.main_window.toast.show_message(f"خطا در هنگام ذخیره: {e}", "critical")
            print(f"ERROR during commit: {traceback.format_exc()}")
            self.btn_new_entry.setDisabled(False)
            
                
    def _new_entry(self):
            """یک ردیف جدید و خالی برای ورود اطلاعات با ارتفاع صحیح ایجاد می‌کند."""
            user_col_idx = self.tbl_entries.columnCount() - 3
            if self.tbl_entries.rowCount() > 0 and isinstance(self.tbl_entries.cellWidget(0, user_col_idx), QtWidgets.QWidget):
                self.main_window.toast.show_message("لطفاً ابتدا ردیف جدید فعلی را ثبت کنید.", "info"); return

            selected = self.lst_defs.selectedItems()
            if not selected: self.main_window.toast.show_message("ابتدا یک فرم را از لیست انتخاب کنید.", "warning"); return
            
            flds = self.db.get_form_fields(selected[0].data(Qt.UserRole))
            self.tbl_entries.blockSignals(True)
            self.tbl_entries.insertRow(0)
            
            self._populate_row(0, flds, is_new_unsaved_row=True)
            
            # --- اصلاح کلیدی: تنظیم خودکار ارتفاع برای ردیف جدید ---
            self.tbl_entries.resizeRowsToContents()
            
            self.tbl_entries.blockSignals(False)
            self.tbl_entries.setCurrentCell(0, 0)
            self.btn_new_entry.setDisabled(True)
        
    def _delete_entry(self):
        self._commit_row_data(self.tbl_entries.currentRow())
        selected_items = self.tbl_entries.selectedItems()
        if not selected_items: self.main_window.toast.show_message("لطفاً ابتدا یک یا چند رکورد را برای حذف انتخاب کنید.", "warning"); return
        
        rows_to_delete = sorted(list(set(item.row() for item in selected_items)), reverse=True)
        ids_to_delete = []
        id_col_idx = self.tbl_entries.columnCount() - 1
        
        for row in rows_to_delete:
            id_item = self.tbl_entries.item(row, id_col_idx)
            if not id_item or not id_item.text().isdigit():
                self.tbl_entries.removeRow(row)
                self.btn_new_entry.setDisabled(False) 
                continue
            ids_to_delete.append(int(id_item.text()))
        
        if not ids_to_delete: return

        if QtWidgets.QMessageBox.question(self, 'تایید حذف', f"آیا از حذف {len(ids_to_delete)} رکورد مطمئنید؟") == QtWidgets.QMessageBox.Yes:
            self.db.delete_form_entries_many(ids_to_delete)
            self._load_entries()
            self.main_window.toast.show_message(f"{len(ids_to_delete)} رکورد با موفقیت حذف شد.", "success")
            
    def _open_multi_file_dialog(self, row, col):
        container = self.tbl_entries.cellWidget(row, col)
        if not container: return
        button = container.layout().itemAt(0).widget()
        initial_files = button.property("file_paths") or []
        dlg = AttachMultipleFilesDialog(initial_files, self)
        if dlg.exec_():
            new_files = dlg.get_final_files(); button.setProperty("file_paths", new_files)
            button.setText(f"پیوست‌ها ({len(new_files)})")

    def _delete_form_def(self):
        # --- اصلاح کلیدی: چک کردن دسترسی صحیح ---
        if not self.main_window.has_permission('page:view:forms'): 
            self.main_window.toast.show_message("شما دسترسی لازم برای حذف فرم را ندارید.", "error"); return
        selected = self.lst_defs.selectedItems()
        if not selected: self.main_window.toast.show_message("ابتدا یک فرم را برای حذف انتخاب کنید.", "warning"); return
        fid = selected[0].data(Qt.UserRole)
        if QtWidgets.QMessageBox.question(self, 'تایید حذف', 'کل این فرم و تمام رکوردهای آن برای همیشه حذف شود؟ این عمل غیرقابل بازگشت است.', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No) == QtWidgets.QMessageBox.Yes:
            self.db.delete_form_def(fid); self._refresh_form_defs(); self.main_window.toast.show_message("✔ فرم با موفقیت حذف شد.", "info")

                                                
                        
            
class StockLocationsDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, item_id: int, parent=None):
        super().__init__(parent)
        self.setWindowTitle('مکان‌هاى نگهدارى کالا')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        v = QtWidgets.QVBoxLayout(self)
        tbl = QtWidgets.QTableWidget(); v.addWidget(tbl)
        tbl.setColumnCount(2)
        tbl.setHorizontalHeaderLabels(['لوکیشن', 'مقدار'])
        tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        tbl.horizontalHeader().setDefaultAlignment(Qt.AlignCenter)
        tbl.setStyleSheet("QTableWidget::item{ qproperty-alignment:AlignCenter; }")

        rows = db.stock_breakdown(item_id)
        tbl.setRowCount(len(rows))
        for r, rec in enumerate(rows):
            tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(rec['loc']))
            tbl.setItem(r, 1, QtWidgets.QTableWidgetItem(str(rec['qty'])))
        tbl.resizeColumnsToContents()
        
        
            
class BOMAttachDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, bom_id: int, parent=None):
        super().__init__(parent)
        self.db, self.bom_id = db, bom_id
        self.setWindowTitle('پیوست‌های مصرف')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(380, 320)

        v = QtWidgets.QVBoxLayout(self)
        self.lst = QtWidgets.QListWidget(); v.addWidget(self.lst, 1)

        h = QtWidgets.QHBoxLayout(); v.addLayout(h)
        btn_scan = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("scanner"), " اسکن"); h.addWidget(btn_scan)
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("add"), " افزودن فایل"); h.addWidget(btn_add)
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("delete"), " حذف");   h.addWidget(btn_del)
        h.addStretch()
        btn_close = QtWidgets.QPushButton('بستن');  h.addWidget(btn_close)

        btn_scan.clicked.connect(self._scan_and_add)
        btn_add.clicked.connect(self._add)
        btn_del.clicked.connect(self._delete)
        btn_close.clicked.connect(self.accept)

        self.lst.itemDoubleClicked.connect(
            lambda itm: QtGui.QDesktopServices.openUrl(
                QtCore.QUrl.fromLocalFile(itm.data(Qt.UserRole))))

        self._load()

    def _load(self):
        self.lst.clear()
        for rec in self.db.list_bom_files(self.bom_id):
            itm = QtWidgets.QListWidgetItem(Path(rec['path']).name)
            itm.setData(Qt.UserRole,   rec['path'])
            itm.setData(Qt.UserRole+1, rec['id'])
            self.lst.addItem(itm)

    def _add(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if not path:
            return
        self.db.add_bom_file(self.bom_id, path)
        self._load()

    def _scan_and_add(self):
        scanned_file_path = scan_document(self)
        if scanned_file_path:
            self.db.add_bom_file(self.bom_id, scanned_file_path)
            self._load()

    def _delete(self):
        itm = self.lst.currentItem()
        if not itm: return
        if QtWidgets.QMessageBox.question(self, 'حذف', 'مطمئنید؟') != QtWidgets.QMessageBox.Yes:
            return
        fid = itm.data(Qt.UserRole+1)
        self.db.delete_bom_file(fid)
        self._load()        

class RecipeManagementDialog(QtWidgets.QDialog):
    """پنجره جامع مدیریت فرمول‌ها (نسخه نهایی با رفع خطاها)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.current_recipe_data = None
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle("مدیریت جامع فرمول‌های ساخت")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(850, 650)

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel); right_layout.addWidget(QtWidgets.QLabel("<b>لیست محصولات مادر و فرمول‌ها</b>")); self.recipe_search_edit = QtWidgets.QLineEdit(placeholderText="🔍 جستجو..."); right_layout.addWidget(self.recipe_search_edit); self.recipe_tree = QtWidgets.QTreeWidget(); self.recipe_tree.setHeaderHidden(True); right_layout.addWidget(self.recipe_tree); splitter.addWidget(right_panel)
        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel); mode_group = QtWidgets.QGroupBox("نوع تعریف"); mode_layout = QtWidgets.QHBoxLayout(mode_group); self.mode_master = QtWidgets.QRadioButton("دستور ساخت مادر (تعریف نسبت)"); self.mode_component = QtWidgets.QRadioButton("فرمول ساخت جزء (تعریف مواد اولیه)"); mode_layout.addWidget(self.mode_master); mode_layout.addWidget(self.mode_component); left_layout.addWidget(mode_group); self.details_stack = QtWidgets.QStackedWidget(); left_layout.addWidget(self.details_stack, 1);
        self.master_panel = self._create_master_recipe_panel(); self.component_panel = self._create_component_recipe_panel(); self.details_stack.addWidget(self.master_panel); self.details_stack.addWidget(self.component_panel)
        main_btn_layout = QtWidgets.QHBoxLayout(); new_btn = QtWidgets.QPushButton("فرم جدید"); save_btn = QtWidgets.QPushButton("ذخیره/ایجاد نسخه جدید"); save_btn.setProperty("class", "primary"); main_btn_layout.addWidget(new_btn); main_btn_layout.addStretch(); main_btn_layout.addWidget(save_btn); left_layout.addLayout(main_btn_layout); splitter.addWidget(left_panel); splitter.setSizes([300, 550])

        self.recipe_search_edit.textChanged.connect(self._filter_recipe_tree); self.recipe_tree.itemSelectionChanged.connect(self.load_selected_recipe_details); self.mode_master.toggled.connect(lambda checked: self.details_stack.setCurrentIndex(0) if checked else None); self.mode_component.toggled.connect(lambda checked: self.details_stack.setCurrentIndex(1) if checked else None); new_btn.clicked.connect(self.clear_form_for_new); save_btn.clicked.connect(self.save_recipe_version)
        self.comp_parent_product_combo.currentIndexChanged.connect(self._update_component_outputs)
        self.comp_part_type_combo.currentIndexChanged.connect(self._update_component_outputs)
        self._populate_all_parent_product_combos(); self.load_recipe_tree(); self.mode_component.setChecked(True)
        self._ensure_recipe_code_preview("")

        
    # BEGIN ADD: RecipeManagementDialog._ensure_recipe_code_preview
    def _ensure_recipe_code_preview(self, recipe_code: str = None):
        """
        ایجاد/به‌روزرسانی فیلد «کد فرمول» در هر دو پنل (مادر و جزء).
        - اگر ویجت‌ها قبلاً ساخته شده باشند، فقط مقدارشان به‌روزرسانی می‌شود.
        - دکمهٔ «کپی» کنار هر فیلد اضافه می‌شود.
        - هیچ وابستگی جدیدی ندارد و با زیرساخت فعلی کار می‌کند.
        """
        from PyQt5 import QtWidgets

        def _ensure_on_form(form: QtWidgets.QFormLayout,
                            edit_attr: str,
                            btn_attr: str,
                            row_label: str):
            if not form:
                return None
            edit = getattr(self, edit_attr, None)
            btn  = getattr(self, btn_attr, None)
            if edit is None or btn is None:
                edit = QtWidgets.QLineEdit()
                edit.setReadOnly(True)
                edit.setPlaceholderText("—")
                edit.setCursorPosition(0)
                edit.setStyleSheet("font-family: monospace;")
                btn = QtWidgets.QPushButton("کپی")
                btn.setFixedWidth(56)

                row = QtWidgets.QWidget()
                h = QtWidgets.QHBoxLayout(row)
                h.setContentsMargins(0, 0, 0, 0)
                h.setSpacing(6)
                h.addWidget(edit, 1)
                h.addWidget(btn, 0)

                form.addRow(row_label, row)

                setattr(self, edit_attr, edit)
                setattr(self, btn_attr, btn)

                def _copy_now():
                    txt = edit.text().strip()
                    QtWidgets.QApplication.clipboard().setText(txt or "")
                    if getattr(self, "toast", None):
                        try: self.toast("کد فرمول کپی شد.", "success")
                        except Exception: pass
                btn.clicked.connect(_copy_now)
            return getattr(self, edit_attr)

        # --- پنل مادر ---
        master_form = None
        if hasattr(self, "master_panel") and isinstance(self.master_panel.layout(), QtWidgets.QFormLayout):
            master_form = self.master_panel.layout()
        master_edit = _ensure_on_form(master_form, "master_recipe_code_edit", "master_recipe_code_copy_btn", "کد فرمول:")

        # --- پنل جزء ---
        comp_form = None
        if hasattr(self, "component_panel") and isinstance(self.component_panel.layout(), QtWidgets.QVBoxLayout):
            lay = self.component_panel.layout()
            for i in range(lay.count()):
                it = lay.itemAt(i)
                if it and it.layout() and isinstance(it.layout(), QtWidgets.QFormLayout):
                    comp_form = it.layout()
                    break
        comp_edit = _ensure_on_form(comp_form, "comp_recipe_code_edit", "comp_recipe_code_copy_btn", "کد فرمول:")

        # مقداردهی (از ورودی یا از دادهٔ جاری)
        if recipe_code is None:
            code = ""
            d = getattr(self, "current_recipe_data", None) or {}
            props = d.get("properties")
            if isinstance(props, str):
                import json
                try:
                    props = json.loads(props or "{}")
                except Exception:
                    props = {}
            if isinstance(props, dict):
                code = props.get("recipe_code") or ""
            recipe_code = code

        for edit in (master_edit, comp_edit):
            if edit:
                edit.setText(recipe_code or "")
                edit.setCursorPosition(0)
    # END ADD: RecipeManagementDialog._ensure_recipe_code_preview

        
        
    def _attach_ratio_helpers(self):
        """
        ردیف کمکی نسبت اختلاط برای «فرمول مادر»:
        - هر ردیف قدیمی (قفل جمع/جمع درصد) را پاک می‌کند تا تکراری نشوند.
        - فقط یک ردیف نمایش می‌سازد که نسبت A:B و تبدیل درصدی را پیش‌نمایش می‌دهد.
        - سیگنال‌ها را یک‌بار وصل می‌کند و اگر هر دو مقدار صفر باشند، روی 1:1 تنظیم می‌کند.
        """
        from PyQt5 import QtWidgets

        panel = getattr(self, "master_panel", None)
        if panel is None or not isinstance(panel.layout(), QtWidgets.QFormLayout):
            return
        form: QtWidgets.QFormLayout = panel.layout()

        # 1) پاک‌سازی ردیف‌های کمکی قدیمی (برای رفع مشکل چندتا شدن)
        for i in reversed(range(form.rowCount())):
            fld = form.itemAt(i, QtWidgets.QFormLayout.FieldRole)
            if not fld:
                continue
            w = fld.widget()
            if not w:
                continue
            # اگر ردیف قبلی قفل/جمع بوده، حذفش کن
            remove = False
            for cb in w.findChildren(QtWidgets.QCheckBox):
                if "قفل جمع" in cb.text():
                    remove = True
                    break
            if not remove:
                for lb in w.findChildren(QtWidgets.QLabel):
                    if lb.text().strip().startswith("جمع"):
                        remove = True
                        break
            # همچنین اگر ردیف کمکی جدید ما قبلاً اضافه شده باشد، فقط یکی را نگه داریم
            if w.objectName() == "ratio_helpers_row":
                remove = True
            if remove:
                lbl = form.itemAt(i, QtWidgets.QFormLayout.LabelRole)
                if lbl and lbl.widget():
                    lbl.widget().deleteLater()
                w.deleteLater()
                form.removeRow(i)

        # 2) اگر ردیف کمکی نداریم، بسازیم
        if getattr(self, "_ratio_helpers_row_widget", None) is None:
            row_widget = QtWidgets.QWidget()
            row_widget.setObjectName("ratio_helpers_row")
            h = QtWidgets.QHBoxLayout(row_widget)
            h.setContentsMargins(0, 0, 0, 0)
            h.setSpacing(8)

            # فقط یک لیبل پیش‌نمایش (نسبت + درصد معادل)
            self.ratio_sum_label = QtWidgets.QLabel("")
            self.ratio_sum_label.setStyleSheet("color:#6c757d;")
            h.addWidget(self.ratio_sum_label)
            h.addStretch(1)

            form.addRow("", row_widget)
            self._ratio_helpers_row_widget = row_widget

        # 3) اتصال سیگنال‌ها فقط یک بار (و حذف اتصال‌های قبلی)
        if hasattr(self, "ratio_a_spin"):
            try:
                self.ratio_a_spin.valueChanged.disconnect(self._on_ratio_spin_changed)
            except Exception:
                pass
            self.ratio_a_spin.valueChanged.connect(self._on_ratio_spin_changed)
        if hasattr(self, "ratio_b_spin"):
            try:
                self.ratio_b_spin.valueChanged.disconnect(self._on_ratio_spin_changed)
            except Exception:
                pass
            self.ratio_b_spin.valueChanged.connect(self._on_ratio_spin_changed)

        # 4) اگر هر دو مقدار صفر هستند، تجربهٔ دوستانه: 1 به 1
        try:
            a0 = float(self.ratio_a_spin.value()) if hasattr(self, "ratio_a_spin") else 0.0
            b0 = float(self.ratio_b_spin.value()) if hasattr(self, "ratio_b_spin") else 0.0
            if a0 == 0.0 and b0 == 0.0:
                self.ratio_a_spin.setValue(1.0)
                self.ratio_b_spin.setValue(1.0)
        except Exception:
            pass

        # 5) به‌روزرسانی پیش‌نمایش
        self._on_ratio_spin_changed()
    
    def _on_ratio_spin_changed(self):
        """
        حالت «نسبت A:B» (نه درصد). این متد فقط پیش‌نمایش می‌دهد:
        - نسبت ساده‌شده A:B (مثلاً 2:1)
        - درصد معادل برای فهم بهتر (A=66.7% | B=33.3%)
        هیچ قفل/اجبار 100٪ وجود ندارد.
        """
        try:
            a = float(self.ratio_a_spin.value()) if hasattr(self, "ratio_a_spin") else 0.0
            b = float(self.ratio_b_spin.value()) if hasattr(self, "ratio_b_spin") else 0.0
            if a <= 0 and b <= 0:
                a, b = 1.0, 1.0

            total = a + b
            a_pct = (a / total * 100.0) if total > 0 else 0.0
            b_pct = (b / total * 100.0) if total > 0 else 0.0

            # ساده‌سازی نسبت با gcd روی مقادیر گرد شده
            import math
            ai = max(1, int(round(a)))
            bi = max(1, int(round(b)))
            g = math.gcd(ai, bi) if ai > 0 and bi > 0 else 1
            a_s, b_s = ai // g, bi // g

            txt = f"نسبت A:B = {a_s}:{b_s}  (A={a_pct:.1f}٪ | B={b_pct:.1f}٪)"
            if hasattr(self, "ratio_sum_label") and self.ratio_sum_label:
                self.ratio_sum_label.setText(txt)
                self.ratio_sum_label.setStyleSheet("color:#2e7d32;")  # سبز خوانا
        except Exception:
            # خطاهای UI نباید تجربه را خراب کنند
            pass

    # BEGIN REWRITE: RecipeManagementDialog._create_master_recipe_panel
    def _create_master_recipe_panel(self):
        from PyQt5 import QtWidgets, QtCore

        panel  = QtWidgets.QWidget()
        layout = QtWidgets.QFormLayout(panel)
        layout.setLabelAlignment(QtCore.Qt.AlignRight)
        layout.setFormAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTop)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(10)

        # 1) انتخاب «محصول مادر»
        self.master_parent_product_combo = QtWidgets.QComboBox()
        self.master_parent_product_combo.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        layout.addRow("برای محصول مادر (ق):", self.master_parent_product_combo)

        # 2) نام دستورِ نمایش‌محور (غیرقابل ویرایش)
        self.master_product_name_label = QtWidgets.QLabel("دستور ساخت اصلی - ...")
        self.master_product_name_label.setStyleSheet("font-weight: bold;")
        layout.addRow("نام دستور ساخت:", self.master_product_name_label)

        # 3) نسبت اختلاط (٪) ← دو فیلد عددی A و B
        ratio_row = QtWidgets.QWidget()
        ratio_lay = QtWidgets.QHBoxLayout(ratio_row)
        ratio_lay.setContentsMargins(0, 0, 0, 0)
        ratio_lay.setSpacing(8)

        self.ratio_a_spin = QtWidgets.QDoubleSpinBox()
        self.ratio_a_spin.setRange(0.0, 100000.0)
        self.ratio_a_spin.setDecimals(3)
        self.ratio_a_spin.setSingleStep(0.1)
        self.ratio_a_spin.setToolTip("نسبت پارت A (درصد یا نسبت)")

        self.ratio_b_spin = QtWidgets.QDoubleSpinBox()
        self.ratio_b_spin.setRange(0.0, 100000.0)
        self.ratio_b_spin.setDecimals(3)
        self.ratio_b_spin.setSingleStep(0.1)
        self.ratio_b_spin.setToolTip("نسبت پارت B (درصد یا نسبت)")

        ratio_lay.addWidget(QtWidgets.QLabel("پارت A:"))
        ratio_lay.addWidget(self.ratio_a_spin)
        ratio_lay.addSpacing(12)
        ratio_lay.addWidget(QtWidgets.QLabel("پارت B:"))
        ratio_lay.addWidget(self.ratio_b_spin)
        ratio_lay.addStretch(1)

        layout.addRow("نسبت اختلاط (٪):", ratio_row)

        # 4) وضعیت پارت‌های فعال (نمایشی)
        status_row = QtWidgets.QWidget()
        status_lay = QtWidgets.QHBoxLayout(status_row)
        status_lay.setContentsMargins(0, 0, 0, 0)
        status_lay.setSpacing(8)

        self.active_part_a_label = QtWidgets.QLabel("<i>(یافت نشد)</i>")
        self.active_part_b_label = QtWidgets.QLabel("<i>(یافت نشد)</i>")
        self.active_part_a_label.setStyleSheet("color: #6c757d;")
        self.active_part_b_label.setStyleSheet("color: #6c757d;")

        status_lay.addWidget(QtWidgets.QLabel("پارت A فعال:"))
        status_lay.addWidget(self.active_part_a_label)
        status_lay.addSpacing(14)
        status_lay.addWidget(QtWidgets.QLabel("پارت B فعال:"))
        status_lay.addWidget(self.active_part_b_label)
        status_lay.addStretch(1)

        layout.addRow("وضعیت پارت‌ها:", status_row)

        # 5) یادداشت
        self.master_notes_edit = QtWidgets.QTextEdit()
        self.master_notes_edit.setPlaceholderText("توضیحات…")
        self.master_notes_edit.setMinimumHeight(120)
        layout.addRow("توضیحات:", self.master_notes_edit)

        # 6) اتصال سیگنال‌ها
        if hasattr(self, "_on_master_parent_selected"):
            self.master_parent_product_combo.currentIndexChanged.connect(self._on_master_parent_selected)

        return panel
    # END REWRITE: RecipeManagementDialog._create_master_recipe_panel

    def _create_component_recipe_panel(self):
        panel = QtWidgets.QWidget(); layout = QtWidgets.QVBoxLayout(panel); form_layout = QtWidgets.QFormLayout();
        self.comp_name_edit = QtWidgets.QLineEdit(); self.comp_name_edit.setReadOnly(True); self.comp_name_edit.setStyleSheet("background-color: #e9ecef;")
        self.comp_parent_product_combo = QtWidgets.QComboBox()
        self.comp_part_type_combo = QtWidgets.QComboBox(); self.comp_part_type_combo.addItems(["---", "تک جزئی (پارت P)", "پارت A (رزین)", "پارت B (هاردنر)"])
        self.produces_item_combo = QtWidgets.QComboBox(); self.produces_item_combo.setEnabled(False)
        form_layout.addRow("برای محصول مادر (*):", self.comp_parent_product_combo); form_layout.addRow("نوع پارت (*):", self.comp_part_type_combo); form_layout.addRow("نام فرمول (خودکار):", self.comp_name_edit); form_layout.addRow("محصول خروجی (خودکار):", self.produces_item_combo); layout.addLayout(form_layout)
        layout.addWidget(QtWidgets.QLabel("<b>مواد اولیه تشکیل‌دهنده:</b>")); self.ingredients_table = QtWidgets.QTableWidget(0, 3); self.ingredients_table.setHorizontalHeaderLabels(['ID ماده', 'نام ماده اولیه', 'درصد (%)']); self.ingredients_table.setColumnHidden(0, True); self.ingredients_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch); self.ingredients_table.cellChanged.connect(self._update_sum_label); layout.addWidget(self.ingredients_table); ing_bottom_layout = QtWidgets.QHBoxLayout(); add_ing_btn = QtWidgets.QPushButton("افزودن مواد اولیه..."); remove_ing_btn = QtWidgets.QPushButton("حذف ماده اولیه"); self.sum_label = QtWidgets.QLabel("مجموع درصدها: 0.0%"); self.sum_label.setStyleSheet("font-weight: bold;"); ing_bottom_layout.addWidget(add_ing_btn); ing_bottom_layout.addWidget(remove_ing_btn); ing_bottom_layout.addStretch(); ing_bottom_layout.addWidget(self.sum_label); layout.addLayout(ing_bottom_layout);
        add_ing_btn.clicked.connect(self.add_ingredients); remove_ing_btn.clicked.connect(self.remove_ingredient)
        self.bulk_items_cache = self.db.get_items_by_category('محصول فله'); self.produces_item_combo.addItem("---", None)
        for item in self.bulk_items_cache: self.produces_item_combo.addItem(item['name'], item['id'])
        return panel

    def save_recipe_version(self):
        from PyQt5 import QtWidgets

        # --- 0) نسخه‌ای که کاربر در لیست انتخاب کرده است (برای تشخیص ویرایشِ همان نوع) ---
        current = self.current_recipe_data or {}
        current_id = current.get('id')
        current_part = (current.get('part_type') or '').strip().upper()
        current_parent_id = current.get('parent_product_id')

        # مقدار پیش‌فرض: «ویرایشِ نسخهٔ قبلی» نداریم
        recipe_id_to_revise = None

        # -----------------------------
        # حالت الف) «فرمولِ مادر (تعریف نسبت)»
        # -----------------------------
        if self.mode_master.isChecked():
            parent_id = self.master_parent_product_combo.currentData()
            if not parent_id:
                QtWidgets.QMessageBox.warning(self, "خطا", "انتخاب «محصول مادر» الزامی است.")
                return

            # اگر کاربر یک «فرمولِ مادرِ ACTIVE» را از لیست انتخاب کرده و همان را اصلاح می‌کند:
            if current_id and current_part == 'MASTER' and current_parent_id == parent_id and (current.get('status') == 'ACTIVE'):
                recipe_id_to_revise = current_id

            # نسبت اختلاط (اگر فیلدها وجود داشته باشند)
            a_val = getattr(self, 'ratio_a_spin', None).value() if hasattr(self, 'ratio_a_spin') else 0.0
            b_val = getattr(self, 'ratio_b_spin', None).value() if hasattr(self, 'ratio_b_spin') else 0.0

            recipe_data = {
                "product_name": f"فرمول مادر برای {self.master_parent_product_combo.currentText()}",
                "part_type": "MASTER",
                "parent_product_id": parent_id,
                "produces_item_id": None,
                "notes": self.master_notes_edit.toPlainText() if hasattr(self, 'master_notes_edit') else "",
                "properties": {"mix_ratio": {"A": a_val, "B": b_val}},
                "yield_percentage": 100.0,   # برای مادر صرفاً نگه‌دارنده
            }
            ingredients_for_db = []  # فرمول مادر مواد ندارد

        # -----------------------------
        # حالت ب) «فرمولِ ساخت جزء (مواد اولیه)»
        # -----------------------------
        else:
            # والد و پارت انتخابی
            parent_data = self.comp_parent_product_combo.currentData() if hasattr(self, 'comp_parent_product_combo') else None
            if not isinstance(parent_data, dict) or not parent_data.get('id'):
                QtWidgets.QMessageBox.warning(self, "خطا", "فیلد ستاره‌دار «برای محصول مادر» باید پر شود.")
                return

            part_index = self.comp_part_type_combo.currentIndex() if hasattr(self, 'comp_part_type_combo') else 0
            if part_index == 0:
                QtWidgets.QMessageBox.warning(self, "خطا", "فیلد ستاره‌دار «نوع پارت» باید انتخاب شود.")
                return
            part_map = {1: 'P', 2: 'A', 3: 'B'}
            part_type = part_map.get(part_index, 'P')

            # اگر کاربر واقعاً همان نوع پارت را از لیست انتخاب کرده و می‌خواهد «اصلاح نسخه» انجام دهد:
            if current_id and current_part == part_type and current_parent_id == parent_data.get('id') and (current.get('status') == 'ACTIVE'):
                recipe_id_to_revise = current_id

            # محصول خروجی (فله)
            produces_item_id = self.produces_item_combo.currentData() if hasattr(self, 'produces_item_combo') else None

            # نام پیشنهادی
            comp_name = self.comp_name_edit.text().strip() if hasattr(self, 'comp_name_edit') else ""
            if not comp_name:
                comp_name = f"فرمول پارت {part_type} برای {parent_data.get('name','')}"

            # جمع‌آوری مواد از جدول (ستون‌ها: 0=id ، 1=نام ، 2=درصد)
            ingredients_for_db = []
            tbl = getattr(self, 'ingredients_table', None)
            if tbl:
                for r in range(tbl.rowCount()):
                    id_item = tbl.item(r, 0)
                    pct_item = tbl.item(r, 2)
                    if not id_item or not pct_item:
                        continue
                    try:
                        iid = int(id_item.text())
                        pct = float(pct_item.text())
                    except Exception:
                        continue
                    ingredients_for_db.append({"item_id": iid, "percentage": pct})

            # در صورت خالی بودن مواد، خطا بدهیم تا نسخهٔ بی‌مصرف ثبت نشود
            if not ingredients_for_db:
                QtWidgets.QMessageBox.warning(self, "خطا", "هیچ مادهٔ اولیه‌ای برای این پارت انتخاب نشده است.")
                return

            recipe_data = {
                "product_name": comp_name,
                "part_type": part_type,                 # 'A' | 'B' | 'P'
                "parent_product_id": parent_data['id'],
                "produces_item_id": produces_item_id,
                "notes": "",
                "properties": {},
                "yield_percentage": 100.0,
            }

        # --- ذخیره در DB ---
        try:
            new_id = self.db.save_recipe(recipe_data, ingredients_for_db, recipe_id_to_revise)
            self._after_recipe_saved(new_id)

        except Exception as e:
            # پیام خطای شفاف برای کاربر
            msg = str(e)
            if "recipes_product_name_version_key" in msg:
                QtWidgets.QMessageBox.critical(self, "خطای نسخه‌بندی", "این نام فرمول برای این نسخه قبلاً ثبت شده است. دوباره ذخیره کنید.")
            else:
                QtWidgets.QMessageBox.critical(self, "خطا", f"ثبت فرمول با خطا مواجه شد:\n{msg}")
            return

        # موفقیت
        if hasattr(self, 'toast') and self.toast:
            self.toast.show_message("✔ نسخه جدید فرمول با موفقیت ذخیره و فعال شد.", "success")

        # رفرش لیست
        try:
            self.load_recipe_tree()
        except Exception:
            pass

        # --- ریست امن فرم فقط پس از موفقیت ---
        try:
            if self.mode_master.isChecked():
                if hasattr(self, "_reset_master_form"):
                    self._reset_master_form()
            else:
                if hasattr(self, "_reset_comp_form"):
                    self._reset_comp_form()

            # حالت پیش‌فرض: برگرداندن به «فرمول جزء»
            if hasattr(self, 'mode_master'):
                self.mode_master.setChecked(False)
            if hasattr(self, 'mode_component'):
                self.mode_component.setChecked(True)

            # پاک کردن انتخاب درخت تا چیزی در حالت ویرایش نماند
            if hasattr(self, 'recipe_tree') and self.recipe_tree:
                try:
                    self.recipe_tree.clearSelection()
                except Exception:
                    pass
        except Exception:
            pass
    # END REWRITE: RecipeManagementDialog.save_recipe_version
    
    
    def _reset_comp_form(self):
        """پاکسازی فرم «فرمول جزء» بدون تغییر معماری."""
        if hasattr(self, 'comp_parent_product_combo'):
            self.comp_parent_product_combo.setCurrentIndex(0)
        if hasattr(self, 'comp_part_type_combo'):
            self.comp_part_type_combo.setCurrentIndex(0)
        if hasattr(self, 'comp_name_edit'):
            self.comp_name_edit.clear()
        if hasattr(self, 'produces_item_combo'):
            self.produces_item_combo.setCurrentIndex(0)
        if hasattr(self, 'ingredients_table'):
            tbl = self.ingredients_table
            for r in range(tbl.rowCount() - 1, -1, -1):
                tbl.removeRow(r)
        if hasattr(self, 'total_percent_label'):
            self.total_percent_label.setText("مجموع درصدها: 0.00%")
        if hasattr(self, 'comp_notes_edit'):
            self.comp_notes_edit.clear()

    def _reset_master_form(self):
        """پاکسازی فرم «فرمول مادر»."""
        if hasattr(self, 'master_parent_product_combo'):
            self.master_parent_product_combo.setCurrentIndex(0)
        if hasattr(self, 'ratio_a_spin'):
            self.ratio_a_spin.setValue(0.0)
        if hasattr(self, 'ratio_b_spin'):
            self.ratio_b_spin.setValue(0.0)
        if hasattr(self, 'master_notes_edit'):
            self.master_notes_edit.clear()

    
        # BEGIN ADD: RecipeManagementDialog._after_recipe_saved
    def _after_recipe_saved(self, new_id: int):
        """
        بعد از ذخیرهٔ نسخهٔ فرمول، «کد فرمول» را از DB خوانده و
        در پیش‌نمایش UI (فیلد فقط‌خواندنی) نمایش می‌دهد.
        """
        try:
            details = self.db.get_recipe_details(new_id)
            code = ""
            if details and details.get('recipe'):
                props = details['recipe'].get('properties')
                if isinstance(props, str):
                    import json
                    try:
                        props = json.loads(props or "{}")
                    except Exception:
                        props = {}
                if isinstance(props, dict):
                    code = props.get('recipe_code') or ""
            # اگر متد پیش‌نمایش ساخته شده باشد، مقدار را بروزرسانی کن
            if hasattr(self, "_ensure_recipe_code_preview"):
                self._ensure_recipe_code_preview(code)
        except Exception as e:
            # خطای UI را خاموش نگه می‌داریم تا ذخیره خراب نشود
            try:
                print("WARN: _after_recipe_saved failed:", e)
            except Exception:
                pass
    # END ADD: RecipeManagementDialog._after_recipe_saved

            
                        
            
    def _populate_all_parent_product_combos(self):
        self.master_parent_product_combo.clear(); self.master_parent_product_combo.addItem("--- انتخاب کنید ---", None); self.comp_parent_product_combo.clear(); self.comp_parent_product_combo.addItem("--- انتخاب کنید ---", None); parents = self.db.execute_query("SELECT id, name FROM items WHERE is_parent_product = TRUE ORDER BY name")
        for p in parents:
            self.master_parent_product_combo.addItem(p['name'], p['id'])
            self.comp_parent_product_combo.addItem(p['name'], {'id': p['id'], 'name': p['name']})
            
    # BEGIN ADD: RecipeManagementDialog._ensure_recipe_filters
    def _ensure_recipe_filters(self):
        """زیر نوار درخت، یک چک‌باکس «فقط همین محصول» و یک جست‌وجو اضافه می‌کند (فقط یک‌بار)."""
        from PyQt5 import QtWidgets
        if getattr(self, "_recipe_filters_ready", False):
            return
        tree = getattr(self, 'recipe_tree', None)
        if not tree:
            return
        parent = tree.parent()
        lay = parent.layout() if parent else None
        if not isinstance(lay, QtWidgets.QVBoxLayout):
            return

        bar = QtWidgets.QHBoxLayout()
        bar.setContentsMargins(0, 0, 0, 4)

        self.chk_only_current_parent = QtWidgets.QCheckBox("فقط همین محصول")
        self.edt_recipe_search = QtWidgets.QLineEdit()
        self.edt_recipe_search.setPlaceholderText("جست‌وجو در: کد فرمول / نام محصول / پارت / نسخه…")

        bar.addWidget(self.chk_only_current_parent)
        bar.addStretch(1)
        bar.addWidget(self.edt_recipe_search)
        lay.insertLayout(0, bar)

        # اتصال
        def _reload():
            if hasattr(self, 'load_recipe_tree'):
                self.load_recipe_tree()
        self.chk_only_current_parent.toggled.connect(_reload)
        self.edt_recipe_search.textChanged.connect(_reload)

        self._recipe_filters_ready = True
    # END ADD: RecipeManagementDialog._ensure_recipe_filters

            
    # BEGIN REWRITE: RecipeManagementDialog._on_master_parent_selected
    def _on_master_parent_selected(self):
        """
        با تغییر «محصول مادر»:
        - اگر اسپین‌های نسبت A/B وجود نداشته باشند، می‌سازد و به فرم اضافه می‌کند.
        - پس از ساخت، حتماً helperهای نسبت را متصل می‌کند (قفل ۱۰۰٪ و جمع رنگی).
        - نسبت‌های ذخیره‌شده در جدیدترین «فرمول مادر ACTIVE» را لود می‌کند.
        - وضعیت پارت‌های A/B فعال را از DB می‌خواند و نمایش می‌دهد.
        """
        from PyQt5 import QtWidgets, QtCore
        import json

        # عنوان
        if hasattr(self, 'master_product_name_label') and hasattr(self, 'master_parent_product_combo'):
            self.master_product_name_label.setText(
                f"دستور ساخت اصلی - {self.master_parent_product_combo.currentText()}"
            )

        # دسترسی به فرم مادر
        panel = getattr(self, 'master_panel', None)
        if panel is None:
            return
        form = panel.layout() if isinstance(panel.layout(), QtWidgets.QFormLayout) else None
        if form is None:
            return

        # ساخت ردیف نسبت A/B در صورت نیاز
        def _ensure_ratio_row():
            if not hasattr(self, 'ratio_a_spin'):
                self.ratio_a_spin = QtWidgets.QDoubleSpinBox()
                self.ratio_a_spin.setRange(0, 100000)
                self.ratio_a_spin.setDecimals(3)
                self.ratio_a_spin.setSingleStep(0.1)
            if not hasattr(self, 'ratio_b_spin'):
                self.ratio_b_spin = QtWidgets.QDoubleSpinBox()
                self.ratio_b_spin.setRange(0, 100000)
                self.ratio_b_spin.setDecimals(3)
                self.ratio_b_spin.setSingleStep(0.1)

            if not getattr(self, '_ratio_row_ready', False):
                row_widget = QtWidgets.QWidget()
                h = QtWidgets.QHBoxLayout(row_widget)
                h.setContentsMargins(0, 0, 0, 0)
                h.setSpacing(8)
                h.addWidget(QtWidgets.QLabel("پارت A:"))
                h.addWidget(self.ratio_a_spin)
                h.addSpacing(12)
                h.addWidget(QtWidgets.QLabel("پارت B:"))
                h.addWidget(self.ratio_b_spin)
                h.addStretch(1)
                form.addRow("نسبت اختلاط (٪):", row_widget)
                self._ratio_row_ready = True

        # ساخت ردیف وضعیت پارت‌ها
        def _ensure_parts_status_row():
            if not hasattr(self, 'active_part_a_label'):
                self.active_part_a_label = QtWidgets.QLabel("<i>(یافت نشد)</i>")
                self.active_part_a_label.setStyleSheet("color:#6c757d;")
            if not hasattr(self, 'active_part_b_label'):
                self.active_part_b_label = QtWidgets.QLabel("<i>(یافت نشد)</i>")
                self.active_part_b_label.setStyleSheet("color:#6c757d;")

            if not getattr(self, '_parts_row_ready', False):
                row_widget = QtWidgets.QWidget()
                h = QtWidgets.QHBoxLayout(row_widget)
                h.setContentsMargins(0, 0, 0, 0)
                h.setSpacing(8)
                h.addWidget(QtWidgets.QLabel("پارت A فعال:"))
                h.addWidget(self.active_part_a_label)
                h.addSpacing(14)
                h.addWidget(QtWidgets.QLabel("پارت B فعال:"))
                h.addWidget(self.active_part_b_label)
                h.addStretch(1)
                form.addRow("وضعیت پارت‌ها:", row_widget)
                self._parts_row_ready = True

        _ensure_ratio_row()
        _ensure_parts_status_row()

        # *** مهم: فراخوانی helper قفل ۱۰۰٪ و جمع رنگی ***
        if hasattr(self, '_attach_ratio_helpers'):
            self._attach_ratio_helpers()

        # شناسهٔ محصول مادر
        parent_id = self.master_parent_product_combo.currentData() if hasattr(self, 'master_parent_product_combo') else None
        if not parent_id:
            self.ratio_a_spin.setValue(0.0); self.ratio_b_spin.setValue(0.0)
            self.active_part_a_label.setText("<i>(یافت نشد)</i>")
            self.active_part_b_label.setText("<i>(یافت نشد)</i>")
            return

        # لود نسبت‌ها از فرمول مادر ACTIVE
        r = self.db.execute_query(
            """
            SELECT properties
            FROM recipes
            WHERE parent_product_id = %s AND part_type = 'MASTER' AND status = 'ACTIVE'
            ORDER BY version DESC, id DESC
            LIMIT 1
            """,
            (parent_id,), fetch_one=True
        )
        if r and r.get('properties'):
            try:
                props = r['properties'] if isinstance(r['properties'], dict) else json.loads(r['properties'])
            except Exception:
                props = {}
            mix = (props or {}).get('mix_ratio') or {}
            try:
                self.ratio_a_spin.setValue(float(mix.get('A') or 50.0))
            except Exception:
                self.ratio_a_spin.setValue(50.0)
            try:
                self.ratio_b_spin.setValue(float(mix.get('B') or 50.0))
            except Exception:
                self.ratio_b_spin.setValue(50.0)
        else:
            # پیش‌فرض دوستانه: ۵۰/۵۰
            self.ratio_a_spin.setValue(50.0); self.ratio_b_spin.setValue(50.0)

        # وضعیت پارت‌های A/B فعال
        parts = self.db.execute_query(
            """
            SELECT part_type, version
            FROM recipes
            WHERE parent_product_id = %s AND status = 'ACTIVE' AND part_type IN ('A','B')
            """,
            (parent_id,)
        ) or []
        a_txt = "<i>(یافت نشد)</i>"; b_txt = "<i>(یافت نشد)</i>"
        for row in parts:
            pt = (row.get('part_type') or '').upper()
            ver = row.get('version')
            if pt == 'A':
                a_txt = f"فعال (v{ver})"
            elif pt == 'B':
                b_txt = f"فعال (v{ver})"
        self.active_part_a_label.setText(a_txt)
        self.active_part_b_label.setText(b_txt)

        # اگر فیلتر «فقط همین محصول» روشن است، درخت نسخه‌ها را محدود کن
        try:
            if getattr(self, 'chk_only_current_parent', None) and self.chk_only_current_parent.isChecked():
                if hasattr(self, 'load_recipe_tree'):
                    self.load_recipe_tree()
        except Exception:
            pass
    # END REWRITE: RecipeManagementDialog._on_master_parent_selected

    def _update_component_outputs(self):
        """
        نسخه اصلاح شده و هوشمند:
        - تلاش می‌کند محصول خروجی را به صورت خودکار انتخاب کند.
        - اگر کاربر قبلاً به صورت دستی محصولی را انتخاب کرده باشد، انتخاب او را تغییر نمی‌دهد.
        """
        parent_data = self.comp_parent_product_combo.currentData()
        part_type_index = self.comp_part_type_combo.currentIndex()

        # اگر اطلاعات پایه (محصول مادر و نوع پارت) کامل نیست، نام فرمول را پاک کن
        if not isinstance(parent_data, dict) or part_type_index == 0:
            self.comp_name_edit.clear()
            return
            
        parent_name = parent_data.get('name', '')
        part_map = {1: 'P', 2: 'A', 3: 'B'}
        part_char = part_map.get(part_type_index)
        
        # نام فرمول همیشه بر اساس ورودی‌ها به‌روز می‌شود
        self.comp_name_edit.setText(f"فرمول پارت {part_char} برای {parent_name}")
        
        # --- *** منطق کلیدی و اصلاح شده اینجاست *** ---
        # فقط در صورتی که کاربر هنوز محصولی را انتخاب نکرده، تلاش برای انتخاب خودکار کن
        if self.produces_item_combo.currentIndex() <= 0:
            self.produces_item_combo.setCurrentIndex(0) # اطمینان از ریست بودن
            expected_bulk_name = f"{parent_name} - پارت {part_char}"
            
            # جستجو برای پیدا کردن محصول فله متناظر
            for item in self.bulk_items_cache:
                if item['name'] == expected_bulk_name:
                    index = self.produces_item_combo.findData(item['id'])
                    if index != -1:
                        self.produces_item_combo.setCurrentIndex(index)
                    break 
        # --- ************************************** ---
        
    def _lock_form_to_parent(self, parent_id: int):
        """
        وقتی کاربر از لیست سمت راست یک «محصول مادر» را انتخاب کرد:
        - کامبوی انتخاب «محصول مادر» در فرم روی همان parent_id ست و قفل شود.
        """
        try:
            # چند نام محتمل برای کامبو در کدبیس؛ اولی که وجود داشت استفاده می‌شود
            combo = None
            for name in ("c_parent", "combo_parent", "cb_parent", "cmb_parent_product", "c_parent_product"):
                combo = getattr(self, name, None)
                if combo is not None:
                    break
            if combo is None:
                return
            # پیدا کردن ایندکس parent_id و انتخاب آن
            idx_to_select = -1
            for i in range(combo.count()):
                data = combo.itemData(i)
                if (int(data) if data is not None else None) == int(parent_id):
                    idx_to_select = i
                    break
            if idx_to_select >= 0:
                combo.setCurrentIndex(idx_to_select)
            # قفل
            combo.setEnabled(False)
        except Exception:
            pass
        
    def _apply_two_component_rules(self, parent_id: int):
        """
        اگر محصول مادر «دو جزئی» باشد، انتخاب پارت P در فرم مجاز نیست.
        (براساس فیلد items.is_two_component یا نام مشابه)
        """
        try:
            row = self.db.execute_query(
                "SELECT is_two_component FROM items WHERE id=%s",
                (int(parent_id),), fetch_one=True
            ) or {}
            is_two = bool(row.get('is_two_component'))
        except Exception:
            is_two = False

        # کنترلِ UI: چند نام محتمل برای انتخاب نوع پارت
        # حالت ۱: یک QComboBox با گزینه‌های ['M','A','B','P']
        part_combo = None
        for name in ("c_part", "combo_part", "cb_part_type", "c_part_type"):
            part_combo = getattr(self, name, None)
            if part_combo is not None:
                break

        if part_combo is not None:
            try:
                # اگر دو جزئی است، گزینهٔ 'P' را غیرفعال/مخفی کنیم
                for i in range(part_combo.count()):
                    text = (part_combo.itemText(i) or "").strip().upper()
                    if text in ("P", "PACKAGING", "بسته بندی", "پارت P"):
                        part_combo.model().item(i).setEnabled(not is_two)
            except Exception:
                pass
            return

        # حالت ۲: رادیوباتن‌ها
        for name in ("r_part_p", "rb_part_p", "radio_part_p", "rdo_part_p"):
            btn = getattr(self, name, None)
            if btn is not None:
                try:
                    btn.setEnabled(not is_two)
                    if is_two and btn.isChecked():
                        # اگر قبلا P انتخاب بوده، به M برگردیم (نام‌های محتمل)
                        for n2 in ("r_part_m", "rb_part_m", "radio_part_m", "rdo_part_m"):
                            mbtn = getattr(self, n2, None)
                            if mbtn is not None:
                                mbtn.setChecked(True)
                                break
                except Exception:
                    pass
                break

        
    def _on_recipe_tree_selection_changed(self):
        """
        با انتخاب یک محصول مادر در درخت:
        - فرم روی همان parent قفل شود.
        - اگر دو جزئی است، پارت P غیرفعال شود.
        """
        from PyQt5 import QtCore
        sel = self.recipe_tree.currentItem()
        if not sel:
            return
        data = sel.data(0, QtCore.Qt.UserRole)
        # اگر روی گره نسخه کلیک شد، parent از دادهٔ آن؛ اگر روی گرهِ والد کلیک شد، خودِ همان
        parent_id = None
        if isinstance(data, dict) and data.get('parent_product_id'):
            parent_id = int(data['parent_product_id'])
        else:
            # شاید خودِ گرهِ والد باشد؛ سعی می‌کنیم از متن/نام پیدا کنیم
            # (در load_recipe_tree ما دادهٔ خاص روی والد نگذاشته‌ایم؛ پس از زیرگره استفاده می‌کنیم)
            ch = sel.child(0)
            if ch:
                d = ch.data(0, QtCore.Qt.UserRole)
                if isinstance(d, dict) and d.get('parent_product_id'):
                    parent_id = int(d['parent_product_id'])
        if parent_id:
            self._lock_form_to_parent(parent_id)
            self._apply_two_component_rules(parent_id)

                        
    def load_recipe_tree(self):
        """
        فهرست درختی فرمول‌ها (فقط ACTIVE). بدون وابستگی به ستون 'code'.
        """
        from PyQt5 import QtWidgets, QtCore
        self.recipe_tree.clear()

        parents = self.db.execute_query("SELECT id, name FROM items WHERE is_parent_product = TRUE ORDER BY name") or []

        # فقط ستون‌های امن/عمومی را بخوانیم
        rows = self.db.execute_query(
            "SELECT id, product_name, part_type, version, status, parent_product_id "
            "FROM recipes WHERE status='ACTIVE' ORDER BY product_name, CAST(version AS INTEGER) DESC"
        ) or []

        by_parent = {}
        for r in rows:
            by_parent.setdefault(r.get('parent_product_id'), []).append(r)

        def _part_label(pt):
            pt = (pt or '').upper()
            return pt if pt in ('A','B') else 'M'

        for p in parents:
            parent_item = QtWidgets.QTreeWidgetItem(self.recipe_tree, [p['name']])
            font = parent_item.font(0); font.setBold(True); parent_item.setFont(0, font)
            for r in by_parent.get(p['id'], []):
                lbl = f"{_part_label(r.get('part_type'))} — v{r.get('version')}"
                child = QtWidgets.QTreeWidgetItem(parent_item, [lbl])
                child.setData(0, QtCore.Qt.UserRole, {'type':'recipe', **r})

        self.recipe_tree.expandAll()

        # منوی راست‌کلیک آرشیو
        try:
            from PyQt5 import QtCore
            self.recipe_tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            try:
                self.recipe_tree.customContextMenuRequested.disconnect(self._recipe_tree_menu)
            except Exception:
                pass
            self.recipe_tree.customContextMenuRequested.connect(self._recipe_tree_menu)
        except Exception:
            pass
        
        try:
            self.recipe_tree.itemSelectionChanged.disconnect(self._on_recipe_tree_selection_changed)
        except Exception:
            pass
        self.recipe_tree.itemSelectionChanged.connect(self._on_recipe_tree_selection_changed)

        
    def _recipe_tree_menu(self, pos):
        """منوی راست‌کلیکِ لیست فرمول‌ها."""
        from PyQt5 import QtWidgets
        menu = QtWidgets.QMenu(self)
        act_arch = menu.addAction("نمایش فرمول‌های آرشیو… (Ctrl+H)")
        a = menu.exec_(self.recipe_tree.viewport().mapToGlobal(pos))
        if a == act_arch:
            self._show_archived_recipes()
            
    def _show_archived_recipes(self):
        """
        پنجرهٔ آرشیو فرمول‌ها (بدون وابستگی به ستون 'code').
        """
        from PyQt5 import QtWidgets, QtCore
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("فرمول‌های آرشیو"); dlg.resize(700, 500)
        v = QtWidgets.QVBoxLayout(dlg)

        search = QtWidgets.QLineEdit(); search.setPlaceholderText("جستجو...")
        v.addWidget(search)

        tree = QtWidgets.QTreeWidget(); tree.setHeaderHidden(True)
        v.addWidget(tree, 1)

        rows = self.db.execute_query(
            "SELECT id, product_name, part_type, version, status, parent_product_id "
            "FROM recipes WHERE status='ARCHIVED' ORDER BY product_name, CAST(version AS INTEGER) DESC"
        ) or []

        parent_ids = sorted({r.get('parent_product_id') for r in rows if r.get('parent_product_id')})
        id2name = {}
        if parent_ids:
            ph = ",".join(["%s"] * len(parent_ids))
            ps = self.db.execute_query(f"SELECT id, name FROM items WHERE id IN ({ph})", tuple(parent_ids)) or []
            id2name = {r['id']: r['name'] for r in ps}

        by_parent = {}
        for r in rows:
            by_parent.setdefault(r.get('parent_product_id'), []).append(r)

        def _part_label(pt):
            pt = (pt or '').upper()
            return pt if pt in ('A','B') else 'M'

        parents = sorted(by_parent.keys(), key=lambda x: id2name.get(x, ''))
        for pid in parents:
            parent_item = QtWidgets.QTreeWidgetItem(tree, [id2name.get(pid, '(بدون مادر)')])
            font = parent_item.font(0); font.setBold(True); parent_item.setFont(0, font)
            for r in by_parent.get(pid, []):
                lbl = f"{_part_label(r.get('part_type'))} — v{r.get('version')} (آرشیو)"
                child = QtWidgets.QTreeWidgetItem(parent_item, [lbl])
                child.setData(0, QtCore.Qt.UserRole, {'type':'recipe_archived', **r})
        tree.expandAll()

        def _filter():
            t = (search.text() or '').strip().lower()
            root = tree.invisibleRootItem()
            for i in range(root.childCount()):
                p = root.child(i); pname = p.text(0).lower()
                visible = (t in pname)
                child_vis = False
                for j in range(p.childCount()):
                    c = p.child(j); cvis = (t in c.text(0).lower()); c.setHidden(not cvis); child_vis = child_vis or cvis
                p.setHidden(not (visible or child_vis))
        search.textChanged.connect(lambda *_: _filter())

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Close)
        btns.rejected.connect(dlg.reject); v.addWidget(btns)
        dlg.exec_()

                
    def _filter_recipe_tree(self, text):
        search_text = self.recipe_search_edit.text().lower().strip(); root = self.recipe_tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i); parent_name = parent_item.text(0).lower(); has_visible_child = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j); child_matches = search_text in child_item.text(0).lower(); child_item.setHidden(not child_matches)
                if not child_item.isHidden(): has_visible_child = True
            parent_item.setHidden(not (search_text in parent_name or has_visible_child))
            
    # BEGIN REWRITE: RecipeManagementDialog.load_selected_recipe_details
    def load_selected_recipe_details(self):
        """
        وقتی درخت سمت راست آیتمی انتخاب شد:
        - اگر آیتم، نسخهٔ فرمول باشد → همان را مثل قبل لود می‌کند.
        - اگر آیتم، «محصول مادر» باشد → جدیدترین فرمول ACTIVE را برای آن مادر پیدا و لود می‌کند.
        (در صورت نبود فرمول، فرم را برای ساخت نسخهٔ جدید روی همان مادر آماده می‌کند.)
        """ 
        from PyQt5 import QtWidgets, QtCore

        selected = self.recipe_tree.selectedItems()
        # فرم را ریست می‌کنیم اما انتخاب کاربر باقی بماند
        self.clear_form_for_new(keep_selection=True)
        if not selected:
            return

        item = selected[0]
        data = item.data(0, QtCore.Qt.UserRole)

        # 1) اگر نسخهٔ فرمول انتخاب شده بود، مثل قبل
        recipe_id = None
        if isinstance(data, dict) and data.get('type') == 'recipe':
            recipe_id = data.get('id')

        # 2) اگر روی «محصول مادر» کلیک شده
        if recipe_id is None:
            # سعی می‌کنیم id مادر را پیدا کنیم
            parent_id = None
            if isinstance(data, dict) and data.get('type') == 'parent':
                parent_id = data.get('id')

            if not parent_id:
                # fallback: از متن آیتم (نام کالا) پیدا کن
                parent_name = item.text(0).strip()
                rec = self.db.execute_query(
                    "SELECT id FROM items WHERE name = %s LIMIT 1",
                    (parent_name,), fetch_one=True
                )
                if rec:
                    parent_id = rec['id']

            if not parent_id:
                return  # اطلاعات کافی نداریم

            # جدیدترین ACTIVE (اولویت با MASTER) را بیاب
            r = self.db.execute_query(
                """
                SELECT *
                FROM recipes
                WHERE parent_product_id = %s AND status = 'ACTIVE'
                ORDER BY (part_type = 'MASTER') DESC, version DESC, id DESC
                LIMIT 1
                """,
                (parent_id,), fetch_one=True
            )
            if not r:
                # اگر ACTIVE نبود، هرچی جدیدتر است
                r = self.db.execute_query(
                    """
                    SELECT *
                    FROM recipes
                    WHERE parent_product_id = %s
                    ORDER BY (part_type = 'MASTER') DESC, version DESC, id DESC
                    LIMIT 1
                    """,
                    (parent_id,), fetch_one=True
                )

            if r:
                recipe_id = r['id']
            else:
                # هیچ فرمولی برای این مادر نیست → فرم را برای ساخت نسخهٔ جدید آماده کن
                # پنل MASTER را روی همین مادر ست می‌کنیم و همچنین پنل جزء را هم همسان می‌گذاریم
                idx = self.master_parent_product_combo.findData(parent_id)
                if idx != -1:
                    self.mode_master.setChecked(True)
                    self.master_parent_product_combo.setCurrentIndex(idx)

                # کامبوی سمت جزء: دادهٔ آیتم‌ها به‌صورت dict{id, name} است
                for i in range(self.comp_parent_product_combo.count()):
                    d = self.comp_parent_product_combo.itemData(i)
                    if isinstance(d, dict) and d.get('id') == parent_id:
                        self.mode_component.setChecked(True)
                        self.comp_parent_product_combo.setCurrentIndex(i)
                        # نام پیش‌فرض فرمول جزء و پیشنهاد خروجی فله را به‌روز کن
                        if hasattr(self, "_update_component_outputs"):
                            self._update_component_outputs()
                        break
                return  # چیزی برای لود نبود

        # 3) در اینجا حتماً recipe_id داریم → جزئیات را لود کن
        details = self.db.get_recipe_details(int(recipe_id))
        if not details or not details.get('recipe'):
            return

        recipe_data = details['recipe']
        self.current_recipe_data = recipe_data  # برای ویرایش نسخه بعدی لازم است
        
        props = recipe_data.get('properties')
        if isinstance(props, str):
            import json; props = json.loads(props or "{}")
        self._ensure_recipe_code_preview((props or {}).get('recipe_code') or "")

        # اگر MASTER
        if recipe_data.get('part_type') == 'MASTER':
            self.mode_master.setChecked(True)
            parent_id = recipe_data.get('parent_product_id')
            idx = self.master_parent_product_combo.findData(parent_id) if parent_id else -1
            if idx != -1:
                self.master_parent_product_combo.setCurrentIndex(idx)

            props = recipe_data.get('properties') or {}
            mix = (props.get('mix_ratio') or {})
            try:
                self.ratio_a_spin.setValue(float(mix.get('A') or 0))
                self.ratio_b_spin.setValue(float(mix.get('B') or 0))
            except Exception:
                self.ratio_a_spin.setValue(0); self.ratio_b_spin.setValue(0)

            self.master_notes_edit.setPlainText(recipe_data.get('notes') or "")
            # MASTER معمولا مواد اولیه ندارد؛ اگر داشت، جدول را خالی نگه می‌داریم
            self.ingredients_table.setRowCount(0)
            self._update_sum_label()
            return

        # اگر فرمول جزء (P/A/B)
        self.mode_component.setChecked(True)

        # مادر
        parent_id = recipe_data.get('parent_product_id')
        for i in range(self.comp_parent_product_combo.count()):
            d = self.comp_parent_product_combo.itemData(i)
            if isinstance(d, dict) and d.get('id') == parent_id:
                self.comp_parent_product_combo.setCurrentIndex(i)
                break

        # نوع پارت
        part_map_to_index = {'P': 1, 'A': 2, 'B': 3}
        self.comp_part_type_combo.setCurrentIndex(part_map_to_index.get(recipe_data.get('part_type'), 0))

        # محصول خروجی (فله)
        produces_id = recipe_data.get('produces_item_id')
        if produces_id:
            idx = self.produces_item_combo.findData(produces_id)
            if idx != -1:
                self.produces_item_combo.setCurrentIndex(idx)

        # مواد اولیه
        self.ingredients_table.setRowCount(0)
        for ing in (details.get('ingredients') or []):
            r = self.ingredients_table.rowCount()
            self.ingredients_table.insertRow(r)
            self.ingredients_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(ing.get('item_id'))))
            self.ingredients_table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(ing.get('item_name') or '')))
            self.ingredients_table.setItem(r, 2, QtWidgets.QTableWidgetItem(str(ing.get('percentage') or 0)))
        self._update_sum_label()
    # END REWRITE: RecipeManagementDialog.load_selected_recipe_details
            
    def clear_form_for_new(self, keep_selection=False):
        if not keep_selection: self.recipe_tree.clearSelection()
        self.current_recipe_data = None; self.master_parent_product_combo.setCurrentIndex(0); self.ratio_a_spin.setValue(0); self.ratio_b_spin.setValue(0); self.master_notes_edit.clear(); self.comp_name_edit.clear(); self.comp_parent_product_combo.setCurrentIndex(0); self.comp_part_type_combo.setCurrentIndex(0); self.produces_item_combo.setCurrentIndex(0); self.ingredients_table.setRowCount(0); self._update_sum_label()
        
    def add_ingredients(self):
        dlg = IngredientSelectionDialog(self.db, self)
        if dlg.exec_() and dlg.selected_items:
            existing_ids = {self.ingredients_table.item(row, 0).text() for row in range(self.ingredients_table.rowCount()) if self.ingredients_table.item(row, 0)}; self.ingredients_table.blockSignals(True)
            for item in dlg.selected_items:
                if str(item['id']) not in existing_ids: row_pos = self.ingredients_table.rowCount(); self.ingredients_table.insertRow(row_pos); self.ingredients_table.setItem(row_pos, 0, QtWidgets.QTableWidgetItem(str(item['id']))); self.ingredients_table.setItem(row_pos, 1, QtWidgets.QTableWidgetItem(item['name'])); self.ingredients_table.setItem(row_pos, 2, QtWidgets.QTableWidgetItem("0.0"))
            self.ingredients_table.blockSignals(False); self._update_sum_label()
            
    def remove_ingredient(self):
        current_row = self.ingredients_table.currentRow();
        if current_row >= 0: self.ingredients_table.removeRow(current_row); self._update_sum_label()

    # --- **متد فراموش شده که باعث خطا شد، اکنون اضافه شده است** ---
    def _update_sum_label(self):
        total = 0.0
        for row in range(self.ingredients_table.rowCount()):
            item = self.ingredients_table.item(row, 2)
            if item and item.text():
                try: total += float(item.text())
                except (ValueError, TypeError): pass
        self.sum_label.setText(f"مجموع درصدها: {total:.2f}%")
        self.sum_label.setStyleSheet("font-weight: bold; color: red;" if abs(total - 100.0) > 0.01 and total != 0 else "font-weight: bold; color: green;")
                
                
        

# کلاس IngredientSelectionDialog را با این نسخه اصلاح‌شده جایگزین کنید
class IngredientSelectionDialog(QtWidgets.QDialog):
    """
    یک دیالوگ برای جستجو و انتخاب چندتایی مواد اولیه.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.selected_items = []

        self.setWindowTitle("انتخاب مواد اولیه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(400, 500)

        layout = QtWidgets.QVBoxLayout(self)

        self.search_edit = QtWidgets.QLineEdit(placeholderText="🔍 جستجوی نام ماده اولیه...")
        self.search_edit.textChanged.connect(self.filter_list)
        layout.addWidget(self.search_edit)

        self.items_list_widget = QtWidgets.QListWidget()
        self.items_list_widget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        layout.addWidget(self.items_list_widget)

        self.add_button = QtWidgets.QPushButton("افزودن موارد انتخاب شده")
        self.add_button.clicked.connect(self.accept_selection)
        layout.addWidget(self.add_button)

        self.populate_list()

    def populate_list(self):
        self.items_list_widget.clear()
        # --- *** اصلاح کلیدی اینجاست: فراخوانی تابع صحیح *** ---
        all_items = self.db.get_all_items_for_selection()

        for item in all_items:
            # فقط مواد اولیه را نمایش می‌دهیم
            if item['category'] == CATEGORY_RAW_MATERIAL: # استفاده از ثابت سراسری
                unit_name = item.get('unit', '')
                display_text = f"{item['name']} (واحد: {unit_name})" if unit_name else item['name']
                list_item = QtWidgets.QListWidgetItem(display_text)
                list_item.setData(Qt.UserRole, item)
                self.items_list_widget.addItem(list_item)

    def filter_list(self):
        search_text = self.search_edit.text().lower()
        for i in range(self.items_list_widget.count()):
            item = self.items_list_widget.item(i)
            item.setHidden(search_text not in item.text().lower())

    def accept_selection(self):
        for item in self.items_list_widget.selectedItems():
            self.selected_items.append(item.data(Qt.UserRole))
        self.accept()
        
# کل کلاس MenuActionWidget را با این نسخه کامل جایگزین کنید

class MenuActionWidget(QtWidgets.QFrame):
    """یک ویجت گرافیکی سفارشی برای نمایش اکشن در منو با قابلیت رنگ‌پذیری."""
    triggered = QtCore.pyqtSignal()

    def __init__(self, icon_path, title, subtitle, icon_bg_color, parent=None):
        super().__init__(parent)
        self.setCursor(Qt.PointingHandCursor)
        self.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.setContentsMargins(0,0,0,0)
        
        self.normal_style = "background-color: #ffffff; border-radius: 6px;"
        self.hover_style = "background-color: #f1f2f6; border: 1px solid #dcdcdc; border-radius: 6px;"
        
        self.setStyleSheet(self.normal_style)

        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(15)

        # --- بخش جدید: آیکون با پس‌زمینه دایره‌ای رنگی ---
        icon_container = QtWidgets.QLabel()
        icon_container.setFixedSize(36, 36)
        # استایل دایره رنگی
        icon_container.setStyleSheet(f"""
            background-color: {icon_bg_color};
            border-radius: 18px; /* نصف اندازه برای ایجاد دایره کامل */
        """)
        
        icon_layout = QtWidgets.QHBoxLayout(icon_container)
        icon_layout.setAlignment(Qt.AlignCenter)
        
        icon_label = QtWidgets.QLabel()
        # بهتر است آیکون شما 20x20 باشد تا در دایره 36x36 زیبا به نظر برسد
        pixmap = QtGui.QPixmap(icon_path).scaled(20, 20, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        icon_label.setPixmap(pixmap)
        icon_layout.addWidget(icon_label)
        # ---------------------------------------------

        text_layout = QtWidgets.QVBoxLayout()
        text_layout.setSpacing(1)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt; background: transparent;")
        
        subtitle_label = QtWidgets.QLabel(subtitle)
        subtitle_label.setStyleSheet("color: #636e72; background: transparent;")

        text_layout.addWidget(title_label)
        text_layout.addWidget(subtitle_label)
        
        layout.addWidget(icon_container) # کانتینر آیکون اضافه می‌شود
        layout.addLayout(text_layout)
        layout.addStretch()

    def enterEvent(self, event):
        self.setStyleSheet(self.hover_style)
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.setStyleSheet(self.normal_style)
        super().leaveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.triggered.emit()
        super().mouseReleaseEvent(event)
        
# این کلاس کاملاً جدید را به فایل اصلی برنامه اضافه کنید

class CountSheetDialog(QtWidgets.QDialog):
    """
    نسخه ۲.۰: بازطراحی کامل با استفاده از نمای درختی (QTreeWidget)
    - اقلام شمارش بر اساس لوکیشن دسته‌بندی می‌شوند تا فرآیند شمارش فیزیکی آسان‌تر شود.
    - رابط کاربری برای ورود داده بهینه‌سازی شده است.
    """
    def __init__(self, db: DB, user_id: int, count_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.count_id = db, user_id, count_id
        
        self.setWindowTitle(f"برگه شمارش سند شماره {self.count_id}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 700)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        
        # نوار جستجو
        search_layout = QtWidgets.QHBoxLayout()
        search_bar = QtWidgets.QLineEdit(placeholderText="جستجوی نام کالا، لوکیشن یا بچ نامبر...")
        search_bar.textChanged.connect(self._filter_tree)
        search_layout.addWidget(search_bar)
        layout.addLayout(search_layout)

        # ویجت درختی به جای جدول
        self.tree_items = QtWidgets.QTreeWidget()
        parent._style_tree(self.tree_items) # استفاده از استایل سراسری برنامه
        self.tree_items.setHeaderLabels(["کالا / بچ", "تاریخ انقضا", "موجودی سیستم", "مقدار شمارش شده"])
        self.tree_items.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, 4):
            self.tree_items.header().setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        
        layout.addWidget(self.tree_items, 1)

        # دکمه‌ها
        button_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره پیشرفت")
        btn_finalize = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " اتمام و ارسال برای بازبینی")
        btn_finalize.setProperty("class", "primary")
        
        btn_save.clicked.connect(self._save_progress)
        btn_finalize.clicked.connect(self._finalize_count)

        button_layout.addStretch()
        button_layout.addWidget(btn_save)
        button_layout.addWidget(btn_finalize)
        layout.addLayout(button_layout)
        
        self._load_and_build_tree()

    def _load_and_build_tree(self):
        """اطلاعات شمارش را خوانده و درخت را بر اساس لوکیشن می‌سازد."""
        items_to_count = self.db.get_items_for_count(self.count_id)
        
        grouped_by_loc = {}
        for item in items_to_count:
            loc_label = item['loc_label']
            if loc_label not in grouped_by_loc:
                grouped_by_loc[loc_label] = []
            grouped_by_loc[loc_label].append(item)

        for loc_label, items in grouped_by_loc.items():
            parent_item = QtWidgets.QTreeWidgetItem(self.tree_items, [loc_label])
            parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
            parent_item.setFlags(parent_item.flags() & ~Qt.ItemIsSelectable) # غیرقابل انتخاب کردن آیتم والد

            for item_data in items:
                child_item = QtWidgets.QTreeWidgetItem(parent_item)
                child_item.setText(0, f"  {item_data['item_name']} (بچ: {item_data['batch_no']})")
                child_item.setText(1, to_shamsi(item_data['expiry_date']))
                child_item.setText(2, str(item_data['system_qty']))
                
                # ذخیره ID اصلی برای آپدیت در دیتابیس
                child_item.setData(0, Qt.UserRole, item_data['count_item_id'])
                
                # ویجت QLineEdit برای ورود مقدار شمارش شده
                counted_edit = QtWidgets.QLineEdit()
                counted_edit.setValidator(QtGui.QDoubleValidator(0, 1e9, 3))
                counted_edit.setAlignment(Qt.AlignCenter)
                counted_edit.setText(str(item_data.get('counted_qty') or item_data['system_qty']))
                self.tree_items.setItemWidget(child_item, 3, counted_edit)
        
        self.tree_items.expandAll()

    def _filter_tree(self, text):
        """درخت را بر اساس متن ورودی فیلتر می‌کند."""
        text = text.lower()
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_items, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            # فیلتر فقط روی آیتم‌های فرزند (کالاها) اعمال می‌شود
            if item.parent(): 
                item_text = item.text(0).lower()
                parent_text = item.parent().text(0).lower()
                is_match = text in item_text or text in parent_text
                item.setHidden(not is_match)
            iterator += 1
        # نمایش/عدم نمایش آیتم‌های والد بر اساس فرزندانشان
        for i in range(self.tree_items.topLevelItemCount()):
            parent = self.tree_items.topLevelItem(i)
            has_visible_child = False
            for j in range(parent.childCount()):
                if not parent.child(j).isHidden():
                    has_visible_child = True
                    break
            parent.setHidden(not has_visible_child)

    def _save_progress(self, show_toast=True):
        """مقادیر وارد شده در درخت را در دیتابیس ذخیره می‌کند."""
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_items, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if item.parent(): # فقط آیتم‌های فرزند پردازش می‌شوند
                count_item_id = item.data(0, Qt.UserRole)
                counted_edit = self.tree_items.itemWidget(item, 3)
                if counted_edit and counted_edit.text().strip():
                    counted_qty = float(counted_edit.text())
                    self.db.update_counted_quantity(count_item_id, counted_qty)
            iterator += 1
            
        if show_toast and self.parent():
            self.parent().toast.show_message("✔ پیشرفت شمارش ذخیره شد.", "success")

    def _finalize_count(self):
        """شمارش را نهایی کرده و وضعیت سند را برای بازبینی ارسال می‌کند."""
        self._save_progress(show_toast=False)
        
        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی",
            "آیا از اتمام شمارش و ارسال نتایج برای بازبینی مطمئن هستید؟\nپس از این مرحله، دیگر قادر به ویرایش مقادیر نخواهید بود.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            
        if reply == QtWidgets.QMessageBox.Yes:
            self.db.change_count_status(self.count_id, 'REVIEW')
            if self.parent():
                self.parent().toast.show_message(f"شمارش سند {self.count_id} نهایی شد و برای بازبینی ارسال گردید.", "info")
            self.accept()
                        
class ReviewCountDialog(QtWidgets.QDialog):
    """
    نسخه ۲.۰: بازطراحی کامل برای بازبینی و تایید نهایی انبارگردانی.
    - نمایش دقیق مغایرت‌ها در سطح بچ/لوکیشن.
    - اصلاح موجودی به صورت دقیق و هدفمند بر اساس ردیف‌های دارای مغایرت.
    """
    def __init__(self, db: DB, user_id: int, count_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.count_id = db, user_id, count_id
        
        self.setWindowTitle(f"بازبینی و تایید سند شمارش شماره {self.count_id}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(1000, 700)

        self.layout = QtWidgets.QVBoxLayout(self)
        self.layout.setSpacing(10)
        
        # نوار ابزار بالا
        action_bar = QtWidgets.QHBoxLayout()
        self.filter_combo = QtWidgets.QComboBox()
        self.filter_combo.addItems(["نمایش همه", "فقط مغایرت‌ها"])
        self.filter_combo.currentTextChanged.connect(self._filter_table)
        action_bar.addWidget(QtWidgets.QLabel("نمایش:"))
        action_bar.addWidget(self.filter_combo)
        action_bar.addStretch()
        self.layout.addLayout(action_bar)

        # جدول اصلی آیتم‌های شمارش شده
        self.tbl_review = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'): parent._style_table(self.tbl_review)
        self.layout.addWidget(self.tbl_review, 1)

        # بخش شماره سند اصلاحی
        doc_no_layout = QtWidgets.QHBoxLayout()
        doc_no_label = QtWidgets.QLabel("شماره سند اصلاحی (اختیاری):")
        self.doc_no_edit = QtWidgets.QLineEdit()
        self.doc_no_edit.setPlaceholderText(f"پیش‌فرض اگر خالی بماند: COUNT-{self.count_id}")
        doc_no_layout.addWidget(doc_no_label); doc_no_layout.addWidget(self.doc_no_edit)
        self.layout.addLayout(doc_no_layout)

        # دکمه‌های عملیاتی مدیر
        button_layout = QtWidgets.QHBoxLayout()
        btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل از مغایرت‌ها")
        btn_finalize = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید نهایی و اصلاح موجودی انبار")
        btn_finalize.setProperty("class", "primary")
        
        btn_export.clicked.connect(lambda: export_table_to_excel(self.tbl_review, self))
        btn_finalize.clicked.connect(self._approve_and_finalize)
        
        button_layout.addStretch()
        button_layout.addWidget(btn_export)
        button_layout.addWidget(btn_finalize)
        self.layout.addLayout(button_layout)
        
        self._load_review_items()

    def _load_review_items(self):
        """جدول بازبینی را با اطلاعات دقیق در سطح بچ/لوکیشن پر می‌کند."""
        items_to_review = self.db.get_items_for_count(self.count_id)
        
        headers = ["کالا", "لوکیشن", "شماره بچ", "تاریخ انقضا", "موجودی سیستم", "مقدار شمارش شده", "مغایرت", "دلیل مغایرت (اجباری)"]
        self.tbl_review.setColumnCount(len(headers))
        self.tbl_review.setHorizontalHeaderLabels(headers)
        self.tbl_review.setRowCount(len(items_to_review))

        DISCREPANCY_COLOR = QtGui.QColor("#ffebee") # رنگ هایلایت برای مغایرت

        for r, item in enumerate(items_to_review):
            counted_qty = item.get('counted_qty') if item.get('counted_qty') is not None else item.get('system_qty', 0)
            system_qty = item.get('system_qty', 0)
            discrepancy = counted_qty - system_qty

            # ذخیره اطلاعات کلیدی در آیتم اول برای دسترسی بعدی
            item_name_cell = QtWidgets.QTableWidgetItem(item['item_name'])
            item_name_cell.setData(Qt.UserRole, item) # کل رکورد را در دیتا ذخیره می‌کنیم
            self.tbl_review.setItem(r, 0, item_name_cell)
            
            self.tbl_review.setItem(r, 1, QtWidgets.QTableWidgetItem(item['loc_label']))
            self.tbl_review.setItem(r, 2, QtWidgets.QTableWidgetItem(item['batch_no']))
            self.tbl_review.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(item['expiry_date'])))
            self.tbl_review.setItem(r, 4, NumericTableWidgetItem(str(system_qty)))
            self.tbl_review.setItem(r, 5, NumericTableWidgetItem(str(counted_qty)))
            self.tbl_review.setItem(r, 6, NumericTableWidgetItem(f"{discrepancy:+.2f}"))

            if abs(discrepancy) > 1e-9: # اگر مغایرت وجود داشت
                for col in range(7):
                    self.tbl_review.item(r, col).setBackground(DISCREPANCY_COLOR)
                
                reason_combo = QtWidgets.QComboBox()
                reason_combo.addItems(['- انتخاب کنید -', 'کسری (ضایعات)', 'کسری (شمارش غلط)', 'اضافی (یافت شده)', 'اصلاح خطای کاربری'])
                self.tbl_review.setCellWidget(r, 7, reason_combo)
        
        self.tbl_review.resizeColumnsToContents()
        self.tbl_review.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.tbl_review.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _filter_table(self, text):
        """جدول را برای نمایش همه یا فقط مغایرت‌ها فیلتر می‌کند."""
        show_only_discrepancies = (text == "فقط مغایرت‌ها")
        for r in range(self.tbl_review.rowCount()):
            discrepancy_text = self.tbl_review.item(r, 6).text()
            discrepancy_val = float(discrepancy_text)
            
            if show_only_discrepancies:
                self.tbl_review.setRowHidden(r, abs(discrepancy_val) < 1e-9)
            else:
                self.tbl_review.setRowHidden(r, False)

    def _approve_and_finalize(self):
        """مغایرت‌ها را در دیتابیس ثبت کرده و انبارگردانی را نهایی می‌کند."""
        custom_doc_no = self.doc_no_edit.text().strip() or f"COUNT-{self.count_id}"
        
        discrepancies_to_apply = []
        for r in range(self.tbl_review.rowCount()):
            if self.tbl_review.isRowHidden(r): continue
            
            discrepancy_val = float(self.tbl_review.item(r, 6).text())
            if abs(discrepancy_val) > 1e-9:
                reason_combo = self.tbl_review.cellWidget(r, 7)
                if not reason_combo or reason_combo.currentIndex() == 0:
                    QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", f"لطفاً برای کالای «{self.tbl_review.item(r, 0).text()}» در لوکیشن «{self.tbl_review.item(r, 1).text()}» دلیل مغایرت را انتخاب کنید.")
                    return
                
                item_data = self.tbl_review.item(r, 0).data(Qt.UserRole)
                discrepancies_to_apply.append({
                    'item_id': item_data['item_id'],
                    'location_id': item_data['location_id'],
                    'batch_no': item_data['batch_no'],
                    'expiry_date': item_data.get('expiry_date'),
                    'adjustment_qty': discrepancy_val,
                    'reason': reason_combo.currentText(),
                })

        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی عملیات",
            f"آیا برای صدور سند اصلاحی به شماره «{custom_doc_no}» و ثبت {len(discrepancies_to_apply)} مغایرت مطمئن هستید؟",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # فراخوانی تابع جدید و دقیق دیتابیس
                self.db.apply_inventory_adjustments(self.count_id, self.user_id, discrepancies_to_apply, custom_doc_no)
                
                self.parent().toast.show_message("✔ انبارگردانی با موفقیت نهایی و موجودی‌ها اصلاح شد.", "success")
                self.accept()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطای بحرانی", f"خطا در هنگام اصلاح موجودی انبار:\n{e}")
                print(traceback.format_exc())
                                                                
class StockCardDialog(QtWidgets.QDialog):
    """یک دیالوگ ساده برای نمایش اطلاعات و موجودی فعلی یک کالا."""
    def __init__(self, db: DB, item_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.item_id = item_id

        item_data = self.db.get_item_details(self.item_id)
        self.setWindowTitle(f"کارت کالا: {item_data.get('name', '')}")
        self.setMinimumWidth(450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        total_qty = item_data.get('qty', 0)
        total_qty_label = QtWidgets.QLabel(f"<b>{total_qty}</b> {item_data.get('unit', '')}")
        form_layout.addRow("موجودی کل فعلی:", total_qty_label)
        layout.addLayout(form_layout)
        
        layout.addWidget(QtWidgets.QLabel("موجودی به تفکیک لوکیشن:"))
        
        table = QtWidgets.QTableWidget()
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(['لوکیشن', 'مقدار'])
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        table.verticalHeader().hide()
        
        stock_details = self.db.stock_breakdown(self.item_id)
        table.setRowCount(len(stock_details))
        for r, detail in enumerate(stock_details):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(detail['loc']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(detail['qty'])))
        
        layout.addWidget(table)
        
# این کلاس جدید را به فایل خود اضافه کنید
class DocumentDetailsDialog(QtWidgets.QDialog):
    """خلاصه یک سند (شامل تمام کالاهای آن) را نمایش می‌دهد."""
    def __init__(self, db: DB, doc_no: str, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"جزئیات سند: {doc_no}")
        self.setMinimumWidth(600)
        # ... (این دیالوگ می‌تواند در آینده تکمیل شود) ...
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel(f"اینجا جزئیات کامل سند شماره {doc_no} نمایش داده خواهد شد."))
        
# این کلاس کاملاً جدید را به بالای فایل کد خود اضافه کنید
# (مثلاً بعد از قسمت import ها)

class NumericTableWidgetItem(QtWidgets.QTableWidgetItem):
    """یک سلول جدول سفارشی که اعداد را بر اساس مقدار واقعی آنها مرتب می‌کند، نه متن."""
    def __lt__(self, other):
        # تلاش برای تبدیل متن دو سلول به عدد (float)
        try:
            # کاماها را حذف می‌کنیم تا تبدیل به عدد به درستی انجام شود
            self_float = float(self.text().replace(',', ''))
            other_float = float(other.text().replace(',', ''))
            return self_float < other_float
        except (ValueError, TypeError):
            # اگر تبدیل به عدد ممکن نبود، بر اساس متن مقایسه کن (برای موارد غیر عددی)
            return super().__lt__(other)
        

# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید

class CustomColorDelegate(QtWidgets.QStyledItemDelegate):
    """
    نسخه نهایی و قطعی (با کنترل دستی پس‌زمینه):
    این نسخه با کنترل کامل و دستی پس‌زمینه، تضمین می‌کند که هم هایلایت انتخاب
    و هم رنگ وضعیت به درستی و بدون تداخل با یکدیگر کار می‌کنند.
    """
    def paint(self, painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex):
        # گام اول: کنترل کامل پس‌زمینه را به دست می‌گیریم
        
        # ابتدا چک می‌کنیم آیا ردیف انتخاب شده است یا خیر
        if option.state & QtWidgets.QStyle.State_Selected:
            # اگر انتخاب شده بود، آن را با رنگ هایلایت استاندارد سیستم پر می‌کنیم
            painter.fillRect(option.rect, option.palette.highlight())
        else:
            # اگر انتخاب نشده بود، رنگ وضعیت سفارشی خودمان را اعمال می‌کنیم
            background_data = index.data(QtCore.Qt.BackgroundRole)
            if background_data:
                painter.fillRect(option.rect, QtGui.QBrush(background_data))
            else:
                # اگر رنگ سفارشی هم نداشت، اجازه می‌دهیم خود استایل‌شیت
                # پس‌زمینه پیش‌فرض یا متناوب را ترسیم کند
                super().paint(painter, option, index)
                return # از ادامه کار جلوگیری می‌کنیم چون همه چیز کشیده شده است

        # گام دوم: حالا که پس‌زمینه را خودمان کشیده‌ایم، از متد اصلی می‌خواهیم
        # که فقط موارد رویی (foreground) مانند متن و آیکون را ترسیم کند.
        # برای این کار یک کپی از آپشن‌ها ساخته و به آن می‌گوییم پس‌زمینه ندارد.
        opt = QtWidgets.QStyleOptionViewItem(option)
        self.initStyleOption(opt, index)
        opt.state &= ~QtWidgets.QStyle.State_HasFocus # حذف فوکوس برای جلوگیری از ترسیم دوباره حاشیه
        opt.backgroundBrush = QtGui.QBrush(QtCore.Qt.transparent) # حذف پس‌زمینه از دستورالعمل
        
        # یک ویجت موقت برای دسترسی به استایل‌ها می‌سازیم
        widget = option.widget
        style = widget.style() if widget else QtWidgets.QApplication.style()
        
        # فقط محتوای آیتم (متن و آیکون) را ترسیم می‌کنیم
        style.drawControl(QtWidgets.QStyle.CE_ItemViewItem, opt, painter, widget)
                                                        
# ╔═════════════════════════════════════════════════════╗
# ║        دیالوگ گزارش‌گیری مالی هوشمند BOM           ║
# ╚═════════════════════════════════════════════════════╝
class FinancialBomReportDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ایجاد گزارش مالی BOM")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(600, 500)

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        self.pcode_combo = QtWidgets.QComboBox()
        self.pcode_combo.addItems(self.db.get_distinct_product_codes())
        form_layout.addRow("انتخاب بچ محصول نهایی برای گزارش:", self.pcode_combo)
        
        layout.addLayout(form_layout)
        
        self.materials_table = QtWidgets.QTableWidget()
        self.materials_table.setColumnCount(3)
        self.materials_table.setHorizontalHeaderLabels(['ماده اولیه مصرفی', 'نحوه گزارش', 'نام گروه (در صورت محرمانگی)'])
        self.materials_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.materials_table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.materials_table)

        btn_generate = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("x-office-spreadsheet"), " ایجاد فایل اکسل")
        btn_generate.setProperty("class", "primary")
        layout.addWidget(btn_generate)

        self.pcode_combo.currentTextChanged.connect(self._populate_materials)
        btn_generate.clicked.connect(self._generate_report)

        self._populate_materials() # فراخوانی اولیه

    def _populate_materials(self):
        self.materials_table.setRowCount(0)
        pcode = self.pcode_combo.currentText()
        if not pcode: return

        materials = self.db.get_bom_for_product_code(pcode)
        self.materials_table.setRowCount(len(materials))

        for r, material in enumerate(materials):
            self.materials_table.setItem(r, 0, QtWidgets.QTableWidgetItem(material['raw_item_name']))
            
            # --- ویجت‌های کنترلی برای هر ردیف ---
            # منوی کشویی
            combo = QtWidgets.QComboBox()
            combo.addItems(['شفاف (با نام اصلی)', 'محرمانه (در گروه)'])
            self.materials_table.setCellWidget(r, 1, combo)
            
            # کادر متن برای نام گروه
            line_edit = QtWidgets.QLineEdit()
            line_edit.setPlaceholderText("نام گروه را وارد کنید...")
            line_edit.setDisabled(True) # در ابتدا غیرفعال است
            self.materials_table.setCellWidget(r, 2, line_edit)
            
            # اتصال سیگنال برای فعال/غیرفعال کردن کادر متن
            combo.currentIndexChanged.connect(lambda state, le=line_edit: le.setEnabled(state == 1))

    def _generate_report(self):
        report_data = {}
        for r in range(self.materials_table.rowCount()):
            name = self.materials_table.item(r, 0).text()
            qty = float(self.db.get_bom_for_product_code(self.pcode_combo.currentText())[r]['qty'])
            
            combo = self.materials_table.cellWidget(r, 1)
            line_edit = self.materials_table.cellWidget(r, 2)

            if combo.currentIndex() == 1: # اگر محرمانه بود
                group_name = line_edit.text().strip()
                if not group_name:
                    QtWidgets.QMessageBox.warning(self, "خطا", f"لطفاً برای ماده محرمانه '{name}' یک نام گروه تعیین کنید.")
                    return
                # جمع‌آوری مقادیر در دیکشنری
                if group_name not in report_data: report_data[group_name] = 0
                report_data[group_name] += qty
            else: # اگر شفاف بود
                report_data[name] = qty
        
        # آماده‌سازی داده برای اکسل
        final_list = [{'ماده اولیه': name, 'مقدار مصرف': value} for name, value in report_data.items()]
        
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره گزارش مالی', f"BOM_{self.pcode_combo.currentText()}.xlsx", 'Excel (*.xlsx)')
        if not path: return
        
        try:
            import pandas as pd
            df = pd.DataFrame(final_list)
            df.to_excel(path, index=False)
            self.parent().toast.show_message("✔ گزارش مالی با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد فایل اکسل: {e}")
            
            
                    
                    
# ╔═════════════════════════════════════════════════════╗
# ║        مرکز کنترل محرمانگی (نسخه نهایی)             ║
# ╚═════════════════════════════════════════════════════╝
class ConfidentialityManagerDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_main = parent
        self.setWindowTitle("مرکز کنترل محرمانگی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 500)

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # پنل سمت راست: لیست گروه‌های تعریف شده توسط کاربر
        right_panel = QtWidgets.QWidget()
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.addWidget(QtWidgets.QLabel("<b>گروه‌های گزارش‌دهی</b>"))
        self.group_list = QtWidgets.QListWidget()
        self.group_list.itemSelectionChanged.connect(self.on_group_select)
        right_layout.addWidget(self.group_list)
        
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add_group = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " گروه جدید")
        btn_del_group = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف گروه")
        btn_layout.addWidget(btn_add_group); btn_layout.addWidget(btn_del_group)
        right_layout.addLayout(btn_layout)

        # پنل سمت چپ: لیست مواد اولیه برای اختصاص به گروه
        left_panel = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.materials_label = QtWidgets.QLabel("<b>مواد اولیه (برای گروه انتخاب شده تیک بزنید)</b>")
        left_layout.addWidget(self.materials_label)
        self.items_table = QtWidgets.QTableWidget()
        self.items_table.setColumnCount(2)
        self.items_table.setHorizontalHeaderLabels(['نام ماده اولیه', 'عضو این گروه است؟'])
        self.items_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.items_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        left_layout.addWidget(self.items_table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره تغییرات این گروه")
        btn_save.setProperty("class", "primary")
        left_layout.addWidget(btn_save)

        splitter.addWidget(left_panel); splitter.addWidget(right_panel)
        splitter.setSizes([450, 250])
        main_layout.addWidget(splitter)
        
        # اتصال سیگنال‌ها
        btn_add_group.clicked.connect(self._add_new_group)
        btn_del_group.clicked.connect(self._delete_group)
        btn_save.clicked.connect(self._save_group_changes)
        self.items_table.cellClicked.connect(self._toggle_checkbox)
        
        self._load_groups()
        self._load_all_raw_materials()

    def _load_groups(self):
        """لیست گروه‌هایی که کاربر تعریف کرده را بارگذاری می‌کند."""
        self.group_list.clear()
        self.group_list.addItems(self.db.get_all_reporting_groups())

    def _load_all_raw_materials(self):
        """جدول مواد اولیه را یک بار برای همیشه پر می‌کند."""
        self.items_table.setRowCount(0)
        materials = self.db.get_raw_materials_for_grouping()
        self.items_table.setRowCount(len(materials))
        for r, item in enumerate(materials):
            name_item = QtWidgets.QTableWidgetItem(item['name'])
            name_item.setData(Qt.UserRole, item['id'])
            name_item.setFlags(name_item.flags() & ~Qt.ItemIsEditable)
            self.items_table.setItem(r, 0, name_item)
            
            check_widget = QtWidgets.QWidget(); check_layout = QtWidgets.QHBoxLayout(check_widget)
            checkbox = QtWidgets.QCheckBox(); check_layout.addWidget(checkbox); check_layout.setAlignment(Qt.AlignCenter); check_layout.setContentsMargins(0,0,0,0)
            self.items_table.setCellWidget(r, 1, check_widget)

    def on_group_select(self):
        """با انتخاب یک گروه، چک‌باکس مواد اولیه مربوطه را در جدول سمت چپ فعال می‌کند."""
        selected_items = self.group_list.selectedItems()
        if not selected_items: 
            self.materials_label.setText("<b>برای اختصاص مواد، یک گروه را انتخاب کنید</b>")
            return
        
        group_name = selected_items[0].text()
        self.materials_label.setText(f"<b>مواد اولیه گروه: {group_name}</b>")
        
        all_materials = self.db.get_raw_materials_for_grouping()
        for r in range(self.items_table.rowCount()):
            item_id = self.items_table.item(r, 0).data(Qt.UserRole)
            checkbox = self.items_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            current_group = next((mat.get('reporting_group') for mat in all_materials if mat['id'] == item_id), "")
            checkbox.setChecked(current_group == group_name)

    def _add_new_group(self):
        """یک گروه گزارش‌دهی جدید با نام دلخواه کاربر ایجاد می‌کند."""
        text, ok = QtWidgets.QInputDialog.getText(self, 'گروه جدید', 'نام گروه محرمانه جدید را وارد کنید:')
        if ok and text:
            if text in [self.group_list.item(i).text() for i in range(self.group_list.count())]:
                QtWidgets.QMessageBox.warning(self, "خطا", "این نام گروه قبلاً استفاده شده است.")
            else:
                self.group_list.addItem(text)
                self.group_list.setCurrentRow(self.group_list.count() - 1)

    def _delete_group(self):
        """یک گروه و تمام تخصیص‌های آن را از سیستم حذف می‌کند."""
        selected_items = self.group_list.selectedItems()
        if not selected_items: return
        
        group_name = selected_items[0].text()
        reply = QtWidgets.QMessageBox.question(self, 'تایید حذف', f"آیا از حذف گروه '{group_name}' مطمئن هستید؟\n(تمام مواد اولیه عضو این گروه، از این پس به صورت شفاف گزارش خواهند شد)")
        
        if reply == QtWidgets.QMessageBox.Yes:
            self.db.clear_reporting_group(group_name)
            self._load_groups()
            self.on_group_select() # رفرش کردن چک‌باکس‌ها

    def _save_group_changes(self):
        """تغییرات عضویت مواد در گروه انتخاب شده را در دیتابیس ذخیره می‌کند."""
        selected_items = self.group_list.selectedItems()
        if not selected_items:
            QtWidgets.QMessageBox.warning(self, "خطا", "لطفاً ابتدا یک گروه را از لیست انتخاب کنید.")
            return
        group_name = selected_items[0].text()
        
        rules_to_save = []
        for r in range(self.items_table.rowCount()):
            item_id = self.items_table.item(r, 0).data(Qt.UserRole)
            is_checked = self.items_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox).isChecked()
            
            if is_checked:
                rules_to_save.append({'id': item_id, 'group_name': group_name})
            else:
                # اگر تیک برداشته شده، گروه آن را خالی می‌کنیم
                rules_to_save.append({'id': item_id, 'group_name': None})

        self.db.save_reporting_rules(rules_to_save)
        if hasattr(self.parent_main, 'toast'):
            self.parent_main.toast.show_message(f"✔ تغییرات برای گروه '{group_name}' ذخیره شد.", "success")

    def _toggle_checkbox(self, row, column):
        """با کلیک روی هر جای سلول ستون دوم، وضعیت چک‌باکس را تغییر می‌دهد."""
        if column == 1:
            widget = self.items_table.cellWidget(row, 1)
            if widget:
                checkbox = widget.findChild(QtWidgets.QCheckBox)
                if checkbox:
                    checkbox.setChecked(not checkbox.isChecked())        
        
# کلاس کمکی برای پنجره استثناها
class ExceptionsDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, group_prefix: str, is_group_confidential: bool, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"مدیریت استثناهای گروه {group_prefix}")
        self.setMinimumWidth(400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        
        # بر اساس وضعیت گروه، متن راهنما تغییر می‌کند
        info_text = "تیک مواردی را بزنید که می‌خواهند **برخلاف قانون گروه (محرمانه)، شفاف** باشند:" if is_group_confidential else "تیک مواردی را بزنید که می‌خواهند **برخلاف قانون گروه (شفاف)، محرمانه** باشند:"
        layout.addWidget(QtWidgets.QLabel(info_text))
        
        self.items_list = QtWidgets.QListWidget()
        layout.addWidget(self.items_list)
        
        items = self.db.get_items_for_main_group(group_prefix)
        for item in items:
            list_item = QtWidgets.QListWidgetItem(item['name'], self.items_list)
            list_item.setData(Qt.UserRole, item['id'])
            # بررسی اینکه آیا آیتم یک استثنا است یا نه
            is_confidential_item = bool(item.get('reporting_group'))
            is_exception = is_confidential_item != is_group_confidential
            list_item.setCheckState(Qt.Checked if is_exception else Qt.Unchecked)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def get_exception_ids(self):
        exceptions = []
        for i in range(self.items_list.count()):
            item = self.items_list.item(i)
            if item.checkState() == Qt.Checked:
                exceptions.append(item.data(Qt.UserRole))
        return exceptions

# کلاس اصلی و جدید مرکز کنترل محرمانگی
class AdvancedConfidentialityDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_main = parent
        self.rules = {} 
        self.setWindowTitle("مرکز کنترل هوشمند محرمانگی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(750, 400)

        layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # پنل راست: لیست گروه‌ها
        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.addWidget(QtWidgets.QLabel("<b>۱. گروه را انتخاب کنید:</b>"))
        self.group_list = QtWidgets.QListWidget()
        self.group_list.itemSelectionChanged.connect(self.on_group_select)
        right_layout.addWidget(self.group_list)
        btn_auto_detect = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), " شناسایی خودکار گروه‌ها")
        right_layout.addWidget(btn_auto_detect)
        
        # پنل چپ: تنظیمات
        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel)
        left_layout.addWidget(QtWidgets.QLabel("<b>۲. قوانین این گروه را تنظیم کنید:</b>"))
        
        self.confidential_check = QtWidgets.QCheckBox("این گروه به طور پیش‌فرض محرمانه است")
        self.report_name_edit = QtWidgets.QLineEdit(placeholderText="مثال: ترکیبات ویژه C")
        self.exceptions_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("preferences-system"), "مدیریت استثناها...")
        
        form_layout = QtWidgets.QFormLayout()
        form_layout.addRow(self.confidential_check)
        form_layout.addRow("نام گروه در گزارش:", self.report_name_edit)
        form_layout.addRow(self.exceptions_btn)
        left_layout.addLayout(form_layout)
        left_layout.addStretch()

        btn_save_rule = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره قانون برای این گروه")
        btn_save_rule.setProperty("class", "primary")
        left_layout.addWidget(btn_save_rule)

        splitter.addWidget(left_panel); splitter.addWidget(right_panel)
        splitter.setSizes([500, 250])
        layout.addWidget(splitter)
        
        # اتصالات
        self.confidential_check.toggled.connect(self.report_name_edit.setEnabled)
        self.exceptions_btn.clicked.connect(self.open_exceptions_dialog)
        btn_save_rule.clicked.connect(self.save_current_rule)
        btn_auto_detect.clicked.connect(self._load_main_groups)

        self.on_group_select() # برای غیرفعال کردن اولیه

    def _load_main_groups(self):
        self.group_list.clear()
        self.group_list.addItems(self.db.get_distinct_main_groups())

    def on_group_select(self):
        is_selected = bool(self.group_list.selectedItems())
        self.confidential_check.setEnabled(is_selected)
        self.report_name_edit.setEnabled(is_selected and self.confidential_check.isChecked())
        self.exceptions_btn.setEnabled(is_selected)
        
        if not is_selected: 
            self.confidential_check.setChecked(False)
            self.report_name_edit.clear()
            return

        group_prefix = self.group_list.currentItem().text()
        items_in_group = self.db.get_items_for_main_group(group_prefix)
        is_confidential = any(item.get('reporting_group') for item in items_in_group)
        self.confidential_check.setChecked(is_confidential)
        
        report_name = ""
        if is_confidential:
            for item in items_in_group:
                if item.get('reporting_group'):
                    report_name = item['reporting_group']; break
        self.report_name_edit.setText(report_name)

    def open_exceptions_dialog(self):
        selected = self.group_list.currentItem()
        if not selected: return
        group_prefix = selected.text()
        
        dlg = ExceptionsDialog(self.db, group_prefix, self.confidential_check.isChecked(), self)
        if dlg.exec_():
            exception_ids = dlg.get_exception_ids()
            self.rules[group_prefix] = self.rules.get(group_prefix, {})
            self.rules[group_prefix]['exceptions'] = exception_ids
            self.parent_main.toast.show_message(f"{len(exception_ids)} استثنا برای گروه {group_prefix} ثبت موقت شد.", "info")

    def save_current_rule(self):
        selected = self.group_list.currentItem()
        if not selected: return
        group_prefix = selected.text()
        
        is_confidential = self.confidential_check.isChecked()
        report_name = self.report_name_edit.text().strip()
        
        if is_confidential and not report_name:
            QtWidgets.QMessageBox.warning(self, "خطا", "برای گروه محرمانه، تعیین «نام در گزارش» الزامی است."); return
            
        report_name_to_save = report_name if is_confidential else ""
        exceptions = self.rules.get(group_prefix, {}).get('exceptions', [])
        
        self.db.save_confidentiality_rule(group_prefix, report_name_to_save, exceptions)
        self.parent_main.toast.show_message(f"✔ قانون برای گروه '{group_prefix}' با موفقیت در دیتابیس ذخیره شد.", "success")
        

# کل کلاس RoleManagerDialog را با این نسخه نهایی و کامل جایگزین کنید
class RoleManagerDialog(QtWidgets.QDialog):
    """پنجره مدیریت نقش‌ها با قابلیت تعیین دسترسی و تخصیص چندین داشبورد."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_role_id = None
        self.main_window = parent

        # --- *** اصلاح کلیدی و نهایی: تکمیل نقشه راهنمای سلسله مراتبی *** ---
        self.PERMISSION_HIERARCHY = {
            'page:view:dashboard': ("داشبورد", []),
            'page:view:items': ("کالاها و دارایی‌ها", ['items:', 'assets:create', 'assets:edit', 'assets:delete']),
            'page:view:transactions': ("تراکنش‌ها و رابط انبار", ['transactions:', 'assets:transact', 'warehouse:']),
            'page:view:purchasing': ("بازرگانی", ['purchasing:']),
            'page:view:qa': ("تضمین کیفیت (QA)", ['qa:']),
            'page:view:qc': ("کنترل کیفیت (QC)", ['qc:']),
            'page:view:sales': ("فروش", ['sales:']),
            'page:view:production': ("مدیریت تولید", ['production:']),
            'page:view:inventory': ("انبارگردانی", ['inventory:']),
            'page:view:forms': ("فرم‌های عمومی", []),
            'page:view:settings': ("تنظیمات", ['settings:']),
        }
        # --- ****************************************************** ---
        
        self.DASHBOARD_MAP = {
            "DEFAULT": "پنل کاربری استاندارد", "WAREHOUSE": "داشبورد انبار",
            "PURCHASING": "داشبورد بازرگانی", "CEO": "داشبورد مدیرعامل",
            "ADMIN": "داشبورد ویژه ادمین"
        }

        self.setWindowTitle("مدیریت نقش‌ها و دسترسی‌ها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(900, 700)
        main_layout = QtWidgets.QHBoxLayout(self); splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        roles_panel = QtWidgets.QWidget(); roles_layout = QtWidgets.QVBoxLayout(roles_panel)
        roles_layout.addWidget(QtWidgets.QLabel("<b>نقش‌های سیستم</b>")); self.roles_list = QtWidgets.QListWidget()
        roles_layout.addWidget(self.roles_list)
        roles_btn_layout = QtWidgets.QHBoxLayout()
        btn_add_role = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " نقش جدید"); btn_del_role = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف نقش")
        roles_btn_layout.addWidget(btn_add_role); roles_btn_layout.addWidget(btn_del_role)
        roles_layout.addLayout(roles_btn_layout); splitter.addWidget(roles_panel)

        details_panel = QtWidgets.QWidget(); details_layout = QtWidgets.QVBoxLayout(details_panel)
        self.details_title = QtWidgets.QLabel("<b>جزئیات (یک نقش را انتخاب کنید)</b>"); details_layout.addWidget(self.details_title)
        
        self.details_tabs = QtWidgets.QTabWidget()
        self.details_tabs.setStyleSheet("QTabBar::tab { min-width: 150px; padding: 10px; }")
        details_layout.addWidget(self.details_tabs)
        
        props_widget = QtWidgets.QWidget(); props_layout = QtWidgets.QFormLayout(props_widget)
        self.role_name_edit = QtWidgets.QLineEdit()
        props_layout.addRow("نام نقش:", self.role_name_edit)
        
        self.dashboard_table = QtWidgets.QTableWidget(len(self.DASHBOARD_MAP), 2)
        self.dashboard_table.verticalHeader().hide()
        self.dashboard_table.setHorizontalHeaderLabels(["نام داشبورد", "دسترسی دارد؟"])
        self.dashboard_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
        for r, (key, name) in enumerate(self.DASHBOARD_MAP.items()):
            name_item = QtWidgets.QTableWidgetItem(name); name_item.setData(Qt.UserRole, key)
            name_item.setFlags(name_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.dashboard_table.setItem(r, 0, name_item)
            
            checkbox_widget = QtWidgets.QWidget(); chk_layout = QtWidgets.QHBoxLayout(checkbox_widget)
            chk_box = QtWidgets.QCheckBox(); chk_layout.addWidget(chk_box); chk_layout.setAlignment(QtCore.Qt.AlignCenter)
            self.dashboard_table.setCellWidget(r, 1, checkbox_widget)
            self.dashboard_table.setRowHeight(r, 60)

        props_layout.addRow("داشبوردهای قابل دسترس:", self.dashboard_table)
        self.details_tabs.addTab(props_widget, "مشخصات و داشبوردها")

        perms_widget = QtWidgets.QWidget(); perms_widget_layout = QtWidgets.QVBoxLayout(perms_widget)
        self.permissions_tree = QtWidgets.QTreeWidget(); self.permissions_tree.setHeaderHidden(True)
        perms_widget_layout.addWidget(self.permissions_tree)
        self.details_tabs.addTab(perms_widget, "دسترسی‌ها")
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره تغییرات برای این نقش"); btn_save.setProperty("class", "primary")
        details_layout.addWidget(btn_save)
        splitter.addWidget(details_panel); splitter.setSizes([250, 650])

        self.roles_list.itemSelectionChanged.connect(self.on_role_selected)
        self.permissions_tree.itemChanged.connect(self.on_permission_toggled)
        btn_add_role.clicked.connect(self._add_role)
        btn_del_role.clicked.connect(self._delete_role)
        btn_save.clicked.connect(self._save_role_changes)

        self._populate_permissions_tree()
        self._load_roles()

    def _populate_permissions_tree(self):
        self.permissions_tree.clear()
        self.permissions_tree.blockSignals(True)
        all_perms_map = {p['code']: p for p in self.db.get_all_permissions()}
        
        parent_keys_ordered = list(self.PERMISSION_HIERARCHY.keys())

        for parent_code in parent_keys_ordered:
            if parent_code in self.PERMISSION_HIERARCHY and parent_code in all_perms_map:
                perm_data = all_perms_map.pop(parent_code)
                display_name, child_prefixes = self.PERMISSION_HIERARCHY[parent_code]
                
                parent_item = QtWidgets.QTreeWidgetItem(self.permissions_tree, [display_name])
                font = parent_item.font(0); font.setBold(True); font.setPointSize(11); parent_item.setFont(0, font)
                parent_item.setData(0, QtCore.Qt.UserRole, perm_data)
                parent_item.setToolTip(0, f"{perm_data['description']}\nکد: {perm_data['code']}")
                parent_item.setFlags(parent_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                parent_item.setCheckState(0, QtCore.Qt.Unchecked)

                children_to_add = []
                for prefix in child_prefixes:
                    matching_codes = [code for code in all_perms_map.keys() if code.startswith(prefix)]
                    for code in matching_codes:
                        children_to_add.append(all_perms_map[code])
                
                for perm in children_to_add:
                    if perm['code'] in all_perms_map:
                        del all_perms_map[perm['code']]

                for child_perm in sorted(children_to_add, key=lambda x: x['description']):
                    child_item = QtWidgets.QTreeWidgetItem(parent_item, [child_perm['description']])
                    child_item.setData(0, QtCore.Qt.UserRole, child_perm)
                    child_item.setToolTip(0, f"کد: {child_perm['code']}")
                    child_item.setFlags(child_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                    child_item.setCheckState(0, QtCore.Qt.Unchecked)
                    child_item.setDisabled(True)

        self.permissions_tree.expandAll()
        self.permissions_tree.blockSignals(False)

    def _load_roles(self):
        self.roles_list.blockSignals(True)
        self.roles_list.clear()
        roles = self.db.get_all_roles()
        for role in roles:
            item = QtWidgets.QListWidgetItem(role['name']); item.setData(Qt.UserRole, role)
            self.roles_list.addItem(item)
        self.roles_list.blockSignals(False)
        self._clear_fields()

    def on_role_selected(self):
        self.details_tabs.setEnabled(True)
        self.permissions_tree.blockSignals(True)
        selected_items = self.roles_list.selectedItems()
        if not selected_items: self._clear_fields(); return
            
        role_data = selected_items[0].data(Qt.UserRole)
        self.current_role_id = role_data['id']
        role_name = role_data['name']
        
        self.details_title.setText(f"<b>جزئیات نقش: {role_name}</b>")
        self.role_name_edit.setText(role_name)

        is_admin_role = (role_name == 'Admin')
        self.role_name_edit.setReadOnly(is_admin_role)
        self.dashboard_table.setEnabled(not is_admin_role)
        self.permissions_tree.setEnabled(not is_admin_role)
        
        current_dashboards = {d['dashboard_key'] for d in self.db.execute_query("SELECT dashboard_key FROM role_dashboards WHERE role_id = %s", (self.current_role_id,))}
        for r in range(self.dashboard_table.rowCount()):
            key = self.dashboard_table.item(r, 0).data(Qt.UserRole)
            chk_box = self.dashboard_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            chk_box.setChecked(key in current_dashboards)

        current_perm_ids = set(self.db.get_permissions_for_role(self.current_role_id))
        
        iterator = QtWidgets.QTreeWidgetItemIterator(self.permissions_tree)
        while iterator.value():
            item = iterator.value()
            perm_data = item.data(0, QtCore.Qt.UserRole)
            if perm_data:
                is_checked = perm_data['id'] in current_perm_ids
                item.setCheckState(0, QtCore.Qt.Checked if is_checked else QtCore.Qt.Unchecked)
                if item.parent():
                    is_parent_checked = item.parent().checkState(0) == QtCore.Qt.Checked
                    item.setDisabled(not is_parent_checked)
            iterator += 1
            
        self.permissions_tree.blockSignals(False)

    def on_permission_toggled(self, item, column):
        if column == 0:
            is_checked = item.checkState(0) == QtCore.Qt.Checked
            self.permissions_tree.blockSignals(True)
            for i in range(item.childCount()):
                child = item.child(i)
                child.setDisabled(not is_checked)
                if not is_checked: child.setCheckState(0, QtCore.Qt.Unchecked)
            parent = item.parent()
            if parent and is_checked: parent.setCheckState(0, QtCore.Qt.Checked)
            self.permissions_tree.blockSignals(False)
    
    def _add_role(self):
        self._clear_fields()
        self.details_tabs.setEnabled(True)
        self.role_name_edit.setFocus()
        if self.toast: self.toast.show_message("اطلاعات نقش جدید را وارد کرده و ذخیره کنید.", "info")

    # --- RoleManagerDialog._delete_role (REPLACE WHOLE METHOD) ---
    def _delete_role(self):
        selected = self.roles_list.selectedItems()
        if not selected:
            return
        role_data = selected[0].data(Qt.UserRole)
        role_id, role_name = role_data['id'], role_data['name']

        if role_name == 'Admin':
            QtWidgets.QMessageBox.warning(self, "عملیات غیرمجاز", "نقش 'Admin' قابل حذف نیست.")
            return

        # هشدار پیش‌دستانه اگر نقش به کاربر وصل است
        users_in_role = self.db.check_role_in_use(role_id)
        if users_in_role:
            user_list_str = "\n - ".join(users_in_role)
            QtWidgets.QMessageBox.warning(self, "عملیات ناموفق",
                                        f"این نقش به کاربران زیر تخصیص یافته و قابل حذف نیست:\n\n{user_list_str}")
            return

        reply = QtWidgets.QMessageBox.question(self, "تایید حذف",
                                            f"آیا از حذف نقش «{role_name}» مطمئنید؟")
        if reply != QtWidgets.QMessageBox.Yes:
            return

        try:
            self.db.delete_role(role_id)
            self._load_roles()
            if self.toast:
                self.toast.show_message(f"✔ نقش «{role_name}» حذف شد.", "success")
        except ValueError as ve:
            QtWidgets.QMessageBox.warning(self, "عملیات ناموفق", str(ve))
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"حذف نقش با خطا مواجه شد:\n{e}")

    def _save_role_changes(self):
        name = self.role_name_edit.text().strip()
        if not name:
            if self.toast:
                self.toast.show_message("نام نقش نمی‌تواند خالی باشد.", "error")
            return

        role_id = self.current_role_id

        # 1) جمع‌آوری داشبوردهای انتخاب شده
        dashboard_keys = []
        for r in range(self.dashboard_table.rowCount()):
            chk_box = self.dashboard_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            if chk_box.isChecked():
                dashboard_keys.append(self.dashboard_table.item(r, 0).data(Qt.UserRole))

        # 2) جمع‌آوری پرمیژن‌های انتخاب‌شده (هم کُد هم ID)
        selected_codes = set()
        selected_ids = set()
        it = QtWidgets.QTreeWidgetItemIterator(self.permissions_tree)
        while it.value():
            item = it.value()
            if item.checkState(0) == QtCore.Qt.Checked:
                perm_data = item.data(0, QtCore.Qt.UserRole)
                if perm_data:
                    selected_codes.add(perm_data['code'])
                    selected_ids.add(perm_data['id'])
            it += 1

        # 3) نگاشت کامل همه‌ی پرمیژن‌ها برای lookup کُد->ID
        all_perms_map = {p['code']: p['id'] for p in self.db.get_all_permissions()}

        # 4) هسته‌ی FIX: اگر هر فرزندِ یک صفحه تیک خورد، والدِ page:view:* را خودکار اضافه کن
        #    PERMISSION_HIERARCHY از قبل در کلاس تعریف شده و برای هر page:view:* لیست پیشوندهای فرزند دارد.
        for parent_code, (_title, child_prefixes) in self.PERMISSION_HIERARCHY.items():
            if not parent_code.startswith('page:view:'):
                continue  # فقط والدهای صفحه مهم‌اند

            needs_parent = False
            for pref in child_prefixes:
                # اگر هر پرمیژنی با این پیشوندها انتخاب شده باشد، والد لازم است
                if any(code.startswith(pref) for code in selected_codes):
                    needs_parent = True
                    break

            if needs_parent and parent_code not in selected_codes:
                # والد را به‌صورت خودکار اضافه کن
                selected_codes.add(parent_code)
                parent_id = all_perms_map.get(parent_code)
                if parent_id is not None:
                    selected_ids.add(parent_id)

        # 5) ذخیره به دیتابیس (همان متد موجود)
        try:
            self.db.save_role_details(role_id, name, list(selected_ids), dashboard_keys)
            if self.toast:
                self.toast.show_message(f"✔ نقش '{name}' با موفقیت ذخیره شد.", "success")
            self._load_roles()

            # اگر این پنجره از MainWindow فراخوان شده، پس از ذخیره نقش‌ها منو را دوباره بساز
            if self.main_window and hasattr(self.main_window, "_rebuild_sidebar_if_needed"):
                # اگر چنین متدی داری استفاده می‌کنیم؛ در غیر این صورت بی‌صدا رد می‌شویم
                self.main_window._rebuild_sidebar_if_needed()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی نقش: {e}")

    def _clear_fields(self):
        self.roles_list.clearSelection()
        self.current_role_id = None
        self.role_name_edit.setReadOnly(False); self.role_name_edit.clear()
        self.permissions_tree.setEnabled(False)
        self.details_tabs.setEnabled(False)
        self.details_title.setText("<b>جزئیات (یک نقش را انتخاب کنید)</b>")
        
        for r in range(self.dashboard_table.rowCount()):
            self.dashboard_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox).setChecked(False)
        
        iterator = QtWidgets.QTreeWidgetItemIterator(self.permissions_tree)
        while iterator.value():
            item = iterator.value()
            item.setCheckState(0, QtCore.Qt.Unchecked)
            if item.parent(): item.setDisabled(True)
            iterator += 1                        
                                                                                                                                    
# این کلاس کاملاً جدید را به فایل خود اضافه کنید
class ApproveVoidDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش و تایید ابطال تراکنش‌های خروج به تولید."""
    def __init__(self, db: DB, user: str, parent=None):
            super().__init__(parent)
            # user_id را از parent می‌گیریم
            self.db, self.user, self.user_id = db, user, getattr(parent, 'user_id', None)
            self.toast = getattr(parent, 'toast', None)

            self.setWindowTitle("تایید/رد ابطال تراکنش‌های تولید")
            self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(600, 400)
            layout = QtWidgets.QVBoxLayout(self)
            layout.addWidget(QtWidgets.QLabel("<b>لیست درخواست‌های ابطال که منتظر تایید یا رد شما هستند:</b>"))

            self.tbl_voids = QtWidgets.QTableWidget()
            if hasattr(parent, '_style_table'): parent._style_table(self.tbl_voids)
            layout.addWidget(self.tbl_voids)

            btn_layout = QtWidgets.QHBoxLayout()
            btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید ابطال")
            btn_approve.setProperty("class", "primary")
            btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), " رد کردن ابطال")

            btn_layout.addWidget(btn_approve); btn_layout.addWidget(btn_reject); btn_layout.addStretch()
            layout.addLayout(btn_layout)

            btn_approve.clicked.connect(self._approve_selected_void)
            btn_reject.clicked.connect(self._reject_selected_void)
            self._load_pending_voids()

    def _load_pending_voids(self):
        """لیست ابطال‌های در انتظار را از دیتابیس خوانده و در جدول نمایش می‌دهد."""
        try:
            pending_voids = self.db.get_pending_voids()
            self.tbl_voids.setRowCount(0)
            # --- اصلاح: تعداد ستون‌ها صحیح شد ---
            self.tbl_voids.setColumnCount(4)
            self.tbl_voids.setHorizontalHeaderLabels(['ID تراکنش', 'نام کالا', 'مقدار', 'نوع تراکنش اصلی'])
            self.tbl_voids.setRowCount(len(pending_voids))

            for r, trans in enumerate(pending_voids):
                self.tbl_voids.setItem(r, 0, QtWidgets.QTableWidgetItem(str(trans['id'])))
                self.tbl_voids.setItem(r, 1, QtWidgets.QTableWidgetItem(trans['item_name']))
                self.tbl_voids.setItem(r, 2, NumericTableWidgetItem(str(trans['qty'])))
                self.tbl_voids.setItem(r, 3, QtWidgets.QTableWidgetItem(str(trans['original_type'])))
            
            self.tbl_voids.resizeColumnsToContents()
            self.tbl_voids.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            self.tbl_voids.setColumnHidden(0, True)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست: {e}", "critical")

    def _approve_selected_void(self):
        """ابطال انتخاب شده را پس از تایید نهایی، در دیتابیس اعمال می‌کند."""
        selected_rows = self.tbl_voids.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً یک ردیف را برای تایید انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        trans_id = int(self.tbl_voids.item(row, 0).text())
        item_name = self.tbl_voids.item(row, 1).text()

        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی",
            f"آیا از تایید ابطال تراکنش برای کالای '{item_name}' و بازگرداندن موجودی آن به انبار اصلی مطمئنید؟",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)

        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # --- اصلاح کلیدی در این خط انجام شده است ---
                # به جای self.user (رشته متنی)، از self.user_id (عدد صحیح) استفاده می‌کنیم
                self.db.approve_void_transaction(trans_id, self.user_id)
                if self.toast: self.toast.show_message("✔ ابطال با موفقیت تایید و موجودی اصلاح شد.", "success")
                self._load_pending_voids()
                if hasattr(self.parent(), 'refresh_all'):
                    self.parent().refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند تایید با خطا مواجه شد:\n{e}")
                
    def _reject_selected_void(self):
            """درخواست ابطال انتخاب شده را رد می‌کند."""
            selected_rows = self.tbl_voids.selectionModel().selectedRows()
            if not selected_rows:
                if self.toast: self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
                return

            reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد درخواست ابطال", "چرا با ابطال این تراکنش موافق نیستید؟")
            if ok and reason:
                row = selected_rows[0].row()
                trans_id = int(self.tbl_voids.item(row, 0).text())
                try:
                    self.db.reject_void_transaction(trans_id, self.user_id, reason)
                    if self.toast: self.toast.show_message("✖ درخواست ابطال رد شد و تراکنش به حالت عادی بازگشت.", "info")
                    self._load_pending_voids()
                    if hasattr(self.parent(), 'refresh_all'): self.parent().refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")                
class ApproveMaterialTransferDialog(QtWidgets.QDialog):
    """
    نسخه 2.0:
    - بهبود یافته با قابلیت رد کردن درخواست تحویل.
    - استفاده از ساختار استاندارد برنامه.
    """
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.toast = db, user_id, getattr(parent, 'toast', None)

        self.setWindowTitle("تایید/رد دریافت مواد اولیه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(750, 500)
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("<b>موارد زیر از انبار ارسال شده و منتظر تایید دریافت شما هستند:</b>"))

        self.tbl_transfers = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'): parent._style_table(self.tbl_transfers)
        layout.addWidget(self.tbl_transfers)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید دریافت موارد انتخاب شده")
        btn_approve.setProperty("class", "primary")
        
        btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), " رد کردن درخواست")
        btn_reject.setProperty("class", "danger")

        btn_layout.addStretch()
        btn_layout.addWidget(btn_reject)
        btn_layout.addWidget(btn_approve)
        layout.addLayout(btn_layout)

        btn_approve.clicked.connect(self._approve_selected)
        btn_reject.clicked.connect(self._reject_selected)
        self._load_pending_transfers()

    def _load_pending_transfers(self):
        # این متد بدون تغییر باقی می‌ماند چون منطق درستی دارد
        try:
            transfers = self.db.get_pending_transfers_to_production()
            self.tbl_transfers.setRowCount(0)
            self.tbl_transfers.setColumnCount(6)
            self.tbl_transfers.setHorizontalHeaderLabels(['ID تراکنش', 'نام کالا', 'شماره بچ', 'مقدار', 'کاربر فرستنده', 'تاریخ ارسال'])
            
            self.tbl_transfers.setRowCount(len(transfers))
            for r, trans in enumerate(transfers):
                self.tbl_transfers.setItem(r, 0, QtWidgets.QTableWidgetItem(str(trans['id'])))
                self.tbl_transfers.setItem(r, 1, QtWidgets.QTableWidgetItem(trans['item_name']))
                self.tbl_transfers.setItem(r, 2, QtWidgets.QTableWidgetItem(trans.get('batch_no', '')))
                self.tbl_transfers.setItem(r, 3, NumericTableWidgetItem(str(trans['qty'])))
                self.tbl_transfers.setItem(r, 4, QtWidgets.QTableWidgetItem(trans['requester']))
                self.tbl_transfers.setItem(r, 5, QtWidgets.QTableWidgetItem(to_shamsi(trans['t_date'])))
            
            self.tbl_transfers.setColumnHidden(0, True)
            self.tbl_transfers.resizeColumnsToContents()
            self.tbl_transfers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست: {e}", "critical")

    def _approve_selected(self):
        """تایید دریافت مواد اولیه (با گِیت QA قبل از هر مورد)."""
        selected_rows = self.tbl_transfers.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً یک یا چند ردیف را برای تایید انتخاب کنید.", "warning")
            return

        approved_count = 0
        for row in selected_rows:
            trans_id = int(self.tbl_transfers.item(row.row(), 0).text())

            
            self.db.finalize_transfer_to_production(trans_id, self.user_id)
            approved_count += 1

        if approved_count > 0:
            if self.toast: self.toast.show_message(f"✔ تعداد {approved_count} مورد با موفقیت دریافت و به موجودی تولید اضافه شد.", "success")
            self._load_pending_transfers()
            if hasattr(self.parent(), 'refresh_all'): self.parent().refresh_all()
    
# در کلاس ApproveMaterialTransferDialog
    def _reject_selected(self):
        """منطق جدید برای رد کردن درخواست تحویل"""
        selected_rows = self.tbl_transfers.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
            return
        
        # فقط اولین آیتم انتخاب شده را رد می‌کنیم تا از پیچیدگی جلوگیری شود
        row = selected_rows[0].row()
        trans_id = int(self.tbl_transfers.item(row, 0).text())
        item_name = self.tbl_transfers.item(row, 1).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کردن", f"چرا درخواست تحویل کالای «{item_name}» را رد می‌کنید؟")
        if not ok or not reason.strip():
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")
            return

        try:
            # --- اصلاح کلیدی اینجاست ---
            # حالا تابع صحیح دیتابیس را که قبلا اصلاح کردیم، فراخوانی می‌کنیم
            self.db.reject_raw_material_transfer(trans_id, self.user_id, reason)
            
            self.toast.show_message("درخواست با موفقیت رد و به انبار اطلاع داده شد.", "success")
            self._load_pending_transfers()
            if hasattr(self.parent(), 'refresh_all'): self.parent().refresh_all()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")                                            
                    
# کلاس RequestMaterialDialog را به طور کامل با این نسخه جایگزین کنید

class RequestMaterialDialog(QtWidgets.QDialog):
    """
    نسخه 2.0:
    - دارای فیلتر برای نمایش جداگانه مواد اولیه و لوازم بسته‌بندی.
    """
    # BEGIN REWRITE: RequestMaterialDialog.__init__
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)

        self.setObjectName('requestMaterialDialog')
        self.db = db
        self.setWindowTitle("درخواست مواد/لوازم از انبار - چندقلمه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(650)

        self._items_cache = {'ALL': [], 'RAW': [], 'PACK': []}

        main = QtWidgets.QVBoxLayout(self)

        # --- نوار ابزار بالایی (فیلتر + دکمه‌ها) ---
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("افزودن از دسته:"))
        self.filter_combo = QtWidgets.QComboBox()
        self.filter_combo.addItems(["هر دو", "مواد اولیه", "لوازم بسته‌بندی"])
        top.addWidget(self.filter_combo)
        top.addStretch(1)

        self.btn_add = QtWidgets.QPushButton("افزودن ردیف")
        self.btn_del = QtWidgets.QPushButton("حذف ردیف(ها)")
        top.addWidget(self.btn_add)
        top.addWidget(self.btn_del)
        main.addLayout(top)

        # --- جدول ردیف‌ها ---
        self.tbl = QtWidgets.QTableWidget(0, 3, self)
        self.tbl.setHorizontalHeaderLabels(["#", "کالا", "مقدار"])
        vh = self.tbl.verticalHeader()
        vh.setVisible(False)
        self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.tbl.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl.setColumnWidth(0, 40)
        self.tbl.setColumnWidth(2, 120)
        # /* UI-SCOPED-FIX: prod-req-dropdown-rows 2025-09-23 */
        self.tbl.setObjectName('productionReqTable')
        self.tbl.setWordWrap(True)
        vh.setDefaultSectionSize(40)
        vh.setMinimumSectionSize(36)
        vh.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
        vh.setDefaultAlignment(QtCore.Qt.AlignCenter)
        self.tbl.setStyleSheet("""/* UI-SCOPED-FIX: prod-req-dropdown-rows 2025-09-23 */
#productionReqTable::item {
    padding: 8px 12px;
}
#productionReqTable QComboBox,
#productionReqTable QLineEdit {
    min-height: 40px;
    padding: 8px 12px;
}
#productionReqTable QComboBox QAbstractItemView {
    max-height: 320px;
}
""")
        main.addWidget(self.tbl)

        # --- یادداشت اختیاری ---
        note_layout = QtWidgets.QHBoxLayout()
        note_layout.addWidget(QtWidgets.QLabel("یادداشت سند:"))
        self.notes_edit = QtWidgets.QLineEdit()
        self.notes_edit.setPlaceholderText("یادداشت اختیاری برای سند...")
        note_layout.addWidget(self.notes_edit)
        main.addLayout(note_layout)

        # --- دکمه‌های پایانی ---
        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        btns.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت درخواست")
        btns.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        main.addWidget(btns)

        # اتصالات
        self.btn_add.clicked.connect(self._add_row)
        self.btn_del.clicked.connect(self._remove_selected_rows)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)

        # داده‌ها
        self._populate_items_cache()
        self._add_row()  # یک ردیف اولیه
    # END REWRITE: RequestMaterialDialog.__init__
    
    # BEGIN ADD: RequestMaterialDialog._populate_items_cache
    def _populate_items_cache(self):
        """فهرست اقلام مجاز را برای سه حالت ALL/RAW/PACK بارگذاری می‌کند."""
        self._items_cache = {'ALL': [], 'RAW': [], 'PACK': []}
        try:
            rows = self.db.execute_query(
                "SELECT i.id, i.name, i.category FROM items i "
                "WHERE i.category IN ('مواد اولیه','لوازم بسته‌بندی') ORDER BY i.name"
            ) or []
            for r in rows:
                cat = r.get('category') or ''
                entry = {'id': r['id'], 'name': r['name']}
                self._items_cache['ALL'].append(entry)
                if cat == 'مواد اولیه':
                    self._items_cache['RAW'].append(entry)
                elif cat == 'لوازم بسته‌بندی':
                    self._items_cache['PACK'].append(entry)
        except Exception as e:
            print(f"populate items cache failed: {e}")
    # END ADD: RequestMaterialDialog._populate_items_cache
    
    # BEGIN ADD: RequestMaterialDialog._add_row
    def _add_row(self):
        """یک ردیف جدید با کمبوباکس کالا و ورودی مقدار اضافه می‌کند."""
        r = self.tbl.rowCount()
        self.tbl.insertRow(r)

        # ستون #
        seq_item = QtWidgets.QTableWidgetItem(str(r + 1))
        seq_item.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        seq_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tbl.setItem(r, 0, seq_item)

        # ستون کالا (ComboBox)
        combo = QtWidgets.QComboBox(self.tbl)
        combo.setEditable(True)
        combo.setInsertPolicy(QtWidgets.QComboBox.NoInsert)
        combo.setMinimumWidth(280)
        combo.setMinimumHeight(40)
        combo.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        combo.setToolTip(combo.currentText())
        combo.currentTextChanged.connect(lambda text, w=combo: w.setToolTip(text))
        self._configure_item_combo(combo)

        # پر کردن بر اساس فیلتر فعلی
        f = self.filter_combo.currentText()
        key = 'ALL' if f == 'هر دو' else ('RAW' if f == 'مواد اولیه' else 'PACK')
        combo.clear()
        for it in self._items_cache.get(key, []):
            combo.addItem(it['name'], it['id'])
        combo.setToolTip(combo.currentText())

        self.tbl.setCellWidget(r, 1, combo)

        # ستون مقدار
        qty = QtWidgets.QLineEdit(self.tbl)
        qty.setMinimumHeight(40)
        qty.setValidator(QtGui.QDoubleValidator(0.001, 1e12, 3))
        qty.setPlaceholderText("0.000")
        qty.setAlignment(QtCore.Qt.AlignCenter)
        qty.textChanged.connect(lambda text, w=qty: w.setToolTip(text))
        self.tbl.setCellWidget(r, 2, qty)
    

    # BEGIN ADD: RequestMaterialDialog._configure_item_combo
    def _configure_item_combo(self, combo: QtWidgets.QComboBox):
        """Ensure dropdown stays within dialog bounds and remains readable."""
        import types
        combo.setMaxVisibleItems(12)
        popup_view = QtWidgets.QListView(combo)
        popup_view.setWordWrap(True)
        popup_view.setSpacing(4)
        popup_view.setUniformItemSizes(False)
        popup_view.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        popup_view.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
        popup_view.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        popup_view.setResizeMode(QtWidgets.QListView.Adjust)
        combo.setView(popup_view)

        def _adjust_popup():
            view = combo.view()
            if not view:
                return
            width = combo.width()
            view.setMinimumWidth(width)
            view.setMaximumWidth(width)
            max_height = 320
            try:
                screen = QtWidgets.QApplication.primaryScreen()
                if screen:
                    screen_limit = int(screen.availableGeometry().height() * 0.4)
                    if screen_limit > 0:
                        max_height = min(max_height, screen_limit)
            except Exception:
                pass
            view.setMaximumHeight(max(220, max_height))

        original_show_popup = combo.showPopup

        def _patched_show_popup(self_combo):
            _adjust_popup()
            original_show_popup()

        combo.showPopup = types.MethodType(_patched_show_popup, combo)

        line_edit = combo.lineEdit()
        if line_edit is not None:
            line_edit.setMinimumHeight(40)
            line_edit.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        _adjust_popup()
    # END ADD: RequestMaterialDialog._configure_item_combo

    # BEGIN ADD: RequestMaterialDialog._remove_selected_rows
    def _remove_selected_rows(self):
        rows = sorted({idx.row() for idx in self.tbl.selectedIndexes()}, reverse=True)
        for r in rows:
            self.tbl.removeRow(r)
        # بازشماری
        for i in range(self.tbl.rowCount()):
            it = self.tbl.item(i, 0)
            if it:
                it.setText(str(i + 1))
    # END ADD: RequestMaterialDialog._remove_selected_rows
    
    

    def _populate_items(self):
        """لیست کالاها را بر اساس دسته‌بندی انتخاب شده، فیلتر و بارگذاری می‌کند."""
        self.item_combo.clear()
        
        category_filter = 'مواد اولیه' if self.radio_raw.isChecked() else 'لوازم بسته‌بندی'
        
        try:
            query = "SELECT id, name FROM items WHERE category = %s ORDER BY name"
            all_requestable_items = self.db.execute_query(query, (category_filter,))
            
            if not all_requestable_items:
                self.item_combo.addItem(f"هیچ کالایی در دسته «{category_filter}» یافت نشد.", -1)
                self.item_combo.setEnabled(False)
            else:
                self.item_combo.setEnabled(True)
                for item in all_requestable_items:
                    self.item_combo.addItem(item['name'], item['id'])
        except Exception as e:
            print(f"Error populating materials for request dialog: {e}")

    # BEGIN REWRITE: RequestMaterialDialog.get_request_data
    def get_request_data(self):
        """
        خروجی جدید: لیست اقلام معتبر برای ثبت چندقلمه‌ای.
        ساختار: [{'item_id': int, 'quantity': float, 'item_name': str}, ...]
        """
        lines = []
        for r in range(self.tbl.rowCount()):
            combo = self.tbl.cellWidget(r, 1)
            qty_w = self.tbl.cellWidget(r, 2)
            try:
                iid = int(combo.currentData()) if combo else None
                qty = float(qty_w.text()) if qty_w and qty_w.text() else 0
            except Exception:
                iid, qty = None, 0
            name = combo.currentText() if combo else ''
            if iid and qty > 0:
                lines.append({'item_id': iid, 'quantity': qty, 'item_name': name})
        notes = (self.notes_edit.text() or '').strip()
        return {'lines': lines, 'notes': notes}
    # END REWRITE: RequestMaterialDialog.get_request_data
    
# این کلاس را به طور کامل جایگزین کنید
class AddAssetDialog(QtWidgets.QDialog):
    """دیالوگ کامل برای افزودن یا ویرایش یک دارایی جدید با فرمت‌بندی قیمت."""
    def __init__(self, db: DB, asset_data=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تعریف/ویرایش دارایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)
        
        layout = QtWidgets.QFormLayout(self)
        self.e_code = QtWidgets.QLineEdit()
        self.e_name = QtWidgets.QLineEdit()
        self.e_brand = QtWidgets.QLineEdit()
        self.e_model = QtWidgets.QLineEdit()
        self.e_cost = QtWidgets.QDoubleSpinBox()
        self.e_cost.setRange(0, 1e12)
        self.e_cost.setDecimals(0)
        self.e_cost.setGroupSeparatorShown(True) # <<< این خط فرمت‌بندی را اعمال می‌کند
        
        layout.addRow("کد دارایی (منحصر به فرد):", self.e_code)
        layout.addRow("نام دارایی:", self.e_name)
        layout.addRow("برند:", self.e_brand)
        layout.addRow("مدل:", self.e_model)
        layout.addRow("ارزش ریالی:", self.e_cost)

        if asset_data:
            self.e_code.setText(asset_data.get('code', ''))
            self.e_name.setText(asset_data.get('name', ''))
            self.e_brand.setText(asset_data.get('brand', ''))
            self.e_model.setText(asset_data.get('model', ''))
            self.e_cost.setValue(asset_data.get('cost', 0))
            self.e_code.setReadOnly(True)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        code = self.e_code.text().strip()
        name = self.e_name.text().strip()
        if code and name:
            return {'code': code, 'name': name, 'brand': self.e_brand.text().strip(), 'model': self.e_model.text().strip(), 'cost': self.e_cost.value()}
        return None
    
        
        
    
class AssetAttachDialog(QtWidgets.QDialog):
    """دیالوگ مدیریت پیوست‌ها برای تراکنش‌های دارایی."""
    def __init__(self, db: DB, asset_trans_id: int, parent=None):
        super().__init__(parent)
        self.db, self.tid = db, asset_trans_id
        self.setWindowTitle('پیوست‌های تراکنش دارایی')
        self.resize(380, 320)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        v = QtWidgets.QVBoxLayout(self)
        self.lst = QtWidgets.QListWidget(); v.addWidget(self.lst)

        btn_row = QtWidgets.QHBoxLayout(); v.addLayout(btn_row)
        btn_scan = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("scanner"), " اسکن"); btn_row.addWidget(btn_scan)
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("add"), " افزودن فایل"); btn_row.addWidget(btn_add)
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("delete"), " حذف"); btn_row.addWidget(btn_del)
        btn_row.addStretch(); btn_close = QtWidgets.QPushButton('بستن'); btn_row.addWidget(btn_close)

        self.lst.itemDoubleClicked.connect(lambda itm: QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(itm.data(Qt.UserRole))))
        
        btn_scan.clicked.connect(self._scan_and_add)
        btn_add.clicked.connect(self._add)
        btn_del.clicked.connect(self._delete)
        btn_close.clicked.connect(self.accept)

        self._load()

    def _load(self):
        self.lst.clear()
        for rec in self.db.list_asset_files(self.tid):
            itm = QtWidgets.QListWidgetItem(Path(rec['path']).name)
            itm.setData(Qt.UserRole, rec['path'])
            itm.setData(Qt.UserRole+1, rec['id'])
            self.lst.addItem(itm)

    def _add(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if path:
            self.db.add_asset_file(self.tid, path); self._load()
    
    def _scan_and_add(self):
        scanned_file_path = scan_document(self)
        if scanned_file_path:
            self.db.add_asset_file(self.tid, scanned_file_path); self._load()

    def _delete(self):
        itm = self.lst.currentItem()
        if not itm: return
        fid = itm.data(Qt.UserRole+1)
        if QtWidgets.QMessageBox.question(self, 'حذف', 'مطمئن؟') != QtWidgets.QMessageBox.Yes: return
        self.db.delete_asset_file(fid); self._load()

class AssetExitDialog(QtWidgets.QDialog):
    """نسخه نهایی و کامل دیالوگ خروج دارایی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent 
        self.setWindowTitle("ثبت خروج دارایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        main_layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        form_layout.setSpacing(15)
        main_layout.addLayout(form_layout)

        self.asset_combo = QtWidgets.QComboBox()
        self.doc_no_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QLineEdit()
        
        form_layout.addRow("انتخاب دارایی:", self.asset_combo)
        form_layout.addRow("شماره سند/حواله:", self.doc_no_edit)
        form_layout.addRow("توضیحات:", self.notes_edit)

        mgmt_layout = QtWidgets.QHBoxLayout()
        btn_add_asset = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " تعریف دارایی جدید")
        btn_add_asset.clicked.connect(self._add_new_asset)
        mgmt_layout.addWidget(btn_add_asset)
        mgmt_layout.addStretch()
        main_layout.addLayout(mgmt_layout)

        self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ادامه و افزودن پیوست")
        self.buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        main_layout.addWidget(self.buttons)

        self._load_assets()

    def _load_assets(self):
        current_selection = self.asset_combo.currentData()
        self.asset_combo.clear()
        assets = self.db.list_assets_in_stock()
        ok_button = self.buttons.button(QtWidgets.QDialogButtonBox.Ok)
        if not assets:
            self.asset_combo.addItem("هیچ دارایی در انبار برای خروج وجود ندارد.", -1)
            if ok_button: ok_button.setEnabled(False)
        else:
            if ok_button: ok_button.setEnabled(True)
            for asset in assets:
                self.asset_combo.addItem(f"{asset['code']} - {asset['name']}", asset['id'])
            if current_selection:
                index = self.asset_combo.findData(current_selection)
                if index != -1: self.asset_combo.setCurrentIndex(index)

    def _add_new_asset(self):
        dlg = AddAssetDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data and self.parent_window and hasattr(self.parent_window, 'user_id'):
                try:
                    self.db.add_asset(data['code'], data['name'], user_id=self.parent_window.user_id)
                    self._load_assets()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"دارایی با این کد از قبل موجود است یا خطای دیگری رخ داد.\n{e}")

    def get_data(self):
        doc_no = self.doc_no_edit.text().strip()
        if not doc_no:
            QtWidgets.QMessageBox.warning(self, "خطای ورودی", "وارد کردن شماره سند الزامی است.")
            return None
        if self.asset_combo.currentData() == -1: return None
        return {
            "asset_id": self.asset_combo.currentData(),
            "doc_no": doc_no,
            "notes": self.notes_edit.text(),
        }

# کلاس SelectAssetDialog را به طور کامل با این نسخه جایگزین کنید

class SelectAssetDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب یک دارایی از لیست فیلتر شده بر اساس وضعیت."""
    def __init__(self, db: DB, title: str, status_filter: list, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(title)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400) # عرض بیشتر برای نمایش پیام
        
        layout = QtWidgets.QFormLayout(self)
        self.asset_combo = QtWidgets.QComboBox()
        self.asset_combo.setEditable(True) # قابلیت جستجو
        self.asset_combo.setCompleter(QtWidgets.QCompleter(self.asset_combo.model()))
        layout.addRow("انتخاب دارایی:", self.asset_combo)
        
        placeholders = ','.join(['%s'] * len(status_filter))
        query = f"SELECT id, code, name FROM assets WHERE status IN ({placeholders}) ORDER BY name"
        assets = self.db.execute_query(query, tuple(status_filter))
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)
        
        # --- اصلاح کلیدی: منطق هوشمند برای نمایش پیام ---
        if not assets:
            # اگر هیچ دارایی یافت نشد، یک پیام راهنما نمایش داده و دکمه OK را غیرفعال کن
            status_text = ' یا '.join(status_filter)
            self.asset_combo.addItem(f"هیچ دارایی با وضعیت '{status_text}' یافت نشد.", -1)
            self.asset_combo.setEnabled(False)
            buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
        else:
            # در غیر این صورت، لیست دارایی‌ها را پر کن
            for asset in assets:
                self.asset_combo.addItem(f"{asset['code']} - {asset['name']}", asset['id'])

    def get_selected_asset_id(self):
        return self.asset_combo.currentData()    
    
# این کلاس جدید را به فایل کد خود اضافه کنید

class TemporaryExitDialog(QtWidgets.QDialog):
    """دیالوگ برای ثبت خروج موقت یک دارایی."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ثبت خروج موقت دارایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        layout = QtWidgets.QFormLayout(self)
        self.reason_combo = QtWidgets.QComboBox()
        self.reason_combo.addItems(["خروج (تعمیرات)", "خروج (پروژه)"])
        self.doc_no_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QLineEdit()
        layout.addRow("دلیل خروج:", self.reason_combo)
        layout.addRow("شماره سند/مجوز:", self.doc_no_edit)
        layout.addRow("توضیحات:", self.notes_edit)
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        return {
            "t_type": self.reason_combo.currentText(),
            "t_no": self.doc_no_edit.text(),
            "notes": self.notes_edit.text()
        }
        
        
# این کلاس کاملاً جدید را به فایل کد خود اضافه کنید
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class BarcodeLabelDialog(QtWidgets.QDialog):
    """
    نسخه نهایی: دیالوگی برای تولید و نمایش لیبل بارکد خوانا و کامل.
    - نام کالا (فارسی/انگلیسی) را به درستی در بالا نمایش می‌دهد.
    - کد عددی را همیشه در پایین بارکد نمایش می‌دهد.
    - نیازمند وجود فایل فونت در کنار اسکریپت است.
    """
    def __init__(self, item_name: str, item_id: str, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"لیبل بارکد برای: {item_name}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(350)

        layout = QtWidgets.QVBoxLayout(self)
        
        self.label_widget = QtWidgets.QLabel("در حال تولید بارکد...")
        self.label_widget.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.label_widget)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره لیبل (جهت چاپ)")
        btn_save.clicked.connect(self.save_label)
        layout.addWidget(btn_save)

        self.barcode_image_bytes = self._generate_barcode(item_id, item_name)
        
        if self.barcode_image_bytes:
            pixmap = QPixmap()
            pixmap.loadFromData(self.barcode_image_bytes)
            self.label_widget.setPixmap(pixmap.scaledToWidth(300, Qt.SmoothTransformation))
        else:
            btn_save.setEnabled(False)

    def _prepare_text(self, text: str):
        """متن را برای نمایش صحیح (فارسی/انگلیسی) آماده می‌کند."""
        import re
        # اگر حتی یک کاراکتر فارسی در متن وجود داشت، عملیات فارسی‌سازی را انجام بده
        if re.search(r'[\u0600-\u06FF]', text):
            reshaped_text = reshape(text)
            return get_display(reshaped_text, base_dir='R')
        # در غیر این صورت، متن اصلی (انگلیسی) را برگردان
        return text

# در کلاس BarcodeLabelDialog، این متد را با نسخه جدید جایگزین کنید
    def _generate_barcode(self, item_id: str, item_name: str):
        """بارکد Code128 را با استفاده از فونت‌های استاندارد ویندوز تولید می‌کند."""
        try:
            import barcode
            from barcode.writer import ImageWriter
            from io import BytesIO
            from PIL import Image, ImageDraw, ImageFont

            code128 = barcode.get_barcode_class('code128')
            
            # ۱. تولید بارکد با نمایش اجباری متن (کد عددی)
            writer_options = {'write_text': True, 'module_height': 12.0, 'font_size': 14, 'text_distance': 5.0}
            buffer = BytesIO()
            code128(item_id, writer=ImageWriter()).write(buffer, writer_options)
            buffer.seek(0)
            barcode_img = Image.open(buffer)

            # ۲. ایجاد بوم (canvas) جدید برای لیبل نهایی
            text_height = 45
            padding = 15
            final_width = max(300, barcode_img.width + 40)
            final_height = barcode_img.height + text_height + padding
            final_img = Image.new('RGB', (final_width, final_height), 'white')
            draw = ImageDraw.Draw(final_img)

            # ۳. نوشتن نام محصول در بالای لیبل با فونت Tahoma
            try:
                # --- اصلاح کلیدی: استفاده مستقیم از فونت ویندوز ---
                font = ImageFont.truetype("tahoma.ttf", 22)
            except IOError:
                # جایگزین در صورت نبود فونت Tahoma (بسیار نادر)
                font = ImageFont.load_default()
            
            bidi_text = self._prepare_text(item_name)
            text_bbox = draw.textbbox((0, 0), bidi_text, font=font)
            text_width = text_bbox[2] - text_bbox[0]
            text_x = (final_img.width - text_width) / 2
            draw.text((text_x, 10), bidi_text, fill='black', font=font)
            
            # ۴. چسباندن بارکد زیر متن
            barcode_x = (final_img.width - barcode_img.width) // 2
            final_img.paste(barcode_img, (barcode_x, text_height))
            
            # ۵. ذخیره تصویر نهایی در حافظه
            final_buffer = BytesIO()
            final_img.save(final_buffer, 'PNG')
            final_buffer.seek(0)
            return final_buffer.getvalue()

        except ImportError as e:
            self.label_widget.setText(f"خطا: کتابخانه‌های لازم نصب نیستند: {e}")
            return None
        except Exception as e:
            print(f"Error generating barcode label: {e}")
            self.label_widget.setText(f"خطا در تولید لیبل: {e}")
            return None
        
        
    def save_label(self):
        """دیالوگ ذخیره فایل را باز کرده و تصویر بارکد را ذخیره می‌کند."""
        if not self.barcode_image_bytes:
            QMessageBox.warning(self, "خطا", "تصویر بارکدی برای ذخیره وجود ندارد.")
            return

        default_filename = f"Label_{self.windowTitle().split(': ')[-1]}.png"
        path, _ = QFileDialog.getSaveFileName(self, "ذخیره فایل لیبل", default_filename, "PNG Image (*.png)")
        
        if path:
            try:
                with open(path, 'wb') as f:
                    f.write(self.barcode_image_bytes)
                if hasattr(self.parent(), 'toast'):
                    self.parent().toast.show_message("✔ لیبل با موفقیت ذخیره شد.", "success")
            except Exception as e:
                QMessageBox.critical(self, "خطا در ذخیره فایل", f"خطا: {e}")
                                

# این کلاس کاملاً جدید را به فایل خود اضافه کنید
class InventoryAdjustmentDialog(QtWidgets.QDialog):
    """پنجره‌ای برای ثبت اصلاحیه‌های انبارگردانی با استفاده از PyQt5."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت سند اصلاحی موجودی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_combo = QtWidgets.QComboBox()
        self.item_combo.setEditable(True)
        self.item_combo.setCompleter(QtWidgets.QCompleter(self.item_combo.model()))

        self.location_combo = QtWidgets.QComboBox()
        
        self.counted_qty_edit = QtWidgets.QLineEdit()
        self.counted_qty_edit.setValidator(QtGui.QDoubleValidator(-1e9, 1e9, 3))

        self.reason_combo = QtWidgets.QComboBox()
        self.reason_combo.addItems(['کسری (ضایعات)', 'کسری (شمارش غلط)', 'اضافی (یافت شده)', 'اصلاح خطای کاربری', 'سایر'])

        layout.addRow("انتخاب کالا:", self.item_combo)
        layout.addRow("محل انبار:", self.location_combo)
        layout.addRow("مقدار شمارش شده (جدید):", self.counted_qty_edit)
        layout.addRow("دلیل اصلاح:", self.reason_combo)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت اصلاحیه")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)
        
        self.item_combo.currentIndexChanged.connect(self._load_locations_for_item)
        self._load_all_items()

    def _load_all_items(self):
        items = self.db.items_brief()
        for item in items:
            self.item_combo.addItem(item['name'], item)

    def _load_locations_for_item(self):
        self.location_combo.clear()
        item_data = self.item_combo.currentData()
        if not isinstance(item_data, dict): return
        
        item_id = item_data.get('id')
        locations = self.db.get_item_locations_with_stock(item_id)
        if not locations:
            self.location_combo.addItem("کالا در هیچ لوکیشنی موجودی ندارد", -1)
        else:
            for loc in locations:
                display_text = f"{loc['loc_label']} (بچ: {loc.get('batch_no', 'N/A')})"
                self.location_combo.addItem(display_text, loc)

    def get_data(self):
        try:
            item_data = self.item_combo.currentData()
            loc_data = self.location_combo.currentData()
            counted_qty_text = self.counted_qty_edit.text()
            reason = self.reason_combo.currentText()

            if not all([isinstance(item_data, dict), isinstance(loc_data, dict), reason, counted_qty_text]):
                return None
            
            return {
                'item_id': item_data['id'],
                'location_id': loc_data['id'],
                'batch_no': loc_data.get('batch_no', 'default_adj_batch'),
                'counted_qty': float(counted_qty_text),
                'reason': reason
            }
        except (ValueError, TypeError):
            return None
        
# این کلاس را به طور کامل با نسخه زیر جایگزین کنید

# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class DetailedStockViewDialog(QtWidgets.QDialog):
    """
    نسخه نهایی (V4.0) پنجره جزئیات کامل موجودی
    ***اصلاح کلیدی: ستون "وضعیت" به جدول اضافه شد.***
    """
    def __init__(self, db: DB, item_data: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.item_data = item_data
        self.parent_window = parent

        self.setWindowTitle(f"جزئیات کامل موجودی: {self.item_data.get('name')}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(800, 600)

        layout = QtWidgets.QVBoxLayout(self)

        # ... (بخش نوار ابزار بدون تغییر باقی می‌ماند) ...
        tools_layout = QtWidgets.QHBoxLayout()
        filter_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), "فیلتر پیشرفته")
        reset_filter_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "ریست فیلتر")
        export_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "خروجی اکسل")
        tools_layout.addStretch(); tools_layout.addWidget(filter_btn); tools_layout.addWidget(reset_filter_btn); tools_layout.addWidget(export_btn)
        layout.addLayout(tools_layout)

        self.tree = QtWidgets.QTreeWidget()
        self.tree.setObjectName("details_tree")
        # --- *** هدر جدید با ستون وضعیت *** ---
        self.tree.setHeaderLabels(['انبار / بچ', 'تاریخ انقضا', 'وضعیت', 'موجودی', 'واحد'])
        header = self.tree.header()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, 5):
            header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)

        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self._show_context_menu)

        layout.addWidget(self.tree)

        filter_btn.clicked.connect(lambda: FilterDialog(self.tree, self).exec_())
        reset_filter_btn.clicked.connect(self._reset_tree_filter)
        export_btn.clicked.connect(lambda: export_table_to_excel(self.tree, self))

        self._populate_stock_details()

    def _populate_stock_details(self):
        self.tree.clear()
        stock_details = self.db.stock_breakdown(self.item_data['id'])

        if not stock_details:
            QtWidgets.QTreeWidgetItem(self.tree, ["این کالا در انبارهای اصلی موجودی ندارد."])
            return

        locations = {}
        for row in stock_details:
            loc_label = row['loc']
            if loc_label not in locations: locations[loc_label] = []
            locations[loc_label].append(row)

        for loc_label, batches in locations.items():
            total_in_loc = sum(b['qty'] for b in batches)
            loc_item = QtWidgets.QTreeWidgetItem(self.tree)
            loc_item.setText(0, f"{loc_label}")
            loc_item.setFont(0, QFont(FONT_FAMILY, FONT_SIZE, QFont.Bold))
            loc_item.setText(3, str(total_in_loc))
            loc_item.setText(4, batches[0]['unit'])

            for batch in batches:
                expiry_text = to_shamsi(batch.get('expiry_date'))
                child_text = f"    بچ: {batch['batch_no']}"

                status_text = batch.get('status', 'نامشخص')
                child_item = QtWidgets.QTreeWidgetItem(loc_item, [child_text, expiry_text, status_text, str(batch['qty']), batch['unit']])
                child_item.setData(0, Qt.UserRole, batch)
                child_item.setToolTip(0, "برای انتقال، روی این ردیف راست‌کلیک کنید")

                # رنگ‌آمیزی بر اساس وضعیت
                if status_text == 'قرنطینه':
                    child_item.setForeground(2, QtGui.QColor("#fd7e14")) # Orange
                elif status_text == 'رد شده':
                    child_item.setForeground(2, QtGui.QColor("#dc3545")) # Red

        self.tree.expandAll()

    # (متدهای _show_context_menu, _initiate_transfer, _reset_tree_filter بدون تغییر باقی می‌مانند)
    def _show_context_menu(self, pos):
        item = self.tree.itemAt(pos)
        if not item or not item.parent(): return
        batch_data = item.data(0, Qt.UserRole)
        if not batch_data: return
        menu = QtWidgets.QMenu(self)
        transfer_action = menu.addAction(QtGui.QIcon.fromTheme("go-next"), "انتقال این بچ...")
        action = menu.exec_(self.tree.mapToGlobal(pos))
        if action == transfer_action: self._initiate_transfer(batch_data)
    def _initiate_transfer(self, batch_data: dict):
        all_locations = self.db.list_locations(exclude_warehouses=['Production'])
        dest_map = {loc['loc_label']: loc['id'] for loc in all_locations if loc['id'] != batch_data['loc_id']}
        if not dest_map: QtWidgets.QMessageBox.warning(self, "خطا", "هیچ لوکیشن مقصد معتبری یافت نشد."); return
        dest_name, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب مقصد", "این بچ را به کدام لوکیشن منتقل می‌کنید؟", dest_map.keys(), 0, False)
        if not ok or not dest_name: return
        dest_loc_id = dest_map[dest_name]
        qty, ok = QtWidgets.QInputDialog.getDouble(self, "مقدار انتقال", f"چه مقداری از موجودی ({batch_data['qty']}) را منتقل می‌کنید؟", batch_data['qty'], 0.001, batch_data['qty'], 3)
        if not ok: return
        try:
            self.db.transfer(item_id=self.item_data['id'], qty=qty, src_loc_id=batch_data['loc_id'], dest_loc_id=dest_loc_id, user_id=self.parent_window.user_id, notes=f"انتقال از پنجره جزئیات موجودی", batch_no=batch_data['batch_no'], expiry_date=batch_data.get('expiry_date'))
            self.parent_window.toast.show_message("✔ انتقال با موفقیت انجام شد.", "success"); self._populate_stock_details(); self.parent_window.refresh_all()
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"انتقال با خطا مواجه شد:\n{e}")
    def _reset_tree_filter(self):
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value(): iterator.value().setHidden(False); iterator += 1
        
                            
class MultiBatchSelectionDialog(QtWidgets.QDialog):
    """
    نسخه 2.0:
    - امکان ورود دستی مقدار برداشت برای هر بچ فراهم شده است.
    - اعتبارسنجی برای جلوگیری از برداشت بیش از موجودی اضافه شده است.
    """
    def __init__(self, item_name, needed_qty, available_batches, parent=None):
            super().__init__(parent)
            self.item_name = item_name
            self.needed_qty = needed_qty
            self.available_batches = available_batches
            self.pick_plan = []

            self.setWindowTitle(f"تخصیص بچ برای: {item_name}")
            self.setMinimumSize(600, 400)
            self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

            layout = QtWidgets.QVBoxLayout(self)
            
            info_layout = QtWidgets.QHBoxLayout()
            self.needed_label = QtWidgets.QLabel(f"مقدار مورد نیاز: <b>{self.needed_qty:.3f}</b>")
            self.selected_label = QtWidgets.QLabel("مقدار انتخاب شده: <b>0.000</b>")
            info_layout.addWidget(self.needed_label); info_layout.addStretch(); info_layout.addWidget(self.selected_label)
            layout.addLayout(info_layout)

            self.table = QtWidgets.QTableWidget()
            
            # --- اصلاح کلیدی اینجاست ---
            self.table.verticalHeader().setDefaultSectionSize(60) # ارتفاع مناسب برای ردیف‌ها
            # --- پایان اصلاح ---

            self.table.setColumnCount(4)
            self.table.setHorizontalHeaderLabels(['بچ نامبر', 'تاریخ انقضا', 'موجودی در دسترس', 'مقدار برداشت'])
            self.table.setRowCount(len(self.available_batches))

            for row, batch in enumerate(self.available_batches):
                for c, key in enumerate(['batch_no', 'expiry_date', 'qty']):
                    val = batch.get(key)
                    text = to_shamsi(val) if isinstance(val, dt.date) else str(val)
                    item = QtWidgets.QTableWidgetItem(text)
                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                    self.table.setItem(row, c, item)
                
                available_qty = batch.get('qty', 0)
                pick_edit = QtWidgets.QLineEdit("0.0")
                pick_edit.setAlignment(Qt.AlignRight)
                pick_edit.setValidator(QtGui.QDoubleValidator(0.0, available_qty, 3))
                pick_edit.textChanged.connect(self._update_totals)
                self.table.setCellWidget(row, 3, pick_edit)

            self.table.resizeColumnsToContents()
            self.table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            layout.addWidget(self.table)

            self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
            self.ok_button = self.buttons.button(QtWidgets.QDialogButtonBox.Ok)
            self.ok_button.setText("تایید تخصیص")
            self.ok_button.setEnabled(False)
            layout.addWidget(self.buttons)

            self.buttons.accepted.connect(self.accept)
            self.buttons.rejected.connect(self.reject)
            self._update_totals()
                
    def _update_totals(self):
        total_selected = 0.0
        for row in range(self.table.rowCount()):
            pick_edit = self.table.cellWidget(row, 3)
            if pick_edit:
                try:
                    total_selected += float(pick_edit.text())
                except (ValueError, TypeError):
                    pass
        
        self.selected_label.setText(f"مقدار انتخاب شده: <b>{total_selected:.3f}</b>")
        
        if abs(total_selected - self.needed_qty) < 0.001:
            self.selected_label.setStyleSheet("color: green; font-weight: bold;")
            self.ok_button.setEnabled(True)
        else:
            self.selected_label.setStyleSheet("color: red;")
            self.ok_button.setEnabled(False)

    def accept(self):
        for row in range(self.table.rowCount()):
            pick_edit = self.table.cellWidget(row, 3)
            if not pick_edit: continue
            
            try:
                pick_qty = float(pick_edit.text())
                if pick_qty > 0:
                    batch_info = self.available_batches[row]
                    # این چک اضافی لازم نیست چون Validator کارش را انجام می‌دهد، اما برای اطمینان خوب است
                    if pick_qty > batch_info['qty']:
                        QtWidgets.QMessageBox.warning(self, "خطای مقدار", f"مقدار برداشت برای بچ {batch_info['batch_no']} از موجودی آن بیشتر است.")
                        return 
                    
                    self.pick_plan.append({
                        'item_id': batch_info['item_id'],
                        'batch_no': batch_info['batch_no'],
                        'qty_to_consume': pick_qty,
                        'expiry_date': batch_info.get('expiry_date')
                    })
            except (ValueError, TypeError):
                continue
        
        super().accept()
        
        
# این کلاس را به طور کامل با نسخه هوشمند زیر جایگزین کنید
class DeliverFinishedGoodDialog(QtWidgets.QDialog):
    """
    نسخه نهایی:
    - پس از انتخاب بچ، به صورت خودکار سفارش تولید مرتبط را پیدا می‌کند.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("اعلام آمادگی تحویل محصول به انبار")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(800, 500)

        self.prod_loc_id = self.db.get_production_floor_location()
        if not self.prod_loc_id:
            QtWidgets.QMessageBox.critical(self, "خطا", "انبار تولید در سیستم تعریف نشده است.")
            QtCore.QTimer.singleShot(0, self.reject)
            return

        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("یک بچ را از لیست زیر انتخاب کرده و مقدار تحویلی را مشخص کنید:"))
        self.products_table = QtWidgets.QTableWidget(); self._style_table(self.products_table); layout.addWidget(self.products_table)
        form_layout = QtWidgets.QFormLayout(); self.qty_edit = QtWidgets.QLineEdit("0.0"); form_layout.addRow("مقدار تحویلی:", self.qty_edit); layout.addLayout(form_layout)
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel); buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت درخواست تحویل"); buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject); layout.addWidget(buttons)
        self.products_table.itemSelectionChanged.connect(self._on_item_selected)
        self._populate_deliverable_items()

    def _style_table(self, table):
        table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        table.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        table.setAlternatingRowColors(True)

    def _apply_tabbar_preferences(self, tab_widget: QtWidgets.QTabWidget):
        try:
            bar = tab_widget.tabBar()
            if bar is not None:
                bar.setElideMode(QtCore.Qt.ElideNone)
                bar.setUsesScrollButtons(True)
                bar.setExpanding(False)
            for idx in range(tab_widget.count()):
                tab_widget.setTabToolTip(idx, tab_widget.tabText(idx))
        except Exception:
            pass

    def _ensure_table_spacing(self, table: QtWidgets.QAbstractItemView):
        if not isinstance(table, (QtWidgets.QTableWidget, QtWidgets.QTableView)):
            return
        try:
            table.setWordWrap(True)
            if hasattr(table, 'verticalHeader'):
                vh = table.verticalHeader()
                if vh is not None:
                    if hasattr(vh, 'defaultSectionSize') and hasattr(vh, 'setDefaultSectionSize'):
                        size = vh.defaultSectionSize() or 0
                        target = 44 if size == 0 else max(44, size)
                        vh.setDefaultSectionSize(target)
                    if hasattr(vh, 'setMinimumSectionSize'):
                        vh.setMinimumSectionSize(40)
        except Exception:
            pass

    def _apply_tabbar_preferences(self, tab_widget: QtWidgets.QTabWidget):
        try:
            bar = tab_widget.tabBar()
            if bar is not None:
                bar.setElideMode(QtCore.Qt.ElideNone)
                bar.setUsesScrollButtons(True)
                bar.setExpanding(False)
            for idx in range(tab_widget.count()):
                tab_widget.setTabToolTip(idx, tab_widget.tabText(idx))
        except Exception:
            pass

    def _refresh_page_tabs(self, root_widget: QtWidgets.QWidget):
        if root_widget is None:
            return
        for tab in root_widget.findChildren(QtWidgets.QTabWidget):
            self._apply_tabbar_preferences(tab)

    def _ensure_table_spacing(self, table: QtWidgets.QAbstractItemView):
        if not isinstance(table, (QtWidgets.QTableWidget, QtWidgets.QTableView)):
            return
        try:
            table.setWordWrap(True)
            if hasattr(table, 'verticalHeader'):
                vh = table.verticalHeader()
                if vh is not None:
                    if hasattr(vh, 'defaultSectionSize') and hasattr(vh, 'setDefaultSectionSize'):
                        size = vh.defaultSectionSize() or 0
                        target = 44 if size == 0 else max(44, size)
                        vh.setDefaultSectionSize(target)
                    if hasattr(vh, 'setMinimumSectionSize'):
                        vh.setMinimumSectionSize(40)
        except Exception:
            pass

    def _ensure_page_table_spacing(self, root_widget: QtWidgets.QWidget):
        if root_widget is None:
            return
        for tbl in root_widget.findChildren(QtWidgets.QAbstractItemView):
            self._ensure_table_spacing(tbl)

    def _populate_deliverable_items(self):
        self.products_table.setRowCount(0)
        items = self.db.get_finished_goods_at_location(self.prod_loc_id, packed_only=True)
        
        headers = ["محصول مادر", "مشخصات پک", "شماره بچ", "موجودی در کارگاه", "تاریخ انقضا"]
        self.products_table.setColumnCount(len(headers)); self.products_table.setHorizontalHeaderLabels(headers)
        
        self.products_table.setRowCount(len(items))
        for r, item in enumerate(items):
            item_data = dict(item)
            parent_name = "نامشخص"
            if item_data.get('parent_item_id'):
                parent_info = self.db.get_item_details(item_data['parent_item_id'])
                if parent_info: parent_name = parent_info.get('name', 'نامشخص')
            
            parent_name_item = QtWidgets.QTableWidgetItem(parent_name)
            parent_name_item.setData(Qt.UserRole, item_data)
            
            self.products_table.setItem(r, 0, parent_name_item)
            self.products_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item_data['name']))
            self.products_table.setItem(r, 2, QtWidgets.QTableWidgetItem(item_data['batch_no']))
            self.products_table.setItem(r, 3, NumericTableWidgetItem(str(item_data['qty'])))
            self.products_table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(item_data.get('expiry_date'))))
        
        self.products_table.resizeColumnsToContents()
        self.products_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.products_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(self.products_table, "هیچ محصول بسته‌بندی شده‌ای برای تحویل یافت نشد.")

    def _on_item_selected(self):
        selected_items = self.products_table.selectedItems()
        if not selected_items: return
        data = self.products_table.item(selected_items[0].row(), 0).data(Qt.UserRole)
        if data:
            max_qty = data.get('qty', 0.0)
            self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, max_qty, 3))
            self.qty_edit.setText(str(max_qty))

    def get_data(self):
        current_row = self.products_table.currentRow()
        if current_row < 0: return None
        try:
            item_with_data = self.products_table.item(current_row, 0)
            if not item_with_data: return None
            item_data = item_with_data.data(Qt.UserRole)
            qty_to_transfer = float(self.qty_edit.text())
            if not all([item_data, qty_to_transfer > 0]): return None
            if qty_to_transfer > item_data.get('qty', 0):
                QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "مقدار تحویلی نمی‌تواند از موجودی بچ بیشتر باشد."); return None

            # --- *** بخش جدید و کلیدی: پیدا کردن سفارش تولید مرتبط *** ---
            production_order_id = None
            prod_order_info = self.db.execute_query("SELECT id FROM production_orders WHERE production_batch_no = %s", (item_data['batch_no'],), fetch_one=True)
            if prod_order_info:
                production_order_id = prod_order_info['id']
            # --- ****************************************************** ---

            return { 
                "item_id": item_data['item_id'], 
                "qty": qty_to_transfer, 
                "batch_no": item_data['batch_no'], 
                "expiry_date": item_data.get('expiry_date'),
                "production_order_id": production_order_id # ارسال شناسه پیدا شده
            }
        except (ValueError, TypeError, AttributeError):
            return None
        
        # این کلاس را به طور کامل با نسخه جدید جایگزین کنید
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class ComponentSelectionDialog(QtWidgets.QDialog):
    """
    دیالوگ کمکی برای انتخاب یک بچ از یک کالا (شامل محصولات فله).
    """
    def __init__(self, db: DB, title: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(title)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(500, 400)

        layout = QtWidgets.QVBoxLayout(self)
        self.search_edit = QtWidgets.QLineEdit(placeholderText="🔍 جستجوی نام یا بچ...")
        self.search_edit.textChanged.connect(self.filter_list)
        layout.addWidget(self.search_edit)

        self.items_list = QtWidgets.QListWidget()
        layout.addWidget(self.items_list)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        self._load_components()

    def _load_components(self):
        items = self.db.get_available_bulk_products()
        for item in items:
            display_text = f"{item['product_name']} (بچ: {item['production_batch_no']}, موجودی: {item['quantity']})"
            list_item = QtWidgets.QListWidgetItem(display_text, self.items_list)
            list_item.setData(Qt.UserRole, item)
            self.items_list.addItem(list_item)

    def filter_list(self, text):
        for i in range(self.items_list.count()):
            item = self.items_list.item(i)
            item.setHidden(text.lower() not in item.text().lower())

    def get_selected_component(self):
        selected = self.items_list.selectedItems()
        if not selected: return None
        return selected[0].data(Qt.UserRole)
    
                        

# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class PackingPreviewDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نمایش پلن برداشت به کاربر و دریافت تایید نهایی."""
    def __init__(self, pick_plan_tree: QtWidgets.QTreeWidget, parent=None):
        super().__init__(parent)
        self.setWindowTitle("پیش‌نمایش و تایید نهایی مصرف")
        self.setMinimumSize(700, 450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        info_label = QtWidgets.QLabel("<b>سیستم پیشنهاد می‌کند موارد زیر از موجودی کسر شوند. لطفاً بررسی و تایید کنید:</b>")
        layout.addWidget(info_label)
        
        pick_plan_tree.setParent(self)
        layout.addWidget(pick_plan_tree, 1)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("✔ تایید و ثبت نهایی بسته‌بندی")
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setProperty("class", "primary")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
                
                                                                            
# این کلاس را به طور کامل جایگزین کنید
class CreateDeliveryRequestDialog(QtWidgets.QDialog):
    """پنجره‌ای برای انتخاب یک محصول پک شده از کف کارگاه و ایجاد درخواست تحویل."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ایجاد درخواست تحویل به انبار")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.items_combo = QtWidgets.QComboBox()
        layout.addRow("انتخاب محصول بسته‌بندی شده:", self.items_combo)

        # --- اصلاح کلیدی: متغیر محلی به متغیر کلاس تبدیل شد ---
        self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        layout.addRow(self.buttons)

        self._load_packable_items()

    def _load_packable_items(self):
        # فقط محصولات پک شده موجود در انبار تولید را می‌خوانیم
        items = self.db.get_finished_goods_at_location(self.db.get_production_floor_location(), packed_only=True)
        if not items:
            self.items_combo.addItem("هیچ محصول بسته‌بندی شده‌ای برای تحویل یافت نشد.", None)
            self.items_combo.setEnabled(False)
            # حالا این خط به درستی کار می‌کند
            self.buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
            return
            
        for item in items:
            display_text = f"{item['name']} (بچ: {item['batch_no']}, موجودی: {item['qty']})"
            self.items_combo.addItem(display_text, item)

    def get_selected_data(self):
        return self.items_combo.currentData()
    
class UomManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت واحدهای اندازه‌گیری (UoM)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle("مدیریت واحدهای اندازه‌گیری")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(500, 400)
        
        layout = QtWidgets.QVBoxLayout(self)
        
        self.tbl_units = QtWidgets.QTableWidget()
        self.tbl_units.setColumnCount(3)
        self.tbl_units.setHorizontalHeaderLabels(['ID', 'نام کامل واحد', 'مخفف (اختیاری)'])
        self.tbl_units.setColumnHidden(0, True)
        self.tbl_units.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_units.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_units.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl_units.itemClicked.connect(self._populate_fields_for_edit)
        layout.addWidget(self.tbl_units)
        
        # بخش ورود داده
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش واحد")
        form_layout = QtWidgets.QFormLayout(form_group)
        self.name_edit = QtWidgets.QLineEdit()
        self.abbr_edit = QtWidgets.QLineEdit()
        form_layout.addRow("نام کامل:", self.name_edit)
        form_layout.addRow("مخفف:", self.abbr_edit)
        layout.addWidget(form_group)

        # دکمه‌ها
        btn_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_save.setProperty("class", "primary")
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن فرم")
        
        btn_layout.addWidget(btn_save)
        btn_layout.addWidget(btn_delete)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_clear)
        layout.addLayout(btn_layout)

        btn_save.clicked.connect(self._add_or_update_unit)
        btn_delete.clicked.connect(self._delete_unit)
        btn_clear.clicked.connect(self._clear_fields)
        
        self._load_units()

    def _load_units(self):
        self.tbl_units.setRowCount(0)
        units = self.db.get_all_units()
        self.tbl_units.setRowCount(len(units))
        for r, unit in enumerate(units):
            self.tbl_units.setItem(r, 0, QtWidgets.QTableWidgetItem(str(unit['id'])))
            self.tbl_units.setItem(r, 1, QtWidgets.QTableWidgetItem(unit['name']))
            self.tbl_units.setItem(r, 2, QtWidgets.QTableWidgetItem(unit.get('abbreviation', '')))

    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.name_edit.setText(self.tbl_units.item(row, 1).text())
        self.abbr_edit.setText(self.tbl_units.item(row, 2).text())
        
    def _clear_fields(self):
        self.tbl_units.clearSelection()
        self.name_edit.clear()
        self.abbr_edit.clear()
        self.name_edit.setFocus()

    def _add_or_update_unit(self):
        name = self.name_edit.text().strip()
        abbr = self.abbr_edit.text().strip()
        
        selected_items = self.tbl_units.selectedItems()
        unit_id = int(self.tbl_units.item(selected_items[0].row(), 0).text()) if selected_items else None
        
        try:
            self.db.add_or_update_unit(name, abbr, unit_id)
            self._load_units()
            self._clear_fields()
            if self.toast:
                self.toast.show_message("✔ واحد با موفقیت ذخیره شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", str(e))

# در کلاس UomManagerDialog
    def _delete_unit(self):
        selected_items = self.tbl_units.selectedItems()
        if not selected_items:
            self.toast.show_message("لطفاً یک واحد را برای حذف انتخاب کنید.", "warning")
            return
            
        unit_id = int(self.tbl_units.item(selected_items[0].row(), 0).text())
        unit_name = self.tbl_units.item(selected_items[0].row(), 1).text()
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف واحد «{unit_name}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # فراخوانی متد دیتابیس که خودش چک‌های لازم را انجام می‌دهد
                self.db.delete_unit(unit_id)
                self._load_units()
                self._clear_fields()
                if self.toast:
                    self.toast.show_message("✔ واحد با موفقیت حذف شد.", "info")
            
            # --- اصلاح کلیدی اینجاست ---
            except ValueError as e:
                # اگر خطا از نوع ValueError بود (یعنی واحد در حال استفاده است)، پیغام مشخص نمایش بده
                QtWidgets.QMessageBox.critical(self, "عملیات ناموفق", f"<b>امکان حذف واحد «{unit_name}» وجود ندارد.</b><br><br>دلیل: {e}")
            except Exception as e:
                # برای خطاهای پیش‌بینی نشده دیگر
                QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام حذف واحد:\n{e}")
                
                                
# کل کلاس AppSettingsDialog را با این نسخه نهایی جایگزین کنید
class AppSettingsDialog(QtWidgets.QDialog):
    """نسخه نهایی با قابلیت تنظیم دوره پشتیبان‌گیری."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.setWindowTitle("تنظیمات برنامه"); self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumWidth(550)
        layout = QtWidgets.QVBoxLayout(self); layout.setSpacing(15); layout.setContentsMargins(15, 15, 15, 15)

        # --- بخش تنظیمات بکاپ خودکار ---
        backup_group = QtWidgets.QGroupBox()
        backup_layout = QtWidgets.QVBoxLayout(backup_group)
        header_layout_1 = QtWidgets.QHBoxLayout(); icon_label_1 = QtWidgets.QLabel(); icon_label_1.setPixmap(QtGui.QIcon.fromTheme("document-save").pixmap(24, 24)); title_label_1 = QtWidgets.QLabel("پشتیبان‌گیری خودکار"); title_label_1.setFont(QFont(FONT_FAMILY, 11, QFont.Bold)); header_layout_1.addWidget(icon_label_1); header_layout_1.addWidget(title_label_1); header_layout_1.addStretch(); backup_layout.addLayout(header_layout_1)
        form_layout_1 = QtWidgets.QFormLayout(); form_layout_1.setContentsMargins(10, 15, 10, 0); form_layout_1.setSpacing(10)
        self.autobackup_check = QtWidgets.QCheckBox("پشتیبان‌گیری خودکار فعال باشد")
        
        # --- فیلد جدید: دوره پشتیبان‌گیری ---
        self.backup_freq_spinbox = QtWidgets.QSpinBox(); self.backup_freq_spinbox.setRange(1, 30); self.backup_freq_spinbox.setSuffix(" روز یکبار")

        time_container_widget = QtWidgets.QWidget(); time_container_widget.setLayoutDirection(QtCore.Qt.LeftToRight); time_layout = QtWidgets.QHBoxLayout(time_container_widget); time_layout.setContentsMargins(0,0,0,0); self.hour_spinbox = QtWidgets.QSpinBox(); self.hour_spinbox.setRange(0, 23); self.minute_spinbox = QtWidgets.QSpinBox(); self.minute_spinbox.setRange(0, 59); self.hour_spinbox.setDisplayIntegerBase(10); self.hour_spinbox.setStyleSheet("padding: 4px;"); self.minute_spinbox.setDisplayIntegerBase(10); self.minute_spinbox.setStyleSheet("padding: 4px;"); time_layout.addWidget(self.hour_spinbox); time_layout.addWidget(QtWidgets.QLabel(":")); time_layout.addWidget(self.minute_spinbox); time_layout.addStretch()
        path_layout = QtWidgets.QHBoxLayout(); self.backup_path_edit = QtWidgets.QLineEdit(); self.backup_path_edit.setPlaceholderText("یک پوشه انتخاب کنید..."); btn_browse = QtWidgets.QPushButton("..."); btn_browse.setFixedSize(30,30); btn_browse.clicked.connect(self._browse_backup_path); path_layout.addWidget(self.backup_path_edit, 1); path_layout.addWidget(btn_browse)
        backup_desc = QtWidgets.QLabel("پشتیبان‌گیری در ساعت مشخص شده انجام می‌شود (برنامه باید باز و کاربر ادمین آنلاین باشد)."); backup_desc.setStyleSheet("color: #6c757d; font-size: 9pt;")
        form_layout_1.addRow(self.autobackup_check); form_layout_1.addRow("دوره پشتیبان‌گیری:", self.backup_freq_spinbox); form_layout_1.addRow("ساعت پشتیبان‌گیری:", time_container_widget); form_layout_1.addRow("محل ذخیره بکاپ‌ها:", path_layout); form_layout_1.addRow(backup_desc)
        backup_layout.addLayout(form_layout_1); layout.addWidget(backup_group)

        # ... (بقیه کد بدون تغییر) ...
        analysis_group = QtWidgets.QGroupBox(); analysis_layout = QtWidgets.QVBoxLayout(analysis_group); header_layout_2 = QtWidgets.QHBoxLayout(); icon_label_2 = QtWidgets.QLabel(); icon_label_2.setPixmap(QtGui.QIcon.fromTheme("view-sort-ascending").pixmap(24, 24)); title_label_2 = QtWidgets.QLabel("تنظیمات تحلیل و هشدارها"); title_label_2.setFont(QFont(FONT_FAMILY, 11, QFont.Bold)); header_layout_2.addWidget(icon_label_2); header_layout_2.addWidget(title_label_2); header_layout_2.addStretch(); analysis_layout.addLayout(header_layout_2); form_layout_2 = QtWidgets.QFormLayout(); form_layout_2.setContentsMargins(10, 15, 10, 0); form_layout_2.setSpacing(10); self.expiry_spinbox = QtWidgets.QSpinBox(); self.expiry_spinbox.setRange(1, 365); self.expiry_spinbox.setSuffix(" روز"); expiry_desc = QtWidgets.QLabel("تعداد روز باقی‌مانده به انقضا که باعث نمایش هشدار می‌شود."); expiry_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("بازه هشدار انقضا:", self.expiry_spinbox); form_layout_2.addRow(expiry_desc); separator = QtWidgets.QFrame(); separator.setFrameShape(QtWidgets.QFrame.HLine); separator.setFrameShadow(QtWidgets.QFrame.Sunken); form_layout_2.addRow(separator); self.service_level_spinbox = QtWidgets.QDoubleSpinBox(); self.service_level_spinbox.setRange(0.50, 0.99); self.service_level_spinbox.setDecimals(2); self.service_level_spinbox.setSingleStep(0.01); service_level_desc = QtWidgets.QLabel("سطح اطمینان برای محاسبه موجودی اطمینان (Safety Stock). پیشنهادی: 0.95"); service_level_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("سطح خدمت (Service Level):", self.service_level_spinbox); form_layout_2.addRow(service_level_desc); self.max_multiplier_spinbox = QtWidgets.QDoubleSpinBox(); self.max_multiplier_spinbox.setRange(1.1, 3.0); self.max_multiplier_spinbox.setDecimals(2); self.max_multiplier_spinbox.setSingleStep(0.1); max_multiplier_desc = QtWidgets.QLabel("ضریب محاسبه حداکثر موجودی (حداکثر = حداقل × ضریب). پیشنهادی: 1.5"); max_multiplier_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("ضریب حداکثر موجودی:", self.max_multiplier_spinbox); form_layout_2.addRow(max_multiplier_desc); self.analysis_days_spinbox = QtWidgets.QSpinBox(); self.analysis_days_spinbox.setRange(1, 730); self.analysis_days_spinbox.setSuffix(" روز"); analysis_days_desc = QtWidgets.QLabel("تعداد روزهای گذشته برای تحلیل مصرف کالا. پیشنهادی: 90"); analysis_days_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("بازه زمانی تحلیل مصرف:", self.analysis_days_spinbox); form_layout_2.addRow(analysis_days_desc); analysis_layout.addLayout(form_layout_2); layout.addWidget(analysis_group); layout.addStretch();
        btn_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Save | QtWidgets.QDialogButtonBox.Cancel); btn_box.button(QtWidgets.QDialogButtonBox.Save).clicked.connect(self._save_settings); btn_box.rejected.connect(self.reject); layout.addWidget(btn_box)
        self._load_settings()

    def _browse_backup_path(self):
        directory = QtWidgets.QFileDialog.getExistingDirectory(self, "انتخاب پوشه برای پشتیبان‌گیری")
        if directory: self.backup_path_edit.setText(directory)

    def _load_settings(self):
        def safe_int_cast(value_str, default):
            try: return int("".join(filter(str.isdigit, str(value_str))))
            except: return default
        def safe_float_cast(value_str, default):
            try: return float(str(value_str).replace(',', '.'))
            except: return default
        
        self.autobackup_check.setChecked(self.db.get_setting('autobackup_enabled', 'false') == 'true')
        self.backup_freq_spinbox.setValue(safe_int_cast(self.db.get_setting('autobackup_frequency_days', '1'), 1))
        time_str = self.db.get_setting('autobackup_time', '02:00'); parts = time_str.split(':')
        if len(parts) == 2: self.hour_spinbox.setValue(int(parts[0])); self.minute_spinbox.setValue(int(parts[1]))
        default_path = str(BASE_DIR / 'Auto_Backups'); self.backup_path_edit.setText(self.db.get_setting('autobackup_path', default_path))
        self.expiry_spinbox.setValue(safe_int_cast(self.db.get_setting('expiry_alert_days', '30'), 30))
        self.service_level_spinbox.setValue(safe_float_cast(self.db.get_setting('reorder_service_level', '0.95'), 0.95))
        self.max_multiplier_spinbox.setValue(safe_float_cast(self.db.get_setting('reorder_max_multiplier', '1.5'), 1.5))
        self.analysis_days_spinbox.setValue(safe_int_cast(self.db.get_setting('reorder_analysis_days', '90'), 90))
    
    def _save_settings(self):
        try:
            hour = self.hour_spinbox.value(); minute = self.minute_spinbox.value(); time_str = f"{hour:02d}:{minute:02d}"
            settings_to_save = {
                'autobackup_enabled': 'true' if self.autobackup_check.isChecked() else 'false',
                'autobackup_frequency_days': self.backup_freq_spinbox.value(),
                'autobackup_time': time_str,
                'autobackup_path': self.backup_path_edit.text(),
                'expiry_alert_days': self.expiry_spinbox.value(),
                'reorder_service_level': self.service_level_spinbox.value(),
                'reorder_max_multiplier': self.max_multiplier_spinbox.value(),
                'reorder_analysis_days': self.analysis_days_spinbox.value()
            }
            for key, value in settings_to_save.items():
                self.db.set_setting(key, str(value))
            if self.toast: self.toast.show_message("✔ تنظیمات با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"مشکلی در ذخیره تنظیمات پیش آمد:\n{e}")
                                                                                
class DebugReportDialog(QtWidgets.QDialog):
    """یک پنجره برای نمایش گزارش‌های متنی طولانی و قابل کپی."""
    def __init__(self, report_text, parent=None):
        super().__init__(parent)
        self.setWindowTitle("گزارش تست مصرف")
        self.setFont(QFont("Tahoma", 10))
        self.setMinimumSize(700, 500)

        layout = QtWidgets.QVBoxLayout(self)

        self.report_display = QtWidgets.QTextEdit()
        self.report_display.setReadOnly(True)
        # استفاده از فونت مونواسپیس برای نمایش ستونی و مرتب
        self.report_display.setFont(QFont("Consolas", 10))
        self.report_display.setText(report_text)
        
        layout.addWidget(self.report_display)

        button_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Close)
        button_box.button(QtWidgets.QDialogButtonBox.Close).setText("بستن")
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        
class SettingsActionCard(QtWidgets.QFrame):
    """یک ویجت سفارشی و زیبا برای نمایش یک گزینه در صفحه تنظیمات (نسخه حرفه‌ای)."""
    clicked = QtCore.pyqtSignal()

    def __init__(self, icon_theme_name: str, icon_bg_color: str, title: str, subtitle: str, parent=None):
        super().__init__(parent)
        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.setObjectName("actionCard")
        
        # --- استایل جدید با سایه ---
        self.setStyleSheet("""
            QFrame#actionCard {
                background-color: #ffffff;
                border-radius: 8px;
            }
        """)
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(25)
        shadow.setOffset(0, 5)
        shadow.setColor(QColor(0, 0, 0, 30))
        self.setGraphicsEffect(shadow)

        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)

        icon_bg = QtWidgets.QLabel()
        icon_bg.setFixedSize(48, 48)
        icon_bg.setStyleSheet(f"background-color: {icon_bg_color}; border-radius: 24px;")
        icon_layout = QVBoxLayout(icon_bg)
        icon_layout.setAlignment(QtCore.Qt.AlignCenter)
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_theme_name).pixmap(24, 24))
        icon_layout.addWidget(icon_label)

        text_layout = QVBoxLayout()
        text_layout.setSpacing(2)
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt; background: transparent;")
        subtitle_label = QtWidgets.QLabel(subtitle)
        subtitle_label.setStyleSheet("color: #6c757d; background: transparent;")
        text_layout.addWidget(title_label)
        text_layout.addWidget(subtitle_label)
        text_layout.addStretch()

        arrow_label = QtWidgets.QLabel("›")
        arrow_label.setStyleSheet("font-size: 24pt; color: #b0bec5; background: transparent;")

        layout.addWidget(icon_bg)
        layout.addLayout(text_layout, 1)
        layout.addWidget(arrow_label)

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.clicked.emit()
        super().mouseReleaseEvent(event)
        
# این کلاس کاملا جدید را به انتهای فایل کد خود اضافه کنید
class DeliverToLabDialog(QtWidgets.QDialog):
    """پنجره‌ای برای ثبت ارسال محصول از کف کارگاه به آزمایشگاه."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت خروج کالا به آزمایشگاه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        self.prod_loc_id = self.db.get_production_floor_location()
        if not self.prod_loc_id:
            QtWidgets.QMessageBox.critical(self, "خطا", "انبار تولید در سیستم تعریف نشده است.")
            QtCore.QTimer.singleShot(0, self.reject)
            return

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_combo = QtWidgets.QComboBox()
        self.batch_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("0.0")
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="مثال: نمونه بچ برای تست فشار")

        layout.addRow("انتخاب محصول موجود در تولید:", self.item_combo)
        layout.addRow("انتخاب بچ محصول:", self.batch_combo)
        layout.addRow("مقدار ارسالی به آزمایشگاه:", self.qty_edit)
        layout.addRow("یادداشت (اختیاری):", self.notes_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت خروج")
        layout.addRow(buttons)

        self.item_combo.currentIndexChanged.connect(self._on_item_selected)
        self.batch_combo.currentIndexChanged.connect(self._on_batch_selected)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        self._populate_finished_goods()

    def _populate_finished_goods(self):
        # فقط محصولات نهایی را لیست می‌کنیم
        items = self.db.get_finished_goods_at_location(self.prod_loc_id, packed_only=False) 
        grouped_items = {}
        for item in items:
            name = item['name']
            if name not in grouped_items: grouped_items[name] = []
            grouped_items[name].append(item)
        
        for name, batches in grouped_items.items():
            self.item_combo.addItem(name, batches)
    
    def _on_item_selected(self):
        self.batch_combo.clear()
        batches = self.item_combo.currentData()
        if not batches: return
        for batch_info in batches:
            display_text = f"بچ: {batch_info['batch_no']} (موجودی: {batch_info['qty']})"
            self.batch_combo.addItem(display_text, batch_info)
    
    def _on_batch_selected(self):
        batch_info = self.batch_combo.currentData()
        if batch_info:
            self.qty_edit.setText(str(batch_info.get('qty', 0.0)))
            self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, batch_info.get('qty', 0.0), 3))

    def get_data(self):
        try:
            batch_info = self.batch_combo.currentData()
            qty_to_send = float(self.qty_edit.text())
            notes = self.notes_edit.text().strip()

            if not all([batch_info, qty_to_send > 0]):
                return None

            available_qty = batch_info.get('qty', 0)
            if qty_to_send > available_qty:
                QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر",
                                              f"مقدار درخواستی ({qty_to_send}) از موجودی بچ ({available_qty}) بیشتر است.")
                return None
            
            return {
                "item_id": batch_info['item_id'],
                "qty": qty_to_send,
                "batch_no": batch_info['batch_no'],
                "expiry_date": batch_info.get('expiry_date'),
                "notes": notes
            }
        except (ValueError, TypeError, AttributeError):
            return None
        
# این کلاس کاملا جدید را به انتهای فایل کد خود اضافه کنید
class PackagingOptionDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک نوع بسته‌بندی (SKU)."""
    def __init__(self, pack_data=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("افزودن/ویرایش نوع بسته‌بندی" if not pack_data else "ویرایش بسته‌بندی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.sku_edit = QtWidgets.QLineEdit()
        self.name_edit = QtWidgets.QLineEdit()
        self.weight_edit = QtWidgets.QLineEdit()
        self.weight_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 3))
        self.notes_edit = QtWidgets.QLineEdit()

        layout.addRow("کد SKU (*):", self.sku_edit)
        layout.addRow("نام پک (*):", self.name_edit)
        layout.addRow("وزن خالص (Kg) (*):", self.weight_edit)
        layout.addRow("توضیحات:", self.notes_edit)

        if pack_data:
            self.sku_edit.setText(pack_data.get('sku', ''))
            self.name_edit.setText(pack_data.get('pack_name', ''))
            self.weight_edit.setText(str(pack_data.get('pack_weight', '')))
            self.notes_edit.setText(pack_data.get('notes', ''))

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        sku = self.sku_edit.text().strip()
        name = self.name_edit.text().strip()
        weight_str = self.weight_edit.text().strip()
        if not all([sku, name, weight_str]):
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", "پر کردن فیلدهای ستاره‌دار الزامی است.")
            return None
        
        try:
            return {
                "sku": sku,
                "pack_name": name,
                "pack_weight": float(weight_str),
                "notes": self.notes_edit.text().strip()
            }
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "لطفاً وزن را به صورت عددی صحیح وارد کنید.")
            return None
        
# این دو کلاس جدید را به انتهای فایل کد خود اضافه کنید

class AddOrEditBomItemDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک جزء به BOM بسته‌بندی."""
    def __init__(self, db: DB, existing_components: list, bom_item_data=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن/ویرایش جزء به BOM")
        self.setMinimumWidth(400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.component_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("1")
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        layout.addRow("جزء بسته‌بندی:", self.component_combo)
        layout.addRow("تعداد/مقدار برای هر پک:", self.qty_edit)

        all_packaging_items = self.db.execute_query("SELECT id, name FROM items WHERE category='لوازم بسته‌بندی' ORDER BY name")
        for item in all_packaging_items:
            if item['id'] not in existing_components or (bom_item_data and item['id'] == bom_item_data.get('component_item_id')):
                self.component_combo.addItem(item['name'], item['id'])

        if bom_item_data:
            index = self.component_combo.findData(bom_item_data.get('component_item_id'))
            if index != -1: self.component_combo.setCurrentIndex(index)
            self.qty_edit.setText(str(bom_item_data.get('quantity', 1)))

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if self.component_combo.currentIndex() == -1: return None
        try:
            return {
                "component_item_id": self.component_combo.currentData(),
                "quantity": float(self.qty_edit.text())
            }
        except (ValueError, TypeError): return None

# کلاس ManagePackagingBomDialog را با این نسخه تعاملی و کامل جایگزین کنید

class ManagePackagingBomDialog(QtWidgets.QDialog):
    """پنجره تعاملی برای مدیریت BOM یک پک خاص به صورت شبیه به اکسل."""
    def __init__(self, db: DB, pack_option_id: int, pack_name: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.pack_option_id = pack_option_id
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle(f"مدیریت BOM برای: {pack_name}")
        self.setMinimumSize(600, 450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر واحد از این پک، لوازم مورد نیاز را تعریف کنید:"))
        
        self.bom_table = QtWidgets.QTableWidget(0, 3)
        self.bom_table.setHorizontalHeaderLabels(["جزء بسته‌بندی (انتخابی)", "مقدار/تعداد", "واحد"])
        self.bom_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.bom_table.verticalHeader().setDefaultSectionSize(50)

        
        layout.addWidget(self.bom_table, 1)
        
        # --- دکمه‌های عملیاتی جدید ---
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن ردیف جدید")
        btn_del_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف ردیف انتخابی")
        btn_layout.addWidget(btn_add_row); btn_layout.addWidget(btn_del_row); btn_layout.addStretch()
        layout.addLayout(btn_layout)

        # --- دکمه ذخیره نهایی ---
        save_button = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره BOM")
        save_button.setProperty("class", "primary")
        layout.addWidget(save_button)

        btn_add_row.clicked.connect(self._add_row)
        btn_del_row.clicked.connect(self._delete_row)
        save_button.clicked.connect(self._save_bom)

        # خواندن لیست لوازم بسته‌بندی یک بار برای استفاده مکرر
        self.packaging_supplies = self.db.get_all_packaging_supplies()
        self._load_bom()

    def _load_bom(self):
        """BOM موجود را خوانده و جدول را با ردیف‌های قابل ویرایش پر می‌کند."""
        self.bom_table.setRowCount(0)
        bom_items = self.db.get_packaging_bom(self.pack_option_id)
        for item in bom_items:
            self._add_row(component_id=item['component_item_id'], quantity=item['quantity'])

    def _add_row(self, component_id=None, quantity=1.0):
        """یک ردیف جدید به جدول اضافه کرده و ویجت‌های لازم را در آن قرار می‌دهد."""
        row_pos = self.bom_table.rowCount()
        self.bom_table.insertRow(row_pos)

        # ستون ۰: انتخاب جزء
        combo = QtWidgets.QComboBox()
        for supply in self.packaging_supplies:
            combo.addItem(supply['name'], supply['id'])
        if component_id:
            index = combo.findData(component_id)
            if index != -1: combo.setCurrentIndex(index)
        combo.currentIndexChanged.connect(lambda _, r=row_pos: self._update_unit(r))
        self.bom_table.setCellWidget(row_pos, 0, combo)

        # ستون ۱: مقدار
        qty_edit = QtWidgets.QLineEdit(str(quantity))
        qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        self.bom_table.setCellWidget(row_pos, 1, qty_edit)

        # ستون ۲: واحد (غیرقابل ویرایش)
        unit_item = QtWidgets.QTableWidgetItem()
        unit_item.setFlags(unit_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.bom_table.setItem(row_pos, 2, unit_item)
        self._update_unit(row_pos)

    def _update_unit(self, row):
        """واحد شمارش را بر اساس جزء انتخاب شده در کمبوباکس، آپدیت می‌کند."""
        combo = self.bom_table.cellWidget(row, 0)
        if not combo: return
        
        selected_id = combo.currentData()
        unit = next((s.get('unit', '') for s in self.packaging_supplies if s['id'] == selected_id), '')
        self.bom_table.item(row, 2).setText(unit)

    def _delete_row(self):
        current_row = self.bom_table.currentRow()
        if current_row >= 0:
            self.bom_table.removeRow(current_row)

    def _save_bom(self):
        """تمام محتویات جدول را به عنوان BOM جدید ذخیره می‌کند."""
        bom_to_save = []
        for r in range(self.bom_table.rowCount()):
            try:
                combo = self.bom_table.cellWidget(r, 0)
                qty_widget = self.bom_table.cellWidget(r, 1)
                
                component_id = combo.currentData()
                quantity = float(qty_widget.text())
                
                if component_id and quantity > 0:
                    bom_to_save.append({
                        "component_item_id": component_id,
                        "quantity": quantity
                    })
            except (ValueError, TypeError, AttributeError):
                QtWidgets.QMessageBox.warning(self, "خطای داده", f"لطفاً اطلاعات ردیف {r+1} را به درستی وارد کنید.")
                return

        try:
            self.db.save_packaging_bom(self.pack_option_id, bom_to_save)
            if self.toast:
                self.toast.show_message("✔ لیست BOM با موفقیت ذخیره شد.", "success")
            self.accept() # بستن دیالوگ پس از ذخیره موفق
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام ذخیره BOM:\n{e}")
            
# این دو کلاس جدید را به انتهای فایل کد خود اضافه کنید

class AddPackagingSupplyDialog(QtWidgets.QDialog):
    """یک دیالوگ کمکی برای انتخاب یک قلم از لوازم بسته‌بندی و تعیین تعداد آن."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن جزء بسته‌بندی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.supply_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("1.0")
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        
        layout.addRow("انتخاب قلم:", self.supply_combo)
        layout.addRow("تعداد/مقدار:", self.qty_edit)
        
        # فقط کالاهای دسته "لوازم بسته‌بندی" را لود می‌کنیم
        supplies = self.db.get_items_by_category('لوازم بسته‌بندی')
        for supply in supplies:
            self.supply_combo.addItem(f"{supply['name']} ({supply['unit']})", supply)
            
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if self.supply_combo.currentIndex() == -1: return None
        try:
            return {
                "item_data": self.supply_combo.currentData(),
                "quantity": float(self.qty_edit.text())
            }
        except (ValueError, TypeError):
            return None

# کلاس PackagingBomDialog را به طور کامل با این نسخه نهایی و اصلاح شده جایگزین کنید

class PackagingBomDialog(QtWidgets.QDialog):
    """
    نسخه نهایی: پنجره مدیریت BOM برای یک پک خاص.
    - بخش نسبت اختلاط از این فرم حذف شده و منطق آن به فرمول مادر منتقل می‌شود.
    - خطای TypeError هنگام ذخیره‌سازی برطرف شده است.
    """
    def __init__(self, db: DB, pack_item_data: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.pack_item_data = pack_item_data
        self.toast = getattr(parent, 'toast', None)
        # recipe_id_to_revise برای ارسال به متد save_bom استفاده خواهد شد
        self.recipe_id_to_revise = None

        self.setWindowTitle(f"مدیریت BOM بسته‌بندی برای: {self.pack_item_data.get('name')}")
        self.setMinimumSize(600, 450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر واحد از این پک، لوازم بسته‌بندی مورد نیاز را تعریف کنید:"))
        
        self.bom_table = QtWidgets.QTableWidget(0, 4)
        self.bom_table.setHorizontalHeaderLabels(["ID جزء", "نام جزء", "مقدار/تعداد", "واحد"])
        self.bom_table.setColumnHidden(0, True)
        self.bom_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.bom_table, 1)
        
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن جزء")
        btn_del_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف جزء")
        btn_layout.addWidget(btn_add_row); btn_layout.addWidget(btn_del_row); btn_layout.addStretch()
        layout.addLayout(btn_layout)

        save_button = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره نهایی BOM بسته‌بندی")
        save_button.setProperty("class", "primary")
        layout.addWidget(save_button)

        btn_add_row.clicked.connect(self._add_row)
        btn_del_row.clicked.connect(self._delete_row)
        save_button.clicked.connect(self._save_bom)

        self.packaging_supplies = self.db.get_all_packaging_supplies()
        self._load_bom()

    def _load_bom(self):
        """
        BOM بسته‌بندی برای پک فعلی را لود می‌کند.
        - اگر ستون part_type در recipes باشد: دنبال آخرین نسخه ACTIVE با part_type='PACKAGING' می‌گردد.
        - اگر نباشد: آخرین نسخه ACTIVE که اجزای بسته‌بندی دارد را پیدا می‌کند.
        سپس اقلام را از DB.get_bom_for_product لود می‌کند.
        """
        self.bom_table.setRowCount(0)

        # اطمینان از وجود ستون (اگر قبلاً در استارتاپ صدا نشده)
        try:
            if hasattr(self.db, 'ensure_recipes_part_type'):
                self.db.ensure_recipes_part_type()
        except Exception:
            pass  # اگر مجوز ALTER نداشتیم، مسیر بدون part_type کار خواهد کرد

        # تشخیص وجود ستون
        has_part_type = self.db.execute_query(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = current_schema()
            AND table_name = 'recipes'
            AND column_name = 'part_type'
            LIMIT 1
            """, fetch_one=True
        )

        recipe_row = None
        if has_part_type:
            recipe_row = self.db.execute_query(
                """
                SELECT id
                FROM recipes
                WHERE product_name = %s
                AND status = 'ACTIVE'
                AND part_type = 'PACKAGING'
                ORDER BY version DESC
                LIMIT 1
                """,
                (self.pack_item_data['name'],),
                fetch_one=True
            )
        else:
            # بدون part_type، بر اساس وجود جزء بسته‌بندی تشخیص می‌دهیم
            recipe_row = self.db.execute_query(
                """
                SELECT r.id
                FROM recipes r
                WHERE r.product_name = %s
                AND r.status = 'ACTIVE'
                AND EXISTS (
                        SELECT 1
                        FROM recipe_ingredients ri
                        JOIN items i ON i.id = ri.raw_material_item_id
                        WHERE ri.recipe_id = r.id
                        AND i.category = %s
                )
                ORDER BY r.version DESC
                LIMIT 1
                """,
                (self.pack_item_data['name'], CATEGORY_PACKAGING),
                fetch_one=True
            )

        if recipe_row:
            self.recipe_id_to_revise = recipe_row['id']
            bom_items = self.db.get_bom_for_product(self.pack_item_data['name'])
            for item in (bom_items or []):
                self._add_row(
                    component_id=item['component_item_id'],
                    quantity=item['quantity'],
                    unit=item.get('unit', '')
                )

    def _add_row(self, component_id=None, quantity=1.0, unit=''):
        row_pos = self.bom_table.rowCount()
        self.bom_table.insertRow(row_pos)
        
        combo = QtWidgets.QComboBox()
        for supply in self.packaging_supplies:
            combo.addItem(supply['name'], supply['id'])
        if component_id:
            index = combo.findData(component_id)
            if index != -1: combo.setCurrentIndex(index)
        combo.currentIndexChanged.connect(lambda _, r=row_pos: self._update_unit(r))
        self.bom_table.setCellWidget(row_pos, 1, combo)

        qty_edit = QtWidgets.QLineEdit(str(quantity))
        qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        self.bom_table.setCellWidget(row_pos, 2, qty_edit)

        unit_item = QtWidgets.QTableWidgetItem(unit)
        unit_item.setFlags(unit_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.bom_table.setItem(row_pos, 3, unit_item)
        if not unit: self._update_unit(row_pos)
        
    def _update_unit(self, row):
        combo = self.bom_table.cellWidget(row, 1)
        if not combo: return
        selected_id = combo.currentData()
        unit = next((s.get('unit', '') for s in self.packaging_supplies if s['id'] == selected_id), '')
        self.bom_table.item(row, 3).setText(unit)

    def _delete_row(self):
        current_row = self.bom_table.currentRow()
        if current_row >= 0:
            self.bom_table.removeRow(current_row)

    def _save_bom(self):
        ingredients = []
        for r in range(self.bom_table.rowCount()):
            try:
                combo = self.bom_table.cellWidget(r, 1)
                qty_widget = self.bom_table.cellWidget(r, 2)
                component_id = combo.currentData()
                quantity = float(qty_widget.text())
                if component_id and quantity > 0:
                    ingredients.append({"item_id": component_id, "percentage": quantity})
            except (ValueError, TypeError, AttributeError):
                QtWidgets.QMessageBox.warning(self, "خطای داده", f"لطفاً اطلاعات ردیف {r+1} را به درستی وارد کنید.")
                return

        # --- *** اصلاح کلیدی: ساخت دیکشنری صحیح برای ارسال به دیتابیس *** ---
        recipe_data_to_save = {
            "product_name": self.pack_item_data['name'],
            "part_type": "PACKAGING",
            "parent_product_id": self.pack_item_data.get('parent_item_id'),
            "produces_item_id": self.pack_item_data['id'],
            "notes": f"BOM بسته‌بندی برای {self.pack_item_data['name']}",
            "yield_percentage": 100.0,
            "properties": {} # بدون نسبت اختلاط
        }

        try:
            # ارسال دیکشنری به متد save_recipe (که اکنون باید به save_bom تغییر نام داده باشد)
            self.db.save_recipe(recipe_data_to_save, ingredients, recipe_id_to_revise=self.recipe_id_to_revise)
            if self.toast:
                self.toast.show_message("✔ لیست BOM بسته‌بندی با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام ذخیره BOM:\n{e}")
            print(traceback.format_exc())
            
                                    
# این کلاس جدید را به انتهای فایل کد خود اضافه کنید
class AssignAssetDialog(QtWidgets.QDialog):
    """دیالوگی برای تخصیص یک دارایی به یک کارمند."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تحویل دارایی به پرسنل")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.asset_combo = QtWidgets.QComboBox()
        self.employee_name_edit = QtWidgets.QLineEdit()
        self.doc_no_edit = QtWidgets.QLineEdit()
        
        layout.addRow("انتخاب دارایی (از انبار):", self.asset_combo)
        layout.addRow("نام تحویل گیرنده:", self.employee_name_edit)
        layout.addRow("شماره/نوع مدرک تحویل:", self.doc_no_edit)

        assets_in_stock = self.db.list_assets_in_stock()
        if not assets_in_stock:
            self.asset_combo.addItem("هیچ دارایی در انبار موجود نیست!", -1)
            self.asset_combo.setEnabled(False)
        else:
            for asset in assets_in_stock:
                self.asset_combo.addItem(f"{asset['code']} - {asset['name']}", asset['id'])

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت تحویل")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if self.asset_combo.currentIndex() == -1 or not self.employee_name_edit.text().strip():
            return None
        return {
            "asset_id": self.asset_combo.currentData(),
            "employee_name": self.employee_name_edit.text().strip(),
            "doc_no": self.doc_no_edit.text().strip()
        }
        
        
# این کلاس جدید را به انتهای فایل کد خود اضافه کنید
class ReasonDialog(QtWidgets.QDialog):
    """یک دیالوگ سفارشی برای دریافت اجباری دلیل از کاربر."""
    def __init__(self, title, label, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)
        self.reason = ""

        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel(label))
        
        self.text_edit = QtWidgets.QLineEdit()
        self.text_edit.setPlaceholderText("وارد کردن دلیل الزامی است...")
        layout.addWidget(self.text_edit)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("تایید")
        buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def validate_and_accept(self):
        """قبل از بستن پنجره، ورودی را چک می‌کند."""
        reason_text = self.text_edit.text().strip()
        if not reason_text:
            QtWidgets.QMessageBox.warning(self, "ورودی ناقص", "وارد کردن دلیل الزامی است.")
            return # از بسته شدن دیالوگ جلوگیری می‌کند
        
        self.reason = reason_text
        self.accept() # حالا که ورودی معتبر است، دیالوگ را می‌بندیم 
                                       
# این کلاس کاملاً جدید را به فایل کد خود اضافه کنید
class AssetHistoryDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش تاریخچه کامل تراکنش‌های یک دارایی."""
    def __init__(self, db: DB, asset_id: int, asset_name: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"تاریخچه دارایی: {asset_name}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 400)

        layout = QtWidgets.QVBoxLayout(self)
        
        self.tbl_history = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(self.tbl_history)
        
        layout.addWidget(self.tbl_history)
        self._load_history(asset_id)

    def _load_history(self, asset_id):
        history = self.db.get_transactions_for_asset(asset_id)
        
        headers = ['نوع تراکنش', 'شماره سند', 'تاریخ', 'کاربر', 'توضیحات']
        self.tbl_history.setColumnCount(len(headers))
        self.tbl_history.setHorizontalHeaderLabels(headers)
        self.tbl_history.setRowCount(len(history))

        for r, trans in enumerate(history):
            self.tbl_history.setItem(r, 0, QtWidgets.QTableWidgetItem(trans.get('t_type', '')))
            self.tbl_history.setItem(r, 1, QtWidgets.QTableWidgetItem(trans.get('t_no', '')))
            self.tbl_history.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(trans.get('t_date'))))
            self.tbl_history.setItem(r, 3, QtWidgets.QTableWidgetItem(trans.get('username', '')))
            self.tbl_history.setItem(r, 4, QtWidgets.QTableWidgetItem(trans.get('notes', '')))

        self.tbl_history.resizeColumnsToContents()
        self.tbl_history.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.Stretch)
        
        
        
# این کلاس جدید را به بالای فایل، کنار بقیه کلاس‌های کمکی اضافه کنید
class NumericTreeWidgetItem(QtWidgets.QTreeWidgetItem):
    """یک آیتم درختی که ستون‌های عددی را به درستی مرتب می‌کند."""
    def __lt__(self, other_item):
        column = self.treeWidget().sortColumn()
        
        # ستون‌هایی که باید به صورت عددی مرتب شوند
        numeric_columns = [2, 4] # ستون 2 (مقدار موجودی) و 4 (حد سفارش)
        
        if column in numeric_columns:
            try:
                self_val = float(self.text(column).replace(',', ''))
                other_val = float(other_item.text(column).replace(',', ''))
                return self_val < other_val
            except (ValueError, TypeError):
                # اگر تبدیل به عدد ممکن نبود، بر اساس متن مقایسه کن
                return super().__lt__(other_item)
        
        # برای بقیه ستون‌ها، از مرتب‌سازی پیش‌فرض استفاده کن
        return super().__lt__(other_item)
    
    
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class BomFilterDialog(QtWidgets.QDialog):
    """یک دیالوگ فیلتر سفارشی برای نمای درختی تاریخچه مصرف (BOM)."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("فیلتر پیشرفته تاریخچه مصرف")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.product_filter = QtWidgets.QLineEdit(placeholderText="مثال: P-2401-001")
        self.material_filter = QtWidgets.QLineEdit(placeholderText="مثال: رزین اپوکسی")
        self.batch_filter = QtWidgets.QLineEdit(placeholderText="مثال: BATCH-XYZ")

        layout.addRow("کد/نام محصول نهایی شامل:", self.product_filter)
        layout.addRow("نام ماده اولیه شامل:", self.material_filter)
        layout.addRow("بچ ماده اولیه شامل:", self.batch_filter)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("اعمال فیلتر")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_filters(self):
        """دیکشنری از فیلترهای وارد شده توسط کاربر را برمی‌گرداند."""
        return {
            "product": self.product_filter.text().lower().strip(),
            "material": self.material_filter.text().lower().strip(),
            "batch": self.batch_filter.text().lower().strip()
        }
        
# کل کلاس NotificationPanel را با این نسخه نهایی و کامل جایگزین کنید
class NotificationPanel(QtWidgets.QFrame):
    """یک پنل اعلان کشویی و مدرن که از زیر دکمه اصلی باز می‌شود."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent
        
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.Popup)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        self.setMinimumSize(500, 600)

        shadow = QtWidgets.QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(30); shadow.setColor(QtGui.QColor(0, 0, 0, 100)); shadow.setOffset(0, 4)
        self.setGraphicsEffect(shadow)
        
        self.main_widget = QtWidgets.QFrame(self)
        self.main_widget.setObjectName("notificationPanel")
        # --- اصلاح استایل: تم سرمه‌ای ---
        self.main_widget.setStyleSheet("""
            #notificationPanel { 
                background-color: #2c3e50; 
                border-radius: 8px; 
            }
        """)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(15, 10, 15, 15)
        layout.addWidget(self.main_widget)

        panel_layout = QtWidgets.QVBoxLayout(self.main_widget)
        panel_layout.setContentsMargins(0, 0, 0, 0)
        panel_layout.setSpacing(0)

        header_frame = QtWidgets.QFrame()
        header_frame.setStyleSheet("background-color: #34495e; border-bottom: 1px solid #4a6572; border-top-left-radius: 8px; border-top-right-radius: 8px;")
        header_layout = QtWidgets.QHBoxLayout(header_frame)
        header_layout.setContentsMargins(15, 10, 10, 10)
        
        title_label = QtWidgets.QLabel("کارتابل اعلانات")
        title_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        title_label.setStyleSheet("background: transparent; border: none; color: #ecf0f1;")

        close_button = QtWidgets.QPushButton("×")
        close_button.setFixedSize(24, 24)
        close_button.setCursor(Qt.PointingHandCursor)
        # --- اصلاح استایل: قرمز شدن دکمه بستن ---
        close_button.setStyleSheet("""
            QPushButton { background-color: #7f8c8d; color: white; border: none; border-radius: 12px; font-size: 16pt; }
            QPushButton:hover { background-color: #e74c3c; }
        """)
        close_button.clicked.connect(self.hide)

        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addWidget(close_button)
        panel_layout.addWidget(header_frame)
        
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setStyleSheet("QListWidget { border: none; background-color: transparent; }")
        self.list_widget.setSpacing(8)
        self.list_widget.itemClicked.connect(self._on_item_clicked)
        panel_layout.addWidget(self.list_widget)

        self.animation = QtCore.QPropertyAnimation(self, b"windowOpacity")
        self.animation.setDuration(200)

    def _load_notifications(self):
        # ... (این متد بدون تغییر باقی می‌ماند) ...
        self.list_widget.clear()
        notifications = self.parent_window.notifications_cache
        if globals().get('DEBUG_NOTIF', False):
            print(f"[TRACE:NOTIF:render] showing={len(notifications)}")
        if not notifications:
            placeholder_label = QtWidgets.QLabel("هیچ اعلان یا کار جدیدی برای شما وجود ندارد.")
            placeholder_label.setAlignment(Qt.AlignCenter)
            placeholder_label.setStyleSheet("color: #95a5a6; font-style: italic; padding: 50px; background:transparent;")
            item = QtWidgets.QListWidgetItem(self.list_widget)
            item.setSizeHint(placeholder_label.sizeHint())
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, placeholder_label)
            return
        for notif in notifications:
            card = NotificationCard(notif)
            item = QtWidgets.QListWidgetItem(self.list_widget)
            item.setSizeHint(card.sizeHint())
            item.setData(Qt.UserRole, notif)
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, card)
            
    # [REPLACE] in class NotificationPanel
    def _on_item_clicked(self, item):
        """با کلیک روی کارت: رفتار متناسب با نوع اعلان اجرا می‌شود."""
        notification_data = item.data(Qt.UserRole)
        if not notification_data:
            self.close()
            return

        action_key = notification_data.get('action_key')
        action_data = notification_data.get('action_data')
        notif_kind = notification_data.get('kind')

        try:
            if notif_kind == 'internal':
                self.parent_window._dismiss_notification(action_key, action_data)
            else:
                mark_read = getattr(self.parent_window, '_mark_notification_read', None)
                if callable(mark_read):
                    mark_read(action_key, action_data, only_read=True)
        except Exception:
            pass

        try:
            self.parent_window._handle_notification_action(action_key, action_data)
        finally:
            self.close()

    def show_panel(self, button_widget):
        # ... (این متد بدون تغییر باقی می‌ماند) ...
        self._load_notifications()
        button_pos = button_widget.mapToGlobal(QtCore.QPoint(0, 0))
        ideal_x = button_pos.x() + button_widget.width() - self.width()
        final_x = max(5, ideal_x)
        target_pos = QtCore.QPoint(final_x, button_pos.y() + button_widget.height() + 5)
        self.move(target_pos)
        self.setWindowOpacity(0.0)
        self.show()
        self.animation.setStartValue(0.0)
        self.animation.setEndValue(1.0)
        self.animation.start()
                
                    
# این کلاس کاملاً جدید را به کد خود اضافه کنید
class NotificationCard(QtWidgets.QFrame):
    """یک ویجت سفارشی برای نمایش یک اعلان به صورت گرافیکی."""
    def __init__(self, notification_data, parent=None):
        super().__init__(parent)
        self.setObjectName("notificationCard")
        self.setCursor(Qt.PointingHandCursor)
        
        # استایل‌دهی بر اساس اولویت
        priority_styles = {
            1: "border-left: 5px solid #e74c3c;", # High
            2: "border-left: 5px solid #3498db;", # Normal
            3: "border-left: 5px solid #95a5a6;"  # Low
        }
        base_style = """
            QFrame#notificationCard {
                background-color: white;
                border-radius: 5px;
                padding: 12px;
            }
            QFrame#notificationCard:hover {
                background-color: #f8f9fa;
            }
        """
        card_style = base_style + priority_styles.get(notification_data.get('priority', 2))
        if notification_data.get('is_read'):
            card_style += "\n            QFrame#notificationCard { background-color: #f4f6f7; }\n        "
        self.setStyleSheet(card_style)

        layout = QtWidgets.QHBoxLayout(self)
        layout.setSpacing(12)

        # آیکون بر اساس نوع
        icon_map = {
            "درخواست مواد": "go-down",
            "تحویل از تولید": "go-up",
            "برگشت از تولید": "go-previous",
            "انتقال به تولید": "go-jump"
        }
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_map.get(notification_data['type'], "dialog-information")).pixmap(32, 32))
        layout.addWidget(icon_label)

        text_layout = QtWidgets.QVBoxLayout()
        text_layout.setSpacing(2)
        type_label = QtWidgets.QLabel(f"<b>{notification_data['type']}</b>")
        details_label = QtWidgets.QLabel(notification_data['details'])
        details_label.setWordWrap(True)
        date_label = QtWidgets.QLabel(to_shamsi(notification_data['date']))
        date_label.setStyleSheet("color: #7f8c8d; font-size: 9pt;")
        text_layout.addWidget(type_label)
        text_layout.addWidget(details_label)
        text_layout.addWidget(date_label)
        layout.addLayout(text_layout, 1)
        
# این کلاس جدید را به انتهای فایل، قبل از MainWindow اضافه کنید
class SupplierManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت کامل تامین‌کنندگان."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_supplier_id = None

        self.setWindowTitle("مدیریت تامین‌کنندگان")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 600)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        # پنل راست: لیست تامین‌کنندگان
        list_panel = QtWidgets.QWidget()
        list_layout = QtWidgets.QVBoxLayout(list_panel)
        list_layout.addWidget(QtWidgets.QLabel("<b>لیست تامین‌کنندگان</b>"))
        self.tbl_suppliers = QtWidgets.QTableWidget()
        self._style_table(self.tbl_suppliers)
        self.tbl_suppliers.itemClicked.connect(self._populate_fields_for_edit)
        list_layout.addWidget(self.tbl_suppliers)
        splitter.addWidget(list_panel)

        # پنل چپ: فرم ورود و ویرایش اطلاعات
        form_panel = QtWidgets.QWidget()
        form_layout = QtWidgets.QVBoxLayout(form_panel)
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش تامین‌کننده")
        self.form = QtWidgets.QFormLayout(form_group)
        self.form.setSpacing(10)
        
        self.name_edit = QtWidgets.QLineEdit()
        self.contact_edit = QtWidgets.QLineEdit()
        self.phone_edit = QtWidgets.QLineEdit()
        self.email_edit = QtWidgets.QLineEdit()
        self.address_edit = QtWidgets.QTextEdit(); self.address_edit.setFixedHeight(60)
        self.ecode_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QTextEdit(); self.notes_edit.setFixedHeight(60)
        self.is_active_check = QtWidgets.QCheckBox("فعال")
        self.is_active_check.setChecked(True)

        self.form.addRow("نام شرکت (*):", self.name_edit)
        self.form.addRow("فرد رابط:", self.contact_edit)
        self.form.addRow("تلفن:", self.phone_edit)
        self.form.addRow("ایمیل:", self.email_edit)
        self.form.addRow("آدرس:", self.address_edit)
        self.form.addRow("کد اقتصادی:", self.ecode_edit)
        self.form.addRow("یادداشت:", self.notes_edit)
        self.form.addRow("وضعیت:", self.is_active_check)
        form_layout.addWidget(form_group)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_save.setProperty("class", "primary")
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف")
        btn_delete.setProperty("class", "danger")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن فرم")
        btn_layout.addWidget(btn_save); btn_layout.addWidget(btn_delete); btn_layout.addStretch(); btn_layout.addWidget(btn_clear)
        form_layout.addLayout(btn_layout)
        
        splitter.addWidget(form_panel)
        splitter.setSizes([550, 350])

        btn_save.clicked.connect(self._save_supplier)
        btn_delete.clicked.connect(self._delete_supplier)
        btn_clear.clicked.connect(self._clear_fields)
        
        self._load_suppliers()

    def _style_table(self, tbl):
        tbl.setAlternatingRowColors(True)
        tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tbl.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)

    def _load_suppliers(self):
        self.tbl_suppliers.setRowCount(0)
        suppliers = self.db.get_all_suppliers()
        headers = ['ID', 'نام شرکت', 'فرد رابط', 'تلفن', 'وضعیت']
        self.tbl_suppliers.setColumnCount(len(headers))
        self.tbl_suppliers.setHorizontalHeaderLabels(headers)
        self.tbl_suppliers.setColumnHidden(0, True)
        self.tbl_suppliers.setRowCount(len(suppliers))
        for r, sup in enumerate(suppliers):
            self.tbl_suppliers.setItem(r, 0, QtWidgets.QTableWidgetItem(str(sup['id'])))
            self.tbl_suppliers.setItem(r, 1, QtWidgets.QTableWidgetItem(sup['name']))
            self.tbl_suppliers.setItem(r, 2, QtWidgets.QTableWidgetItem(sup.get('contact_person', '')))
            self.tbl_suppliers.setItem(r, 3, QtWidgets.QTableWidgetItem(sup.get('phone', '')))
            status_item = QtWidgets.QTableWidgetItem("فعال" if sup.get('is_active') else "غیرفعال")
            status_item.setForeground(QtGui.QColor("green") if sup.get('is_active') else QtGui.QColor("red"))
            self.tbl_suppliers.setItem(r, 4, status_item)
        self.tbl_suppliers.resizeColumnsToContents()
        self.tbl_suppliers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.current_supplier_id = int(self.tbl_suppliers.item(row, 0).text())
        # برای خواندن اطلاعات کامل، یکبار دیگر از دیتابیس استعلام می‌کنیم
        supplier_details = self.db.execute_query("SELECT * FROM suppliers WHERE id = %s", (self.current_supplier_id,), fetch_one=True)
        if not supplier_details: return

        self.name_edit.setText(supplier_details.get('name', ''))
        self.contact_edit.setText(supplier_details.get('contact_person', ''))
        self.phone_edit.setText(supplier_details.get('phone', ''))
        self.email_edit.setText(supplier_details.get('email', ''))
        self.address_edit.setPlainText(supplier_details.get('address', ''))
        self.ecode_edit.setText(supplier_details.get('economic_code', ''))
        self.notes_edit.setPlainText(supplier_details.get('notes', ''))
        self.is_active_check.setChecked(supplier_details.get('is_active', True))

    def _clear_fields(self):
        self.current_supplier_id = None
        self.tbl_suppliers.clearSelection()
        for widget in [self.name_edit, self.contact_edit, self.phone_edit, self.email_edit, self.ecode_edit]:
            widget.clear()
        for widget in [self.address_edit, self.notes_edit]:
            widget.clear()
        self.is_active_check.setChecked(True)
        self.name_edit.setFocus()

    def _save_supplier(self):
        supplier_data = {
            "name": self.name_edit.text().strip(),
            "contact_person": self.contact_edit.text().strip(),
            "phone": self.phone_edit.text().strip(),
            "email": self.email_edit.text().strip(),
            "address": self.address_edit.toPlainText().strip(),
            "economic_code": self.ecode_edit.text().strip(),
            "notes": self.notes_edit.toPlainText().strip(),
            "is_active": self.is_active_check.isChecked()
        }
        try:
            self.db.add_or_update_supplier(supplier_data, self.current_supplier_id)
            if self.toast: self.toast.show_message("✔ اطلاعات تامین‌کننده با موفقیت ذخیره شد.", "success")
            self._load_suppliers()
            self._clear_fields()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ذخیره‌سازی", str(e))

    def _delete_supplier(self):
        if self.current_supplier_id is None:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک تامین‌کننده را از لیست انتخاب کنید.", "warning")
            return
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف تامین‌کننده «{self.name_edit.text()}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_supplier(self.current_supplier_id)
                if self.toast: self.toast.show_message("✔ تامین‌کننده با موفقیت حذف شد.", "info")
                self._load_suppliers()
                self._clear_fields()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در حذف", f"این تامین‌کننده احتمالاً در سوابق خرید استفاده شده و قابل حذف نیست.\nبه جای حذف، آن را غیرفعال کنید.\n\n{e}")

# BEGIN ADD: Compat.nullcontext shim
try:
    from contextlib import nullcontext  # Py3.7+
except Exception:
    from contextlib import contextmanager
    @contextmanager
    def nullcontext(enter_result=None):
        yield enter_result
# END ADD: Compat.nullcontext shim

from dataclasses import dataclass

@dataclass(slots=True)
class PurchaseRequestDTO:
    """ورودی استاندارد ساخت PR؛ تضمین می‌کند اعداد و متن‌ها تمیز باشند."""
    item_id: int
    quantity: float
    requester_user_id: int
    original_dept_id: int | None = None
    notes: str = ""

    @classmethod
    def from_ui(
        cls,
        item_id,
        qty,
        requester_id,
        original_dept_id=None,
        notes: str = ""
    ) -> "PurchaseRequestDTO":
        # مقدار
        try:
            q = float(qty)
        except (TypeError, ValueError):
            raise ValueError("مقدار درخواست باید عددی باشد.")
        if q <= 0:
            raise ValueError("مقدار درخواست باید بزرگ‌تر از صفر باشد.")
        # شناسه‌ها
        try:
            iid = int(item_id)
        except (TypeError, ValueError):
            raise ValueError("کالای انتخاب‌شده نامعتبر است.")
        try:
            rid = int(requester_id)
        except (TypeError, ValueError):
            raise ValueError("کاربر درخواست‌دهنده نامعتبر است.")
        od = None
        if original_dept_id not in (None, "", 0, "0"):
            try:
                od = int(original_dept_id)
            except (TypeError, ValueError):
                od = None  # اگر قابل‌تبدیل نبود، می‌گذاریم سیستم خودش تعیین کند
        nt = (notes or "").strip()
        if len(nt) > 500:
            nt = nt[:500]
        return cls(iid, q, rid, od, nt)
    

class MyPurchaseRequestsDialog(QtWidgets.QDialog):
    """نمایش «درخواست‌های خرید من». ساده و سریع."""
    def __init__(self, db, user_id, parent=None):
        super().__init__(parent)
        self.db, self.user_id = db, user_id
        self.setWindowTitle("پیگیری درخواست‌های من (PR)")
        self.resize(1000, 580)

        root = QtWidgets.QVBoxLayout(self)

        # نوار فیلتر
        fl = QtWidgets.QHBoxLayout()
        self.cmb_status = QtWidgets.QComboBox(); self.cmb_status.addItems(["همه", "در انتظار مدیر واحد", "در انتظار مدیرعامل", "بازرگانی", "سفارش صادر شده", "انبار"])
        self.cmb_urg    = QtWidgets.QComboBox(); self.cmb_urg.addItems(["همه", "عادی", "فوری", "آنی"])
        self.e_search   = QtWidgets.QLineEdit(); self.e_search.setPlaceholderText("جست‌وجو: شماره/نام کالا/مشخصات/یادداشت…")
        self.e_date_from = QtWidgets.QLineEdit(); self.e_date_from.setPlaceholderText("از تاریخ (YYYY-MM-DD)")
        self.e_date_to   = QtWidgets.QLineEdit(); self.e_date_to.setPlaceholderText("تا تاریخ (YYYY-MM-DD)")
        fl.addWidget(QtWidgets.QLabel("وضعیت:")); fl.addWidget(self.cmb_status)
        fl.addWidget(QtWidgets.QLabel("فوریت:")); fl.addWidget(self.cmb_urg)
        fl.addWidget(self.e_search, 1)
        fl.addWidget(self.e_date_from); fl.addWidget(self.e_date_to)

        # جدول
        headers = ["شماره","وضعیت","کالا (والد/نام)","مقدار/یکا","مشخصات فنی","یادداشت","فوریت","پیوست","نوبت اقدام","تاریخ ثبت"]
        self.tbl = QtWidgets.QTableWidget(0, len(headers))
        self.tbl.setHorizontalHeaderLabels(headers)
        self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl.horizontalHeader().setStretchLastSection(True)
        self.tbl.verticalHeader().setVisible(False)

        # دکمه‌ها
        bl = QtWidgets.QHBoxLayout()
        self.btn_show_group = QtWidgets.QPushButton("جزئیات فرم…")  # ← دکمهٔ جدید

        self.btn_refresh = QtWidgets.QPushButton("تازه‌سازی")
        self.btn_export  = QtWidgets.QPushButton("برون‌بری CSV")
        
        self.btn_close   = QtWidgets.QPushButton("بستن")
        bl.addStretch(1);  bl.addWidget(self.btn_refresh); bl.addWidget(self.btn_export); bl.addWidget(self.btn_close)

        bl.addWidget(self.btn_show_group)
        self.btn_show_group.clicked.connect(self._show_group_details)

        root.addLayout(fl)
        root.addWidget(self.tbl)
        root.addLayout(bl)

        # رویدادها
        self.btn_refresh.clicked.connect(self.refresh)
        self.btn_export.clicked.connect(self._export_csv)
        self.btn_close.clicked.connect(self.accept)
        self.cmb_status.currentIndexChanged.connect(self.refresh)
        self.cmb_urg.currentIndexChanged.connect(self.refresh)
        self.e_search.returnPressed.connect(self.refresh)

        self._cache_rows = []  # برای فیلتر سبک سمت نما
        self.refresh()
    # END REWRITE: UI.MyPurchaseRequestsDialog.__init__

    def showEvent(self, event):
        """هر بار دیالوگ نمایش داده شد، ستون/دکمهٔ پیوست‌ها در صفحهٔ اصلی مخفی بماند."""
        try:
            super().showEvent(event)
        except Exception:
            pass
        try:
            self._hide_main_attachments_ui()
        except Exception:
            pass
    # END ADD: UI.MyPurchaseRequestsDialog.showEvent

    
    
    
    # BEGIN REWRITE: UI.MyPurchaseRequestsDialog._show_group_details
    def _show_group_details(self):
        """نمایش اقلام فرم (گروه) + امکان دیدن پیوست‌ها برای هر قلم."""
        from PyQt5 import QtWidgets
        try:
            # اطمینان: در صفحهٔ اصلی، ستون/دکمهٔ پیوست‌ها مخفی بماند
            self._hide_main_attachments_ui()
        except Exception:
            pass

        pr_id = self._selected_pr_id()
        if not pr_id:
            return
        snap = self.db.get_pr_group_snapshot(int(pr_id)) or {}
        items = snap.get("items") or []
        if not items:
            QtWidgets.QMessageBox.information(self, "اطلاعاتی نیست", "اقلام این فرم قابل نمایش نیست.")
            return

        dlg = QtWidgets.QDialog(self)
        gid  = snap.get("group_id")
        phys = snap.get("physical_request_no") or "-"
        dlg.setWindowTitle(f"جزئیات فرم PR گروه #{gid}  —  شمارهٔ فیزیکی: {phys}")
        v = QtWidgets.QVBoxLayout(dlg)

        tbl = QtWidgets.QTableWidget(0, 6)
        tbl.setHorizontalHeaderLabels(["PR#", "کالا", "مقدار", "یکا", "مشخصات", "یادداشت"])
        tbl.horizontalHeader().setStretchLastSection(True)
        v.addWidget(tbl)

        tbl.setRowCount(len(items))
        for r, it in enumerate(items):
            tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(str(it["pr_id"])))
            tbl.setItem(r, 1, QtWidgets.QTableWidgetItem(it["item_name"]))
            tbl.setItem(r, 2, QtWidgets.QTableWidgetItem(str(it["qty"])))
            tbl.setItem(r, 3, QtWidgets.QTableWidgetItem(it["unit"]))
            tbl.setItem(r, 4, QtWidgets.QTableWidgetItem(it["specs"]))
            note_txt = (it.get("notes") or "").strip()
            attc = int(it.get("attachments_count") or 0)
            tbl.setItem(r, 5, QtWidgets.QTableWidgetItem(f"{note_txt}"))

        # دکمه‌ها
        bl = QtWidgets.QHBoxLayout(); v.addLayout(bl)
        btn_att = QtWidgets.QPushButton("پیوست‌های ردیف…"); bl.addWidget(btn_att)
        btn_close = QtWidgets.QPushButton("بستن"); bl.addStretch(1); bl.addWidget(btn_close)

        def _open_row_attachments():
            rr = tbl.currentRow()
            if rr < 0:
                QtWidgets.QMessageBox.information(dlg, "انتخاب کن", "یک ردیف را انتخاب کن.")
                return
            sel_pr = int(items[rr]["pr_id"])
            self._show_attachments(sel_pr)

        btn_att.clicked.connect(_open_row_attachments)
        tbl.itemDoubleClicked.connect(lambda *_: _open_row_attachments())

        dlg.resize(950, 520)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()
    # END REWRITE: UI.MyPurchaseRequestsDialog._show_group_details

    
    # BEGIN ADD: UI.MyPurchaseRequestsDialog._export_csv
    def _export_csv(self):
        try:
            path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "ذخیرهٔ CSV", "my_pr.csv", "CSV Files (*.csv)")
            if not path:
                return
            import csv
            headers = ["id","status","item","qty_unit","specs","urgency","attachments","next_actor","created_at"]
            with open(path, "w", newline="", encoding="utf-8") as f:
                wr = csv.writer(f)
                wr.writerow(headers)
                for r in range(self.tbl.rowCount()):
                    row = [self.tbl.item(r, i).text() if self.tbl.item(r, i) else "" for i in range(self.tbl.columnCount())]
                    # نگاشت به ترتیب headers
                    mapped = [
                        row[0], row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8]
                    ]
                    wr.writerow(mapped)
            QtWidgets.QMessageBox.information(self, "اطلاع", "فایل CSV ذخیره شد.")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "خطا", f"ذخیره انجام نشد: {e}")
    # END ADD: UI.MyPurchaseRequestsDialog._export_csv

    def refresh(self):
        """
        نمایش «فرم‌ها» (گروه‌های PR) به جای ردیف‌های تکی.
        ستون‌ها: # فرم | شماره فیزیکی | تعداد اقلام | واحد | درخواست‌کننده | مرحله/وضعیت | نوبت اقدام | تاریخ ثبت
        """
        try:
            from PyQt5 import QtCore, QtWidgets
            rows = self.db.list_my_pr_groups_overview(user_id=int(self.user_id), limit=500) or []

            headers = ["# فرم", "شماره فیزیکی", "تعداد اقلام", "واحد", "درخواست‌کننده",
                    "مرحله/وضعیت", "نوبت اقدام", "تاریخ ثبت"]
            self.table.setColumnCount(len(headers))
            self.table.setHorizontalHeaderLabels(headers)
            self.table.setRowCount(len(rows))

            for r, d in enumerate(rows):
                # ستون 0: group_id (نمایش) + نگه‌داری کلید در UserRole
                item0 = QtWidgets.QTableWidgetItem(str(d.get("group_id") or "-"))
                item0.setData(QtCore.Qt.UserRole, int(d.get("group_id") or 0))
                self.table.setItem(r, 0, item0)

                self.table.setItem(r, 1, QtWidgets.QTableWidgetItem(d.get("physical_no") or "—"))
                self.table.setItem(r, 2, QtWidgets.QTableWidgetItem(str(d.get("items_count") or 0)))
                self.table.setItem(r, 3, QtWidgets.QTableWidgetItem(d.get("dept_name") or ""))
                self.table.setItem(r, 4, QtWidgets.QTableWidgetItem(d.get("requester_name") or ""))
                self.table.setItem(r, 5, QtWidgets.QTableWidgetItem(d.get("stage_label") or ""))
                self.table.setItem(r, 6, QtWidgets.QTableWidgetItem(d.get("next_actor") or ""))
                self.table.setItem(r, 7, QtWidgets.QTableWidgetItem(d.get("created_at_fmt") or ""))

            self.table.resizeColumnsToContents()
            self.table.resizeRowsToContents()
        except Exception as e:
            from PyQt5 import QtWidgets
            QtWidgets.QMessageBox.warning(self, "خطا", f"به‌روزرسانی لیست ناموفق بود:\n{e}")
            
    

    # BEGIN ADD: UI.MyPurchaseRequestsDialog._selected_pr_id
    def _selected_pr_id(self):
        rows = self.tbl.selectionModel().selectedRows()
        if not rows:
            return None
        r = rows[0].row()
        it = self.tbl.item(r, 0)
        if not it:
            return None
        val = it.data(QtCore.Qt.UserRole)
        try:
            return int(val) if val is not None else None
        except Exception:
            return None
    # END ADD: UI.MyPurchaseRequestsDialog._selected_pr_id

    # BEGIN REWRITE: UI.MyPurchaseRequestsDialog._show_attachments
    def _show_attachments(self, pr_id: int | None = None):
        """پیوست‌های PR را نمایش و باز می‌کند (bytes/path/url). دابل‌کلیک = باز کردن."""
        from PyQt5 import QtWidgets, QtCore
        import os, webbrowser, tempfile, subprocess, sys

        # pr_id
        if pr_id is None:
            table_candidates = [getattr(self, "tbl", None), getattr(self, "table", None), getattr(self, "tbl_requests", None)]
            tbl = next((t for t in table_candidates if t is not None), None)
            if tbl is None or tbl.currentRow() < 0:
                QtWidgets.QMessageBox.information(self, "انتخاب لازم", "اول یک درخواست را انتخاب کن.")
                return
            it0 = tbl.item(tbl.currentRow(), 0)
            try:
                pr_id = int((it0.data(QtCore.Qt.UserRole) if it0 else None) or (it0.text() if it0 else ""))
            except Exception:
                QtWidgets.QMessageBox.warning(self, "خطا", "شناسهٔ PR پیدا نشد."); return

        files = self.db.get_pr_attachments(int(pr_id)) or []
        if not files:
            QtWidgets.QMessageBox.information(self, "پیوستی نیست", "برای این ردیف، پیوستی ثبت نشده."); return

        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle(f"پیوست‌های PR #{pr_id}")
        vbox = QtWidgets.QVBoxLayout(dlg)
        vbox.addWidget(QtWidgets.QLabel("نکته: با دابل‌کلیک روی سطر یا دکمه «باز کردن»، فایل باز می‌شود."))

        table = QtWidgets.QTableWidget(len(files), 2)
        table.setHorizontalHeaderLabels(["نام فایل", "حجم"])
        table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        table.horizontalHeader().setStretchLastSection(True)
        vbox.addWidget(table)

        def _fmt_size(b):
            try:
                b = float(b or 0)
                for u in ("B","KB","MB","GB","TB"):
                    if b < 1024: return f"{b:,.0f} {u}"
                    b /= 1024.0
                return f"{b:.1f} PB"
            except Exception:
                return ""

        for r, f in enumerate(files):
            fn = f.get("filename") or f.get("name") or ""
            sz = f.get("size_bytes") or f.get("size") or 0
            att_id = f.get("id") or f.get("attachment_id")
            it = QtWidgets.QTableWidgetItem(fn); it.setData(QtCore.Qt.UserRole, {"att_id": att_id, "filename": fn})
            table.setItem(r, 0, it); table.setItem(r, 1, QtWidgets.QTableWidgetItem(_fmt_size(sz)))

        def _current():
            rr = table.currentRow()
            if rr < 0: return None, ""
            meta = table.item(rr, 0).data(QtCore.Qt.UserRole) or {}
            return meta.get("att_id"), meta.get("filename") or ""

        def _open_bytes(fname, data: bytes):
            fd, p = tempfile.mkstemp(prefix="pr_", suffix="_"+(fname or "file")); os.close(fd)
            with open(p, "wb") as f: f.write(data)
            try:
                if sys.platform.startswith("win"): os.startfile(p)  # type: ignore
                elif sys.platform == "darwin": subprocess.run(["open", p], check=False)
                else: subprocess.run(["xdg-open", p], check=False)
            except Exception:
                QtWidgets.QMessageBox.information(dlg, "ذخیره شد", f"مسیر فایل: {p}")

        def _load_any(att_id, fname):
            rec = None
            try:
                rec = self.db.fetch_pr_attachment(attachment_id=att_id, pr_id=int(pr_id), filename=fname)
            except Exception:
                rec = None
            if rec and rec.get("data") is not None:
                return ("bytes", rec.get("filename") or fname, bytes(rec["data"]))
            if rec and rec.get("path"):
                pth = str(rec["path"])
                try:
                    with open(pth, "rb") as f: return ("bytes", rec.get("filename") or os.path.basename(pth), f.read())
                except Exception:
                    return ("error", None, None)
            if rec and rec.get("url"):
                return ("url", str(rec["url"]), None)
            s = (fname or "").strip()
            if s.startswith("http://") or s.startswith("https://"):
                return ("url", s, None)
            return ("none", None, None)

        def _do_open():
            att_id, fn = _current()
            kind, val, data = _load_any(att_id, fn)
            if kind == "bytes" and data is not None: _open_bytes(val or fn, data); return
            if kind == "url" and val:
                import webbrowser
                try: webbrowser.open(val); return
                except Exception: pass
            QtWidgets.QMessageBox.warning(dlg, "یافت نشد", "محتوای فایل یا لینک قابل بازیابی نیست.")

        def _do_save():
            att_id, fn = _current()
            kind, val, data = _load_any(att_id, fn)
            if kind == "bytes" and data is not None:
                path, _ = QtWidgets.QFileDialog.getSaveFileName(dlg, "ذخیرهٔ فایل", val or fn or "file")
                if path:
                    with open(path, "wb") as f: f.write(data)
            else:
                QtWidgets.QMessageBox.information(dlg, "ذخیره", "فقط فایل‌های دارای محتوای باینری قابل ذخیره هستند.")

        btns = QtWidgets.QHBoxLayout(); vbox.addLayout(btns)
        b_open = QtWidgets.QPushButton("باز کردن"); b_save = QtWidgets.QPushButton("ذخیره…"); b_close = QtWidgets.QPushButton("بستن")
        btns.addWidget(b_open); btns.addWidget(b_save); btns.addStretch(1); btns.addWidget(b_close)
        b_open.clicked.connect(_do_open); b_save.clicked.connect(_do_save); b_close.clicked.connect(dlg.accept)
        table.doubleClicked.connect(lambda *_: _do_open())

        dlg.resize(600, 360); dlg.exec_()
    # END REWRITE: UI.MyPurchaseRequestsDialog._show_attachments

    # BEGIN ADD: UI.MyPurchaseRequestsDialog._to_jalali
    def _to_jalali(self, dt):
        """
        تبدیل سادهٔ تاریخ/زمان میلادی به رشتهٔ شمسی «YYYY-MM-DD HH:MM».
        بدون وابستگی بیرونی. اگر خطا شد، همان ورودی را برمی‌گرداند.
        """
        from datetime import datetime, date
        # نرمال‌سازی به datetime
        if isinstance(dt, str):
            try:
                # تلاش برای خواندن «YYYY-MM-DD HH:MM:SS»
                dt = datetime.fromisoformat(dt.split('+')[0])
            except Exception:
                return dt
        elif isinstance(dt, date) and not isinstance(dt, datetime):
            dt = datetime(dt.year, dt.month, dt.day)
        elif not isinstance(dt, datetime):
            return dt

        gy, gm, gd = dt.year, dt.month, dt.day
        # الگوریتم تبدیل (تقویم جلالی ساده)
        g_d_m = [0,31,59,90,120,151,181,212,243,273,304,334]
        if (gy%4==0 and gy%100!=0) or (gy%400==0):
            leap = True
        else:
            leap = False
        gy2 = gy - 1600
        gm2 = gm - 1
        gd2 = gd - 1
        g_day_no = 365*gy2 + (gy2+3)//4 - (gy2+99)//100 + (gy2+399)//400
        g_day_no += g_d_m[gm2] + gd2
        if leap and gm2>1:
            g_day_no += 1
        j_day_no = g_day_no - 79
        j_np = j_day_no // 12053
        j_day_no %= 12053
        jy = 979 + 33*j_np + 4*(j_day_no//1461)
        j_day_no %= 1461
        if j_day_no >= 366:
            jy += (j_day_no-366)//365 + 1
            j_day_no = (j_day_no-366)%365
        jm_list = [31,31,31,31,31,31,30,30,30,30,30,29]
        jm = 0
        while jm < 12 and j_day_no >= jm_list[jm]:
            j_day_no -= jm_list[jm]
            jm += 1
        jd = j_day_no + 1
        jm += 1
        hhmm = dt.strftime("%H:%M")
        return f"{jy:04d}-{jm:02d}-{jd:02d} {hhmm}"
    # END ADD: UI.MyPurchaseRequestsDialog._to_jalali

    
# BEGIN ADD: UI.ApprovalsCenterDialog
from PyQt5 import QtWidgets

class ApprovalsCenterDialog(QtWidgets.QDialog):
    """مرکز تأیید PR برای مدیر واحد."""
# BEGIN REWRITE: UI.ApprovalsCenterDialog.__init__
    def __init__(self, db, manager_user_id, parent=None):
        super().__init__(parent)
        self.db, self.manager_user_id = db, manager_user_id
        self.setWindowTitle("مرکز تأیید PR (مدیر واحد)")
        self.resize(1000, 560)

        v = QtWidgets.QVBoxLayout(self)

        # نوار فیلتر سبک
        fl = QtWidgets.QHBoxLayout()
        self.cmb_status = QtWidgets.QComboBox(); self.cmb_status.addItems(["در انتظار مدیر واحد"])  # این نما مخصوص همین وضعیت است
        self.cmb_urg = QtWidgets.QComboBox(); self.cmb_urg.addItems(["همه","عادی","فوری","آنی"])
        self.e_search = QtWidgets.QLineEdit(); self.e_search.setPlaceholderText("جست‌وجو: نام/کد کالا، درخواست‌کننده، مشخصات فنی…")
        btn_refresh = QtWidgets.QPushButton("↻ تازه‌سازی"); btn_export = QtWidgets.QPushButton("برون‌بری CSV")
        fl.addWidget(QtWidgets.QLabel("فوریت:")); fl.addWidget(self.cmb_urg)
        fl.addWidget(self.e_search, 1)
        fl.addStretch(1); fl.addWidget(btn_refresh); fl.addWidget(btn_export)
        v.addLayout(fl)

        # جدول با ستون‌های کامل
        headers = ["#","کالا","مقدار/واحد","مشخصات فنی","پیوست","فوریت","درخواست‌کننده","واحد","تاریخ ثبت","نوبت اقدام"]
        self.tbl = QtWidgets.QTableWidget(0, len(headers))
        self.tbl.setHorizontalHeaderLabels(headers)
        self.tbl.horizontalHeader().setStretchLastSection(True)
        self.tbl.verticalHeader().setVisible(False)
        self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        v.addWidget(self.tbl, 1)

        # دکمه‌های اقدام
        h = QtWidgets.QHBoxLayout()
        self.btn_approve = QtWidgets.QPushButton("تأیید")
        self.btn_reject  = QtWidgets.QPushButton("رد…")
        self.btn_close   = QtWidgets.QPushButton("بستن")
        h.addStretch(1); h.addWidget(self.btn_approve); h.addWidget(self.btn_reject); h.addWidget(self.btn_close)
        v.addLayout(h)

        # رویدادها
        btn_refresh.clicked.connect(self.refresh)
        btn_export.clicked.connect(self._export_csv)
        self.btn_approve.clicked.connect(self._on_approve)
        self.btn_reject.clicked.connect(self._on_reject)
        self.btn_close.clicked.connect(self.accept)
        self.cmb_urg.currentIndexChanged.connect(self.refresh)
        self.e_search.returnPressed.connect(self.refresh)

        self._cache_rows = []
        self.refresh()
    # END REWRITE: UI.ApprovalsCenterDialog.__init__
    
    # BEGIN ADD: UI.CEOApprovalBoard._set_busy
    def _set_busy(self, on: bool) -> None:
        """قفل/آزادکردن موقت دکمه‌های «تأیید/رد» برای جلوگیری از دوباره‌کلیک."""
        try:
            if getattr(self, "_deciding", False) == on:
                return
            self._deciding = on
            for btn in (getattr(self, "btn_approve", None), getattr(self, "btn_reject", None)):
                if btn is not None:
                    btn.setEnabled(not on)
            try:
                self.table.setEnabled(not on)
            except Exception:
                pass
            # پیام کوتاه روی عنوان
            self.setWindowTitle(("داشبورد مدیرعامل – (در حال اعمال…)") if on else "داشبورد مدیرعامل – تأیید درخواست‌های خرید")
            from PyQt5 import QtWidgets as _QtW
            _QtW.QApplication.processEvents()
        except Exception:
            pass
    # END ADD: UI.CEOApprovalBoard._set_busy

    def _current_pr_id(self):
        r = self.tbl.currentRow()
        if r < 0: return None
        item = self.tbl.item(r, 0)
        try: return int(item.text()) if item else None
        except Exception: return None

    # BEGIN REWRITE: UI.ApprovalsCenterDialog.refresh
    def refresh(self):
        """
        لود لیست PRهای «در انتظار تأیید مدیر واحد» با پشتیبانی نیابت و فیلترهای سبک.
        - منبع داده: DB.list_prs_pending_unit_manager(self.manager_user_id)
        - فیلترها: فوریت (cmb_urg)، جستجو (e_search)
        - پیام‌ها: «مدیر واحد تعریف نشده» یا «موردی برای بررسی نیست»
        """
        from PyQt5 import QtWidgets

        # 1) دریافت داده از DB (واحد خودش + نیابت)
        try:
            data = self.db.list_prs_pending_unit_manager(self.manager_user_id) or []
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"دریافت داده ناموفق بود:\n{e}")
            return

        # 2) اعمال فیلترهای UI
        pick_urg = (self.cmb_urg.currentText() or "").strip()
        q = (self.e_search.text() or "").strip()

        def _t(x):
            return "—" if x in (None, "", 0) else str(x)

        def _ok_urg(d: dict) -> bool:
            if pick_urg == "همه":
                return True
            return (d.get("final_urgency") or "عادی") == pick_urg

        def _ok_search(d: dict) -> bool:
            if not q:
                return True
            hay_parts = [
                str(d.get("id") or ""),
                d.get("item_name") or "",
                d.get("requester_name") or "",
                d.get("specs") or "",
                d.get("dept_name") or "",
            ]
            hay = " ".join(hay_parts)
            return q in hay

        rows = [d for d in data if _ok_urg(d) and _ok_search(d)]

        # 3) پیام‌های کمبود داده طبق سیاست شما
        if not rows:
            try:
                has_mapping = bool(self.db.has_unit_manager_mapping(self.manager_user_id))
            except Exception:
                has_mapping = False
            if not has_mapping:
                QtWidgets.QMessageBox.information(self, "راهنما", "مدیر واحد تعریف نشده.")
            else:
                QtWidgets.QMessageBox.information(self, "اطلاع", "موردی برای بررسی نیست.")

        # 4) پرکردن جدول (ظاهر موجود حفظ شود)
        # ستون‌های رایج: ["#","کالا","مقدار/واحد","مشخصات فنی","پیوست","فوریت","درخواست‌کننده","واحد","تاریخ ثبت","نوبت اقدام"]
        self.tbl.setRowCount(len(rows))
        for i, d in enumerate(rows):
            qty_unit = f"{_t(d.get('requested_qty'))} {_t(d.get('unit_name'))}".strip()
            specs = (d.get("specs") or "").strip()
            specs_show = "(ناقص)" if not specs else (specs if len(specs) <= 60 else specs[:57] + "…")

            def _set(col, value):
                item = QtWidgets.QTableWidgetItem(_t(value))
                # غیرفعال‌کردن ادیت دستی سطرها
                item.setFlags(item.flags() & ~QtWidgets.Qt.ItemIsEditable)
                self.tbl.setItem(i, col, item)

            _set(0, d.get("id"))
            _set(1, d.get("item_name"))
            _set(2, qty_unit)
            _set(3, specs_show)
            _set(4, d.get("attachments_count"))
            _set(5, d.get("final_urgency"))
            _set(6, d.get("requester_name"))
            _set(7, d.get("dept_name"))
            _set(8, d.get("submitted_at"))
            _set(9, d.get("next_actor"))

        # 5) انتخاب قبلی حفظ نشود (رفتار ساده و ایمن)
        if self.tbl.rowCount() > 0:
            self.tbl.selectRow(0)
    # END REWRITE: UI.ApprovalsCenterDialog.refresh

    # BEGIN REWRITE: UI.ApprovalsCenterDialog._on_approve
    def _on_approve(self):
        if getattr(self, "_busy", False):
            return
        pr_id = self._current_pr_id()
        if not pr_id:
            QtWidgets.QMessageBox.information(self, "انتخاب لازم", "یک ردیف را انتخاب کنید.")
            return
        self._set_busy(True)
        try:
            self.db.approve_pr(int(pr_id), approver_id=int(self.manager_user_id))
            self.refresh()
            QtWidgets.QMessageBox.information(self, "موفق", f"PR #{pr_id} تأیید شد.")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"تأیید ناموفق بود:\n{e}")
        finally:
            self._set_busy(False)
    # END REWRITE: UI.ApprovalsCenterDialog._on_approve

    # BEGIN REWRITE: UI.ApprovalsCenterDialog._on_reject
    def _on_reject(self):
        if getattr(self, "_busy", False):
            return
        pr_id = self._current_pr_id()
        if not pr_id:
            QtWidgets.QMessageBox.information(self, "انتخاب لازم", "یک ردیف را انتخاب کنید.")
            return
        reason, ok = QtWidgets.QInputDialog.getText(self, "علت رد", "علت را بنویسید:")
        if not ok:
            return
        self._set_busy(True)
        try:
            self.db.reject_pr(int(pr_id), approver_id=int(self.manager_user_id), reason=(reason or ""))
            self.refresh()
            QtWidgets.QMessageBox.information(self, "انجام شد", f"PR #{pr_id} رد شد.")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"رد ناموفق بود:\n{e}")
        finally:
            self._set_busy(False)
    # END REWRITE: UI.ApprovalsCenterDialog._on_reject

    

                
                                                            
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید

class DynamicFormDialog(QtWidgets.QDialog):
    """
    نسخه 3.4 (نهایی):
    - از فیلد "لیست کشویی" (dropdown) پشتیبانی می‌کند.
    - فیلد "لیست کالاها" را به صورت یک نمای درختی کامل (دسته‌بندی > مادر > فرزند) نمایش می‌دهد.
    """
    def __init__(self, db: DB, form_id: int, title: str, parent=None,initial_data: dict = None):
        super().__init__(parent)
        self.db = db
        self.form_id = form_id
        self.initial_data = initial_data # <<<<<<< پارامتر جدید را ذخیره کن

        
        self.form_fields = self.db.get_form_fields(self.form_id)
        
        self.setWindowTitle(title)
        self.setMinimumWidth(500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        self.layout = QtWidgets.QFormLayout(self)
        self.layout.setSpacing(15)
        self.widgets = {}
        self.condition_map = {}

        if not self.form_fields:
            self.layout.addRow(QtWidgets.QLabel("خطا: هیچ فیلدی برای این فرم تعریف نشده است."))
            return

        for field in self.form_fields:
            self._create_widget_for_field(field)

        self._connect_conditional_signals()
        self._evaluate_all_conditions()

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        self.layout.addRow(buttons)

    # در کلاس DynamicFormDialog جایگزین کن
    def _populate_items_tree_model(self, model, category_filter):
        """
        یک QStandardItemModel را با ساختار درختی کالاها پر می‌کند:
        دسته → (محصول مادر/پک والد) → (پک‌های فرزند)
        منبع داده: DB.get_all_items_for_selection()
        """
        try:
            # 1) دریافت همهٔ کالاها برای نمایش انتخابی
            all_items = self.db.get_all_items_for_selection()  # خروجی: id,name,category,unit,...  ✔
            if not all_items:
                return

            # 2) فیلتر اختیاری روی دسته
            if category_filter:
                all_items = [it for it in all_items if (it.get('category') or '') == category_filter]

            # 3) ساخت نگاشت دسته → لیست آیتم‌ها
            items_by_category = {}
            for it in all_items:
                cat = it.get('category') or 'نامشخص'
                items_by_category.setdefault(cat, []).append(it)

            # 4) ریشهٔ مدل
            root = model.invisibleRootItem()

            # 5) ترتیب دسته‌ها
            categories_to_show = [category_filter] if category_filter else sorted(items_by_category.keys())

            from PyQt5 import QtGui
            for cat in categories_to_show:
                if cat not in items_by_category:
                    continue

                # نود دسته
                cat_node = QtGui.QStandardItem(str(cat))
                cat_node.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
                # دسته انتخاب‌پذیر نباشد
                cat_node.setFlags(cat_node.flags() & ~Qt.ItemIsSelectable)
                root.appendRow(cat_node)

                # 6) داخل هر دسته، والد/فرزند بسازیم
                items_in_cat = items_by_category[cat]
                items_by_id = {row['id']: dict(row) for row in items_in_cat}

                child_map, top_level = {}, []
                for _id, row in items_by_id.items():
                    pid = row.get('parent_item_id')
                    if pid and pid in items_by_id:
                        child_map.setdefault(pid, []).append(row)
                    else:
                        top_level.append(row)

                # 7) نودهای والد (محصول مادر یا پک بدون والد)
                for row in sorted(top_level, key=lambda x: x.get('name', '')):
                    parent = QtGui.QStandardItem(row.get('name', ''))
                    parent.setData(row, Qt.UserRole)

                    # اگر «محصول مادر» است، انتخاب‌پذیر نباشد
                    is_parent_product = bool(row.get('is_parent_product', False))
                    if is_parent_product:
                        parent.setFlags(parent.flags() & ~Qt.ItemIsSelectable)

                    cat_node.appendRow(parent)

                    # 8) نودهای فرزند (پک‌های زیرمجموعه)
                    children = sorted(child_map.get(row['id'], []), key=lambda x: x.get('name', ''))
                    for ch in children:
                        child = QtGui.QStandardItem(f"  └ {ch.get('name', '')}")
                        child.setData(ch, Qt.UserRole)
                        parent.appendRow(child)
        except Exception as e:
            # لاگ بی‌صدا + جلوگیری از کرش UI
            print("ERROR in _populate_items_tree_model:", e)

# در کلاس DynamicFormDialog، این متد را به طور کامل جایگزین کنید

    def _create_widget_for_field(self, field_data):
        """یک ویجت می‌سازد و آن را بر اساس اتصال داده سیستمی، پیش‌جمعیت می‌کند."""
        label_text = field_data['label']
        field_id = field_data['id']
        properties = field_data
        
        if properties.get('required'): label_text += " (*)"
        field_type = properties.get('type', 'text')
        widget = None
        
        # ... (بخش ساخت ویجت‌ها بدون تغییر باقی می‌ماند) ...
        if field_type == 'text': widget = QtWidgets.QLineEdit()
        elif field_type == 'number':
            widget = QtWidgets.QLineEdit(); min_val = properties.get('min', -float('inf')); max_val = properties.get('max', float('inf'))
            widget.setValidator(QtGui.QDoubleValidator(float(min_val or -float('inf')), float(max_val or float('inf')), 2))
        elif field_type == 'date': widget = QtWidgets.QLineEdit(); widget.setInputMask("0000/00/00;_")
        elif field_type == 'checkbox': widget = QtWidgets.QCheckBox()
        elif field_type == 'dropdown':
            widget = QtWidgets.QComboBox(); options = properties.get('options', [])
            if isinstance(options, list): widget.addItems(["--- انتخاب کنید ---"] + options)
        # ... (و الی آخر) ...
        elif field_type == 'item_list':
            widget = QtWidgets.QComboBox(); model = QtGui.QStandardItemModel(); placeholder_item = QtGui.QStandardItem("--- انتخاب کنید ---"); placeholder_item.setData(None, Qt.UserRole); model.appendRow(placeholder_item)
            category_filter = properties.get('category_filter'); self._populate_items_tree_model(model, category_filter)
            widget.setModel(model); widget.setView(QtWidgets.QTreeView()); widget.setCurrentIndex(0)
        elif field_type == 'user_list':
            widget = QtWidgets.QComboBox(); widget.addItem("--- انتخاب کنید ---", None)
            for user in self.db.get_all_users_brief(): widget.addItem(user['username'], user['id'])
        elif field_type == 'supplier_list':
            widget = QtWidgets.QComboBox(); widget.addItem("--- انتخاب کنید ---", None)
            for supplier in self.db.get_all_suppliers(active_only=True): widget.addItem(supplier['name'], supplier['id'])
        elif field_type == 'department_list':
            widget = QtWidgets.QComboBox(); widget.addItem("--- انتخاب کنید ---", None)
            for dept in self.db.get_departments_tree(): widget.addItem(dept['name'], dept['id'])
        if widget:
            if isinstance(widget, QtWidgets.QLineEdit) and 'placeholder' in properties:
                 widget.setPlaceholderText(str(properties['placeholder']))
            
            # --- *** بخش جدید و کلیدی: پر کردن خودکار فیلد بر اساس کلید سیستمی *** ---
            system_data_key = properties.get('system_data_key')
            if self.initial_data and system_data_key and system_data_key in self.initial_data:
                value = self.initial_data[system_data_key]
                if isinstance(widget, QtWidgets.QLineEdit):
                    widget.setText(str(value))
                elif isinstance(widget, QtWidgets.QCheckBox):
                    widget.setChecked(bool(value))
            # --- ***************************************************************** ---

            self.layout.addRow(label_text, widget)
            self.widgets[field_id] = {'widget': widget, 'properties': properties, 'label': field_data['label']}
            if 'conditional_logic' in properties and properties['conditional_logic']:
                logic = properties['conditional_logic']; trigger_id = logic.get('trigger_field_id')
                if trigger_id not in self.condition_map: self.condition_map[trigger_id] = []
                self.condition_map[trigger_id].append(field_id)
                
                                
    def _connect_conditional_signals(self):
        for trigger_id, target_ids in self.condition_map.items():
            if trigger_id in self.widgets:
                trigger_widget = self.widgets[trigger_id]['widget']
                if isinstance(trigger_widget, QtWidgets.QLineEdit):
                    trigger_widget.textChanged.connect(self._evaluate_all_conditions)
                elif isinstance(trigger_widget, QtWidgets.QCheckBox):
                    trigger_widget.toggled.connect(self._evaluate_all_conditions)
                elif isinstance(trigger_widget, QtWidgets.QComboBox):
                    trigger_widget.currentIndexChanged.connect(self._evaluate_all_conditions)

    def _evaluate_all_conditions(self):
        for field_id, data in self.widgets.items():
            props = data['properties']
            if 'conditional_logic' in props and props['conditional_logic']:
                logic = props['conditional_logic']
                trigger_id = logic.get('trigger_field_id')
                if trigger_id in self.widgets:
                    trigger_widget = self.widgets[trigger_id]['widget']
                    trigger_value = ""
                    if isinstance(trigger_widget, QtWidgets.QLineEdit):
                        trigger_value = trigger_widget.text()
                    elif isinstance(trigger_widget, QtWidgets.QCheckBox):
                        trigger_value = trigger_widget.isChecked()
                    elif isinstance(trigger_widget, QtWidgets.QComboBox):
                        trigger_value = trigger_widget.currentText()

                    condition_met = self._check_single_condition(trigger_value, logic)
                    should_be_visible = (logic.get('action') == 'نمایش بده' and condition_met) or \
                                      (logic.get('action') == 'مخفی کن' and not condition_met)
                    
                    data['widget'].setVisible(should_be_visible)
                    self.layout.labelForField(data['widget']).setVisible(should_be_visible)

    def _check_single_condition(self, trigger_value, logic):
        operator = logic.get('operator'); value_to_compare = logic.get('value'); trigger_type = logic.get('trigger_field_type')
        if trigger_type == 'checkbox':
            if operator == 'تیک خورده باشد': return trigger_value is True
            if operator == 'تیک نخورده باشد': return trigger_value is False
        else:
            if operator == 'خالی باشد': return not str(trigger_value)
            if operator == 'خالی نباشد': return bool(str(trigger_value))
            if not str(trigger_value): return False
            if operator == 'برابر با': return str(trigger_value) == value_to_compare
            if operator == 'مخالف با': return str(trigger_value) != value_to_compare
            if operator == 'شامل': return value_to_compare in str(trigger_value)
            try:
                val_compare_num = float(value_to_compare); rec_val_num = float(trigger_value)
                if operator == 'بزرگتر از': return rec_val_num > val_compare_num
                if operator == 'کوچکتر از': return rec_val_num < val_compare_num
            except (ValueError, TypeError): pass
        return False

    def validate_and_accept(self):
        for field_id, data in self.widgets.items():
            if data['widget'].isVisible():
                props = data['properties']; is_required = props.get('required', False)
                widget = data['widget']; value = None
                
                if isinstance(widget, QtWidgets.QLineEdit): value = widget.text().strip()
                elif isinstance(widget, QtWidgets.QCheckBox): value = widget.isChecked()
                elif isinstance(widget, QtWidgets.QComboBox):
                    # For item_list, data is a dict in UserRole
                    item_data = widget.model().item(widget.currentIndex()).data(Qt.UserRole)
                    if item_data: # If it's not the placeholder
                        value = item_data
                    else:
                         # For simple dropdowns, the value is the text
                        value = widget.currentText() if "---" not in widget.currentText() else None

                if is_required and not value:
                    QtWidgets.QMessageBox.warning(self, "خطای اعتبارسنجی", f"فیلد «{data['label']}» اجباری است و نمی‌تواند خالی باشد.")
                    return
                
                if props.get('type') == 'text' and props.get('min_length') is not None:
                    if len(value) < props['min_length']:
                        QtWidgets.QMessageBox.warning(self, "خطای اعتبارسنجی", f"طول فیلد «{data['label']}» باید حداقل {props['min_length']} کاراکتر باشد.")
                        return
        self.accept()

    def get_data(self) -> dict:
        if not self.form_fields: return None
        data = {}
        for field_id, widget_data in self.widgets.items():
            if widget_data['widget'].isVisible():
                label = widget_data['label']
                widget = widget_data['widget']
                if isinstance(widget, QtWidgets.QLineEdit):
                    data[label] = widget.text()
                elif isinstance(widget, QtWidgets.QCheckBox):
                    data[label] = widget.isChecked()
                elif isinstance(widget, QtWidgets.QComboBox):
                    current_data = widget.model().item(widget.currentIndex()).data(Qt.UserRole)
                    if isinstance(current_data, dict): # Smart list (item, user, etc.)
                        data[label] = {"id": current_data.get('id'), "name": widget.currentText().strip().replace("└", "").strip()}
                    else: # Simple dropdown
                        data[label] = widget.currentText()
        return data
    
        
                                            
                    
# این کلاس کاملا جدید را به فایل خود اضافه کنید
class ConditionRowWidget(QtWidgets.QWidget):
    """یک ویجت سفارشی که یک ردیف کامل از قانون را به صورت یک جمله نمایش می‌دهد."""
    def __init__(self, is_first_row: bool, form_fields: list, parent=None):
        super().__init__(parent)
        self.form_fields = form_fields
        
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(0, 5, 0, 5)

        if is_first_row:
            self.logic_combo = QtWidgets.QLabel("<b>اگر</b>")
        else:
            self.logic_combo = QtWidgets.QComboBox()
            self.logic_combo.addItems(["و", "یا"])
        
        self.field_combo = QtWidgets.QComboBox()
        for field in self.form_fields:
            self.field_combo.addItem(field['label'])

        self.op_combo = QtWidgets.QComboBox()
        self.op_combo.addItems(['برابر با', 'مخالف با', 'بزرگتر از', 'کوچکتر از', 'شامل'])
        
        self.value_edit = QtWidgets.QLineEdit()

        layout.addWidget(self.logic_combo)
        layout.addWidget(self.field_combo, 1) # Stretch factor 1
        layout.addWidget(self.op_combo)
        layout.addWidget(self.value_edit, 1) # Stretch factor 1

    def get_data(self):
        """اطلاعات این ردیف را به صورت دیکشنری برمی‌گرداند."""
        logic = "and" # پیش‌فرض برای ردیف اول
        if isinstance(self.logic_combo, QtWidgets.QComboBox):
            logic = "and" if self.logic_combo.currentText() == "و" else "or"
            
        return {
            "logic": logic,
            "condition": {
                "field": self.field_combo.currentText(),
                "operator": self.op_combo.currentText(),
                "value": self.value_edit.text().strip()
            }
        }

    def set_data(self, data):
        """اطلاعات یک قانون را در ویجت‌ها تنظیم می‌کند."""
        if isinstance(self.logic_combo, QtWidgets.QComboBox):
            self.logic_combo.setCurrentText("و" if data.get('logic') == 'and' else "یا")
        
        condition = data.get('condition', {})
        self.field_combo.setCurrentText(condition.get('field', ''))
        self.op_combo.setCurrentText(condition.get('operator', ''))
        self.value_edit.setText(condition.get('value', ''))
                                    
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ConditionEditorDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک شرط منفرد در ویرایشگر قوانین."""
    def __init__(self, form_fields: list, condition_data=None, parent=None):
        super().__init__(parent)
        self.form_fields = form_fields
        self.setWindowTitle("افزودن / ویرایش شرط")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)
        
        self.field_combo = QtWidgets.QComboBox()
        for field in self.form_fields:
            self.field_combo.addItem(field['label'])
            
        self.op_combo = QtWidgets.QComboBox()
        self.op_combo.addItems(['برابر با', 'مخالف با', 'بزرگتر از', 'کوچکتر از', 'شامل'])
        
        self.value_edit = QtWidgets.QLineEdit()

        layout.addRow("فیلد:", self.field_combo)
        layout.addRow("عملگر:", self.op_combo)
        layout.addRow("مقدار:", self.value_edit)
        
        if condition_data:
            self.field_combo.setCurrentText(condition_data.get('field', ''))
            self.op_combo.setCurrentText(condition_data.get('operator', ''))
            self.value_edit.setText(str(condition_data.get('value', '')))

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if not self.value_edit.text().strip():
            return None
        return {
            "field": self.field_combo.currentText(),
            "operator": self.op_combo.currentText(),
            "value": self.value_edit.text().strip()
        }
                                            
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید

class ManageQaFormsDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, user_id: int, user_role: str, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.user_role = db, user_id, user_role
        self.toast = getattr(parent, 'toast', None)
        self.main_window = parent

        self.setWindowTitle("مدیریت فرم‌های تضمین کیفیت (QA)")
        self.setMinimumSize(700, 500); self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        self.tbl_forms = QtWidgets.QTableWidget(0, 3)
        self.tbl_forms.setHorizontalHeaderLabels(["ID", "نام فرم", "ID سازنده"]); self.tbl_forms.setColumnHidden(0, True)
        self.tbl_forms.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_forms.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl_forms.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_forms.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tbl_forms.itemDoubleClicked.connect(self._edit_form)
        layout.addWidget(self.tbl_forms)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " فرم QA جدید")
        btn_edit = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), " ویرایش فرم انتخاب شده")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف فرم انتخاب شده"); btn_del.setProperty("class", "danger")
        btn_layout.addStretch(); btn_layout.addWidget(btn_add); btn_layout.addWidget(btn_edit); btn_layout.addWidget(btn_del)
        layout.addLayout(btn_layout)
        
        btn_add.clicked.connect(self._add_form); btn_edit.clicked.connect(self._edit_form); btn_del.clicked.connect(self._delete_form)
        self._load_forms()

    def _load_forms(self):
        self.tbl_forms.setRowCount(0)
        forms = self.db.list_form_defs_by_type(form_type='QA', user_id=self.user_id, is_admin=(self.user_role == 'Admin'))
        self.tbl_forms.setRowCount(len(forms))
        for r, form in enumerate(forms):
            self.tbl_forms.setItem(r, 0, QtWidgets.QTableWidgetItem(str(form['id'])))
            self.tbl_forms.setItem(r, 1, QtWidgets.QTableWidgetItem(form['name']))
            self.tbl_forms.setItem(r, 2, QtWidgets.QTableWidgetItem(str(form.get('user_id', ''))))

    def _add_form(self):
        if not self.main_window.has_permission('qa:manage_forms'):
            self.toast.show_message("شما دسترسی لازم برای ایجاد فرم جدید را ندارید.", "error"); return
        
        dlg = AdvancedFormBuilderDialog(self.db, self.user_id, form_id=None, default_form_type='QA', parent=self.main_window)
        
        if dlg.exec_():
            self.toast.show_message("✔ فرم QA جدید با موفقیت ایجاد شد.", "success")
            self._load_forms()

# در کلاس ManageQaFormsDialog، این متد را جایگزین کنید
    def _edit_form(self):
        selected = self.tbl_forms.selectedItems()
        if not selected:
            self.toast.show_message("لطفاً ابتدا یک فرم را برای ویرایش انتخاب کنید.", "warning"); return
        form_id = int(self.tbl_forms.item(selected[0].row(), 0).text())
        
        # --- *** بخش جدید: پیدا کردن نوع فرآیند متصل به این فرم *** ---
        process_type_key = None
        workflow_using_form = self.db.execute_query("SELECT process_type_key FROM workflows WHERE form_def_id = %s LIMIT 1", (form_id,), fetch_one=True)
        if workflow_using_form:
            process_type_key = workflow_using_form.get('process_type_key')
        # --- ****************************************************** ---

        dlg = AdvancedFormBuilderDialog(self.db, self.user_id, form_id=form_id, process_type_key=process_type_key, parent=self.main_window)
        if dlg.exec_():
            self.toast.show_message("✔ فرم با موفقیت ویرایش شد.", "success")
            self._load_forms()
            
    def _delete_form(self):
        selected = self.tbl_forms.selectedItems()
        if not selected:
            self.toast.show_message("لطفاً ابتدا یک فرم را برای حذف انتخاب کنید.", "warning")
            return

        form_id = int(self.tbl_forms.item(selected[0].row(), 0).text())

        # چک: آیا این فرم در یک Workflow استفاده شده؟
        in_use = self.db.check_form_in_use(form_id)  # SELECT از workflows
        if in_use:
            QtWidgets.QMessageBox.warning(
                self, "غیرقابل حذف",
                f"این فرم در فرآیند «{in_use.get('name', 'نامشخص')}» استفاده شده و قابل حذف نیست.\n"
                "ابتدا باید فرآیند مرتبط را ویرایش یا غیرفعال کنید."
            )
            return

        reply = QtWidgets.QMessageBox.question(
            self, "تایید حذف",
            "آیا از حذف این فرم مطمئن هستید؟ این عملیات قابل بازگشت نیست."
        )
        if reply != QtWidgets.QMessageBox.Yes:
            return

        try:
            self.db.delete_form_def(form_id)
            self.toast.show_message("✔ فرم با موفقیت حذف شد.", "success")
            self._load_forms()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در حذف فرم", str(e))
                
                                                                                            
# کلاس ProcessActionDialog را به طور کامل با این نسخه جایگزین کنید
class ProcessActionDialog(QtWidgets.QDialog):
    """دیالوگ گرافیکی و هوشمند برای انجام تایید/رد/بازبینی (نسخه امن)."""
    def __init__(self, task_data: dict, parent=None):
        super().__init__(parent)
        self.task_data = task_data
        self.outcome = None # برای ذخیره نتیجه نهایی اقدام کاربر
        
        self.setWindowTitle(f"اقدام برای: {task_data.get('workflow_name')}")
        self.setMinimumWidth(500); self.setFont(QFont(FONT_FAMILY, 11)); self.setObjectName("actionDialog")
        self.setStyleSheet("#actionDialog { background-color: #f8f9fa; }")

        layout = QtWidgets.QVBoxLayout(self); layout.setContentsMargins(0, 0, 0, 20)
        header = QtWidgets.QLabel(f"مرحله: {task_data.get('step_name')}")
        header.setStyleSheet("background-color: #34495e; color: white; padding: 15px; font-size: 14pt; font-weight: bold;")
        layout.addWidget(header)

        form_layout = QtWidgets.QFormLayout(); form_layout.setContentsMargins(20, 20, 20, 20); form_layout.setSpacing(15)
        if task_data.get('related_table_name') == 'purchase_requests':
            details = task_data.get('details', {})
            form_layout.addRow("کالا:", QtWidgets.QLabel(f"<b>{details.get('item_name', '')}</b>"))
            form_layout.addRow("مقدار:", QtWidgets.QLabel(f"<b>{details.get('qty', '')}</b>"))
            form_layout.addRow("درخواست دهنده:", QtWidgets.QLabel(f"<b>{details.get('requester', '')}</b>"))
            form_layout.addRow(QtWidgets.QLabel("---"))

        self.reason_edit = QtWidgets.QTextEdit(placeholderText="در صورت رد کردن یا ارسال برای بازبینی، وارد کردن دلیل الزامی است...")
        form_layout.addRow("دلیل/توضیحات:", self.reason_edit)
        layout.addLayout(form_layout)

        buttons = QtWidgets.QDialogButtonBox()
        btn_rework = buttons.addButton("ارسال برای بازبینی", QtWidgets.QDialogButtonBox.HelpRole)
        btn_reject = buttons.addButton("رد کردن نهایی", QtWidgets.QDialogButtonBox.RejectRole)
        btn_approve = buttons.addButton("تایید", QtWidgets.QDialogButtonBox.AcceptRole)

        btn_rework.setProperty("class", "warning"); btn_rework.setMinimumHeight(40)
        btn_reject.setProperty("class", "danger"); btn_reject.setMinimumHeight(40)
        btn_approve.setProperty("class", "primary"); btn_approve.setMinimumHeight(40)
        layout.addWidget(buttons)

        # اتصال دکمه‌ها به توابع داخلی جدید
        btn_approve.clicked.connect(self._handle_approve)
        btn_reject.clicked.connect(self._handle_reject)
        btn_rework.clicked.connect(self._handle_rework)

    def _handle_approve(self):
        self.outcome = "APPROVED"
        self.accept() # این متد باعث می‌شود دیالوگ با موفقیت بسته شود

    def _handle_reject(self):
        if not self.reason_edit.toPlainText().strip():
            QtWidgets.QMessageBox.warning(self, "خطا", "برای رد کردن، وارد کردن دلیل الزامی است.")
            return
        self.outcome = "REJECTED"
        self.accept()

    def _handle_rework(self):
        if not self.reason_edit.toPlainText().strip():
            QtWidgets.QMessageBox.warning(self, "خطا", "برای ارسال به بازبینی، وارد کردن دلیل الزامی است.")
            return
        self.outcome = "REWORK"
        self.accept()

    def get_data(self):
        # این تابع حالا هم نتیجه و هم دلیل را برمی‌گرداند
        return {"outcome": self.outcome, "reason": self.reason_edit.toPlainText().strip()}            
                
    
class DelegationManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت تفویض اختیارها."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.toast = db, user_id, getattr(parent, 'toast', None)
        self.setWindowTitle("مدیریت تفویض اختیار")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        
        # ... (بقیه کد دیالوگ در اینجا قرار می‌گیرد - به دلیل طولانی بودن فعلا خلاصه شده)
        
        self.table = QtWidgets.QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["ID", "جانشین", "برای فرآیند", "از تاریخ", "تا تاریخ", "یادداشت"])
        layout.addWidget(self.table)
        
        btn_add = QtWidgets.QPushButton("ثبت تفویض اختیار جدید")
        btn_add.clicked.connect(self._add_delegation)
        layout.addWidget(btn_add)
        
        self._load_delegations()

    def _load_delegations(self):
        # ... (منطق بارگذاری اطلاعات در جدول)
        pass

    def _add_delegation(self):
        # ... (باز کردن دیالوگ برای افزودن رکورد جدید)
        pass
    
class SetUrgencyDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب فوریت خرید."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("تعیین فوریت خرید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.urgency_combo = QtWidgets.QComboBox()
        self.urgency_combo.addItems(["فوری (۱ روزه)", "عادی (۱ هفته‌ای)", "غیر فوری (۲ هفته‌ای)"])
        layout.addRow("سطح فوریت:", self.urgency_combo)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_urgency(self):
        return self.urgency_combo.currentText()
    
    
# این کلاس را به طور کامل جایگزین نسخه قبلی RolesAssignmentPanel کنید

class RolesAssignmentPanel(QtWidgets.QWidget):
    """
    یک پنل سفارشی که چیدمان داخلی خود را به صورت دستی و تضمین شده مدیریت می‌کند
    تا مشکل اسکرول به طور قطعی حل شود. نسخه نهایی و اصلاح شده.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id = None
        
        main_layout = QtWidgets.QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        
        left_panel = QtWidgets.QGroupBox("۱. واحد سازمانی")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.dept_list = QtWidgets.QListWidget()
        self.dept_list.itemSelectionChanged.connect(self._on_department_selected)
        left_layout.addWidget(self.dept_list)
        splitter.addWidget(left_panel)
        
        self.right_panel_content = QtWidgets.QWidget()
        self.right_panel_content.setObjectName("rightPanel")
        self.right_panel_content.setStyleSheet("#rightPanel { background-color: #f8f9fa; border: 1px solid #dfe4ea; border-radius: 8px; }")

        self.roles_label = QtWidgets.QLabel("<b>۲. نقش‌های مجاز</b>", self.right_panel_content)
        self.roles_list_widget = QtWidgets.QListWidget(self.right_panel_content)
        self.roles_list_widget.setSpacing(5)
        self.roles_list_widget.setStyleSheet("border: 1px solid #ced4da; background-color: white;")
        
        self.btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات", self.right_panel_content)
        self.btn_save.setProperty("class", "primary")
        self.btn_save.clicked.connect(self._save_assignments)
        
        splitter.addWidget(self.right_panel_content)
        main_layout.addWidget(splitter)
        splitter.setSizes([250, 500])

        self._load_departments()
        self._load_all_roles()
        
        # --- اصلاح کلیدی: اتصال مستقیم رویداد به متد کلاس ---
        self.right_panel_content.resizeEvent = self.custom_resize_event

    def custom_resize_event(self, event: QtGui.QResizeEvent):
        """مهمترین بخش: محاسبه و تنظیم دستی موقعیت و اندازه ویجت‌ها با مقادیر صحیح (integer)."""
        super(QtWidgets.QWidget, self.right_panel_content).resizeEvent(event)
        
        panel_width = self.right_panel_content.width()
        panel_height = self.right_panel_content.height()
        margin = 10
        button_height = 40
        label_height = 30
        spacing = 5

        # --- محاسبات با تبدیل قطعی به integer ---
        self.roles_label.setGeometry(margin, margin, panel_width - (2 * margin), label_height)
        
        list_y = self.roles_label.y() + self.roles_label.height() + spacing
        list_height = panel_height - list_y - button_height - (margin * 2)
        
        self.roles_list_widget.setGeometry(
            int(margin), 
            int(list_y), 
            int(panel_width - (2 * margin)), 
            int(list_height)
        )
        
        self.btn_save.setGeometry(
            int(margin), 
            int(self.roles_list_widget.y() + self.roles_list_widget.height() + margin), 
            int(panel_width - (2 * margin)), 
            int(button_height)
        )

    def _load_departments(self):
        self.dept_list.clear()
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            item = QtWidgets.QListWidgetItem(dept['name']); item.setData(Qt.UserRole, dept['id']); self.dept_list.addItem(item)
            
    def _load_all_roles(self):
        self.roles_list_widget.clear()
        all_roles = self.db.get_all_roles()
        for role in all_roles:
            item = QtWidgets.QListWidgetItem(role['name'])
            item.setData(Qt.UserRole, role['id'])
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Unchecked)
            self.roles_list_widget.addItem(item)
        self.roles_list_widget.setEnabled(False)

    def _on_department_selected(self):
        selected = self.dept_list.selectedItems()
        if not selected:
            self.current_dept_id = None; self.roles_list_widget.setEnabled(False); return
        self.current_dept_id = selected[0].data(Qt.UserRole); self.roles_list_widget.setEnabled(True)
        self.roles_label.setText(f"<b>۲. نقش‌های مجاز برای «{selected[0].text()}»:</b>")
        assigned_role_ids = self.db.get_role_ids_for_department(self.current_dept_id)
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i)
            role_id = item.data(Qt.UserRole)
            item.setCheckState(QtCore.Qt.Checked if role_id in assigned_role_ids else QtCore.Qt.Unchecked)

    def _save_assignments(self):
        if self.current_dept_id is None:
            self.toast.show_message("لطفاً ابتدا یک واحد سازمانی را انتخاب کنید.", "warning"); return
        selected_role_ids = []
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i)
            if item.checkState() == QtCore.Qt.Checked:
                selected_role_ids.append(item.data(Qt.UserRole))
        try:
            self.db.update_roles_for_department(self.current_dept_id, selected_role_ids)
            self.toast.show_message("✔ ارتباط نقش‌ها و واحد با موفقیت ذخیره شد.", "success")
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
        

# کل کلاس UserManager را با این نسخه نهایی و استاندارد جایگزین کنید

class UserManager(QtWidgets.QDialog):
    def __init__(self, db: DB, all_roles: list, current_user: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.all_roles_cache = all_roles
        self.current_user = current_user
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id_for_roles = None

        self.setWindowTitle('مرکز مدیریت کاربران و دسترسی‌ها')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(850, 600)

        main_layout = QtWidgets.QVBoxLayout(self)
        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setStyleSheet("QTabBar::tab { min-width: 200px; padding: 10px; }")
        main_layout.addWidget(self.tabs)

        user_management_page = self._create_user_management_tab()
        role_assignment_page = self._create_role_assignment_tab()

        self.tabs.addTab(user_management_page, "مدیریت کاربران")
        self.tabs.addTab(role_assignment_page, "تخصیص نقش به واحد")
        
        self._load_table()
        self._load_departments_for_roles_tab()
        self._load_all_roles_for_roles_tab()

    def _create_user_management_tab(self):
        page = QtWidgets.QWidget()
        v_layout = QtWidgets.QVBoxLayout(page)
        self.tbl_users = QtWidgets.QTableWidget()
        self.tbl_users.setColumnCount(3); self.tbl_users.setHorizontalHeaderLabels(['نام کاربری', 'نقش', 'واحد سازمانی']); self.tbl_users.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch); self.tbl_users.verticalHeader().hide(); self.tbl_users.setEditTriggers(QtWidgets.QTableWidget.NoEditTriggers); self.tbl_users.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows); self.tbl_users.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        v_layout.addWidget(self.tbl_users, 1)
        form = QtWidgets.QFormLayout()
        self.e_user = QtWidgets.QLineEdit()
        self.e_pass = QtWidgets.QLineEdit(); self.e_pass.setEchoMode(self.e_pass.Password)
        self.c_dept_users = QtWidgets.QComboBox()
        self.c_role_users = QtWidgets.QComboBox()
        form.addRow('نام کاربری:', self.e_user); form.addRow('رمز عبور:', self.e_pass); form.addRow('واحد سازمانی:', self.c_dept_users); form.addRow('نقش (*وابسته به واحد):', self.c_role_users)
        v_layout.addLayout(form)
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("save"), " ایجاد / به‌روزرسانی"); btn_add.setProperty("class", "primary")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف کاربر"); btn_del.setProperty("class", "danger")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), " پاک کردن فرم")
        btn_layout.addWidget(btn_add); btn_layout.addWidget(btn_del); btn_layout.addStretch(); btn_layout.addWidget(btn_clear)
        v_layout.addLayout(btn_layout)
        btn_add.clicked.connect(self._add_or_update); btn_del.clicked.connect(self._delete_user); btn_clear.clicked.connect(self._reset_fields)
        self.tbl_users.itemClicked.connect(self._populate_fields_for_edit)
        self.c_dept_users.currentIndexChanged.connect(self._update_roles_for_department)
        self._populate_departments_combo()
        return page

    def _create_role_assignment_tab(self):
        page = QtWidgets.QWidget()
        main_layout = QtWidgets.QHBoxLayout(page)
        main_layout.setSpacing(15)
        
        left_panel = QtWidgets.QGroupBox("۱. واحد سازمانی را انتخاب کنید")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.dept_list_roles = QtWidgets.QListWidget()
        self.dept_list_roles.itemSelectionChanged.connect(self._on_department_selected_for_roles_tab)
        left_layout.addWidget(self.dept_list_roles)
        
        right_panel = QtWidgets.QGroupBox("۲. نقش‌های مجاز را مشخص کنید")
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        self.roles_list_widget = QtWidgets.QListWidget()
        self.roles_list_widget.setSpacing(5)
        right_layout.addWidget(self.roles_list_widget, 1) # ضریب کشش 1
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات برای این واحد")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_role_assignments)
        right_layout.addWidget(btn_save)

        main_layout.addWidget(left_panel, 1)
        main_layout.addWidget(right_panel, 2)
        
        return page

    def _load_table(self):
        self.tbl_users.setSortingEnabled(False); rows = self.db.get_all_users_detailed(); self.tbl_users.setRowCount(len(rows))
        for r, row in enumerate(rows):
            name_item = QtWidgets.QTableWidgetItem(row['username']); name_item.setData(Qt.UserRole, row); self.tbl_users.setItem(r, 0, name_item)
            self.tbl_users.setItem(r, 1, QtWidgets.QTableWidgetItem(row.get('role_name') or 'بدون نقش')); self.tbl_users.setItem(r, 2, QtWidgets.QTableWidgetItem(row.get('department_name') or '---'))
        self.tbl_users.resizeColumnsToContents(); self.tbl_users.setSortingEnabled(True)
    def _populate_departments_combo(self):
        self.c_dept_users.blockSignals(True); self.c_dept_users.clear(); self.c_dept_users.addItem("--- انتخاب کنید ---", None)
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']): self.c_dept_users.addItem(dept['name'], dept['id'])
        self.c_dept_users.blockSignals(False)
    def _update_roles_for_department(self):
        self.c_role_users.clear(); dept_id = self.c_dept_users.currentData()
        if dept_id is None: self.c_role_users.addItem("ابتدا یک واحد انتخاب کنید", None); self.c_role_users.setEnabled(False); return
        self.c_role_users.setEnabled(True); roles_for_dept = self.db.get_roles_for_department(dept_id)
        if not roles_for_dept: self.c_role_users.addItem("نقشی برای این واحد تعریف نشده", None); self.c_role_users.setEnabled(False)
        else:
            self.c_role_users.addItem("--- انتخاب کنید ---", None)
            for role in roles_for_dept: self.c_role_users.addItem(role['name'], role['id'])
    def _populate_fields_for_edit(self, item: QtWidgets.QTableWidgetItem):
        user_data = self.tbl_users.item(item.row(), 0).data(Qt.UserRole);
        if not user_data: return
        self.e_user.setText(user_data['username']); self.e_user.setReadOnly(True); self.e_pass.clear(); self.e_pass.setPlaceholderText("برای تغییر رمز، رمز جدید را وارد کنید")
        dept_id = user_data.get('department_id'); dept_index = self.c_dept_users.findData(dept_id) if dept_id else 0
        self.c_dept_users.setCurrentIndex(dept_index if dept_index != -1 else 0)
        QtCore.QTimer.singleShot(50, lambda: self._select_role_after_dept_update(user_data.get('role_id')))
    def _select_role_after_dept_update(self, role_id_to_select):
        role_index = self.c_role_users.findData(role_id_to_select); self.c_role_users.setCurrentIndex(role_index if role_index != -1 else 0)
    def _add_or_update(self):
        uname = self.e_user.text().strip(); pwd = self.e_pass.text(); role_id = self.c_role_users.currentData(); dept_id = self.c_dept_users.currentData()
        if not uname: QtWidgets.QMessageBox.warning(self, 'خطا', 'نام کاربری نمی‌تواند خالی باشد.'); return
        is_new_user = not self.e_user.isReadOnly()
        try:
            self.db.add_or_update_user(uname, pwd, role_id, dept_id, is_new_user)
            if self.toast: self.toast.show_message(f"✔ کاربر '{uname}' با موفقیت ذخیره شد.", "success")
            self._load_table(); self._reset_fields()
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام ذخیره کاربر: {e}")
    def _delete_user(self):
        if self.e_user.isReadOnly() == False or not self.e_user.text():
             if self.toast: self.toast.show_message("لطفاً ابتدا یک کاربر را از جدول انتخاب کنید.", "warning"); return
        username_to_delete = self.e_user.text()
        if username_to_delete.lower() == self.current_user.lower(): QtWidgets.QMessageBox.critical(self, "عملیات غیرمجاز", "شما نمی‌توانید حساب کاربری خودتان را حذف کنید."); return
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف دائمی کاربر '{username_to_delete}' مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_user(username_to_delete)
                if self.toast: self.toast.show_message(f"کاربر '{username_to_delete}' با موفقیت حذف شد.", "success")
                self._load_table(); self._reset_fields()
            except ValueError as e: QtWidgets.QMessageBox.critical(self, "عملیات غیرمجاز", str(e))
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام حذف کاربر: {e}")
    def _reset_fields(self):
        self.e_user.clear(); self.e_user.setReadOnly(False); self.e_user.setFocus(); self.e_pass.clear(); self.e_pass.setPlaceholderText(""); self.c_dept_users.setCurrentIndex(0); self.tbl_users.clearSelection()
    def _load_departments_for_roles_tab(self):
        self.dept_list_roles.clear()
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            item = QtWidgets.QListWidgetItem(dept['name']); item.setData(Qt.UserRole, dept['id']); self.dept_list_roles.addItem(item)
    def _load_all_roles_for_roles_tab(self):
        self.roles_list_widget.clear()
        all_roles = self.db.get_all_roles()
        for role in all_roles:
            item = QtWidgets.QListWidgetItem(role['name']); item.setData(Qt.UserRole, role['id'])
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable); item.setCheckState(QtCore.Qt.Unchecked); self.roles_list_widget.addItem(item)
        self.roles_list_widget.setEnabled(False)
    def _on_department_selected_for_roles_tab(self):
        selected = self.dept_list_roles.selectedItems()
        if not selected: self.current_dept_id_for_roles = None; self.roles_list_widget.setEnabled(False); return
        self.current_dept_id_for_roles = selected[0].data(Qt.UserRole); self.roles_list_widget.setEnabled(True)
        self.roles_list_widget.parentWidget().setTitle(f"۲. نقش‌های مجاز برای «{selected[0].text()}»")
        assigned_role_ids = self.db.get_role_ids_for_department(self.current_dept_id_for_roles)
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i); role_id = item.data(Qt.UserRole); item.setCheckState(QtCore.Qt.Checked if role_id in assigned_role_ids else QtCore.Qt.Unchecked)
    def _save_role_assignments(self):
        if self.current_dept_id_for_roles is None: self.toast.show_message("لطفاً ابتدا یک واحد سازمانی را انتخاب کنید.", "warning"); return
        selected_role_ids = []
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i)
            if item.checkState() == QtCore.Qt.Checked: selected_role_ids.append(item.data(Qt.UserRole))
        try:
            self.db.update_roles_for_department(self.current_dept_id_for_roles, selected_role_ids)
            self.toast.show_message("✔ ارتباط نقش‌ها و واحد با موفقیت ذخیره شد.", "success")
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
        
        #
# این کلاس را به طور کامل با نسخه قبلی DepartmentNode جایگزین کنید
#
class DepartmentNode(QtWidgets.QGraphicsRectItem):
    """یک گره گرافیکی حرفه‌ای برای نمایش یک واحد سازمانی در چارت."""
    def __init__(self, department_data, dialog):
        super().__init__()
        self.dialog = dialog
        self.data = department_data
        self.setRect(0, 0, 200, 70)
        
        # --- ارتقاء گرافیکی ---
        self.setPen(QtGui.QPen(QtGui.QColor("#adb5bd"), 1.5))
        gradient = QtGui.QLinearGradient(self.rect().topLeft(), self.rect().bottomLeft())
        gradient.setColorAt(0, QtGui.QColor("#ffffff"))
        gradient.setColorAt(1, QtGui.QColor("#f1f3f5"))
        self.setBrush(QtGui.QBrush(gradient))
        
        shadow = QtWidgets.QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setColor(QtGui.QColor(0, 0, 0, 50))
        shadow.setOffset(2, 2)
        self.setGraphicsEffect(shadow)
        
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable)
        self.setFlag(QtWidgets.QGraphicsItem.ItemSendsScenePositionChanges)

        self.name_text = QtWidgets.QGraphicsTextItem(self.data['name'], self)
        font = QFont(FONT_FAMILY, 11, QFont.Bold); self.name_text.setFont(font)
        self.name_text.setDefaultTextColor(QtGui.QColor("#212529")); self.name_text.setPos(10, 10)

        manager_name = self.data.get('manager_name') or "---"
        self.manager_text = QtWidgets.QGraphicsTextItem(f"مدیر: {manager_name}", self)
        font.setBold(False); font.setPointSize(9); self.manager_text.setFont(font)
        self.manager_text.setDefaultTextColor(QtGui.QColor("#495057")); self.manager_text.setPos(10, 38)

    def itemChange(self, change, value):
        if change == QtWidgets.QGraphicsItem.ItemPositionHasChanged:
            self.dialog._draw_connections()
        return super().itemChange(change, value)

    def mouseDoubleClickEvent(self, event):
        try:
            if self.dialog and hasattr(self.dialog, 'tree') and self.dialog.tree:
                self.dialog.tree.clearSelection()
                item_in_tree = self.dialog.item_map.get(self.data['id'])
                if item_in_tree:
                    item_in_tree.setSelected(True)
                    self.dialog.tree.scrollToItem(item_in_tree)
                    self.dialog._on_item_selected(item_in_tree)
        except RuntimeError:
            print("INFO: Caught a RuntimeError on a deleted widget, ignoring.")
        super().mouseDoubleClickEvent(event)
        
    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        new_pos = self.scenePos()
        self.dialog.db.update_department_position(self.data['id'], new_pos.x(), new_pos.y())
        
        colliding_items = self.collidingItems()
        target_node = None
        for item in colliding_items:
            if isinstance(item, DepartmentNode) and item is not self:
                target_node = item
                break
        
        if target_node:
            self.dialog._handle_drop(self, target_node)
        else:
            self.dialog._draw_connections()

#
# بلوک ۲: کلاس اصلی مدیریت چارت سازمانی
#
class OrgChartManagerDialog(QtWidgets.QDialog):
    """پنجره مدیریت چارت سازمانی با رابط کاربری گرافیکی، چیدمان هوشمند و Drag & Drop."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id = None

        self.setWindowTitle("مدیریت چارت سازمانی (نسخه گرافیکی پیشرفته)")
        self.setMinimumSize(1200, 800)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        graphics_panel = QtWidgets.QWidget(); graphics_layout = QtWidgets.QVBoxLayout(graphics_panel)
        graphics_layout.setContentsMargins(0,0,0,0)
        self.scene = QtWidgets.QGraphicsScene(); self.scene.setBackgroundBrush(QtGui.QBrush(QtGui.QColor("#f8f9fa")))
        self.view = QtWidgets.QGraphicsView(self.scene); self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        
        graphics_toolbar = QtWidgets.QHBoxLayout()
        btn_reset_layout = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), "بازنشانی چیدمان")
        btn_reset_layout.setToolTip("تمام تغییرات دستی در چیدمان را لغو کرده و چارت را به صورت خودکار مرتب می‌کند.")
        btn_reset_layout.clicked.connect(self._reset_layout)
        graphics_toolbar.addStretch()
        graphics_toolbar.addWidget(btn_reset_layout)
        graphics_layout.addLayout(graphics_toolbar)
        graphics_layout.addWidget(self.view)
        splitter.addWidget(graphics_panel)

        details_panel = QtWidgets.QWidget(); details_layout = QtWidgets.QVBoxLayout(details_panel)
        self.details_group = QtWidgets.QGroupBox("جزئیات واحد"); self.details_group.setDisabled(True)
        details_form = QtWidgets.QFormLayout(self.details_group)
        self.dept_name_edit = QtWidgets.QLineEdit()
        self.manager_combo = QtWidgets.QComboBox()
        self.user_list_label = QtWidgets.QLabel("<b>کارمندان این واحد:</b>")
        self.user_list_widget = QtWidgets.QListWidget()
        self.user_list_widget.setStyleSheet("border: 1px solid #dfe4ea;")
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات"); btn_save.clicked.connect(self._save_details)
        details_form.addRow("نام واحد:", self.dept_name_edit); details_form.addRow("مدیر واحد:", self.manager_combo)
        details_form.addRow(self.user_list_label); details_form.addRow(self.user_list_widget)
        details_form.addRow(btn_save)
        details_layout.addWidget(self.details_group, 1)

        tree_group = QtWidgets.QGroupBox("ساختار درختی (برای افزودن/حذف راست‌کلیک کنید)")
        tree_layout = QtWidgets.QVBoxLayout(tree_group)
        self.tree = QtWidgets.QTreeWidget(); self.tree.setHeaderHidden(True)
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self._show_context_menu)
        self.tree.itemClicked.connect(self._on_item_selected)
        tree_layout.addWidget(self.tree)
        
        toolbar_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن واحد")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف واحد")
        btn_add.clicked.connect(self._add_department_action)
        btn_del.clicked.connect(self._delete_department_action)
        toolbar_layout.addWidget(btn_add); toolbar_layout.addWidget(btn_del); toolbar_layout.addStretch()
        tree_layout.addLayout(toolbar_layout)
        details_layout.addWidget(tree_group, 2)
        
        splitter.addWidget(details_panel)
        splitter.setSizes([800, 400])
        self._load_chart_data()
        self._load_users_for_combo()

    def _load_chart_data(self):
        self.scene.clear(); self.tree.clear(); self.nodes = {}; self.item_map = {}
        departments = self.db.get_departments_tree()
        self.dept_map = {d['id']: d for d in departments}

        self.child_map = {d['id']: [] for d in departments}
        root_ids = []
        for dept in departments:
            parent_id = dept.get('parent_id')
            if parent_id in self.child_map: self.child_map[parent_id].append(dept['id'])
            else: root_ids.append(dept['id'])

        for dept in departments:
            node = DepartmentNode(dept, self); self.nodes[dept['id']] = node; self.scene.addItem(node)
            item = QtWidgets.QTreeWidgetItem([dept['name']]); item.setData(0, Qt.UserRole, dept); self.item_map[dept['id']] = item

        for dept_id, item in self.item_map.items():
            parent_id = self.dept_map.get(dept_id, {}).get('parent_id')
            if parent_id and parent_id in self.item_map: self.item_map[parent_id].addChild(item)
            else: self.tree.addTopLevelItem(item)
        
        self.tree.expandAll()
        self._auto_layout_and_draw()

    def _auto_layout_and_draw(self):
        root_ids = [dept_id for dept_id, dept in self.dept_map.items() if dept.get('parent_id') is None]
        self._auto_layout_recursive(root_ids, 0, 0)
        self._draw_connections()
        self.view.centerOn(0,0)

    def _auto_layout_recursive(self, node_ids, x, y, x_spacing=220, y_spacing=120):
        subtree_widths = {}
        def calculate_width(d_id):
            if d_id in subtree_widths: return subtree_widths[d_id]
            children = self.child_map.get(d_id, [])
            width = sum(calculate_width(c_id) for c_id in children) if children else x_spacing
            subtree_widths[d_id] = width
            return width

        total_width = sum(calculate_width(d_id) for d_id in node_ids)
        current_x = x - total_width / 2

        for d_id in node_ids:
            subtree_width = subtree_widths[d_id]
            node_x = current_x + subtree_width / 2
            
            # فقط گره‌های بدون موقعیت دستی را جابجا می‌کند
            if d_id in self.nodes:
                if self.dept_map[d_id].get('pos_x') is not None and self.dept_map[d_id].get('pos_y') is not None:
                    self.nodes[d_id].setPos(self.dept_map[d_id]['pos_x'], self.dept_map[d_id]['pos_y'])
                else:
                    self.nodes[d_id].setPos(node_x - self.nodes[d_id].rect().width()/2, y)
            
            children = self.child_map.get(d_id, [])
            if children:
                self._auto_layout_recursive(children, node_x, y + y_spacing)
            
            current_x += subtree_width

    def _draw_connections(self):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsPathItem):
                self.scene.removeItem(item)

        pen = QtGui.QPen(QtGui.QColor("#6c757d"), 1.5, Qt.DashLine)
        
        for dept_id, node in self.nodes.items():
            parent_id = self.dept_map[dept_id].get('parent_id')
            if parent_id and parent_id in self.nodes:
                parent_node = self.nodes[parent_id]
                
                p1 = parent_node.scenePos() + QtCore.QPointF(parent_node.rect().width()/2, parent_node.rect().height())
                p4 = node.scenePos() + QtCore.QPointF(node.rect().width()/2, 0)
                
                p2 = QtCore.QPointF(p1.x(), (p1.y() + p4.y()) / 2)
                p3 = QtCore.QPointF(p4.x(), (p1.y() + p4.y()) / 2)

                path = QtGui.QPainterPath(); path.moveTo(p1); path.lineTo(p2); path.lineTo(p3); path.lineTo(p4)
                line = self.scene.addPath(path, pen); line.setZValue(-1)
    
    def _load_users_for_combo(self):
        self.manager_combo.clear(); self.manager_combo.addItem("--- هیچکس ---", None)
        users = self.db.get_all_users_brief()
        for user in users: self.manager_combo.addItem(user['username'], user['id'])

    def _on_item_selected(self, item):
        dept_data = item.data(0, Qt.UserRole)
        if not dept_data: self._clear_fields(); return
        
        self.details_group.setDisabled(False); self.current_dept_id = dept_data['id']; self.dept_name_edit.setText(dept_data['name'])
        
        for node in self.nodes.values(): node.setSelected(False)
        if self.current_dept_id in self.nodes: self.nodes[self.current_dept_id].setSelected(True)

        manager_id = dept_data.get('manager_user_id')
        index = self.manager_combo.findData(manager_id) if manager_id is not None else 0
        self.manager_combo.setCurrentIndex(index if index != -1 else 0)
        
        self.user_list_widget.clear()
        users_in_dept = self.db.get_users_in_department(self.current_dept_id)
        if users_in_dept: self.user_list_widget.addItems([u['username'] for u in users_in_dept])
        else: self.user_list_widget.addItem("هیچ کارمندی در این واحد نیست.")

    def _show_context_menu(self, pos):
        menu = QtWidgets.QMenu(self); add_action = menu.addAction("افزودن زیرمجموعه جدید"); del_action = menu.addAction("حذف واحد انتخاب شده")
        action = menu.exec_(self.tree.mapToGlobal(pos)); selected_item = self.tree.itemAt(pos)
        item_id = selected_item.data(0, Qt.UserRole)['id'] if selected_item else None
        if action == add_action: self._add_department(item_id)
        elif action == del_action and item_id: self._delete_department(item_id, selected_item.text(0))

    def _add_department_action(self):
        selected_item = self.tree.currentItem()
        parent_id = selected_item.data(0, Qt.UserRole)['id'] if selected_item else None
        self._add_department(parent_id)

    def _delete_department_action(self):
        selected_item = self.tree.currentItem()
        if not selected_item:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک واحد را برای حذف انتخاب کنید.", "warning")
            return
        dept_id = selected_item.data(0, Qt.UserRole)['id']; dept_name = selected_item.text(0)
        self._delete_department(dept_id, dept_name)

    def _add_department(self, parent_id):
        name, ok = QtWidgets.QInputDialog.getText(self, "واحد جدید", "نام واحد سازمانی جدید را وارد کنید:")
        if ok and name:
            try:
                self.db.add_department(name, parent_id); self._load_chart_data()
            except psycopg2.errors.UniqueViolation: QtWidgets.QMessageBox.critical(self, "خطا", "واحدی با این نام از قبل وجود دارد.")
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطای پیش‌بینی نشده:\n{e}")

    def _delete_department(self, dept_id, dept_name):
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف واحد «{dept_name}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_department(dept_id); self._load_chart_data(); self._clear_fields()
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"امکان حذف این واحد وجود ندارد.\nاحتمالاً کاربرانی به آن اختصاص یافته‌اند یا دارای زیرمجموعه است.\n{e}")

# در کلاس OrgChartManagerDialog، این متد را جایگزین کنید

    def _save_details(self):
        if self.current_dept_id is None:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک واحد را از درخت انتخاب کنید.", "warning")
            return
        
        name = self.dept_name_edit.text().strip()
        manager_id = self.manager_combo.currentData()
        
        # --- *** اصلاح کلیدی: پیدا کردن والد از طریق داده‌های ذخیره شده به جای آیتم فعلی *** ---
        # به جای self.tree.currentItem() از self.dept_map که قابل اطمینان‌تر است استفاده می‌کنیم
        current_dept_data = self.dept_map.get(self.current_dept_id)
        parent_id = current_dept_data.get('parent_id') if current_dept_data else None
        # --- ************************************************************************** ---
        
        if name:
            try:
                self.db.update_department(self.current_dept_id, name, parent_id, manager_id)
                if self.toast: self.toast.show_message("✔ تغییرات با موفقیت ذخیره شد.", "success")
                self._load_chart_data() # رفرش کردن کل چارت
            except psycopg2.errors.UniqueViolation:
                QtWidgets.QMessageBox.critical(self, "خطا", "واحدی با این نام از قبل وجود دارد.")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطای پیش‌بینی نشده:\n{e}")
                                
    def _clear_fields(self):
        self.current_dept_id = None; self.dept_name_edit.clear(); self.manager_combo.setCurrentIndex(0)
        self.details_group.setDisabled(True); self.tree.clearSelection(); self.user_list_widget.clear()

    def _handle_drop(self, dragged_node, target_node):
        dragged_id = dragged_node.data['id']
        new_parent_id = target_node.data['id']

        temp_id = new_parent_id
        while temp_id is not None:
            if temp_id == dragged_id:
                QtWidgets.QMessageBox.warning(self, "عملیات غیرمجاز", "امکان انتقال یک واحد به زیرمجموعه خودش وجود ندارد.")
                self._auto_layout_and_draw(); return
            temp_id = self.dept_map.get(temp_id, {}).get('parent_id')
        
        try:
            self.db.update_department_parent(dragged_id, new_parent_id)
            if self.toast: self.toast.show_message("ساختار با موفقیت به‌روزرسانی شد.", "success")
            self._load_chart_data()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در به‌روزرسانی ساختار:\n{e}")
            self._auto_layout_and_draw()

    def _reset_layout(self):
        """تمام موقعیت‌های دستی را پاک کرده و چارت را دوباره می‌چیند."""
        reply = QtWidgets.QMessageBox.question(self, "تایید بازنشانی", "آیا می‌خواهید تمام تغییرات چیدمان به حالت خودکار بازگردد؟")
        if reply == QtWidgets.QMessageBox.Yes:
            self.db.reset_all_department_positions()
            self._load_chart_data()
            
        
import logging
from typing import Optional, List, Dict, Any,Tuple
from PyQt5.QtGui import QFont, QTextOption

from logging.handlers import RotatingFileHandler

logger = logging.getLogger(__name__)

_PRODUCTION_LOGGER = None

def get_production_logger() -> logging.Logger:
    """Return a rotating logger dedicated to the production page."""
    global _PRODUCTION_LOGGER
    log_dir = BASE_DIR / "logs"
    try:
        log_dir.mkdir(exist_ok=True)
    except Exception:
        logger.exception("Failed to create log directory at %s", log_dir)
        log_dir = BASE_DIR
    log_path = log_dir / "production.log"

    prod_logger = _PRODUCTION_LOGGER or logging.getLogger("inventory.production")
    if not prod_logger.handlers:
        handler = RotatingFileHandler(log_path, maxBytes=1_000_000, backupCount=5, encoding="utf-8")
        handler.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s"))
        prod_logger.addHandler(handler)
        prod_logger.setLevel(logging.INFO)
    _PRODUCTION_LOGGER = prod_logger
    return prod_logger

# [CLASS: UI.ReplenishmentDialog] — نسخه کامل، بهبود یافته، همراه با Picker درختی و پیوست‌ها
from typing import Optional, List, Dict, Any, Tuple
from functools import partial
from PyQt5 import QtWidgets, QtGui, QtCore
from PyQt5.QtCore import Qt, QUrl
from PyQt5.QtGui import QFont, QTextOption
import os

# [CLASS: UI._ItemPickerDialog] — انتخاب کالا به‌صورت درختی با جست‌وجو و منع انتخاب مادر
from PyQt5 import QtWidgets, QtGui
from PyQt5.QtCore import Qt, QTimer

class _ItemPickerDialog(QtWidgets.QDialog):
    """دیالوگ انتخاب کالا (مادر/بسته‌بندی). فقط «فرزند» یا «کالای مستقلِ بدون فرزند» قابل انتخاب است."""
    def __init__(self, db: 'DB', parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("انتخاب کالا")
        self.resize(760, 560)

        v = QtWidgets.QVBoxLayout(self)
        srow = QtWidgets.QHBoxLayout()
        self.txt_search = QtWidgets.QLineEdit()
        self.txt_search.setPlaceholderText("جست‌وجو در نام یا SKU…")
        srow.addWidget(self.txt_search)
        v.addLayout(srow)

        self.tree = QtWidgets.QTreeWidget()
        self.tree.setHeaderLabels(["کالا", "ID"])
        self.tree.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.tree.setColumnHidden(1, True)
        v.addWidget(self.tree, 1)

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        v.addWidget(btns)
        btns.accepted.connect(self._accept_if_selectable)
        btns.rejected.connect(self.reject)
        self.tree.itemDoubleClicked.connect(lambda *_: self._accept_if_selectable())

        # ── داده‌ها
        pcol = self.db.get_parent_column() or 'parent_id'  # سازگار با پروژه‌ی فعلی که parent_id دارد. :contentReference[oaicite:0]{index=0}
        self._all = self.db.execute_query(
            f"SELECT id, name, unit_id, {pcol} AS parent_id FROM items ORDER BY COALESCE({pcol}, id), name",
            None
        ) or []
        # کدها برای فیلترِ SKU
        self._code_cols = self.db._get_existing_columns('items', ['sku', 'code', 'item_code', 'barcode', 'part_code'])
        self._codes = {}
        if self._code_cols:
            # یکبار تمام کدها را می‌خوانیم (ایمن و سریع برای فیلتر سمت کلاینت)
            coalesce = "COALESCE(" + ",".join(self._code_cols) + ")"
            rows = self.db.execute_query(f"SELECT id, {coalesce} AS code FROM items", None) or []
            self._codes = {int(r['id']): (r.get('code') or "") for r in rows}

        self._build_tree()
        # جست‌وجو با تاخیر کوچک (debounce)
        self._deb = QTimer(self); self._deb.setSingleShot(True); self._deb.setInterval(220)
        self._deb.timeout.connect(self._filter_now)
        self.txt_search.textChanged.connect(lambda _t: self._deb.start())

    def _build_tree(self):
        self.tree.clear()
        by_parent = {}
        for r in self._all:
            by_parent.setdefault(r.get('parent_id'), []).append(r)

        roots = by_parent.get(None, []) + by_parent.get('', []) + by_parent.get(0, [])
        for p in roots:
            has_children = len(by_parent.get(p['id'], [])) > 0
            pitem = QtWidgets.QTreeWidgetItem([p.get('name', ''), str(p['id'])])
            # اگر «مادرِ واقعی» باشد (فرزند دارد) ⇒ انتخاب‌ناپذیر
            if has_children:
                flags = pitem.flags()
                pitem.setFlags(flags & ~Qt.ItemIsSelectable)
                pitem.setForeground(0, QtGui.QBrush(QtGui.QColor("#6b7c93")))
            pitem.setData(0, Qt.UserRole, {'id': p['id'], 'is_parent': has_children})
            self.tree.addTopLevelItem(pitem)

            # بچه‌ها (بسته‌بندی‌ها) — قابل انتخاب
            for c in by_parent.get(p['id'], []):
                citem = QtWidgets.QTreeWidgetItem([c.get('name', ''), str(c['id'])])
                citem.setData(0, Qt.UserRole, {'id': c['id'], 'is_parent': False})
                pitem.addChild(citem)
        self.tree.expandAll()

    def _filter_now(self):
        text = (self.txt_search.text() or "").strip().lower()
        it = QtWidgets.QTreeWidgetItemIterator(self.tree)
        while it.value():
            item = it.value()
            data = item.data(0, Qt.UserRole) or {}
            iid = data.get('id')
            name = (item.text(0) or "").lower()
            code = (self._codes.get(int(iid)) or "").lower() if iid else ""
            match = (not text) or (text in name) or code.startswith(text)
            item.setHidden(not match)
            it += 1

    def _accept_if_selectable(self):
        itms = self.tree.selectedItems()
        if not itms:
            return
        data = itms[0].data(0, Qt.UserRole) or {}
        if data.get('is_parent'):
            QtWidgets.QMessageBox.warning(self, "انتخاب نامعتبر", "محصول مادر قابل انتخاب نیست؛ یکی از بسته‌بندی‌ها را انتخاب کن.")
            return
        self.accept()

    def selected_item_id(self) -> int | None:
        itms = self.tree.selectedItems()
        if not itms:
            return None
        data = itms[0].data(0, Qt.UserRole) or {}
        return int(data['id']) if data.get('id') else None

class ReplenishmentDialog(QtWidgets.QDialog):
    """
    پنجره‌ی ادغامی «پیشنهادهای هوشمند تأمین» + «فرم درخواست خرید چندردیفی».
    نکات کلیدی:
      - هیچ ردیف پیش‌فرضی ایجاد نمی‌شود؛ کاربر خودش ردیف می‌افزاید.
      - ستون SKU = کد واردشده‌ی کاربر (child). اگر به مادر اشاره کند، پیام می‌دهیم.
      - نام کالا = «نام مادر / نام بسته‌بندی»؛ انتخاب از طریق Picker درختی با جست‌وجو نیز ممکن است.
      - پیوست‌های هر ردیف: آپلود نامحدود (مجموع ≤ 2MB) + امکان باز کردن فایل.
      - فوریت «برای هر ردیف» ثبت می‌شود. بازه‌های زمانی فوریت در DB ذخیره خطی می‌شود (ستون‌های موجود: urgency/specs/attachments).
      - اندازه و فیلدهای متنی بزرگ و WRAP شده‌اند.
    """
    URGENCY_CHOICES = ["آنی", "فوریت 1", "فوریت 2", "فوریت 3", "عادی"]
    REASON_CHOICES = [
        ("WAREHOUSE_SHORTAGE", "کمبود موجودی نسبت به درخواست"),
        ("REORDER_POINT",      "رسیدن به نقطه سفارش"),
        ("MANUAL_URGENT",      "درخواست فوری دستی"),
    ]
    
    
# BEGIN REWRITE: UI.ReplenishmentDialog.__init__
    def __init__(self, db: 'DB', user_id: int, parent=None, preselected_item_id: Optional[int] = None):
        super().__init__(parent)
        self.db, self.user_id = db, user_id

        # استایل و عنوان
        self.setStyleSheet(self.styleSheet() + """
            QPushButton[class="primary"] {
                background:#1677ff; color:white; border:1px solid #1677ff; border-radius:6px; padding:6px 12px;
            }
            QPushButton[class="primary"]:hover { background:#3b8cff; }
            QToolButton { padding:0 8px; }
            QLineEdit, QTextEdit, QComboBox, QToolButton, QPushButton { font-size: 10.5pt; }
            QTableWidget::item { padding:4px; }
        """)
        self.setWindowTitle("مرکز هوشمند تأمین کالا")
        try:
            self.setFont(QFont(FONT_FAMILY, FONT_SIZE))  # type: ignore[name-defined]
        except Exception:
            self.setFont(QFont("Tahoma", 10))
        self.setMinimumSize(1350, 900)

        # کش واحدها
        try:
            self._units: List[Dict[str, Any]] = self.db.execute_query(
                "SELECT id, name FROM units ORDER BY name", None
            ) or []
        except Exception:
            self._units = []
        self._units_by_id = {u['id']: u['name'] for u in self._units}

        # وضعیت داخلی فرم پایین
        self._row_item_ids: Dict[int, int] = {}                      # row -> child item_id
        self._row_attachments: Dict[int, List[Tuple[str,int]]] = {}  # row -> [(path,size),...]
        self._current_pr_id: Optional[int] = None                    # بعد از اولین ثبت مقدار می‌گیرد

        # لایهٔ ریشه
        root = QtWidgets.QVBoxLayout(self)
        root.setContentsMargins(12, 12, 12, 12)
        root.setSpacing(8)

        # هدر
        hdr = QtWidgets.QHBoxLayout()
        self.auto_open_tracking_after_submit = False

        # اکشن منو (اگر منوبار در دسترس بود)
        try:
            act = QtWidgets.QAction("پیگیری درخواست‌ها (PR)", self)
            act.triggered.connect(self._open_my_purchase_requests_from_dialog)
            if hasattr(self, "menuBar"):
                self.menuBar().addAction(act)
        except Exception:
            pass

        # دکمه‌ی هدر: پیگیری PR
        btn_pr_center = QtWidgets.QPushButton("پیگیری درخواست‌ها (PR)")
        btn_pr_center.setProperty("class", "primary")
        btn_pr_center.clicked.connect(self._open_my_purchase_requests_from_dialog)
        hdr.addWidget(btn_pr_center)

        hdr.addStretch(1)
        root.addLayout(hdr)

        # تب‌ها
        self.tabs = QtWidgets.QTabWidget()
        root.addWidget(self.tabs, 1)

        # تب «فرم درخواست خرید»
        self._build_form_tab()

        # تب «پیشنهادهای هوشمند» (نمایش RP)
        self._build_smart_tab()

        # ⛳️ اتصال دکمهٔ «ثبت و ارسال…» فرم به متد Stage 2
        # تلاش می‌کنیم هرکدام از نام‌های محتمل دکمه پیدا شد، همان را وصل کنیم.
        submit_btn = None
        for _name in [
            "btn_submit", "btn_submit_and_send", "btn_register_and_send",
            "btn_register", "btn_send_to_manager", "btn_save_and_submit"
        ]:
            b = getattr(self, _name, None)
            if isinstance(b, QtWidgets.QAbstractButton):
                submit_btn = b
                break
        if submit_btn and not getattr(submit_btn, "_wired_submit", False):
            submit_btn.clicked.connect(self._submit_pr_form_and_send)
            submit_btn._wired_submit = True  # جلوگیری از چندبار وصل‌شدن تصادفی

        # شورتکات‌های کیبورد برای ثبت (اختیاری)
        try:
            from PyQt5 import QtGui
            QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Return"), self,
                                activated=self._submit_pr_form_and_send)
            QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Enter"), self,
                                activated=self._submit_pr_form_and_send)
        except Exception:
            pass

        # انتخاب اولیهٔ کالا (اختیاری)
        if preselected_item_id:
            try:
                self._preselect_item(preselected_item_id)
            except Exception:
                pass
    # END REWRITE: UI.ReplenishmentDialog.__init__
    
    # BEGIN ADD: UI.ReplenishmentDialog._calc_group_attachments_bytes
    def _calc_group_attachments_bytes(self) -> int:
        """جمع اندازهٔ همهٔ پیوست‌های فرم (همهٔ ردیف‌ها)."""
        total = 0
        try:
            for _, lst in (self._row_attachments or {}).items():
                for _p, s in lst:
                    try: total += int(s)
                    except Exception: pass
        except Exception:
            return 0
        return total
    # END ADD: UI.ReplenishmentDialog._calc_group_attachments_bytes
    
    # BEGIN ADD: UI.ReplenishmentDialog._clear_row_error
    def _clear_row_error(self, row_idx: int):
        """استایل خطا و پیام راهنمای ردیف را پاک می‌کند."""
        try:
            from PyQt5 import QtWidgets
            cols = [2, 3, 4, 5, 6, 7]  # specs, qty, unit, urgency, reason, note
            for c in cols:
                w = self.tbl_form.cellWidget(row_idx, c) if hasattr(self, "tbl_form") else None
                if w is None:
                    continue
                try:
                    w.setStyleSheet("")  # استایل پیش‌فرض
                    if hasattr(w, "setToolTip"):
                        w.setToolTip("")
                except Exception:
                    pass
        except Exception:
            pass
    # END ADD: UI.ReplenishmentDialog._clear_row_error

    # BEGIN ADD: UI.ReplenishmentDialog._mark_row_error
    def _mark_row_error(self, row_idx: int, message: str):
        """ردیف را با خط قرمز مشخص و پیام راهنما را تنظیم می‌کند."""
        try:
            from PyQt5 import QtWidgets
            # اول همه‌چیز را پاک کنیم
            self._clear_row_error(row_idx)
            # فیلدهای محتمل خطا را هایلایت می‌کنیم (کم‌خطر)
            cols = [2, 3, 4, 7]  # specs, qty, unit, note
            for c in cols:
                w = self.tbl_form.cellWidget(row_idx, c) if hasattr(self, "tbl_form") else None
                if w is None:
                    continue
                try:
                    w.setStyleSheet("border: 1px solid #e53935; border-radius:4px;")
                    if hasattr(w, "setToolTip"):
                        w.setToolTip(message.strip())
                except Exception:
                    pass
        except Exception:
            pass
    # END ADD: UI.ReplenishmentDialog._mark_row_error

    
        # BEGIN ADD: UI.ReplenishmentDialog._compute_form_signature
    def _compute_form_signature(self, lines, header_note: str = "", physical_no: str = "", dept_id=None) -> str:
        """
        یک امضای سبک از محتوای فرم می‌سازد تا ارسال تکراری ظرف ۳ دقیقه تشخیص داده شود.
        فقط فیلدهای معنادار را در نظر می‌گیرد؛ بایت‌های فایل‌ها را وارد نمی‌کند.
        """
        try:
            norm_lines = []
            for ln in (lines or []):
                norm_lines.append({
                    "item_id": int(ln.get("item_id")),
                    "quantity": float(ln.get("quantity") or ln.get("qty") or 0),
                    "unit_id": ln.get("unit_id") if ln.get("unit_id") not in (None, "", 0, "0") else None,
                    "urgency": (ln.get("urgency") or ln.get("urgency_suggested") or "").strip(),
                    "reason_code": (ln.get("reason_code") or "").strip(),
                    "note": (ln.get("note") or ln.get("notes") or "").strip(),
                    # فقط نام فایل‌ها برای امضا کافی است
                    "attachments": [
                        (a.get("filename") if isinstance(a, dict) else str(a[0]))
                        for a in (ln.get("attachments") or [])
                    ][:5]
                })
            payload = {
                "dept_id": (int(dept_id) if dept_id not in (None, "", 0, "0") else None),
                "physical_no": (physical_no or "").strip(),
                "header_note": (header_note or "").strip(),
                "lines": norm_lines
            }
            b = json.dumps(payload, ensure_ascii=False, sort_keys=True).encode("utf-8")
            return hashlib.sha1(b).hexdigest()
        except Exception:
            # اگر هر چیزی شد، یک امضای تصادفی برمی‌گردانیم که جلوی ارسال را نگیرد
            return f"fallback:{time.time()}"
    # END ADD: UI.ReplenishmentDialog._compute_form_signature

    def _get_selected_dept_id(self):
        """
        شناسه‌ی واحد انتخاب‌شده را به‌صورت int برمی‌گرداند؛
        اگر چیزی انتخاب نشده یا داده معتبر نیست، None می‌دهد.
        با هر دو نام قدیمی/جدید کمبو سازگار است.
        """
        import re

        # سازگاری با نام‌های قدیمی/جدید
        cb = getattr(self, "dept_req_combo", None) or getattr(self, "cmb_departments", None)
        if cb is None:
            return None

        idx = cb.currentIndex()
        if idx is None or idx < 0:
            return None

        # تلاش اول: داده‌ی خام آیتم
        try:
            data = cb.itemData(idx)
        except Exception:
            data = None

        # حالت معمول: userData مستقیماً شناسه است
        try:
            if data not in (None, "", "None"):
                return int(data)
        except Exception:
            pass

        # تلاش دوم: اگر userData تنظیم نشده/نامعتبر بود، از متن کمبو حدس نمی‌زنیم،
        # فقط اگر الگوی شفافِ «#123» وجود داشت، برداشت می‌کنیم (بدون تغییر رفتار بیرونی).
        try:
            txt = cb.currentText().strip()
            m = re.search(r"#(\d+)", txt)
            return int(m.group(1)) if m else None
        except Exception:
            return None

    
    # BEGIN REWRITE: UI.ReplenishmentDialog._set_submitting
    def _set_submitting(self, is_on: bool) -> None:
        """
        قفل/آزاد کردن کنترل‌های فرم هنگام ارسال.
        - رفتار بیرونی حفظ شده؛ فقط گاردهای خطا و بازگردانی مطمئن‌تر شده.
        - از یک دیکشنری داخلی برای حفظ وضعیت قبلی استفاده می‌کند تا دقیقاً همان حالت برگردد.
        """
        from PyQt5 import QtCore

        # لیست کنترل‌هایی که منطقی‌ست هنگام ارسال قفل شوند (هر کدام اگر وجود داشت)
        candidate_names = [
            "btn_submit",
            "btn_add", "btn_del",
            "dept_req_combo", "cmb_departments",
            "tbl_form",
            "txt_physical_no",
            "txt_header_note",
        ]

        # جای امن برای ذخیرهٔ وضعیت قبلی (فقط یک بار بساز)
        if not hasattr(self, "_submit_prev_enabled"):
            self._submit_prev_enabled = {}

        # روی هر کنترل، setEnabled را فقط اگر واقعاً وجود داشت صدا می‌زنیم
        for name in candidate_names:
            try:
                w = getattr(self, name, None)
                if w is None or not hasattr(w, "isEnabled") or not hasattr(w, "setEnabled"):
                    continue

                key = f"{id(w)}:{name}"
                if is_on:
                    # هنگام قفل‌کردن: وضعیت فعلی را ذخیره کن (اگر قبلاً نداشتیم)
                    if key not in self._submit_prev_enabled:
                        try:
                            self._submit_prev_enabled[key] = bool(w.isEnabled())
                        except Exception:
                            self._submit_prev_enabled[key] = True
                    # قفل
                    try:
                        w.setEnabled(False)
                    except Exception:
                        pass
                else:
                    # هنگام آزادکردن: اگر وضعیت قبلی را داریم، دقیقاً همان را برگردان
                    prev = self._submit_prev_enabled.get(key)
                    try:
                        if prev is None:
                            # اگر چیزی ذخیره نشده بود، پیش‌فرض فعال
                            w.setEnabled(True)
                        else:
                            w.setEnabled(bool(prev))
                    except Exception:
                        pass
            except Exception:
                # هیچ‌وقت crash نکن
                continue

        # کرسر انتظار فقط زمانی ست می‌شود که پنجرهٔ فعلی این متد را داشته باشد
        try:
            if is_on:
                self.setCursor(QtCore.Qt.WaitCursor)
            else:
                self.unsetCursor()
        except Exception:
            pass

        # وقتی ارسال تمام شد، وضعیت‌های ذخیره‌شده را پاک کن تا حافظه تمیز بماند
        if not is_on:
            try:
                self._submit_prev_enabled.clear()
            except Exception:
                self._submit_prev_enabled = {}
    # END REWRITE: UI.ReplenishmentDialog._set_submitting

# BEGIN REWRITE: UI.ReplenishmentDialog._open_my_purchase_requests_from_dialog
    def _open_my_purchase_requests_from_dialog(self):
        """باز کردن دیالوگ پیگیری PRها؛ قبلش اتصال DB را از حالت aborted خارج می‌کنیم."""
        from PyQt5 import QtWidgets
        try:
            try: self.db._reset_aborted_tx()
            except Exception: pass
            dlg = MyPurchaseRequestsDialog(self.db, self.user_id, self)
            dlg.exec_()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "هشدار", f"نمایش لیست PR ناموفق بود:\n{e}")
    # END REWRITE: UI.ReplenishmentDialog._open_my_purchase_requests_from_dialog

    # BEGIN ADD: MainWindow._open_pr_approvals_center (manager)
    def _open_pr_approvals_center(self):
        """مرکز تأیید PR مخصوص مدیر واحد را باز می‌کند (فقط از داخل پنل استاندارد قابل‌دسترسی می‌گذاریم)."""
        try:
            dlg = ApprovalsCenterDialog(self.db, self.user_id, self)
            dlg.exec_()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"باز کردن مرکز تأیید ناموفق بود:\n{e}")
    # END ADD: MainWindow._open_pr_approvals_center (manager)
    

    def _build_form_tab(self):
        page = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(page)

        # --- مشخصات کلی درخواست ---
        grp = QtWidgets.QGroupBox("مشخصات کلی درخواست")
        form = QtWidgets.QFormLayout(grp)
        form.setContentsMargins(10, 8, 10, 8)
        form.setSpacing(8)

        # 1) انتخاب واحد مقصد
        self.dept_req_combo = QtWidgets.QComboBox()
        self.dept_req_combo.setMinimumWidth(220)
        self.dept_req_combo.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        self.dept_req_combo.addItem("— انتخاب کنید —", None)
        form.addRow("درخواست برای واحد:", self.dept_req_combo)
        # سازگاری با کدهای قدیمی
        self.cmb_departments = self.dept_req_combo

        # 2) شماره درخواست فیزیکی (کاغذی)
        self.txt_physical_no = QtWidgets.QLineEdit()
        self.txt_physical_no.setPlaceholderText("مثال: PR 1401-001 (شماره کاغذی)")
        form.addRow("شماره درخواست فیزیکی:", self.txt_physical_no)

        v.addWidget(grp)

        # --- نوار ابزار ردیف‌ها ---
        bar = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton("افزودن ردیف")
        btn_add.clicked.connect(self._add_row)
        btn_del = QtWidgets.QPushButton("حذف ردیف")
        btn_del.clicked.connect(self._del_row)
        bar.addWidget(btn_add)
        bar.addWidget(btn_del)
        bar.addStretch(1)

        # دکمه‌ی ثبت و ارسال (فقط یک‌بار، مستقیم)
        self.btn_submit = QtWidgets.QPushButton("ثبت و ارسال برای تایید مدیرعامل")
        self.btn_submit.setObjectName("Primary")              # حفظ نام قدیمی برای سازگاری
        self.btn_submit.setProperty("class", "primary")       # استایل جدید
        if not getattr(self.btn_submit, "_wired_submit", False):
            self.btn_submit.clicked.connect(self._submit_pr_form_and_send)
            self.btn_submit._wired_submit = True
        bar.addWidget(self.btn_submit)

        v.addLayout(bar)

        # --- جدول ردیف‌ها ---
        headers = [
            "SKU", "نام کامل کالا (مادر/بسته‌بندی)", "مشخصات دقیق",
            "مقدار", "یکا", "فوریت ردیف", "نوع درخواست", "یادداشت", "فایل‌ها"
        ]
        self.tbl_form = QtWidgets.QTableWidget(0, len(headers))
        self.tbl_form.setHorizontalHeaderLabels(headers)
        self.tbl_form.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_form.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.tbl_form.horizontalHeader().setSectionResizeMode(7, QtWidgets.QHeaderView.Stretch)
        self.tbl_form.setAlternatingRowColors(True)
        self.tbl_form.verticalHeader().setDefaultSectionSize(72)
        self.tbl_form.verticalHeader().setMinimumSectionSize(64)
        self.tbl_form.setColumnWidth(0, 160)   # SKU
        self.tbl_form.setColumnWidth(8, 260)   # فایل‌ها
        v.addWidget(self.tbl_form, 1)

        # پر کردن کمبو واحدها (اولین بار)
        try:
            self._populate_departments_for_request()
        except Exception as e:
            print(f"WARN: cannot populate departments for request: {e}")

        # اضافه کردن تب
        self.tabs.addTab(page, "فرم درخواست خرید")

    # [FUNC: UI.ReplenishmentDialog._add_row] — کنترل‌ها با ارتفاع ثابتِ هم‌راستا
    def _add_row(self):
        r = self.tbl_form.rowCount()
        self.tbl_form.insertRow(r)
        row_h = self.tbl_form.verticalHeader().defaultSectionSize()
        self.tbl_form.setRowHeight(r, row_h)

        def _fixh(w: QtWidgets.QWidget) -> QtWidgets.QWidget:
            h = max(32, int(row_h) - 10)
            w.setMinimumHeight(h); w.setMaximumHeight(h)
            w.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            return w

        # 0) SKU + completer زنده
        w_sku = _fixh(QtWidgets.QLineEdit()); w_sku.setPlaceholderText("کد/بارکد…")
        self.tbl_form.setCellWidget(r, 0, w_sku)
        self._build_sku_completer_for_row(r, w_sku)
        w_sku.textChanged.connect(lambda _t, row=r: self._build_sku_completer_for_row(row, w_sku))
        w_sku.editingFinished.connect(lambda row=r: self._handle_entered_sku(row))

        # 1) نام + دکمهٔ انتخاب
        container = QtWidgets.QWidget(); hl = QtWidgets.QHBoxLayout(container); hl.setContentsMargins(0,0,0,0); hl.setSpacing(6)
        w_name = _fixh(QtWidgets.QLineEdit()); w_name.setReadOnly(True)
        btn_pick = QtWidgets.QToolButton(); btn_pick.setText("🔎"); btn_pick.setAutoRaise(True); btn_pick.setCursor(Qt.PointingHandCursor)
        btn_pick = _fixh(btn_pick)  # هم‌ارتفاع با ردیف
        btn_pick.clicked.connect(lambda _=False, row=r: self._pick_item_for_row(row))
        hl.addWidget(w_name, 1); hl.addWidget(btn_pick, 0)
        container.setLayout(hl)
        self.tbl_form.setCellWidget(r, 1, container)

        # 2) مشخصات (WRAP) — ارتفاع دقیقاً داخل ردیف
        w_specs = QtWidgets.QTextEdit(); w_specs.setAcceptRichText(False)
        w_specs.setWordWrapMode(QTextOption.WordWrap)
        w_specs.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)  # نیاز به اسکرول ندارد چون ارتفاع ردیف زیاد است
        w_specs.setFixedHeight(max(32, int(row_h) - 10))
        self.tbl_form.setCellWidget(r, 2, w_specs)

        # 3) مقدار
        w_qty = _fixh(QtWidgets.QDoubleSpinBox()); w_qty.setDecimals(3); w_qty.setRange(0.001, 1e12); w_qty.setValue(1.000)
        self.tbl_form.setCellWidget(r, 3, w_qty)

        # 4) یکا
        w_unit = _fixh(QtWidgets.QComboBox())
        for u in self._units: w_unit.addItem(u['name'], u['id'])
        self.tbl_form.setCellWidget(r, 4, w_unit)

        # 5) فوریت
        w_urg = _fixh(QtWidgets.QComboBox()); [w_urg.addItem(x) for x in self.URGENCY_CHOICES]
        self.tbl_form.setCellWidget(r, 5, w_urg)

        # 6) نوع درخواست
        w_rtype = _fixh(QtWidgets.QComboBox())
        for val, label in self.REASON_CHOICES: w_rtype.addItem(label, val)
        self.tbl_form.setCellWidget(r, 6, w_rtype)

        # 7) یادداشت (WRAP) — داخل ردیف
        w_note = QtWidgets.QTextEdit(); w_note.setAcceptRichText(False)
        w_note.setWordWrapMode(QTextOption.WordWrap)
        w_note.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        w_note.setFixedHeight(max(32, int(row_h) - 10))
        self.tbl_form.setCellWidget(r, 7, w_note)

        # 8) فایل‌ها
        self.tbl_form.setCellWidget(r, 8, self._make_attach_cell(r))
    
    def _del_row(self):
        rows = sorted({i.row() for i in self.tbl_form.selectedIndexes()}, reverse=True)
        for r in rows:
            self.tbl_form.removeRow(r)
            self._row_item_ids.pop(r, None)
            self._row_attachments.pop(r, None)
            
    # BEGIN REWRITE: UI.ReplenishmentDialog._collect_form_lines
    def _collect_form_lines(self):
        """
        ردیف‌های فرم را جمع‌آوری می‌کند؛ خروجی همیشه list[dict] با کلیدهای:
        item_id, quantity, unit_id, specs, note, urgency, reason_code, attachments
        رفتار بیرونی حفظ شده و فقط گاردهای ضد ارور اضافه شده‌اند.
        """
        from PyQt5 import QtWidgets
        import os

        self._last_collect_error = False
        lines, errors = [], []

        # یادداشت سربرگ اختیاری (اگر وجود داشت)
        try:
            header_note = (
                getattr(self, "txt_header_note", None).toPlainText().strip()
                if hasattr(self, "txt_header_note") and getattr(self, "txt_header_note") else ""
            )
        except Exception:
            header_note = ""

        # وجود جدول
        tbl = getattr(self, "tbl_form", None)
        if tbl is None or getattr(tbl, "rowCount", None) is None:
            QtWidgets.QMessageBox.warning(self, "فرم نامعتبر", "جدول ردیف‌ها در دسترس نیست.")
            self._last_collect_error = True
            return []

        row_count = int(tbl.rowCount() or 0)

        # مپ کمکی: r -> item_id (برای ردگیری آیتم انتخاب‌شده)
        row_map = getattr(self, "_row_item_ids", {}) or {}
        self._row_item_ids = row_map  # اطمینان از وجود

        for r in range(row_count):
            # پاک کردن نشانهٔ خطای قبلی همین ردیف (اگر متدها وجود دارند)
            try:
                if hasattr(self, "_clear_row_error"):
                    self._clear_row_error(r)
            except Exception:
                pass

            # --- کالا: اول از مپ، اگر نبود از SKU حل کن
            item_id = row_map.get(r)
            if not item_id:
                try:
                    w_sku = tbl.cellWidget(r, 0)
                    sku_text = (w_sku.text() if hasattr(w_sku, "text") else "").strip()
                except Exception:
                    sku_text = ""
                if sku_text:
                    try:
                        rec = self.db.find_item_by_sku(sku_text)
                    except Exception:
                        rec = None
                    if rec and not rec.get("is_parent"):
                        try:
                            item_id = int(rec["id"])
                        except Exception:
                            item_id = rec.get("id")
                        self._row_item_ids[r] = item_id

            # اگر هنوز آیتم نامشخص بود، ردیف را نادیده بگیر
            if not item_id:
                continue

            # تبدیل امن به int در صورت امکان
            try:
                item_id = int(item_id)
            except Exception:
                # اگر تبدیل نشد، خطا و ادامه به ردیف بعد
                errors.append(f"ردیف {r+1}: شناسهٔ کالا نامعتبر است.")
                try:
                    if hasattr(self, "_mark_row_error"):
                        self._mark_row_error(r, "شناسهٔ کالا نامعتبر است.")
                except Exception:
                    pass
                continue

            # --- مقدار: QDoubleSpinBox.value() مقدم بر lineEdit/text()
            qty = 0.0
            w_qty = tbl.cellWidget(r, 3)
            try:
                if hasattr(w_qty, "value"):
                    qty = float(w_qty.value())
                elif hasattr(w_qty, "text"):
                    t = (w_qty.text() or "").replace(",", ".").strip()
                    qty = float(t or "0")
            except Exception:
                qty = 0.0

            if qty <= 0:
                errors.append(f"ردیف {r+1}: مقدار باید بزرگ‌تر از صفر باشد.")
                try:
                    if hasattr(self, "_mark_row_error"):
                        self._mark_row_error(r, "مقدار باید بزرگ‌تر از صفر باشد.")
                except Exception:
                    pass
                continue

            # --- واحد اختیاری
            unit_id = None
            try:
                cb_unit = tbl.cellWidget(r, 4)
                if cb_unit is not None:
                    # currentData مقدم؛ اگر تهی بود Unit نامشخص
                    raw = cb_unit.currentData() if hasattr(cb_unit, "currentData") else None
                    if raw not in (None, "", "None", 0, "0"):
                        try:
                            unit_id = int(raw)
                        except Exception:
                            # اگر عددی نبود، همان raw (سازگاری با کد فعلی)
                            unit_id = raw
            except Exception:
                unit_id = None

            # --- استخراج متون
            def _tget(w):
                try:
                    if hasattr(w, "toPlainText"):
                        return (w.toPlainText() or "").strip()
                    if hasattr(w, "text"):
                        return (w.text() or "").strip()
                except Exception:
                    pass
                return ""

            specs = _tget(tbl.cellWidget(r, 2))
            note  = _tget(tbl.cellWidget(r, 7)) or header_note

            # --- فوریت و نوع درخواست
            try:
                w_urg = tbl.cellWidget(r, 5)
                urg = w_urg.currentText() if hasattr(w_urg, "currentText") else ""
            except Exception:
                urg = ""
            try:
                w_reason = tbl.cellWidget(r, 6)
                reason_code = w_reason.currentData() if hasattr(w_reason, "currentData") else None
            except Exception:
                reason_code = None

            # --- پیوست‌ها (≤۲MB/ردیف؛ کنترل گروهی در جای دیگر)
            attachments_content, total_bytes = [], 0
            try:
                row_atts = (getattr(self, "_row_attachments", {}) or {}).get(r, [])
            except Exception:
                row_atts = []

            for pair in row_atts:
                try:
                    path, sz = pair
                except Exception:
                    # اگر ساختار متفاوت بود، از این آیتم می‌گذریم
                    continue
                try:
                    with open(path, "rb") as f:
                        data = f.read()
                    attachments_content.append((os.path.basename(path), data))
                    total_bytes += len(data)
                    if total_bytes > (2 * 1024 * 1024):
                        errors.append(f"ردیف {r+1}: حجم مجموع پیوست‌ها بیش از ۲MB است.")
                        try:
                            if hasattr(self, "_mark_row_error"):
                                self._mark_row_error(r, "حجم پیوست‌های این ردیف بیش از ۲MB است.")
                        except Exception:
                            pass
                        attachments_content = []
                        break
                except Exception as ex:
                    errors.append(f"ردیف {r+1}: خواندن فایل پیوست ناموفق بود: {ex}")
                    try:
                        if hasattr(self, "_mark_row_error"):
                            self._mark_row_error(r, "پیوست این ردیف خوانده نشد.")
                    except Exception:
                        pass
                    attachments_content = []
                    break

            # ساخت ردیف نهایی
            lines.append({
                "item_id": item_id,
                "quantity": float(qty),
                "unit_id": unit_id,
                "specs": specs,
                "note": note,
                "urgency": urg,
                "reason_code": reason_code,
                "attachments": attachments_content
            })

        # تجمیع خطاهای کاربری (تا ۱۰ مورد برای پیام)
        if errors:
            msg = "لطفاً خطاهای زیر را برطرف کنید:\n• " + "\n• ".join(errors[:10])
            QtWidgets.QMessageBox.warning(self, "خطا در داده‌های ردیف‌ها", msg)
            self._last_collect_error = True
            return []

        return lines
    # END REWRITE: UI.ReplenishmentDialog._collect_form_lines

    # BEGIN REWRITE: UI.ReplenishmentDialog._submit_pr_form_and_send
    def _submit_pr_form_and_send(self):
        """
        ثبت فرم PR از مسیر واحد (DB.create_purchase_request_multi)
        + بلافاصله «ارسال برای تایید مدیر واحد» روی همهٔ PRهای ساخته‌شده (مستقل از workflow).
        """
        from PyQt5 import QtWidgets

        try:
            self.db._reset_aborted_tx()
        except Exception:
            pass

        # 1) جمع‌آوری ردیف‌ها
        lines = self._collect_form_lines()
        if getattr(self, "_last_collect_error", False) or not lines:
            return

        # 2) ورودی‌های سربرگ
        physical_no = (self.txt_physical_no.text() or "").strip() if hasattr(self, "txt_physical_no") else ""
        dept_id = self._get_selected_dept_id()
        if dept_id is None:
            QtWidgets.QMessageBox.warning(self, "واحد نامشخص", "لطفاً «درخواست برای واحد» را انتخاب کنید.")
            return

        # 3) گیت: مدیرِ همین واحد باید معلوم باشد
        manager_id = None
        try:
            # اول از درخت واحدها
            if hasattr(self.db, "get_departments_tree"):
                tree = self.db.get_departments_tree() or []
                stack = list(tree)
                while stack:
                    node = stack.pop()
                    if isinstance(node, dict):
                        try:
                            nid = node.get("id") or node.get("dept_id") or node.get("department_id")
                            if nid is not None and int(nid) == int(dept_id):
                                mid = node.get("manager_user_id")
                                if mid not in (None, "", "None", 0, "0"):
                                    manager_id = int(mid)
                                    break
                        except Exception:
                            pass
                        children = node.get("children") or node.get("items") or []
                        if isinstance(children, list):
                            stack.extend(children)
            # fallback مستقیم
            if manager_id is None:
                rec = self.db.execute_query(
                    "SELECT manager_user_id FROM departments WHERE id = %s",
                    (int(dept_id),),
                    fetch_one=True
                )
                mid = rec.get("manager_user_id") if isinstance(rec, dict) else (rec[0] if rec else None)
                manager_id = int(mid) if mid not in (None, "", "None", 0, "0") else None
        except Exception:
            manager_id = None

        if manager_id is None:
            QtWidgets.QMessageBox.warning(self, "مدیر واحد نامشخص است", "مدیر واحد نامشخص است")
            return

        # 4) آماده‌سازی payload اقلام
        items_payload = [{
            "item_id": int(ln["item_id"]),
            "qty": float(ln["quantity"]),
            "requested_unit_id": ln.get("unit_id"),
            "specs": ln.get("specs", ""),
            "note": ln.get("note", ""),
            "urgency": ln.get("urgency"),
            "reason_code": ln.get("reason_code"),
            "attachments": ln.get("attachments") or [],
        } for ln in lines]

        # 5) چک یکتایی شمارهٔ فیزیکی (اختیاری)
        if physical_no:
            try:
                if self.db.is_physical_request_no_taken(physical_no):
                    QtWidgets.QMessageBox.warning(self, "شمارهٔ فیزیکی تکراری", f"شمارهٔ «{physical_no}» قبلاً ثبت شده است.")
                    return
            except Exception:
                pass

        # 6) ثبت + ارسال به تایید مدیر واحد
        self._set_submitting(True)
        try:
            res = self.db.create_purchase_request_multi(
                items=items_payload,
                requester_id=int(self.user_id),
                original_dept_id=int(dept_id),
                group_physical_no=(physical_no or None),
                request_note="",
            )

            # ---- دریافت pr_ids ساخته‌شده
            pr_ids = list(res.get("pr_ids") or res.get("ids") or [])
            if (not pr_ids) and res.get("group_id") is not None:
                # fallback: از گروه بخوان
                try:
                    with self.db.transaction() as cur:
                        cols = set(self.db._get_existing_columns("purchase_requests", cursor=cur)) or set()
                        c_gid = "group_id" if "group_id" in cols else ("request_group_id" if "request_group_id" in cols else None)
                        if c_gid:
                            cur.execute(f"SELECT id FROM purchase_requests WHERE {c_gid}=%s ORDER BY id ASC", (int(res["group_id"]),))
                            rows = cur.fetchall() or []
                            pr_ids = [int(r[0] if not isinstance(r, dict) else r.get("id")) for r in rows if r]
                except Exception:
                    pr_ids = pr_ids or []

            # ---- ارسال هر PR برای تایید مدیر واحد (ست status + manager_approver_id + صف Pending)
            sent_cnt = 0
            for pid in pr_ids:
                try:
                    ok = self.db.submit_pr_for_unit_manager(int(pid), int(self.user_id))
                    if ok: sent_cnt += 1
                except Exception:
                    pass

            # پیام همون قبلی می‌مونه (حفظ رفتار بیرونی)
            QtWidgets.QMessageBox.information(self, "ثبت شد", f"درخواست خرید ثبت شد (گروه #{res.get('group_id')}).")

            # رفرش سبک UI (اگر توست/رفرش عمومی داری)
            try:
                if hasattr(self, "refresh_all"): self.refresh_all()
                if hasattr(self, "toast") and sent_cnt:
                    self.toast.show_message("برای تایید مدیر واحد ارسال شد.", "success")
            except Exception:
                pass

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ثبت", str(e))
            try:
                self.db._reset_aborted_tx()
            except Exception:
                pass
        finally:
            self._set_submitting(False)
    # END REWRITE: UI.ReplenishmentDialog._submit_pr_form_and_send

            
    def _build_sku_completer_for_row(self, row: int, w_sku: QtWidgets.QLineEdit):
        prefix = (w_sku.text() or "").strip()
        # فقط وقتی حداقل 2 کاراکتر تایپ شده پیشنهاد بده
        items = self.db.search_items_by_sku_prefix(prefix, limit=20) if len(prefix) >= 2 else []
        model = QtGui.QStandardItemModel()
        self._sku_suggest_map = getattr(self, '_sku_suggest_map', {})
        self._sku_suggest_map[row] = {}
        for rec in items:
            display = f"{rec['code']} — {rec['full_name']}"
            it = QtGui.QStandardItem(display)
            model.appendRow(it)
            self._sku_suggest_map[row][display] = rec
        comp = QtWidgets.QCompleter(model, self)
        comp.setCaseSensitivity(Qt.CaseInsensitive)
        w_sku.setCompleter(comp)

        def on_activated(text: str, row=row):
            rec = self._sku_suggest_map.get(row, {}).get(text)
            if not rec: return
            self._apply_item_to_row(row, rec['id'], rec.get('unit_id'))
            # ست کردن SKU دقیق
            sku_edit: QtWidgets.QLineEdit = self.tbl_form.cellWidget(row, 0)  # type: ignore
            sku_edit.setText(rec.get('code') or "")

        comp.activated[str].connect(on_activated)
        
    def _apply_item_to_row(self, row: int, item_id: int, unit_id: int | None):
        self._row_item_ids[row] = int(item_id)
        # نام کامل
        name_w: QtWidgets.QLineEdit = self.tbl_form.cellWidget(row, 1).findChild(QtWidgets.QLineEdit)  # type: ignore
        name_w.setText(self._compose_full_name(int(item_id)))
        # واحد
        if unit_id is None:
            try:
                rec = self.db.execute_query("SELECT unit_id FROM items WHERE id=%s", (int(item_id),), fetch_one=True) or {}
                unit_id = rec.get('unit_id')
            except Exception:
                unit_id = None
        if unit_id is not None:
            w_unit: QtWidgets.QComboBox = self.tbl_form.cellWidget(row, 4)  # type: ignore
            idx = w_unit.findData(int(unit_id))
            if idx >= 0: w_unit.setCurrentIndex(idx)

    # BEGIN REWRITE: UI.ReplenishmentDialog._make_attach_cell
    def _make_attach_cell(self, row: int) -> QtWidgets.QWidget:
        """سلول پیوست‌ها: افزودن با فیلتر نوع فایل، مشاهده/بازکردن، حذف تکی/همه.
        سقف هر ردیف: ۲MB، سقف کل گروه: ۱۰MB. نام فایل‌ها تمیز می‌شود و پیام‌ها واضح‌اند."""
        from PyQt5.QtGui import QDesktopServices
        from PyQt5.QtCore import QUrl
        import os

        MAX_ROW = 2 * 1024 * 1024   # ۲MB

        box = QtWidgets.QWidget()
        hl = QtWidgets.QHBoxLayout(box)
        hl.setContentsMargins(0, 0, 0, 0)

        btn_add = QtWidgets.QPushButton("افزودن…")
        btn_add.setToolTip("فقط pdf/png/jpg/jpeg/webp · سقف هر ردیف: ۲MB · سقف کل گروه: ۱۰MB")

        btn_menu = QtWidgets.QToolButton()
        btn_menu.setPopupMode(QtWidgets.QToolButton.InstantPopup)
        btn_menu.setText("فایل‌ها (0)")
        menu = QtWidgets.QMenu(btn_menu)
        btn_menu.setMenu(menu)

        def _names_tooltip() -> None:
            """لیست نام فایل‌ها را به‌صورت راهنما روی دکمه نشان می‌دهد."""
            files = list(self._row_attachments.get(row, []))
            if not files:
                btn_menu.setToolTip("فایلی افزوده نشده.")
                return
            names = "".join(os.path.basename(p) for p, _ in files)
            btn_menu.setToolTip(names)

        def refresh_menu() -> None:
            menu.clear()
            files = list(self._row_attachments.get(row, []))
            btn_menu.setText(f"فایل‌ها ({len(files)})")
            if not files:
                act = menu.addAction("(فایلی اضافه نشده)")
                act.setEnabled(False)
            else:
                from functools import partial
                for p, sz in files:
                    base = os.path.basename(p)
                    act_open = menu.addAction(f"باز کردن: {base}")
                    act_open.triggered.connect(partial(lambda path: QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.abspath(path))), p))
                    act_del = menu.addAction(f"حذف: {base}")
                    def _rm_factory(path=p):
                        def _inner():
                            cur = list(self._row_attachments.get(row, []))
                            cur = [(pp, ss) for (pp, ss) in cur if pp != path]
                            self._row_attachments[row] = cur
                            refresh_menu(); _names_tooltip()
                        return _inner
                    act_del.triggered.connect(_rm_factory())
            if files:
                menu.addSeparator()
                act_clear = menu.addAction("حذف همهٔ فایل‌ها")
                def _clear_all():
                    self._row_attachments[row] = []
                    refresh_menu(); _names_tooltip()
                act_clear.triggered.connect(_clear_all)
            _names_tooltip()

        def _group_sum_bytes(extra: int = 0) -> int:
            """جمع اندازهٔ همهٔ پیوست‌های فرم (همهٔ ردیف‌ها) + اضافهٔ درحال افزودن."""
            total = 0
            for rr, lst in (self._row_attachments or {}).items():
                for _p, s in lst:
                    try: total += int(s)
                    except Exception: pass
            return total + int(extra or 0)

        def add_files() -> None:
            # فیلتر نوع فایل در دیالوگ انتخاب
            paths, _ = QtWidgets.QFileDialog.getOpenFileNames(
                self,
                "انتخاب فایل‌های پیوست",
                "",
                "اسناد (%.pdf);;تصاویر (%.png %.jpg %.jpeg %.webp);;همهٔ فایل‌ها (*.*)".replace('%','*')
            )
            if not paths:
                return
            cur = list(self._row_attachments.get(row, []))
            known = {p for p, _ in cur}
            total_row = sum(sz for _, sz in cur)

            for p in paths:
                try:
                    if p in known:
                        continue
                    sz = os.path.getsize(p)
                    # نوع مجاز
                    ext = os.path.splitext(p)[1].lower().lstrip('.')
                    ok, msg = _is_allowed_attachment(os.path.basename(p), sz)
                    if not ok:
                        QtWidgets.QMessageBox.warning(self, "نوع/حجم نامعتبر", msg)
                        continue
                    # سقف ردیف
                    if total_row + sz > MAX_ROW:
                        QtWidgets.QMessageBox.warning(self, "حجم زیاد", "حداکثر مجموع پیوست‌های هر ردیف ۲MB است.")
                        break
                    # سقف گروه (۱۰MB)
                    if _group_sum_bytes(sz) > (10 * 1024 * 1024):
                        QtWidgets.QMessageBox.warning(self, "حجم گروه زیاد", "مجموع پیوست‌های این گروه بیش از ۱۰MB است.")
                        break
                except Exception:
                    QtWidgets.QMessageBox.warning(self, "خطا", f"فایل در دسترس نیست: {p}")
                    continue
                total_row += sz
                cur.append((p, sz))
                known.add(p)
            self._row_attachments[row] = cur
            refresh_menu()

        btn_add.clicked.connect(add_files)
        hl.addWidget(btn_add)
        hl.addWidget(btn_menu)
        hl.addStretch(1)

        try:
            self._enhance_specs_cell(row)
        except Exception:
            pass

        return box
    # END REWRITE: UI.ReplenishmentDialog._make_attach_cell
    # ───────────── UI: تب پیشنهادها (RP)
    def _build_smart_tab(self):
        page = QtWidgets.QWidget(); v = QtWidgets.QVBoxLayout(page)
        info = QtWidgets.QLabel("کالاهایی که موجودی‌شان از نقطه سفارش کمتر شده‌اند.")
        info.setStyleSheet("color:#2c3e50; background:#eef7ff; border:1px solid #bfe0ff; border-radius:4px; padding:6px;")
        v.addWidget(info)
        self.tbl_rp = QtWidgets.QTableWidget(0, 5)
        self.tbl_rp.setHorizontalHeaderLabels(["کالا", "موجودی", "نقطه سفارش", "کسری", "افزودن به فرم"])
        self.tbl_rp.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        v.addWidget(self.tbl_rp, 1)

        btns = QtWidgets.QHBoxLayout()
        self.btn_refresh_rp = QtWidgets.QPushButton("به‌روزرسانی"); self.btn_refresh_rp.clicked.connect(self._load_rp)
        self.btn_add_selected_rp = QtWidgets.QPushButton("افزودن انتخاب‌ها به فرم"); self.btn_add_selected_rp.clicked.connect(self._push_rp_to_form)
        btns.addWidget(self.btn_refresh_rp); btns.addStretch(1); btns.addWidget(self.btn_add_selected_rp)
        v.addLayout(btns)
        self.tabs.addTab(page, "پیشنهادهای تامین")
        self._load_rp()

    def _load_rp(self) -> None:
        """لیست اقلام زیر نقطه سفارش را در جدول پیشنهادها بارگذاری می‌کند."""
        self.tbl_rp.setRowCount(0)
        try:
            rows = self.db.list_reorder_candidates() or []
        except Exception:
            rows = []

        # جدول این تب ۵ ستون دارد: [کالا, موجودی, نقطه سفارش, کسری, دکمه افزودن]
        for rec in rows:
            rr = self.tbl_rp.rowCount()
            self.tbl_rp.insertRow(rr)

            name = rec.get('label') or rec.get('name') or ""
            stock = float(rec.get('stock') or 0.0)
            rp    = float(rec.get('reorder_point') or 0.0)
            deficit = float(rec.get('deficit') or (rp - stock))
            # نوشتن داده‌ها
            self.tbl_rp.setItem(rr, 0, QtWidgets.QTableWidgetItem(name))
            self.tbl_rp.setItem(rr, 1, QtWidgets.QTableWidgetItem(str(round(stock, 3))))
            self.tbl_rp.setItem(rr, 2, QtWidgets.QTableWidgetItem(str(round(rp, 3))))
            self.tbl_rp.setItem(rr, 3, QtWidgets.QTableWidgetItem(str(round(deficit, 3))))
            # دکمه‌ی افزودن تکی
            btn = QtWidgets.QPushButton("افزودن")
            btn.clicked.connect(lambda _=False, r=rec: self._add_rp_to_form(r))
            self.tbl_rp.setCellWidget(rr, 4, btn)

            # ذخیره item_id در هدر عمودی ردیف (برای انتخاب چندگانه)
            item_id = rec.get('item_id') or rec.get('id')
            self.tbl_rp.setVerticalHeaderItem(rr, QtWidgets.QTableWidgetItem(str(int(item_id))))
            self.tbl_rp.setRowHeight(rr, 24)
        
    # BEGIN REWRITE: UI.ReplenishmentDialog._add_rp_to_form
    def _add_rp_to_form(self, rec: dict) -> None:
        """افزودن یک قلم RP به فرم پایین (با گارد جلوگیری از تکرار در صورت وجود PO باز)."""
        try:
            item_id = int(rec.get('item_id') or rec.get('id'))
        except Exception:
            return

        # --- گارد: اگر برای این کالا PO باز وجود دارد، اضافه نکن
        try:
            if self.db.has_open_po_for_item(item_id):
                QtWidgets.QMessageBox.information(
                    self, "ممانعت از تکرار",
                    "برای این کالا یک سفارش خریدِ باز وجود دارد؛ دوباره اضافه نکنید."
                )
                try:
                    btn = self.sender()
                    if isinstance(btn, QtWidgets.QAbstractButton):
                        btn.setEnabled(False)
                        btn.setText("رزرو شد")
                except Exception:
                    pass
                return
        except Exception:
            # اگر چک DB به هر دلیل خطا داد، نمی‌گذاریم کرش کند؛ ادامه نمی‌دهیم.
            return

        # مقدار پیشنهادی (همان منطق فعلی)
        qty = float(rec.get('suggested_qty') or rec.get('deficit') or 1.0)
        qty = max(qty, 1.0)

        # افزودن یک ردیف جدید به فرم پایین
        self._add_row()
        row = self.tbl_form.rowCount() - 1
        self._row_item_ids[row] = item_id

        # 1) نام کامل کالا
        name_w: QtWidgets.QLineEdit = self.tbl_form.cellWidget(row, 1).findChild(QtWidgets.QLineEdit)  # type: ignore
        name_w.setText(self._compose_full_name(item_id))  # منطق فعلی نام کامل  :contentReference[oaicite:8]{index=8}

        # 2) مقدار
        w_qty: QtWidgets.QDoubleSpinBox = self.tbl_form.cellWidget(row, 3)  # type: ignore
        w_qty.setValue(qty)  # :contentReference[oaicite:9]{index=9}

        # 3) یکا (اگر در rec بود)
        unit_id = rec.get('unit_id')
        if unit_id is not None:
            w_unit: QtWidgets.QComboBox = self.tbl_form.cellWidget(row, 4)  # type: ignore
            uidx = w_unit.findData(int(unit_id))
            if uidx >= 0:
                w_unit.setCurrentIndex(uidx)  # :contentReference[oaicite:10]{index=10}

        # 4) SKU ← از DB بخوان و ست کن
        try:
            sku_val = self.db.get_sku_for_item(item_id)
        except Exception:
            sku_val = None
        if sku_val:
            w_sku: QtWidgets.QLineEdit = self.tbl_form.cellWidget(row, 0)  # type: ignore
            w_sku.setText(str(sku_val))  # :contentReference[oaicite:11]{index=11}

        # 5) یادداشت را با برچسب [RP] پیشوند بزن
        try:
            w_note: QtWidgets.QTextEdit = self.tbl_form.cellWidget(row, 7)  # type: ignore
            cur = (w_note.toPlainText() or "").strip()
            w_note.setPlainText(("[RP] " + cur).strip())
        except Exception:
            pass  # :contentReference[oaicite:12]{index=12}

        
    # BEGIN REWRITE: UI.ReplenishmentDialog._push_rp_to_form
    def _push_rp_to_form(self) -> None:
        """ردیف‌های انتخاب‌شده در جدول RP را به فرم درخواست اضافه می‌کند (با گارد تکرار)."""
        selected_rows = sorted({idx.row() for idx in self.tbl_rp.selectedIndexes()})
        if not selected_rows:
            QtWidgets.QMessageBox.information(self, "بدون انتخاب", "لطفاً چند ردیف را در جدول پیشنهادها انتخاب کن.")
            return

        added = 0
        for rr in selected_rows:
            # item_id را از هدر عمودی بخوان
            vh = self.tbl_rp.verticalHeaderItem(rr)
            if not vh:
                continue
            try:
                item_id = int(vh.text())
            except Exception:
                continue

            # --- گارد: اگر PO باز برای این کالا هست، همین‌جا رد شو و دکمه را هم قفل کن
            try:
                if self.db.has_open_po_for_item(item_id):
                    btn = self.tbl_rp.cellWidget(rr, 4)
                    if isinstance(btn, QtWidgets.QAbstractButton):
                        btn.setEnabled(False)
                        btn.setText("رزرو شد")
                    continue
            except Exception:
                continue

            # مقدار از ستون «کسری» (ستون ۳) یا حداقل ۱
            deficit_cell = self.tbl_rp.item(rr, 3)
            try:
                qty = max(float(deficit_cell.text()), 1.0) if deficit_cell else 1.0
            except Exception:
                qty = 1.0

            # ساخت rec حداقلی و استفاده از متد واحد
            rec = {'item_id': item_id, 'unit_id': None, 'deficit': qty}
            self._add_rp_to_form(rec)
            added += 1

        if added == 0:
            QtWidgets.QMessageBox.information(self, "هشدار", "هیچ ردیفی به فرم اضافه نشد.")
    # END REWRITE: UI.ReplenishmentDialog._push_rp_to_form
    
    def _compose_full_name(self, item_id: int) -> str:
        pcol = self.db.get_parent_column()
        row = self.db.execute_query(
            f"SELECT id, name, {pcol or 'NULL'} AS parent_id FROM items WHERE id=%s LIMIT 1",
            (item_id,), fetch_one=True
        ) or {}
        if row.get('parent_id'):
            pr = self.db.execute_query("SELECT name FROM items WHERE id=%s", (int(row['parent_id']),), fetch_one=True) or {}
            return f"{pr.get('name','-')} / {row.get('name','-')}"
        return row.get('name') or ''

    # [FUNC: UI.ReplenishmentDialog._pick_item_for_row] — استفاده از دیالوگ جدید و ست هم‌زمان SKU
    def _pick_item_for_row(self, row: int):
        dlg = _ItemPickerDialog(self.db, self)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return
        iid = dlg.selected_item_id()
        if not iid:
            return
        # ست نام/واحد
        self._apply_item_to_row(row, int(iid), None)
        # ست SKU
        try:
            sku = self.db.get_sku_for_item(int(iid))
            if sku:
                w_sku: QtWidgets.QLineEdit = self.tbl_form.cellWidget(row, 0)  # type: ignore
                w_sku.setText(str(sku))
        except Exception:
            pass

    # [FUNC: UI.ReplenishmentDialog._handle_entered_sku] — resolve + سنکرون کردن نام
    def _handle_entered_sku(self, row: int):
        w_sku: QtWidgets.QLineEdit = self.tbl_form.cellWidget(row, 0)  # type: ignore
        sku = (w_sku.text() or "").strip()
        if not sku:
            return
        rec = self.db.find_item_by_sku(sku)
        if not rec:
            QtWidgets.QMessageBox.warning(self, "یافت نشد", "کالایی با این کد پیدا نشد.")
            return
        if rec.get('is_parent'):
            QtWidgets.QMessageBox.warning(self, "کالای مادر", "برای درخواست خرید باید یکی از بسته‌بندی‌های زیرِ کالا را انتخاب کنی.")
            return

        self._apply_item_to_row(row, int(rec['id']), rec.get('unit_id'))
        # اگر نام قبلاً ست نشده بود، همینجا ست است؛ SKU هم همان مقدار واردشده می‌ماند
        
    def _populate_departments_for_request(self) -> None:
        """
        کمبوی «درخواست برای واحد» را با لیست واحدها پر می‌کند.
        - با هر دو نام کمبو سازگار است: dept_req_combo / cmb_departments
        - آیتم اول: «— انتخاب کنید —» با userData=None
        - ب رای هر واحد: متن «نام واحد» و userData=dept_id
        - اگر امکان‌پذیر بود، واحد پیش‌فرض کاربر را انتخاب می‌کند (بدون خطا در صورت نبود)
        """
        from PyQt5 import QtWidgets

        # پیداکردن کمبوی هدف (سازگاری با نام قدیم/جدید)
        cb = getattr(self, "dept_req_combo", None) or getattr(self, "cmb_departments", None)
        if cb is None or not hasattr(cb, "clear"):
            return

        # حفظ انتخاب قبلی اگر قابل استخراج بود
        prev_id = None
        try:
            prev_data = cb.currentData()
            if prev_data not in (None, "", "None"):
                prev_id = int(prev_data)
        except Exception:
            prev_id = None

        # پاک‌سازی و افزودن آیتم راهنما
        try:
            cb.blockSignals(True)
        except Exception:
            pass
        try:
            cb.clear()
            cb.addItem("— انتخاب کنید —", None)
        except Exception:
            # اگر حتی clear/addItem هم در دسترس نبود، همینجا برگردیم
            try:
                cb.blockSignals(False)
            except Exception:
                pass
            return

        # گرفتن لیست واحدها از DB با چند مسیرِ سازگار
        departments = []
        try:
            # 1) متد اختصاصی اگر وجود داشته باشد
            if hasattr(self.db, "get_departments_for_request"):
                departments = self.db.get_departments_for_request() or []
            # 2) درخت واحدها (扁‌سازی به لیست ساده از dict)
            elif hasattr(self.db, "get_departments_tree"):
                tree = self.db.get_departments_tree() or []
                # انتظار: هر نود dict با حداقل id و name؛ در صورت وجود children扁‌سازی می‌کنیم
                stack = list(tree)
                seen = set()
                while stack:
                    node = stack.pop()
                    if not isinstance(node, dict):
                        continue
                    did = node.get("id")
                    name = node.get("name") or node.get("title") or ""
                    if did and did not in seen:
                        departments.append({"id": did, "name": name, "manager_user_id": node.get("manager_user_id")})
                        seen.add(did)
                    ch = node.get("children") or node.get("items") or []
                    if isinstance(ch, list):
                        stack.extend(ch)
            # 3) fallback خام با SQL
            else:
                try:
                    rows = self.db.execute_query(
                        "SELECT id, name, manager_user_id FROM departments ORDER BY name ASC",
                        (),
                        fetch_all=True
                    ) or []
                    for r in rows:
                        departments.append({"id": r.get("id"), "name": r.get("name"), "manager_user_id": r.get("manager_user_id")})
                except Exception:
                    departments = []
        except Exception:
            # هر مشکلی بود، لیست خالی می‌ماند تا UI کرش نکند
            departments = []

        # پرکردن کمبو
        added_ids = set()
        for d in departments:
            try:
                did = int(d.get("id"))
                name = (d.get("name") or "").strip() or f"واحد #{did}"
                if did in added_ids:
                    continue
                cb.addItem(name, did)
                added_ids.add(did)
            except Exception:
                continue

        # تلاش برای انتخاب پیش‌فرض: ۱) انتخاب قبلی ۲) واحد کاربر
        target_id = prev_id
        if target_id is None:
            # تلاش برای پیدا کردن واحد کاربر از DB با مسیرهای امن
            try:
                # اول متد اختصاصی اگر باشد
                if hasattr(self.db, "get_user_department_id"):
                    target_id = self.db.get_user_department_id(int(self.user_id))
                elif hasattr(self.db, "get_user_dept_id"):
                    target_id = self.db.get_user_dept_id(int(self.user_id))
                else:
                    # fallback SQL
                    rec = self.db.execute_query(
                        "SELECT department_id FROM users WHERE id = %s",
                        (int(self.user_id),),
                        fetch_one=True
                    )
                    target_id = rec.get("department_id") if rec else None
            except Exception:
                target_id = None

        # اعمال انتخاب اگر در کمبو موجود بود
        if target_id is not None:
            try:
                # پیدا کردن ایندکس با userData
                for i in range(cb.count()):
                    try:
                        if cb.itemData(i) == target_id:
                            cb.setCurrentIndex(i)
                            break
                    except Exception:
                        continue
            except Exception:
                pass

        try:
            cb.blockSignals(False)
        except Exception:
            pass

        # سازگاری: آلیاس قدیمی را به جدید ست نگه داریم
        try:
            self.dept_req_combo = cb
            self.cmb_departments = cb
        except Exception:
            pass
        
    # BEGIN ADD: UI.ReplenishmentDialog._enhance_specs_cell
    def _enhance_specs_cell(self, row: int) -> None:
        """
        به سلول «مشخصات فنی» در ستون ۲، منوی راست‌کلیک اضافه می‌کند:
        - الگوی مشخصات
        - پرکردن از پیش‌فرض کالا (اگر در DB در دسترس باشد)
        - کپی از ردیف قبلی
        - پاک‌سازی
        نکته: نوع ویجت همان QTextEdit می‌ماند؛ بنابراین با متد _submit_group سازگار است.
        """
        from PyQt5 import QtCore, QtWidgets
        te = None
        try:
            te = self.tbl_form.cellWidget(row, 2)
        except Exception:
            te = None
        if te is None:
            return

        # فقط یک‌بار نصب شود
        if getattr(te, "_specs_menu_installed", False):
            return

        te.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        def _get_item_id_for_row(r: int):
            try:
                return (getattr(self, "_row_item_ids", {}) or {}).get(r)
            except Exception:
                return None

        def _get_default_specs_from_db(item_id):
            """
            تلاش نرم برای گرفتن مشخصات پیش‌فرض کالا از DB؛ اگر نبود، '' برمی‌گرداند.
            هیچ وابستگی جدیدی اضافه نمی‌شود؛ صرفاً روش‌های رایج DB را امتحان می‌کنیم.
            """
            try:
                if not item_id:
                    return ""
                # حالت ۱: متد مستقیم
                fn = getattr(self.db, "get_item_default_specs", None)
                if callable(fn):
                    val = fn(int(item_id))
                    return (val or "").strip()
                # حالت ۲: بازگرداندن دیکشنری از متد اطلاعات کالا
                for cand in ("get_item_by_id", "get_item", "fetch_item"):
                    f = getattr(self.db, cand, None)
                    if callable(f):
                        info = f(int(item_id))
                        if isinstance(info, dict):
                            for k in ("default_specs", "specs", "spec", "tech_spec", "description"):
                                if k in info and info[k]:
                                    return str(info[k]).strip()
                return ""
            except Exception:
                return ""

        def _on_context_menu(pos):
            menu = QtWidgets.QMenu(te)
            act_tpl = menu.addAction("الگوی مشخصات (پیشنهادی)")
            act_fill = menu.addAction("پرکردن از خودِ کالا (اگر موجود)")
            act_copy_prev = menu.addAction("کپی از ردیف قبلی")
            menu.addSeparator()
            act_clear = menu.addAction("پاک‌سازی")

            chosen = menu.exec_(te.mapToGlobal(pos))
            if chosen is None:
                return

            if chosen == act_tpl:
                tpl = "بیس/گرید: \nنسبت/اختلاط: \nرنگ/کد: \nحلال/ویسکوز: \nبسته‌بندی: "
                cur = (te.toPlainText() or "").strip()
                te.setPlainText(tpl if not cur else f"{cur}\n{tpl}")
                te.setFocus()

            elif chosen == act_fill:
                item_id = _get_item_id_for_row(row)
                val = _get_default_specs_from_db(item_id)
                if not val:
                    QtWidgets.QMessageBox.information(self, "در دسترس نیست", "برای این کالا مشخصات پیش‌فرضی پیدا نشد.")
                    return
                cur = (te.toPlainText() or "").strip()
                te.setPlainText(val if not cur else f"{cur}\n{val}")
                te.setFocus()

            elif chosen == act_copy_prev:
                if row <= 0:
                    QtWidgets.QMessageBox.information(self, "ردیف اول", "ردیف قبلی وجود ندارد.")
                    return
                try:
                    te_prev = self.tbl_form.cellWidget(row - 1, 2)
                    prev = (te_prev.toPlainText() or "").strip() if te_prev else ""
                except Exception:
                    prev = ""
                if not prev:
                    QtWidgets.QMessageBox.information(self, "خالی", "در ردیف قبلی مشخصاتی وجود ندارد.")
                    return
                cur = (te.toPlainText() or "").strip()
                te.setPlainText(prev if not cur else f"{cur}\n{prev}")
                te.setFocus()

            elif chosen == act_clear:
                te.clear()
                te.setFocus()

        te.customContextMenuRequested.connect(_on_context_menu)
        te._specs_menu_installed = True
    # END ADD: UI.ReplenishmentDialog._enhance_specs_cell

    def _submit_group(self) -> None:
        """
        مسیر قدیمی «ارسال گروهی» اکنون فقط به مسیر نهایی دلیگیت می‌کند
        تا تکرار صفر شود و رفتار بیرونی تغییری نکند.
        """
        try:
            return self._submit_pr_form_and_send()
        except Exception:
            # برای حفظ پایداری: در صورت بروز خطا، بی‌سروصدا از متد خارج شو.
            return None 
                    
    def _open_pr_center(self):
        # اگر Workbench بازرگانی/تاییدها دارید، اینجا باز کنید؛ در غیراینصورت پیام:
        try:
            dlg = PurchasingWorkbenchWidget(self.db, self.user_id, self)  # اگر کلاس موجود است
            dlg.exec_()
        except Exception:
            QtWidgets.QMessageBox.information(self, "", "مرکز تایید PR از اینجا در دسترس است (در صورت فعال بودن ماژول بازرگانی).")
                                
# [CLASS: UI.PRPanelWidget] — پنل ادغامی ثبت درخواست خرید (تک/چند) با نوع درخواست
class PRPanelWidget(QtWidgets.QGroupBox):
    """پنل ثبت PR: تک/چند ردیفی + نوع درخواست (کمبود/نقطه سفارش/دستی) + فوریت."""
    URGENCY_CHOICES = ["آنی", "فوریت 1", "فوریت 2", "فوریت 3", "عادی"]
    REASON_MAP = {
        "WAREHOUSE_SHORTAGE": "کمبود موجودی نسبت به درخواست",
        "REORDER_POINT": "رسیدن به نقطه سفارش",
        "MANUAL_URGENT": "درخواست فوری دستی",
    }

    # BEGIN REWRITE: PRPanelWidget.__init__
    def __init__(self, db: 'DB', user_id: int, parent=None):
        super().__init__("درخواست خرید", parent)
        self.db, self.user_id = db, user_id
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        v = QtWidgets.QVBoxLayout(self)

        # نوع درخواست
        typ = QtWidgets.QHBoxLayout()
        self.rb_shortage = QtWidgets.QRadioButton(self.REASON_MAP["WAREHOUSE_SHORTAGE"]); self.rb_shortage.setChecked(True)
        self.rb_reorder  = QtWidgets.QRadioButton(self.REASON_MAP["REORDER_POINT"])
        self.rb_manual   = QtWidgets.QRadioButton(self.REASON_MAP["MANUAL_URGENT"])
        typ.addWidget(QtWidgets.QLabel("نوع درخواست:"))
        typ.addWidget(self.rb_shortage); typ.addWidget(self.rb_reorder); typ.addWidget(self.rb_manual); typ.addStretch()
        v.addLayout(typ)

        # فوریت/توضیح
        hdr = QtWidgets.QFormLayout()
        self.cmb_urg = QtWidgets.QComboBox(); self.cmb_urg.addItems(self.URGENCY_CHOICES)
        self.txt_group_note = QtWidgets.QLineEdit(); self.txt_group_note.setPlaceholderText("توضیح کلی (اختیاری)…")
        info = QtWidgets.QLabel("تعریف فوریت: آنی(≤۲۴ساعت) • ۱:۱روز–۱هفته • ۲:۱–۲هفته • ۳:۲هفته–۱ماه • عادی:۱–۳ماه (پس از تایید)")
        info.setStyleSheet("color:#2c3e50; background:#e8f4ff; border:1px solid #b5dafd; border-radius:4px; padding:6px;")
        hdr.addRow("فوریت پیشنهادی:", self.cmb_urg)
        hdr.addRow("توضیح:", self.txt_group_note)
        v.addWidget(info); v.addLayout(hdr)

        # جدول ردیف‌ها: ستون «فایل‌ها» اضافه شد (۷ ستون)
        self.table = QtWidgets.QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels(["کد", "نام کالا", "مشخصات دقیق", "مقدار", "یکا", "یادداشت", "فایل‌ها"])
        self.table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.Stretch)
        v.addWidget(self.table, 1)

        # دکمه‌ها
        btns = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("افزودن ردیف")
        self.btn_del = QtWidgets.QPushButton("حذف ردیف")
        self.btn_submit = QtWidgets.QPushButton("ثبت و ارسال برای تایید مدیرعامل")
        btns.addWidget(self.btn_add); btns.addWidget(self.btn_del); btns.addStretch(); btns.addWidget(self.btn_submit)
        v.addLayout(btns)

        # دیتا
        self._items = self.db.list_items_minimal()
        self._units = self.db.execute_query("SELECT id, name FROM units ORDER BY name", None) or []
        self._units_by_id = {u['id']: u['name'] for u in self._units}

        # نگهدارندهٔ پیوست‌های هر ردیف: {row: [(path, size), ...]}
        self._row_attachments = {}

        # اتصال‌ها
        self.btn_add.clicked.connect(self._add_row)
        self.btn_del.clicked.connect(self._del_row)
        self.btn_submit.clicked.connect(self._submit)

        self._add_row()
    # END REWRITE: PRPanelWidget.__init__
        
        # [CLASS: UI.PRPanelWidget] — افزودن API برنامه‌ای برای درج ردیف
    def add_item(self, item_id: int, qty: float, unit_id: int | None = None, specs: str = "", note: str = "") -> None:
        """یک ردیف به جدول PR اضافه می‌کند و فیلدها را ست می‌نماید."""
        r = self.table.rowCount()
        self.table.insertRow(r)

        # ویدجت‌های ردیف مثل _add_row
        cb_code = QtWidgets.QComboBox(); cb_code.setEditable(True)
        cb_name = QtWidgets.QComboBox(); cb_name.setEditable(True)
        for it in self._items:
            cb_code.addItem(it['label'], it['id'])
            cb_name.addItem(it['name'] or "", it['id'])
        self.table.setCellWidget(r, 0, cb_code)
        self.table.setCellWidget(r, 1, cb_name)

        # انتخاب آیتم
        idx_code = cb_code.findData(item_id);  idx_name = cb_name.findData(item_id)
        if idx_code >= 0: cb_code.setCurrentIndex(idx_code)
        if idx_name >= 0: cb_name.setCurrentIndex(idx_name)

        # سایر فیلدها
        w_specs = QtWidgets.QLineEdit(); w_specs.setText(specs or "")
        w_qty = QtWidgets.QDoubleSpinBox(); w_qty.setDecimals(3); w_qty.setRange(0.001, 1e12); w_qty.setValue(float(qty or 1.0))
        w_unit = QtWidgets.QComboBox(); w_unit.addItem("---", None)
        for u in self._units: w_unit.addItem(u['name'], u['id'])
        if unit_id is not None:
            uidx = w_unit.findData(unit_id)
            if uidx >= 0: w_unit.setCurrentIndex(uidx)
        w_note = QtWidgets.QLineEdit(); w_note.setText(note or "")

        self.table.setCellWidget(r, 2, w_specs)
        self.table.setCellWidget(r, 3, w_qty)
        self.table.setCellWidget(r, 4, w_unit)
        self.table.setCellWidget(r, 5, w_note)

    # BEGIN PATCH: UI.PRPanelWidget._add_row — جلوگیری از انتخاب پیش‌فرض کالا
    def _add_row(self):
        r = self.table.rowCount()
        self.table.insertRow(r)

        cb_code = QtWidgets.QComboBox(); cb_code.setEditable(True)
        cb_name = QtWidgets.QComboBox(); cb_name.setEditable(True)

        # جلوگیری از ثبت ناخواسته: انتخاب خنثی با data=None
        cb_code.addItem("— انتخاب —", None)
        cb_name.addItem("— انتخاب —", None)
        for it in self._items:
            cb_code.addItem(it['label'], it['id'])
            cb_name.addItem(it['name'] or "", it['id'])
        cb_code.setCurrentIndex(0)
        cb_name.setCurrentIndex(0)

        self.table.setCellWidget(r, 0, cb_code)
        self.table.setCellWidget(r, 1, cb_name)

        # همگام‌سازی انتخاب نام/کد (اگر چیزی واقعا انتخاب شد)
        def sync(a: QtWidgets.QComboBox, b: QtWidgets.QComboBox):
            item_id = a.currentData()
            if item_id is None:
                return
            idx = b.findData(item_id)
            if idx >= 0:
                b.setCurrentIndex(idx)
        cb_code.currentIndexChanged.connect(lambda _: sync(cb_code, cb_name))
        cb_name.currentIndexChanged.connect(lambda _: sync(cb_name, cb_code))

        # بقیهٔ فیلدهای ردیف
        specs = QtWidgets.QLineEdit(); specs.setPlaceholderText("مشخصات/گرید/ابعاد…")
        qty = QtWidgets.QDoubleSpinBox(); qty.setDecimals(3); qty.setRange(0.001, 1e12); qty.setValue(1.000)
        cb_unit = QtWidgets.QComboBox(); cb_unit.addItem("---", None)
        for u in self._units:
            cb_unit.addItem(u['name'], u['id'])
        note = QtWidgets.QLineEdit(); note.setPlaceholderText("یادداشت (اختیاری)…")

        self.table.setCellWidget(r, 2, specs)
        self.table.setCellWidget(r, 3, qty)
        self.table.setCellWidget(r, 4, cb_unit)
        self.table.setCellWidget(r, 5, note)

        # واحد پیش‌فرض از روی کالا (در حالت None کاری نمی‌کند)
        def set_default_unit(_):
            item_id = cb_name.currentData()
            rec = next((x for x in self._items if x['id'] == item_id), None)
            if rec and rec.get('unit_id'):
                uidx = cb_unit.findData(rec['unit_id'])
                if uidx >= 0:
                    cb_unit.setCurrentIndex(uidx)
        cb_name.currentIndexChanged.connect(set_default_unit)
        # set_default_unit(None)  # لازم نیست؛ انتخاب اولیه None است

        # سلول «فایل‌ها»
        self.table.setCellWidget(r, 6, self._make_attach_cell(r))
    # END PATCH

    def _del_row(self):
        r = self.table.currentRow()
        if r >= 0: self.table.removeRow(r)

    # BEGIN REWRITE: UI.PRPanelWidget._submit
    def _submit(self):
        # ضد‌کلیک
        if getattr(self, "_busy", False):
            return
        self._busy = True

        # در صورت گیر کردن تراکنش قبلی، قبل از شروع سعی کن اتصال را ریست کنی
        try:
            if hasattr(self.db, "_reset_aborted_tx"):
                self.db._reset_aborted_tx()
        except Exception:
            pass

        try:
            # UI: حالت مشغول
            self.btn_submit.setEnabled(False)
            old_txt = self.btn_submit.text()
            self.btn_submit.setText("در حال ارسال…")
            QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)

            # فوریت/علت/توضیح گروه
            urgency = (self.cmb_urg.currentText() or "").strip()
            if self.rb_shortage.isChecked():
                reason_code = "WAREHOUSE_SHORTAGE"
            elif self.rb_reorder.isChecked():
                reason_code = "REORDER_POINT"
            else:
                reason_code = "MANUAL_URGENT"
            group_note = (self.txt_group_note.text() or "").strip()

            # جمع‌آوری ردیف‌ها
            rows = self.table.rowCount()
            items = []
            for r in range(rows):
                cb_code = self.table.cellWidget(r, 0)
                cb_name = self.table.cellWidget(r, 1)
                specs   = self.table.cellWidget(r, 2)
                qty     = self.table.cellWidget(r, 3)
                cb_unit = self.table.cellWidget(r, 4)
                note    = self.table.cellWidget(r, 5)

                if not (cb_code and cb_name and qty):
                    continue

                item_id = cb_name.currentData()
                if item_id is None:
                    item_id = cb_code.currentData()
                if item_id is None:
                    # سطر ناقص را نادیده بگیر
                    continue

                q = float(qty.value() if hasattr(qty, "value") else 0.0)
                if q <= 0:
                    QtWidgets.QMessageBox.warning(self, "خطای ورودی", f"ردیف {r+1}: مقدار باید بیشتر از صفر باشد.")
                    return

                # پیوست‌های این ردیف → به بایت
                atts = []
                for (p, sz) in list(self._row_attachments.get(r, [])):
                    try:
                        with open(p, "rb") as fh:
                            data = fh.read()
                        atts.append({"filename": os.path.basename(p), "file_data": data, "size_bytes": sz})
                    except Exception:
                        # اگر فایل در دسترس نبود، همان سطر را بدون پیوست ادامه بده
                        pass

                items.append({
                    "item_id": int(item_id),
                    "qty": q,
                    "requested_unit_id": (cb_unit.currentData() if cb_unit else None),
                    "specs": (specs.text() if hasattr(specs, "text") else "" ).strip(),
                    "note": (note.text() if hasattr(note, "text") else "" ).strip(),
                    "urgency": urgency,
                    "reason_code": reason_code,
                    "attachments": atts,
                })

            if not items:
                QtWidgets.QMessageBox.information(self, "ردیف خالی", "حداقل یک ردیف معتبر اضافه کنید.")
                return

            # ثبت گروهی روی موتور واحد
            res = self.db.create_purchase_request_multi(
                items=items,
                requester_id=int(self.user_id),
                original_dept_id=None,                 # این پنل فیلد «درخواست برای واحد» ندارد
                group_physical_no=None,                # شمارهٔ فیزیکی در این پنل تعریف نشده
                request_note=f"[{reason_code}] {group_note}".strip(),
            )

            if res and res.get("pr_ids"):
                QtWidgets.QMessageBox.information(
                    self, "ثبت شد",
                    f"{len(res['pr_ids'])} ردیف ثبت و برای تایید ارسال شد."
                )
                # نوتیف/بازخوانی سبک
                try:
                    if hasattr(self.db, "signals"):
                        self.db.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
                except Exception:
                    pass
                # پاکسازی فرم
                self.table.setRowCount(0)
                self._row_attachments.clear()
                self._add_row()
                self.txt_group_note.clear()
            else:
                QtWidgets.QMessageBox.warning(self, "نامشخص", "پاسخ ساخت درخواست‌ها نامشخص بود.")
        except Exception as e:
            # نمایش خطا و ریست اتصالِ معیوب
            QtWidgets.QMessageBox.critical(self, "خطا در ثبت", f"{e}")
            try:
                if hasattr(self.db, "_reset_aborted_tx"):
                    self.db._reset_aborted_tx()
            except Exception:
                pass
        finally:
            # بازگردانی UI
            try:
                QtWidgets.QApplication.restoreOverrideCursor()
            except Exception:
                pass
            try:
                self.btn_submit.setText(old_txt)
                self.btn_submit.setEnabled(True)
            except Exception:
                pass
            self._busy = False

    # BEGIN ADD: UI.PRPanelWidget._make_attach_cell
    def _make_attach_cell(self, row: int) -> QtWidgets.QWidget:
        from PyQt5.QtGui import QDesktopServices
        from PyQt5.QtCore import QUrl
        import os

        box = QtWidgets.QWidget()
        hl = QtWidgets.QHBoxLayout(box); hl.setContentsMargins(0,0,0,0)

        btn_add = QtWidgets.QPushButton("افزودن…")
        btn_menu = QtWidgets.QPushButton("فایل‌ها (0)")
        menu = QtWidgets.QMenu(btn_menu); btn_menu.setMenu(menu)

        def _names_tooltip():
            files = list(self._row_attachments.get(row, []))
            btn_menu.setToolTip("\n".join(os.path.basename(p) for p,_ in files) or "بدون فایل")

        def refresh_menu():
            menu.clear()
            files = list(self._row_attachments.get(row, []))
            btn_menu.setText(f"فایل‌ها ({len(files)})")
            if not files:
                act = menu.addAction("(فایلی اضافه نشده)"); act.setEnabled(False)
                return
            for p, sz in files:
                base = os.path.basename(p)
                act_open = menu.addAction(f"باز کردن: {base}")
                act_open.triggered.connect(lambda ch=False, path=p: QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.abspath(path))))
                act_del = menu.addAction(f"حذف: {base}")
                def _rm_factory(path=p):
                    def _inner():
                        cur = list(self._row_attachments.get(row, []))
                        cur = [(pp, ss) for (pp, ss) in cur if pp != path]
                        self._row_attachments[row] = cur
                        refresh_menu(); _names_tooltip()
                    return _inner
                act_del.triggered.connect(_rm_factory())

        def add_files():
            from PyQt5.QtWidgets import QFileDialog, QMessageBox
            paths, _ = QFileDialog.getOpenFileNames(self, "انتخاب فایل‌ها", "", "مدارک (pdf png jpg jpeg webp)")
            if not paths: return
            cur = list(self._row_attachments.get(row, []))
            # کنترل نوع/حجم در همین‌جا
            import os
            MAX_ROW = 2 * 1024 * 1024
            for p in paths:
                if not os.path.isfile(p): continue
                base = os.path.basename(p).lower()
                if not any(base.endswith(ext) for ext in (".pdf",".png",".jpg",".jpeg",".webp")):
                    QMessageBox.warning(self, "نوع نامعتبر", f"«{base}» مجاز نیست.")
                    continue
                sz = os.path.getsize(p)
                if sz <= 0 or sz > MAX_ROW:
                    QMessageBox.warning(self, "حجم نامعتبر", f"«{base}» بیش از ۲MB یا صفر است.")
                    continue
                cur.append((p, sz))
            self._row_attachments[row] = cur
            refresh_menu(); _names_tooltip()

        btn_add.clicked.connect(add_files)
        hl.addWidget(btn_add); hl.addWidget(btn_menu); hl.addStretch(1)
        refresh_menu(); _names_tooltip()
        return box
    # END ADD: UI.PRPanelWidget._make_attach_cell
    
    # [CLASS: UI.SmartSupplyPanel] — پنل هوشمند: تشخیص خودکار + افزودن به فرم پایین
class SmartSupplyPanel(QtWidgets.QGroupBox):
    """نمایش هوشمند اقلام نیازمند سفارش (نقطه سفارش) و جایگاه آینده «کمبود نسبت به درخواست‌ها»."""
    def __init__(self, db: 'DB', pr_panel: 'PRPanelWidget', parent=None):
        super().__init__("پیشنهادهای هوشمند تأمین", parent)
        self.db, self.pr_panel = db, pr_panel
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        v = QtWidgets.QVBoxLayout(self)

        # ── نوار راهنما
        hint = QtWidgets.QLabel("• «نیازمند سفارش»: کالاهایی که موجودی‌شان از نقطه سفارش کمتر است. "
                                "• «کمبود نسبت به درخواست‌ها»: در آینده با اتصال درخواست‌های بین‌واحدی فعال می‌شود.")
        hint.setStyleSheet("color:#2c3e50; background:#eef7ff; border:1px solid #bfe0ff; border-radius:4px; padding:6px;")
        v.addWidget(hint)

        # ── تب‌ها
        self.tabs = QtWidgets.QTabWidget(); v.addWidget(self.tabs, 1)

        # TAB 1: نیازمند سفارش (نقطه سفارش)
        self.tab_rp = QtWidgets.QWidget(); t1 = QtWidgets.QVBoxLayout(self.tab_rp)
        self.tbl_rp = QtWidgets.QTableWidget(0, 6)
        self.tbl_rp.setHorizontalHeaderLabels(["انتخاب", "کالا", "موجودی", "نقطه سفارش", "کسری", "پیشنهاد خرید"])
        self.tbl_rp.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        t1.addWidget(self.tbl_rp, 1)

        btns = QtWidgets.QHBoxLayout()
        self.btn_refresh = QtWidgets.QPushButton("به‌روزرسانی")
        self.btn_add_selected = QtWidgets.QPushButton("افزودن انتخاب‌ها به فرم پایین")
        btns.addWidget(self.btn_refresh); btns.addStretch(); btns.addWidget(self.btn_add_selected)
        t1.addLayout(btns)
        self.tabs.addTab(self.tab_rp, "نیازمند سفارش")

        # TAB 2: کمبود نسبت به درخواست‌ها (Placeholder)
        self.tab_shortage = QtWidgets.QWidget(); t2 = QtWidgets.QVBoxLayout(self.tab_shortage)
        w = QtWidgets.QLabel("این بخش پس از پیاده‌سازی سیستم درخواست بین‌واحدی فعال می‌شود.\n"
                             "فعلاً زیرساخت گروه‌بندی بر اساس واحد درخواست‌دهنده آماده است.")
        w.setAlignment(Qt.AlignCenter)
        w.setStyleSheet("color:#777; border:1px dashed #bbb; padding:18px;")
        t2.addWidget(w)
        self.tabs.addTab(self.tab_shortage, "کمبود نسبت به درخواست‌ها")

        # اتصال دکمه‌ها
        self.btn_refresh.clicked.connect(self._load_rp)
        self.btn_add_selected.clicked.connect(self._push_selected_to_form)

        # بارگذاری اولیه
        self._load_rp()

    def _load_rp(self):
        self.tbl_rp.setRowCount(0)
        rows = []
        try:
            rows = self.db.list_reorder_candidates()
        except Exception:
            rows = []
        for r in rows:
            ridx = self.tbl_rp.rowCount()
            self.tbl_rp.insertRow(ridx)
            # چک‌باکس انتخاب
            chk = QtWidgets.QTableWidgetItem(); chk.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable); chk.setCheckState(Qt.Unchecked)
            self.tbl_rp.setItem(ridx, 0, chk)
            # برچسب کالا
            self.tbl_rp.setItem(ridx, 1, QtWidgets.QTableWidgetItem(r.get("label") or ""))
            # موجودی، RP، کسری، پیشنهاد
            self.tbl_rp.setItem(ridx, 2, QtWidgets.QTableWidgetItem(str(r.get("stock", ""))))
            self.tbl_rp.setItem(ridx, 3, QtWidgets.QTableWidgetItem(str(r.get("reorder_point", ""))))
            self.tbl_rp.setItem(ridx, 4, QtWidgets.QTableWidgetItem(str(r.get("deficit", ""))))
            self.tbl_rp.setItem(ridx, 5, QtWidgets.QTableWidgetItem(str(r.get("suggested_qty", ""))))
            # ذخیره‌ی متادیتا
            self.tbl_rp.setRowHeight(ridx, 24)
            self.tbl_rp.setVerticalHeaderItem(ridx, QtWidgets.QTableWidgetItem(str(r.get("item_id"))))
            # unit_id را در Data حلقه نگه نمی‌داریم؛ هنگام افزودن کشف می‌کنیم

    def _push_selected_to_form(self):
        for ridx in range(self.tbl_rp.rowCount()):
            item_chk = self.tbl_rp.item(ridx, 0)
            if not item_chk or item_chk.checkState() != Qt.Checked:
                continue
            # item_id از هدر عمودی (راه ساده بدون ستون مخفی)
            try:
                item_id = int(self.tbl_rp.verticalHeaderItem(ridx).text())
            except Exception:
                continue
            suggested = float(self.tbl_rp.item(ridx, 5).text() or "0") if self.tbl_rp.item(ridx, 5) else 0.0
            if suggested <= 0:
                suggested = max(float(self.tbl_rp.item(ridx, 4).text() or "1"), 1.0) if self.tbl_rp.item(ridx, 4) else 1.0
            # کشف واحد پیش‌فرض از items
            unit_id = None
            try:
                rec = self.execute_query("SELECT unit_id FROM items WHERE id=%s", (item_id,), fetch_one=True)
                unit_id = int(rec['unit_id']) if rec and rec.get('unit_id') else None
            except Exception:
                pass
            # افزودن به فرم پایین
            self.pr_panel.add_item(item_id=item_id, qty=suggested, unit_id=unit_id, specs="", note="[RP]")

            
            
                        
        
#
# این کلاس جدید را به طور کامل به فایل خود اضافه کنید
#
class AddQuoteDialog(QtWidgets.QDialog):
    """دیالوگی برای ثبت جزئیات یک پیشنهاد قیمت از طرف یک تامین‌کننده."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن پیشنهاد قیمت جدید")
        self.setMinimumWidth(500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.supplier_combo = QtWidgets.QComboBox()
        self.price_edit = QtWidgets.QLineEdit()
        self.price_edit.setValidator(QtGui.QDoubleValidator(0, 1e12, 2))
        self.lead_time_edit = QtWidgets.QLineEdit("1")
        self.lead_time_edit.setValidator(QtGui.QIntValidator(0, 365))
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری (مثال: شامل هزینه حمل)")

        # بخش انتخاب فایل پیوست
        path_layout = QtWidgets.QHBoxLayout()
        self.doc_path_edit = QtWidgets.QLineEdit()
        self.doc_path_edit.setReadOnly(True)
        btn_browse = QtWidgets.QPushButton("...")
        btn_browse.setFixedSize(30, 30)
        btn_browse.clicked.connect(self._browse_file)
        path_layout.addWidget(self.doc_path_edit)
        path_layout.addWidget(btn_browse)

        # پر کردن لیست تامین‌کنندگان فعال
        suppliers = self.db.get_all_suppliers(active_only=True)
        for s in suppliers:
            self.supplier_combo.addItem(s['name'], s['id'])
            
        layout.addRow("تامین کننده (*):", self.supplier_combo)
        layout.addRow("قیمت واحد (*):", self.price_edit)
        layout.addRow("زمان تحویل (روز):", self.lead_time_edit)
        layout.addRow("یادداشت:", self.notes_edit)
        layout.addRow("فایل پیش‌فاکتور:", path_layout)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def _browse_file(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل پیش‌فاکتور')
        if path:
            self.doc_path_edit.setText(path)

    def get_data(self):
        """اطلاعات وارد شده در فرم را به صورت دیکشنری برمی‌گرداند."""
        if self.supplier_combo.currentIndex() == -1 or not self.price_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", "لطفاً تامین‌کننده و قیمت واحد را مشخص کنید.")
            return None
        try:
            return {
                "supplier_id": self.supplier_combo.currentData(),
                "unit_price": float(self.price_edit.text()),
                "lead_time": int(self.lead_time_edit.text() or 0),
                "notes": self.notes_edit.text().strip(),
                "doc_path": self.doc_path_edit.text()
            }
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "لطفاً مقادیر عددی را به درستی وارد کنید.")
            return None
        
                                        
class MemoDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نوشتن و ارسال نامه داخلی جدید."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("نامه جدید")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()

        self.to_list = QtWidgets.QListWidget(); self.to_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.cc_list = QtWidgets.QListWidget(); self.cc_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.subject_edit = QtWidgets.QLineEdit()
        self.body_edit = QtWidgets.QTextEdit()
        
        # پر کردن لیست کاربران برای انتخاب
        users = self.db.get_all_users_brief()
        for user in users:
            item_to = QtWidgets.QListWidgetItem(user['username']); item_to.setData(Qt.UserRole, user['id'])
            item_cc = QtWidgets.QListWidgetItem(user['username']); item_cc.setData(Qt.UserRole, user['id'])
            self.to_list.addItem(item_to)
            self.cc_list.addItem(item_cc)

        # استفاده از اسپلیتر برای انتخاب گیرندگان
        recipient_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        to_group = QtWidgets.QGroupBox("گیرندگان اصلی (To)"); to_layout = QtWidgets.QVBoxLayout(to_group); to_layout.addWidget(self.to_list)
        cc_group = QtWidgets.QGroupBox("رونوشت (CC)"); cc_layout = QtWidgets.QVBoxLayout(cc_group); cc_layout.addWidget(self.cc_list)
        recipient_splitter.addWidget(to_group); recipient_splitter.addWidget(cc_group)
        
        form_layout.addRow(recipient_splitter)
        form_layout.addRow("موضوع:", self.subject_edit)
        layout.addLayout(form_layout)
        layout.addWidget(self.body_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ارسال نامه")
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def get_data(self):
        to_ids = [self.to_list.item(i).data(Qt.UserRole) for i in range(self.to_list.count()) if self.to_list.item(i).isSelected()]
        cc_ids = [self.cc_list.item(i).data(Qt.UserRole) for i in range(self.cc_list.count()) if self.cc_list.item(i).isSelected()]
        
        if not to_ids and not cc_ids:
            QtWidgets.QMessageBox.warning(self, "خطا", "حداقل یک گیرنده باید انتخاب شود.")
            return None
        if not self.subject_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "خطا", "موضوع نامه نمی‌تواند خالی باشد.")
            return None
            
        return {
            "subject": self.subject_edit.text().strip(),
            "body": self.body_edit.toPlainText(),
            "to_user_ids": to_ids,
            "cc_user_ids": cc_ids
        }
        
class CommunicationWidget(QtWidgets.QWidget):
    """ویجت یکپارچه برای نمایش صندوق ورودی و نامه‌های ارسالی."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        self.tabs = QtWidgets.QTabWidget()
        self.tbl_inbox = QtWidgets.QTableWidget()
        self.tbl_sent = QtWidgets.QTableWidget()
        
        self.parent_window._style_table(self.tbl_inbox)
        self.parent_window._style_table(self.tbl_sent)
        
        self.tbl_inbox.itemDoubleClicked.connect(self._on_inbox_double_clicked)
        self.tbl_sent.itemDoubleClicked.connect(self._on_sent_double_clicked)

        self.tabs.addTab(self.tbl_inbox, "صندوق ورودی (Inbox)")
        self.tabs.addTab(self.tbl_sent, "نامه‌های ارسالی (Sent)")
        layout.addWidget(self.tabs)
        
        self.refresh_inbox()
        self.refresh_sent()

    # BEGIN REWRITE: CommunicationWidget.refresh_inbox
    def refresh_inbox(self):
        try:
            items = self.db.get_user_inbox(self.user_id, limit=200) or []
        except Exception as e:
            # در صورت خطای موقت DB، جدول را خالی نشان بده تا UI نریزد
            items = []

        self.tbl_inbox.setRowCount(len(items))
        for r, it in enumerate(items):
            # پر کردن سلول‌ها با گارد None
            subj = (it.get("subject") if isinstance(it, dict) else None) or ""
            body = (it.get("body") if isinstance(it, dict) else None) or ""
            sender = (it.get("sender_name") if isinstance(it, dict) else None) or ""
            created = (it.get("created_at") if isinstance(it, dict) else None)
            created_txt = str(created) if created else ""

            self.tbl_inbox.setItem(r, 0, QtWidgets.QTableWidgetItem(subj))
            self.tbl_inbox.setItem(r, 1, QtWidgets.QTableWidgetItem(sender))
            self.tbl_inbox.setItem(r, 2, QtWidgets.QTableWidgetItem(created_txt))
            self.tbl_inbox.setItem(r, 3, QtWidgets.QTableWidgetItem(body))
    # END REWRITE: CommunicationWidget.refresh_inbox

    def refresh_sent(self):
        sent_items = self.db.get_user_sent_items_detailed(self.user_id)
        headers = ["ID", "گیرندگان", "موضوع", "تاریخ ارسال"]
        self.tbl_sent.setColumnCount(len(headers)); self.tbl_sent.setHorizontalHeaderLabels(headers)
        self.tbl_sent.setRowCount(len(sent_items))
        for r, item in enumerate(sent_items):
            self.tbl_sent.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.tbl_sent.setItem(r, 1, QtWidgets.QTableWidgetItem(item.get('recipients_list', '')))
            self.tbl_sent.setItem(r, 2, QtWidgets.QTableWidgetItem(item['subject']))
            self.tbl_sent.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(item['created_at'])))
        self.tbl_sent.setColumnHidden(0, True)
        self.tbl_sent.resizeColumnsToContents()
        self.tbl_sent.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _on_inbox_double_clicked(self, item):
        memo_item = self.tbl_inbox.item(item.row(), 0)
        if not memo_item:
            return
        self._show_memo_dialog(memo_item.text(), refresh_inbox=True)

    def _on_sent_double_clicked(self, item):
        memo_item = self.tbl_sent.item(item.row(), 0)
        if not memo_item:
            return
        self._show_memo_dialog(memo_item.text(), refresh_inbox=False)

    def open_memo_from_notification(self, memo_id):
        return self._show_memo_dialog(memo_id, refresh_inbox=True)

    def _show_memo_dialog(self, memo_id_value, *, refresh_inbox=False):
        try:
            memo_id_int = int(memo_id_value) if memo_id_value is not None else None
        except Exception:
            memo_id_int = None
        if not memo_id_int:
            if self.parent_window and getattr(self.parent_window, 'toast', None):
                self.parent_window.toast.show_message('شناسه نامه معتبر نیست.', 'warning')
            return False

        try:
            memo_data = self.db.get_memo_details(memo_id_int, self.user_id)
        except Exception as exc:
            if self.parent_window and getattr(self.parent_window, 'toast', None):
                self.parent_window.toast.show_message(f'خطا در بارگیری نامه: {exc}', 'error')
            return False

        if not memo_data:
            if self.parent_window and getattr(self.parent_window, 'toast', None):
                self.parent_window.toast.show_message('نامه موردنظر یافت نشد.', 'warning')
            return False

        if globals().get('DEBUG_MAIL_NOTIF', False):
            print(f"[TRACE:MAIL:open] memo_id={memo_id_int} viewer_opened=True")

        dlg = MemoViewDialog(dict(memo_data), self)
        dlg.exec_()

        mark_result = {'ok': False, 'changed': False}
        try:
            mark_result = self.db.mark_memo_as_read(memo_id_int, self.user_id)
        except Exception as exc:
            if globals().get('DEBUG_MAIL_NOTIF', False):
                print(f"[TRACE:MAIL:read] memo_id={memo_id_int} mark_err={exc}")
            mark_result = {'ok': False, 'changed': False}

        read_ok = bool(mark_result.get('ok'))
        read_changed = bool(mark_result.get('changed'))

        if read_ok and read_changed and hasattr(self.parent_window, '_dismiss_notification'):
            try:
                self.parent_window._dismiss_notification('VIEW_MEMO', memo_id_int)
                if globals().get('DEBUG_MAIL_NOTIF', False):
                    print(f"[TRACE:MAIL:dismiss] key=VIEW_MEMO:{memo_id_int} stored=True")
            except Exception as exc:
                if globals().get('DEBUG_MAIL_NOTIF', False):
                    print(f"[TRACE:MAIL:dismiss] key=VIEW_MEMO:{memo_id_int} stored=False err={exc}")

        if globals().get('DEBUG_MAIL_NOTIF', False) and read_ok and not read_changed:
            print(f"[TRACE:MAIL:dismiss] key=VIEW_MEMO:{memo_id_int} skipped=already-read")
        if refresh_inbox:
            try:
                self.refresh_inbox()
            except Exception:
                pass


    def select_tab(self, code: str | None):
        """Select a communications tab based on code."""
        if code is None:
            if self.tabs.count():
                self.tabs.setCurrentIndex(0)
            return True
        mapping = {
            'inbox': 0,
            'sent': 1,
        }
        idx = mapping.get(str(code))
        if idx is None:
            return False
        if 0 <= idx < self.tabs.count():
            self.tabs.setCurrentIndex(idx)
            return True
        return False

class MemoViewDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نمایش جزئیات یک نامه (فقط خواندنی)."""
    def __init__(self, memo_data: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"مشاهده نامه: {memo_data.get('subject', '')}")
        self.setMinimumSize(600, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        to_list = ", ".join(memo_data.get('to_list') or [])
        cc_list = ", ".join(memo_data.get('cc_list') or [])
        
        form_layout.addRow("شماره نامه:", QtWidgets.QLabel(f"<b>{memo_data.get('memo_number')}</b>"))
        form_layout.addRow("از:", QtWidgets.QLabel(memo_data.get('author_name', '')))
        form_layout.addRow("به:", QtWidgets.QLabel(to_list))
        if cc_list:
            form_layout.addRow("رونوشت:", QtWidgets.QLabel(cc_list))
        form_layout.addRow("تاریخ:", QtWidgets.QLabel(to_shamsi(memo_data.get('created_at'))))
        form_layout.addRow("موضوع:", QtWidgets.QLabel(f"<b>{memo_data.get('subject')}</b>"))

        body_edit = QtWidgets.QTextEdit()
        body_edit.setPlainText(memo_data.get('body', ''))
        body_edit.setReadOnly(True)
        
        layout.addLayout(form_layout)
        layout.addWidget(body_edit)
        
                    
            
        
# کلاس CardWidget را به طور کامل با این نسخه جایگزین کنید
class CardWidget(QtWidgets.QFrame):
    """یک ویجت کارتی مدرن و جمع‌شونده (نسخه اصلاح شده برای محتوای گرافیکی)."""
    def __init__(self, title, icon_name, color, parent=None):
        super().__init__(parent)
        self.setObjectName("cardWidget")
        self.setStyleSheet("#cardWidget { border: 1px solid #dfe4ea; border-radius: 5px; background-color: white; }")
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        self.header = CardWidgetHeader(title, icon_name, color)
        self.content = QtWidgets.QWidget()
        self.content.setContentsMargins(10, 10, 10, 10)
        
        main_layout.addWidget(self.header)
        main_layout.addWidget(self.content)
        
        self.animation = QtCore.QPropertyAnimation(self.content, b"maximumHeight")
        self.animation.setDuration(200)
        self.header.toggled.connect(self.toggle_content)
        
    def setContentLayout(self, layout):
        old_layout = self.content.layout()
        if old_layout is not None:
            QtWidgets.QWidget().setLayout(old_layout)
        self.content.setLayout(layout)
        self.content.adjustSize()
        self.toggle_content(True)

    def toggle_content(self, expanded):
        """نسخه اصلاح شده: محتوا را قبل و بعد از انیمیشن، مخفی/نمایش می‌دهد."""
        if expanded:
            # قبل از باز شدن، ویجت را نمایش بده
            self.content.setVisible(True)
            start_height = 0
            end_height = self.content.sizeHint().height()
        else:
            start_height = self.content.height()
            end_height = 0
        
        self.animation.setStartValue(start_height)
        self.animation.setEndValue(end_height)
        # پس از اتمام انیمیشن بسته شدن، ویجت را مخفی کن
        if not expanded:
            self.animation.finished.connect(lambda: self.content.setVisible(False))
        else:
            # اطمینان از حذف کانکشن‌های قبلی برای جلوگیری از اجرای چندباره
            try: self.animation.finished.disconnect()
            except TypeError: pass

        self.animation.start()
        
# این کلاس کاملاً جدید را به انتهای فایل اضافه کنید
class TaskCardWidget(QtWidgets.QFrame):
    """یک کارت گرافیکی زیبا برای نمایش یک وظیفه در بورد کانبان."""
    approveClicked = QtCore.pyqtSignal(int)
    rejectClicked = QtCore.pyqtSignal(int)
    detailsClicked = QtCore.pyqtSignal(dict)

# در کلاس TaskCardWidget، این متد را جایگزین کنید

    def __init__(self, task_data: dict, parent=None):
        super().__init__(parent)
        self.task_data = task_data
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setObjectName("taskCard")
        self.setStyleSheet("""
            QFrame#taskCard {
                background-color: white;
                border: 1px solid #dfe4ea;
                border-radius: 6px;
            }
        """)

        main_layout = QtWidgets.QVBoxLayout(self)

        # بخش هدر کارت
        header_layout = QtWidgets.QHBoxLayout()
        workflow_label = QtWidgets.QLabel(f"<b>{task_data.get('workflow_name', 'فرآیند نامشخص')}</b>")
        header_layout.addWidget(workflow_label)
        header_layout.addStretch()
        main_layout.addLayout(header_layout)

        # بخش بدنه کارت
        step_label = QtWidgets.QLabel(f"مرحله: {task_data.get('step_name', '')}")
        details_text = ""
        if task_data.get('related_table_name') == 'purchase_requests':
            details = task_data.get('details', {})
            details_text = f"برای: «{details.get('item_name', '')}»"
        details_label = QtWidgets.QLabel(details_text)
        details_label.setStyleSheet("color: #6c757d;")
        main_layout.addWidget(step_label)
        main_layout.addWidget(details_label)

        # بخش دکمه‌ها
        btn_layout = QtWidgets.QHBoxLayout()
        btn_details = QtWidgets.QPushButton("جزئیات")
        btn_reject = QtWidgets.QPushButton("رد")
        btn_approve = QtWidgets.QPushButton("تایید")

        btn_reject.setProperty("class", "danger")
        btn_approve.setProperty("class", "primary")

        btn_layout.addWidget(btn_details)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_reject)
        btn_layout.addWidget(btn_approve)
        main_layout.addLayout(btn_layout)

        # اتصال سیگنال‌ها
        task_id = self.task_data['process_instance_id']
        btn_approve.clicked.connect(lambda: self.approveClicked.emit(task_id))
        btn_reject.clicked.connect(lambda: self.rejectClicked.emit(task_id))
        # --- *** اصلاح کلیدی: تبدیل داده به دیکشنری قبل از ارسال *** ---
        btn_details.clicked.connect(lambda: self.detailsClicked.emit(dict(self.task_data)))
    
    def mouseMoveEvent(self, event):
        """برای شروع عملیات Drag & Drop."""
        if event.buttons() != QtCore.Qt.LeftButton:
            return

        drag = QtGui.QDrag(self)
        mime_data = QtCore.QMimeData()
        # ID وظیفه را به عنوان متن ارسال می‌کنیم
        mime_data.setText(str(self.task_data['process_instance_id']))
        drag.setMimeData(mime_data)
        
        # یک تصویر کوچک از کارت را به عنوان پیش‌نمایش درگ نمایش می‌دهیم
        pixmap = self.grab()
        drag.setPixmap(pixmap)
        drag.setHotSpot(event.pos())
        
        drag.exec_(QtCore.Qt.MoveAction)            
                                    
# این کلاس را به طور کامل جایگزین نسخه قبلی کنید
class KanbanColumnWidget(QtWidgets.QListWidget):
    """یک ستون در بورد کانبان که قابلیت پذیرش کارت‌های وظیفه را دارد."""
    def __init__(self, state_key, parent_board):
        super().__init__(parent_board)
        self.state_key = state_key
        self.parent_board = parent_board
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        self.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)
        self.setDefaultDropAction(QtCore.Qt.MoveAction)
        self.setSpacing(10)
        self.setStyleSheet("QListWidget { border: 2px dashed #b0bec5; border-radius: 5px; background-color: #f1f3f5; }")

    def add_task(self, task_data):
        card = TaskCardWidget(task_data, self)
        # اتصال سیگنال‌های کارت به متدهای والد (KanbanBoardWidget)
        card.approveClicked.connect(self.parent_board.approve_task)
        card.rejectClicked.connect(self.parent_board.reject_task)
        card.detailsClicked.connect(self.parent_board.show_task_details)
        
        item = QtWidgets.QListWidgetItem(self)
        item.setSizeHint(card.sizeHint())
        item.setData(Qt.UserRole, task_data['process_instance_id']) # ذخیره ID برای شناسایی
        self.addItem(item)
        self.setItemWidget(item, card)

    # --- *** اصلاح کلیدی: افزودن این دو متد برای فعال‌سازی Drop *** ---
    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()
    # --- ********************************************************** ---

    def dropEvent(self, event):
        if event.source() is not self: # اگر کارت از ستون دیگری آمده بود
            task_id = int(event.mimeData().text())
            
            source_widget = event.source()
            if not isinstance(source_widget, TaskCardWidget): return
            
            source_column = source_widget.parent()
            if not isinstance(source_column, KanbanColumnWidget): return

            task_data = source_column.parent_board.get_task_data_by_id(task_id)

            if task_data:
                self.add_task(task_data)
                # حذف آیتم از لیست مبدا
                for i in range(source_column.count()):
                    if source_column.item(i).data(Qt.UserRole) == task_id:
                        source_column.takeItem(i)
                        break
                
                self.parent_board.update_task_state(task_id, self.state_key)
                event.acceptProposedAction()
        else:
            super().dropEvent(event)
                        
                                                
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class KanbanBoardWidget(QtWidgets.QWidget):
    """ویجت اصلی که بورد کانبان را شامل ستون‌ها و کارت‌ها می‌سازد."""
    task_activated = QtCore.pyqtSignal(dict) 

    def __init__(self, db: DB, user_id: int, user_role_id: int, parent=None):
        super().__init__(parent)
        self.db = db; self.user_id = user_id; self.user_role_id = user_role_id
        self.tasks_data_map = {}
        self.parent_window = parent

        layout = QtWidgets.QHBoxLayout(self); layout.setSpacing(15)

        self.columns = {}; self.column_counts = {}
        column_map = {"new": "جدید", "in_progress": "در حال انجام", "done": "انجام شده"}

        for key, name in column_map.items():
            col_container = QtWidgets.QWidget(); col_layout = QtWidgets.QVBoxLayout(col_container)
            header_layout = QtWidgets.QHBoxLayout(); title_label = QtWidgets.QLabel(f"<h3>{name}</h3>"); count_label = QtWidgets.QLabel("0")
            count_label.setStyleSheet("background-color: #ced4da; color: #495057; border-radius: 8px; padding: 2px 8px; font-weight: bold;"); self.column_counts[key] = count_label
            header_layout.addWidget(title_label); header_layout.addStretch(); header_layout.addWidget(count_label); col_layout.addLayout(header_layout)
            list_widget = KanbanColumnWidget(key, self); self.columns[key] = list_widget; col_layout.addWidget(list_widget); layout.addWidget(col_container)
        self.refresh_board()

    def approve_task(self, task_id):
        """یک وظیفه را با ارسال کد وضعیت و یک دیکشنری خالی، تایید می‌کند."""
        task_data = self.get_task_data_by_id(task_id)
        if task_data:
            # --- *** اصلاح کلیدی: ارسال آرگومان سوم به صورت یک دیکشنری خالی *** ---
            self.parent_window._execute_workflow_action(dict(task_data), QtWidgets.QDialog.Accepted, {})

    def reject_task(self, task_id):
        """
        برای رد کردن یک وظیفه، پنجره کامل اقدام را باز می‌کند تا دلیل از کاربر دریافت شود.
        """
        task_data = self.get_task_data_by_id(task_id)
        if task_data:
            # --- *** بهبود فرآیندی: فراخوانی دیالوگ اصلی برای دریافت دلیل *** ---
            self.show_task_details(dict(task_data))

    # BEGIN REWRITE: KanbanBoardWidget.refresh_board
    def refresh_board(self):
        # خالی‌کردن ستون‌ها
        for col in self.columns.values():
            col.clear()

        # گرفتن وظایف؛ اگر None شد، لیست خالی
        tasks = self.db.get_user_tasks_for_kanban(self.user_id, self.user_role_id) or []

        # مپ امن (اگر کلیدی نبود، رد می‌کنیم)
        self.tasks_data_map = {}
        for t in tasks:
            if not t:
                continue
            pid = t.get('process_instance_id')
            if pid is not None:
                self.tasks_data_map[pid] = t

        # پخش کارت‌ها
        for task in tasks:
            state = (task or {}).get('kanban_state') or 'new'
            if state in self.columns:
                self.columns[state].add_task(task)

        self._update_column_counts()
    # END REWRITE: KanbanBoardWidget.refresh_board

    def update_task_state(self, task_id, new_state):
        self.db.update_task_kanban_state(task_id, new_state)
        self._update_column_counts()
    def get_task_data_by_id(self, task_id):
        return self.tasks_data_map.get(task_id)
    def _update_column_counts(self):
        for key, list_widget in self.columns.items():
            self.column_counts[key].setText(str(list_widget.count()))
    def show_task_details(self, task_data):
        self.parent_window._process_task_action_from_data(task_data)
                            
                                                            
        
class CardWidgetHeader(QtWidgets.QWidget):
    """هدر سفارشی برای کارت‌های داشبورد که قابل کلیک است."""
    toggled = QtCore.pyqtSignal(bool)

    def __init__(self, title, icon_name, color, parent=None):
        super().__init__(parent)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.is_expanded = True
        
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(10, 5, 5, 5)
        
        self.icon_label = QtWidgets.QLabel()
        self.icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(18, 18))
        
        self.title_label = QtWidgets.QLabel(f"<b>{title}</b>")
        
        self.toggle_button = QtWidgets.QToolButton()
        self.toggle_button.setArrowType(QtCore.Qt.DownArrow)
        self.toggle_button.setStyleSheet("QToolButton { border: none; }")
        
        layout.addWidget(self.icon_label)
        layout.addWidget(self.title_label)
        layout.addStretch()
        layout.addWidget(self.toggle_button)
        
        self.setStyleSheet(f"border-bottom: 2px solid {color};")

    def mousePressEvent(self, event):
        self.is_expanded = not self.is_expanded
        self.toggle_button.setArrowType(QtCore.Qt.DownArrow if self.is_expanded else QtCore.Qt.RightArrow)
        self.toggled.emit(self.is_expanded)
        super().mousePressEvent(event)

        
#
# بلوک ۱: این کلاس جدید را قبل از کلاس MainWindow اضافه کنید
#
class NavCardWidget(QtWidgets.QFrame):
    """یک کارت گرافیکی زیبا و قابل کلیک برای راهبری در داشبورد."""
    clicked = QtCore.pyqtSignal()
    
    def __init__(self, title, description, icon_name, color, parent=None):
        super().__init__(parent)
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.setMinimumHeight(150)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        
        self.color_strip = QtWidgets.QFrame()
        self.color_strip.setFixedWidth(10)
        self.color_strip.setStyleSheet(f"background-color: {color};")
        
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(48, 48))
        
        text_layout = QtWidgets.QVBoxLayout()
        title_label = QtWidgets.QLabel(f"<h2>{title}</h2>")
        desc_label = QtWidgets.QLabel(description)
        desc_label.setStyleSheet("color: #6c757d;")
        self.badge_label = QtWidgets.QLabel("")
        self.badge_label.setStyleSheet("background-color: #e44d26; color: white; border-radius: 8px; padding: 2px 8px; font-weight: bold;")
        self.badge_label.hide()
        
        text_layout.addWidget(title_label); text_layout.addWidget(desc_label); text_layout.addStretch()
        
        badge_layout = QtWidgets.QHBoxLayout()
        badge_layout.addStretch(); badge_layout.addWidget(self.badge_label)
        text_layout.addLayout(badge_layout)
        
        main_layout.addWidget(self.color_strip); main_layout.addWidget(icon_label, 0, QtCore.Qt.AlignCenter)
        main_layout.addLayout(text_layout, 1)
        
        self.setObjectName("navCard")
        self.setStyleSheet("#navCard { background-color: white; border-radius: 5px; border: 1px solid #dfe4ea; }")
        
    def mousePressEvent(self, event):
        self.setStyleSheet("#navCard { background-color: #e9ecef; border-radius: 5px; border: 1px solid #ced4da; }")
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        self.setStyleSheet("#navCard { background-color: white; border-radius: 5px; border: 1px solid #dfe4ea; }")
        if self.rect().contains(event.pos()):
            self.clicked.emit()
        super().mouseReleaseEvent(event)
        
    def set_badge_count(self, count):
        if count > 0:
            self.badge_label.setText(str(count))
            self.badge_label.show()
        else:
            self.badge_label.hide()

# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class TasksWidget(QtWidgets.QWidget):
    """ویجت یکپارچه و هوشمند برای نمایش کارتابل وظایف کاربر."""
    task_activated = QtCore.pyqtSignal(dict) 

    def __init__(self, db: DB, user_id: int, user_role_id: int, parent_window, title: str):
        super().__init__(parent_window)
        self.db = db
        self.user_id = user_id
        self.user_role_id = user_role_id
        self.parent_window = parent_window
        
        layout = QtWidgets.QVBoxLayout(self)
        group = QtWidgets.QGroupBox(title)
        group_layout = QtWidgets.QVBoxLayout(group)
        
        self.table = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.table)
        self.table.itemDoubleClicked.connect(self._on_task_activated)
        
        group_layout.addWidget(self.table)
        layout.addWidget(group)

    # BEGIN REWRITE: UI.TasksWidget.refresh_tasks
    def refresh_tasks(self):
        """
        «آخرین وظایف شما» — ستون‌ها: [فرآیند، مرحله، نام کالا(لیست)، شماره فیزیکی، درخواست‌کننده، تاریخ، ID]
        - نام کالا: از details.item_names (۳ نام اول) + «+N قلم» اگر بیشتر بود
        - درخواست‌کننده: details.requester
        - بعد از تایید چون کوئری Pending واقعی شد، آیتم از لیست حذف می‌شود؛ اینجا فقط رندر است.
        """
        from PyQt5 import QtWidgets, QtCore
        from PyQt5.QtGui import QStandardItemModel, QStandardItem
        from PyQt5.QtWidgets import QHeaderView
        import datetime as _dt

        def _clean_dt(v) -> str:
            try:
                if isinstance(v, _dt.datetime): return v.strftime("%Y-%m-%d %H:%M")
                if isinstance(v, _dt.date): return v.strftime("%Y-%m-%d 00:00")
                s = str(v or "").strip().replace("T", " ")
                if "+" in s: s = s.split("+", 1)[0]
                if s.endswith("Z"): s = s[:-1]
                if "." in s: s = s.split(".", 1)[0]
                if len(s) == 10: s = f"{s} 00:00"
                return s[:16] if len(s) >= 16 else s
            except Exception:
                return str(v or "")

        def _to_shamsi_safe(v) -> str:
            try:
                if hasattr(self.parent_window, "to_shamsi"):
                    return self.parent_window.to_shamsi(v, include_time=True) or (_clean_dt(v) or "—")
                if "to_shamsi" in globals():
                    return globals()["to_shamsi"](v, include_time=True) or (_clean_dt(v) or "—")
            except Exception:
                pass
            return _clean_dt(v) or "—"

        # 1) دیتا
        try:
            tasks = self.db.get_pending_tasks_for_user_role(self.user_id, self.user_role_id) or []
        except Exception as e:
            print(f"[UI] refresh_tasks: DB error: {e}")
            tasks = []

        # 2) ردیف‌ها
        rows = []
        for t in tasks:
            t   = t if isinstance(t, dict) else {}
            det = t.get("details") or {}
            pr_id    = t.get("related_record_id") or t.get("pr_id") or t.get("id")
            phys_no  = det.get("physical_no") or t.get("physical_no") or "—"
            req_name = det.get("requester") or det.get("requester_name") or "—"

            names = list(det.get("item_names") or [])
            if names:
                shown = names[:3]
                extra = max(0, int(det.get("items_count") or len(names)) - len(shown))
                name_col = "، ".join(shown) + (f"  +{extra} قلم" if extra > 0 else "")
            else:
                nm = det.get("first_item_name") or det.get("item_name") or "—"
                cnt = int(det.get("items_count") or 0)
                name_col = f"{nm}  +{cnt-1} قلم" if (nm != "—" and cnt > 1) else nm

            date_text = _to_shamsi_safe(t.get("started_at") or t.get("created_at") or t.get("request_date"))
            flow_text = t.get("workflow_name") or "درخواست خرید"
            step_text = t.get("step_name") or "تأیید مدیر واحد"
            rows.append((flow_text, step_text, name_col, phys_no, req_name, date_text, pr_id, t))

        # 3) کنترل و رندر
        table = next((getattr(self, a) for a in ("table", "tblTasks")
                    if hasattr(self, a) and isinstance(getattr(self, a), QtWidgets.QTableWidget)), None)
        view  = next((getattr(self, a) for a in ("tableView", "viewTasks", "view")
                    if hasattr(self, a) and isinstance(getattr(self, a), QtWidgets.QTableView)), None)

        headers = ["فرآیند", "مرحله", "نام کالا", "شماره فیزیکی", "درخواست‌کننده", "تاریخ", "ID"]

        if table is not None:
            try:
                table.setSortingEnabled(False)
                table.clearContents()
                table.setColumnCount(len(headers))
                table.setHorizontalHeaderLabels(headers)
                table.setRowCount(len(rows))
                for i, (flow_text, step_text, name_col, phys_no, req_name, date_text, pr_id, payload) in enumerate(rows):
                    vals = [flow_text, step_text, name_col, phys_no, req_name, date_text, pr_id or ""]
                    for c, v in enumerate(vals):
                        it = QtWidgets.QTableWidgetItem(str(v))
                        if c in (3, 6):
                            it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                        table.setItem(i, c, it)
                    table.item(i, 0).setData(QtCore.Qt.UserRole, payload)
                if hasattr(table, "horizontalHeader"):
                    hh = table.horizontalHeader(); from PyQt5.QtWidgets import QHeaderView
                    hh.setSectionResizeMode(2, QHeaderView.Stretch)
                    for col in (0,1,3,4,5,6): hh.setSectionResizeMode(col, QHeaderView.ResizeToContents)
                table.setSortingEnabled(True)
                if len(rows) > 0: table.selectRow(0)
                return
            except Exception as e:
                print(f"[UI] refresh_tasks (QTableWidget) error: {e}")

        if view is not None:
            try:
                model = QStandardItemModel(max(len(rows), 0), len(headers))
                model.setHorizontalHeaderLabels(headers)
                for r, (flow_text, step_text, name_col, phys_no, req_name, date_text, pr_id, payload) in enumerate(rows):
                    vals = [flow_text, step_text, name_col, phys_no, req_name, date_text, pr_id or ""]
                    for c, val in enumerate(vals):
                        it = QStandardItem(str(val))
                        if c == 0: it.setData(payload, QtCore.Qt.UserRole)
                        model.setItem(r, c, it)
                view.setModel(model)
                if hasattr(view, "resizeColumnsToContents"): view.resizeColumnsToContents()
                return
            except Exception as e:
                print(f"[UI] refresh_tasks (QTableView) error: {e}")

        print("[UI] refresh_tasks: No known tasks view found.")
    # END REWRITE: UI.TasksWidget.refresh_tasks

    def _on_task_activated(self, item: QtWidgets.QTableWidgetItem):
        """با دابل کلیک، سیگنالی حاوی اطلاعات کامل وظیفه را ارسال می‌کند."""
        task_data = self.table.item(item.row(), 0).data(Qt.UserRole)
        if task_data:
            # --- *** اصلاح کلیدی: تبدیل DictRow به dict استاندارد *** ---
            self.task_activated.emit(dict(task_data))
                    
            
                            
                                        
    
# این کلاس را به کد خود اضافه کنید (اگر از قبل وجود دارد، جایگزین کنید)
class FormFieldWidget(QtWidgets.QFrame):
    """یک ویجت سفارشی که یک فیلد را روی بوم طراحی فرم نمایندگی می‌کند و قابل انتخاب است."""
    selected = QtCore.pyqtSignal(object)

    def __init__(self, field_id, field_type_text, field_type_key, field_label, parent=None):
        super().__init__(parent)
        self.field_id = field_id
        self.properties = {'type': field_type_key, 'label': field_label, 'required': False, 'placeholder': '', 'min': None, 'max': None}
        
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.setStyleSheet("QFrame { background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 5px; } QFrame:hover { border-color: #3498db; }")

        layout = QtWidgets.QHBoxLayout(self)
        self.icon_label = QtWidgets.QLabel()
        self.label_widget = QtWidgets.QLabel(f"<b>{field_label}</b>")
        self.required_indicator = QtWidgets.QLabel("")
        self.required_indicator.setStyleSheet("color: red; font-weight: bold; font-size: 14pt;")
        
        layout.addWidget(self.icon_label); layout.addWidget(self.label_widget); layout.addStretch(); layout.addWidget(self.required_indicator)
        self.update_display(field_type_text)

    def mousePressEvent(self, event):
        self.selected.emit(self)
        super().mousePressEvent(event)

    def set_selected(self, is_selected):
        if is_selected:
            self.setStyleSheet("QFrame { background-color: #dbeafe; border: 2px solid #0d6efd; border-radius: 5px; }")
        else:
            self.setStyleSheet("QFrame { background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 5px; } QFrame:hover { border-color: #3498db; }")

    def update_display(self, field_type_text=None):
        self.label_widget.setText(f"<b>{self.properties['label']}</b>")
        self.required_indicator.setText("*" if self.properties.get('required') else "")
        type_to_display = field_type_text or self.properties['type']
        icon_map = {"فیلد متنی": "edit-rename", "فیلد عددی": "format-text-direction-ltr", "فیلد تاریخ": "x-office-calendar", "چک‌باکس": "object-select"}
        icon_name = icon_map.get(type_to_display, 'document-properties')
        self.icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(24, 24))

    def get_data_for_json(self):
        clean_properties = {k: v for k, v in self.properties.items() if v is not None and v != ''}
        return {'id': self.field_id, **clean_properties}
    
    

                
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ReceivePoDialog(QtWidgets.QDialog):
    """دیالوگی برای ثبت دریافت اقلام یک سفارش خرید در انبار (با قابلیت تصمیم‌گیری برای QC)."""
    # BEGIN REWRITE: ReceivePoDialog.__init__
    def __init__(self, db: DB, po_data: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.po_data = po_data
        self.parent_window = parent
        self.setWindowTitle(f"ثبت رسید برای PO: {po_data.get('po_number')}")
        self.setMinimumSize(800, 560)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)

        # اطلاعات بالای فرم
        info_layout = QtWidgets.QFormLayout()
        info_layout.addRow("شماره سفارش:", QtWidgets.QLabel(f"<b>{po_data.get('po_number')}</b>"))
        info_layout.addRow("تامین‌کننده:", QtWidgets.QLabel(f"<b>{po_data.get('supplier_name')}</b>"))

        # فیلدهای جدید: شماره رسید + تاریخ/ساعت دریافت
        from datetime import datetime
        self.txt_receipt_no = QtWidgets.QLineEdit(f"DN-{datetime.now().strftime('%Y%m%d-%H%M%S')}")
        self.dt_received_at = QtWidgets.QDateTimeEdit()
        self.dt_received_at.setCalendarPopup(True)
        self.dt_received_at.setDateTime(QtCore.QDateTime.currentDateTime())
        info_layout.addRow("شمارهٔ رسید (DN):", self.txt_receipt_no)
        info_layout.addRow("تاریخ/ساعت دریافت:", self.dt_received_at)

        layout.addLayout(info_layout)

        # جدول اقلام (همان قبل)
        self.items_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.items_table)
        layout.addWidget(self.items_table)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت نهایی رسید")
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self._load_po_items()
    # END REWRITE: ReceivePoDialog.__init__
    
    # BEGIN ADD: ReceivePoDialog.receipt_meta
    def receipt_meta(self) -> tuple[str | None, str | None]:
        """خروجی: (شمارهٔ رسید، تاریخ/ساعت) به‌صورت رشتهٔ 'YYYY-MM-DD HH:MM:SS'."""
        try:
            dn = (self.txt_receipt_no.text() or "").strip()
        except Exception:
            dn = None
        try:
            dt = self.dt_received_at.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        except Exception:
            dt = None
        return (dn or None), (dt or None)
    # END ADD: ReceivePoDialog.receipt_meta

        
    # BEGIN ADD: ReceivePoDialog._default_location_id
    def _default_location_id(self) -> int:
        """
        اگر کاربر «محل انبار» انتخاب نکرد:
        - اگر آخرین انتخاب در همین دیالوگ وجود دارد، همان؛
        - وگرنه اولین محل موجود از list_locations؛
        - وگرنه 1 (حدس محافظه‌کارانه).
        """
        if getattr(self, "_last_location_id", None):
            try:
                return int(self._last_location_id)
            except Exception:
                pass
        try:
            locs = self.db.list_locations() or []
            if locs:
                first = locs[0]
                # پشتیبانی از فرمت‌های مختلف
                if isinstance(first, dict):
                    for k in ("id", "location_id", "loc_id"):
                        if k in first:
                            return int(first[k])
                try:
                    return int(first[0])  # اگر تاپل (id, label) باشد
                except Exception:
                    pass
        except Exception:
            pass
        return 1
    # END ADD: ReceivePoDialog._default_location_id

    def _load_po_items(self):
        po_id = self.po_data.get('id')
        items = self.db.execute_query("""
            SELECT poi.id, i.id as item_id, i.name, i.requires_qc, poi.quantity as ordered_qty
            FROM purchase_order_items poi
            JOIN items i ON poi.item_id = i.id
            WHERE poi.purchase_order_id = %s
        """, (po_id,))

        headers = ["ID", "کالا", "مقدار سفارش", "مقدار دریافتی", "نیاز به QC؟", "شماره بچ", "تاریخ انقضا", "محل انبارش"]
        self.items_table.setColumnCount(len(headers)); self.items_table.setHorizontalHeaderLabels(headers)
        self.items_table.setRowCount(len(items)); self.items_table.setColumnHidden(0, True)

        all_locations = self.db.list_locations(exclude_warehouses=['Production'])

        for r, item in enumerate(items):
            self.items_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.items_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['name']))
            self.items_table.setItem(r, 2, NumericTableWidgetItem(str(item['ordered_qty'])))

            qty_edit = QtWidgets.QLineEdit(str(item['ordered_qty'])); qty_edit.setValidator(QtGui.QDoubleValidator(0, item['ordered_qty'], 3)); self.items_table.setCellWidget(r, 3, qty_edit)

            qc_check_widget = QtWidgets.QWidget(); chk_layout = QtWidgets.QHBoxLayout(qc_check_widget)
            chk_box = QtWidgets.QCheckBox(); chk_box.setChecked(item.get('requires_qc', True)); chk_layout.addWidget(chk_box); chk_layout.setAlignment(QtCore.Qt.AlignCenter)
            self.items_table.setCellWidget(r, 4, qc_check_widget)

            batch_edit = QtWidgets.QLineEdit(f"PO-{self.po_data.get('po_number')}-{r+1}"); self.items_table.setCellWidget(r, 5, batch_edit)
            expiry_edit = QtWidgets.QLineEdit(); expiry_edit.setInputMask("0000/00/00;_"); self.items_table.setCellWidget(r, 6, expiry_edit)
            loc_combo = QtWidgets.QComboBox()
            for loc in all_locations: loc_combo.addItem(loc['loc_label'], loc['id'])
            self.items_table.setCellWidget(r, 7, loc_combo)

        self.items_table.resizeColumnsToContents()
        self.items_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    # BEGIN REWRITE: ReceivePoDialog.get_received_data
    def get_received_data(self):
        """
        داده‌های دریافت‌شده را از جدول می‌خواند و تمیز برمی‌گرداند.
        کنترل‌ها:
        - مقدار دریافتی باید > ۰ باشد.
        - اگر تاریخ انقضا وارد شده، به میلادی تبدیل شود؛ در صورت خطا پیام بدهد.
        - اگر «محل انبار» انتخاب نشده باشد، محل پیش‌فرض گذاشته می‌شود.
        خروجی: لیستی از دیکشنری‌ها برای ارسال به پایگاه.
        """
        from PyQt5 import QtWidgets
        from datetime import date
        received_items = []

        # کمک: پیام خطای ردیف
        def _warn(msg):
            QtWidgets.QMessageBox.warning(self, "خطا در ورودی", msg)

        try:
            rows = self.items_table.rowCount()
        except Exception:
            _warn("جدول اقلام دریافت در دسترس نیست.")
            return []

        for r in range(rows):
            try:
                # شناسهٔ ردیف سفارش (ستون 0)
                po_item_id = int(self.items_table.item(r, 0).text())
            except Exception:
                # اگر شناسه موجود نیست، این ردیف را نادیده بگیر
                continue

            # مقدار دریافتی (ستون 3)
            qty_received = 0.0
            w_qty = self.items_table.cellWidget(r, 3)
            if hasattr(w_qty, "text"):
                s = (w_qty.text() or "").replace(",", ".").strip()
                if s:
                    try:
                        qty_received = float(s)
                    except Exception:
                        _warn(f"ردیف {r+1}: مقدار دریافتی نامعتبر است.")
                        return []
            if qty_received <= 0:
                # ردیف بدون دریافت را صرفاً رد می‌کنیم
                continue

            # شماره بچ (ستون 5)
            batch_no = ""
            w_batch = self.items_table.cellWidget(r, 5)
            if hasattr(w_batch, "text"):
                batch_no = (w_batch.text() or "").strip()

            # تاریخ انقضا (ستون 6) ⇒ به میلادی
            expiry_date = ""
            w_exp = self.items_table.cellWidget(r, 6)
            if hasattr(w_exp, "text"):
                exp_in = (w_exp.text() or "").strip()
                if exp_in:
                    try:
                        # تابع تبدیل در فایل موجود است
                        expiry_date = shamsi_to_gregorian(exp_in)
                    except Exception:
                        _warn(f"ردیف {r+1}: تاریخ انقضا نامعتبر است.")
                        return []

            # نیاز به QC؟ (ستون 4)
            requires_qc = False
            try:
                requires_qc = self.items_table.cellWidget(r, 4).findChild(QtWidgets.QCheckBox).isChecked()
            except Exception:
                requires_qc = False

            # محل انبار (ستون 7) ⇒ اگر انتخاب نشده، پیش‌فرض
            location_id = None
            w_loc = self.items_table.cellWidget(r, 7)
            if hasattr(w_loc, "currentData"):
                location_id = w_loc.currentData()
            if not location_id:
                location_id = self._default_location_id()
            else:
                # آخرین محل انتخابی را به خاطر بسپاریم
                try:
                    self._last_location_id = int(location_id)
                except Exception:
                    pass

            received_items.append({
                "po_item_id": po_item_id,
                "qty": float(qty_received),
                "requires_qc": bool(requires_qc),
                "batch_no": batch_no,
                "expiry_date": expiry_date,  # ممکن است خالی باشد
                "location_id": int(location_id)
            })

        return received_items

    # BEGIN ADD: ReceivePoDialog.accept
    def accept(self):
        """پیش‌بررسی قبل از ثبت: شماره رسید، محل انبار، تاریخ انقضا."""
        from PyQt5 import QtWidgets
        from datetime import datetime, date

        # ۱) شمارهٔ رسید: اگر خالی بود، خودکار بساز و به کاربر خبر بده
        try:
            dn = (self.txt_receipt_no.text() or "").strip()
        except Exception:
            dn = ""
        if not dn:
            auto_dn = f"DN-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
            self.txt_receipt_no.setText(auto_dn)
            QtWidgets.QMessageBox.information(self, "شمارهٔ رسید",
                                            f"شمارهٔ رسید خالی بود؛ «{auto_dn}» گذاشته شد.")

        # ۲) بررسی ردیف‌ها برای محل انبار انتخاب‌نشده
        rows = self.items_table.rowCount()
        missing_loc_rows = []
        for r in range(rows):
            # مقدار دریافتی > ۰؟
            w_qty = self.items_table.cellWidget(r, 3)
            qtxt = (w_qty.text() if hasattr(w_qty, "text") else "").replace(",", ".").strip()
            q = 0.0
            try:
                q = float(qtxt) if qtxt else 0.0
            except Exception:
                q = 0.0
            if q <= 0:
                continue
            # محل؟
            loc_combo = self.items_table.cellWidget(r, 7)
            loc_id = loc_combo.currentData() if hasattr(loc_combo, "currentData") else None
            if loc_id in (None, "", 0):
                missing_loc_rows.append(r)

        if missing_loc_rows:
            msg = f"{len(missing_loc_rows)} ردیف بدون «محل انبار» هستند.\n" \
                f"در صورت ادامه، برای این ردیف‌ها «محل پیش‌فرض» گذاشته می‌شود.\n" \
                f"ادامه بدهم؟"
            ret = QtWidgets.QMessageBox.question(self, "محل پیش‌فرض", msg,
                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if ret != QtWidgets.QMessageBox.Yes:
                return
            # اعمال محل پیش‌فرض روی همان ردیف‌ها
            try:
                default_loc = int(self._default_location_id())
            except Exception:
                default_loc = 1
            for r in missing_loc_rows:
                loc_combo = self.items_table.cellWidget(r, 7)
                if hasattr(loc_combo, "findData"):
                    idx = loc_combo.findData(default_loc)
                    if idx >= 0 and hasattr(loc_combo, "setCurrentIndex"):
                        loc_combo.setCurrentIndex(idx)

        # ۳) بررسی تاریخ‌های انقضا (اگر وارد شده‌اند)
        today = date.today()
        near_bad = 0
        for r in range(rows):
            w_qty = self.items_table.cellWidget(r, 3)
            qtxt = (w_qty.text() if hasattr(w_qty, "text") else "").strip()
            try:
                q = float(qtxt.replace(",", ".")) if qtxt else 0.0
            except Exception:
                q = 0.0
            if q <= 0:
                continue

            w_exp = self.items_table.cellWidget(r, 6)
            exp_in = (w_exp.text() if hasattr(w_exp, "text") else "").strip()
            if not exp_in:
                continue
            try:
                exp_g = shamsi_to_gregorian(exp_in)  # خروجی: YYYY-MM-DD
                y, m, d = [int(x) for x in exp_g.split("-")]
                exp_dt = date(y, m, d)
                if exp_dt < today:
                    near_bad += 1
            except Exception:
                QtWidgets.QMessageBox.warning(self, "تاریخ انقضا",
                                            f"ردیف {r+1}: تاریخ انقضا نامعتبر است.")
                return

        if near_bad > 0:
            ret = QtWidgets.QMessageBox.question(
                self, "هشدار انقضا",
                f"{near_bad} ردیف تاریخ انقضای گذشته دارند. ادامه بدهم؟",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if ret != QtWidgets.QMessageBox.Yes:
                return

        # همه‌چیز اوکی؛ تأیید دیالوگ
        super().accept()
    # END ADD: ReceivePoDialog.accept
        
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class SelectPoDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب یک سفارش خرید باز."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("انتخاب سفارش خرید برای ثبت رسید")
        self.setMinimumSize(700, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("لطفاً سفارش خریدی که کالای آن را تحویل گرفته‌اید، از لیست زیر انتخاب کنید:"))
        
        self.table = QtWidgets.QTableWidget()
        parent._style_table(self.table)
        layout.addWidget(self.table)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ادامه")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self._load_open_pos()

    def _load_open_pos(self):
        orders = self.db.execute_query("SELECT po.*, s.name as supplier_name FROM purchase_orders po JOIN suppliers s ON po.supplier_id = s.id WHERE po.status = 'تایید شده' ORDER BY po.id DESC")
        
        headers = ["ID", "شماره PO", "تامین‌کننده", "تاریخ صدور"]
        self.table.setColumnCount(len(headers)); self.table.setHorizontalHeaderLabels(headers)
        self.table.setRowCount(len(orders))

        for r, order in enumerate(orders):
            self.table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
            self.table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['po_number']))
            self.table.setItem(r, 2, QtWidgets.QTableWidgetItem(order['supplier_name']))
            self.table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(order['issue_date'])))

        self.table.setColumnHidden(0, True)
        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(self.table, "هیچ سفارش خرید بازی برای دریافت کالا وجود ندارد.")

    def get_selected_po_id(self):
        selected = self.table.selectedItems()
        if not selected:
            return None
        return int(self.table.item(selected[0].row(), 0).text())
    
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class IncomingQCWidget(QtWidgets.QWidget):
    """ویجت میزکار واحد کنترل کیفیت برای بازرسی کالاهای ورودی در قرنطینه (با رفرش خودکار)."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.toast = getattr(parent, 'toast', None)
        self.parent_window = parent

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        # نوار ابزار بالا حذف شد چون دکمه رفرش دیگر لازم نیست
        
        self.tbl_quarantine = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_quarantine)
        layout.addWidget(self.tbl_quarantine, 1)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), " رد کیفی")
        btn_reject.setProperty("class", "danger")
        btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید کیفی")
        btn_approve.setProperty("class", "primary")
        
        btn_layout.addStretch()
        btn_layout.addWidget(btn_reject)
        btn_layout.addWidget(btn_approve)
        layout.addLayout(btn_layout)

        # --- بخش جدید: تعریف و تنظیم تایمر برای رفرش خودکار ---
        self.refresh_timer = QtCore.QTimer(self)
        self.refresh_timer.setInterval(60000) # هر ۶۰ ثانیه
        self.refresh_timer.timeout.connect(self.refresh_data)
        # ---------------------------------------------------------

        btn_approve.clicked.connect(self._approve_selected)
        btn_reject.clicked.connect(self._reject_selected)

        self.refresh_data() # اولین اجرا به صورت دستی

    def showEvent(self, event):
        """وقتی ویجت نمایش داده می‌شود، تایمر را فعال می‌کند."""
        super().showEvent(event)
        self.refresh_timer.start()
        print("INFO: QC Widget became visible. Auto-refresh timer started.")

    def hideEvent(self, event):
        """وقتی ویجت مخفی می‌شود، تایمر را متوقف می‌کند تا منابع مصرف نشود."""
        super().hideEvent(event)
        self.refresh_timer.stop()
        print("INFO: QC Widget hidden. Auto-refresh timer stopped.")

    def refresh_data(self):
        """لیست اقلام در قرنطینه را از دیتابیس خوانده و در جدول نمایش می‌دهد."""
        try:
            # برای جلوگیری از پرش ناگهانی هنگام رفرش، آیتم انتخاب شده فعلی را ذخیره می‌کنیم
            current_selected_id = self._get_selected_stock_id(silent=True)

            items = self.db.get_quarantined_stock()
            self.tbl_quarantine.setSortingEnabled(False) # برای عملکرد بهتر حین آپدیت
            self.tbl_quarantine.setRowCount(0)
            headers = ['ID موجودی', 'نام کالا', 'شماره بچ', 'تامین‌کننده', 'مقدار', 'واحد', 'محل در انبار', 'تاریخ انقضا']
            self.tbl_quarantine.setColumnCount(len(headers))
            self.tbl_quarantine.setHorizontalHeaderLabels(headers)
            self.tbl_quarantine.setRowCount(len(items))

            new_row_to_select = -1
            for r, item in enumerate(items):
                stock_id = item['stock_id']
                if stock_id == current_selected_id:
                    new_row_to_select = r
                
                self.tbl_quarantine.setItem(r, 0, QtWidgets.QTableWidgetItem(str(stock_id)))
                self.tbl_quarantine.setItem(r, 1, QtWidgets.QTableWidgetItem(item['item_name']))
                self.tbl_quarantine.setItem(r, 2, QtWidgets.QTableWidgetItem(item['batch_no']))
                self.tbl_quarantine.setItem(r, 3, QtWidgets.QTableWidgetItem(item.get('supplier_name', '---')))
                self.tbl_quarantine.setItem(r, 4, NumericTableWidgetItem(str(item['qty'])))
                self.tbl_quarantine.setItem(r, 5, QtWidgets.QTableWidgetItem(item.get('unit', '')))
                self.tbl_quarantine.setItem(r, 6, QtWidgets.QTableWidgetItem(item['location_label']))
                self.tbl_quarantine.setItem(r, 7, QtWidgets.QTableWidgetItem(to_shamsi(item.get('expiry_date'))))
            
            self.tbl_quarantine.setColumnHidden(0, True)
            self.tbl_quarantine.resizeColumnsToContents()
            self.tbl_quarantine.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            self.tbl_quarantine.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_quarantine, "هیچ کالایی در حال حاضر در قرنطینه نیست.")
            
            # انتخاب قبلی کاربر را بازیابی می‌کنیم
            if new_row_to_select != -1:
                self.tbl_quarantine.selectRow(new_row_to_select)

            self.tbl_quarantine.setSortingEnabled(True)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست قرنطینه: {e}", "critical")

    def _get_selected_stock_id(self, silent=False):
        """ID ردیف انتخاب شده در جدول را برمی‌گرداند."""
        selected_rows = self.tbl_quarantine.selectionModel().selectedRows()
        if not selected_rows:
            if not silent and self.toast:
                self.toast.show_message("لطفاً ابتدا یک ردیف را از جدول انتخاب کنید.", "warning")
            return None
        try:
            return int(self.tbl_quarantine.item(selected_rows[0].row(), 0).text())
        except (AttributeError, ValueError):
            return None

    def _approve_selected(self):
        """کالای انتخاب شده را تایید کیفی می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        stock_details = self.db.get_stock_details_by_id(stock_id)
        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی", 
            f"آیا از تایید کیفی کالای «{stock_details.get('item_name')}» با بچ نامبر «{stock_details.get('batch_no')}» مطمئن هستید؟\n"
            "این کالا پس از تایید، به موجودی قابل مصرف انبار اضافه خواهد شد.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
        
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.update_stock_status(stock_id, 'موجود', self.user_id, "تایید شده توسط واحد کنترل کیفیت.")
                if self.toast: self.toast.show_message("✔ کالا با موفقیت تایید و به موجودی اصلی اضافه شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))

    def _reject_selected(self):
        """کالای انتخاب شده را رد کیفی می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کیفی", "لطفاً دلیل رد کردن این کالا را به طور کامل وارد کنید:")
        if ok and reason.strip():
            try:
                self.db.update_stock_status(stock_id, 'رد شده', self.user_id, f"رد کیفی: {reason.strip()}")
                if self.toast: self.toast.show_message("✖ کالا رد کیفی شد و به موجودی 'رد شده' منتقل گردید.", "info")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
        elif ok:
            self.toast.show_message("عملیات لغو شد. دلیل رد کیفی باید وارد شود.", "warning")
            
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class QCHistoryWidget(QtWidgets.QWidget):
    """ویجت بایگانی و جستجوی گزارش‌های کنترل کیفیت."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        # بخش فیلتر و جستجو
        filter_group = QtWidgets.QGroupBox("جستجو در گزارش‌ها")
        filter_layout = QtWidgets.QHBoxLayout(filter_group)
        self.product_search = QtWidgets.QLineEdit(placeholderText="بخشی از نام محصول...")
        self.batch_search = QtWidgets.QLineEdit(placeholderText="بخشی از شماره بچ...")
        btn_search = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), " جستجو")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), " پاک کردن فیلتر")

        filter_layout.addWidget(QtWidgets.QLabel("نام محصول:"))
        filter_layout.addWidget(self.product_search)
        filter_layout.addWidget(QtWidgets.QLabel("شماره بچ:"))
        filter_layout.addWidget(self.batch_search)
        filter_layout.addStretch()
        filter_layout.addWidget(btn_search)
        filter_layout.addWidget(btn_clear)
        layout.addWidget(filter_group)

        # جدول نتایج
        self.tbl_history = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_history)
        self.tbl_history.itemDoubleClicked.connect(self._show_form_details)
        layout.addWidget(self.tbl_history, 1)

        btn_search.clicked.connect(self.search_records)
        btn_clear.clicked.connect(self._clear_search)

        self.search_records() # بارگذاری اولیه

    def search_records(self):
        """جستجو را اجرا کرده و نتایج را در جدول نمایش می‌دهد."""
        product_name = self.product_search.text().strip()
        batch_no = self.batch_search.text().strip()
        
        try:
            records = self.db.search_qc_form_entries(product_name, batch_no)
            self.tbl_history.setRowCount(0)
            
            # استخراج تمام کلیدهای ممکن از داده‌های JSON برای ساخت هدرهای داینامیک
            all_keys = set()
            for rec in records:
                if isinstance(rec['data'], dict):
                    all_keys.update(rec['data'].keys())
            
            static_headers = ['ID', 'تاریخ ثبت', 'ثبت توسط']
            dynamic_headers = sorted(list(all_keys))
            headers = static_headers + dynamic_headers

            self.tbl_history.setColumnCount(len(headers))
            self.tbl_history.setHorizontalHeaderLabels(headers)
            self.tbl_history.setRowCount(len(records))

            for r, rec in enumerate(records):
                self.tbl_history.setItem(r, 0, QtWidgets.QTableWidgetItem(str(rec['id'])))
                self.tbl_history.setItem(r, 1, QtWidgets.QTableWidgetItem(to_shamsi(rec['submission_date'])))
                self.tbl_history.setItem(r, 2, QtWidgets.QTableWidgetItem(rec['submitted_by']))
                
                data = rec.get('data', {})
                for c, key in enumerate(dynamic_headers):
                    value = data.get(key, '')
                    self.tbl_history.setItem(r, 3 + c, QtWidgets.QTableWidgetItem(str(value)))
            
            self.tbl_history.setColumnHidden(0, True)
            self.tbl_history.resizeColumnsToContents()
            set_empty_placeholder(self.tbl_history, "هیچ گزارش کنترل کیفی با این مشخصات یافت نشد.")

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در جستجو: {e}", "critical")

    def _clear_search(self):
        self.product_search.clear()
        self.batch_search.clear()
        self.search_records()

    def _show_form_details(self, item):
        """یک دیالوگ برای نمایش کامل اطلاعات فرم انتخاب شده باز می‌کند."""
        # این بخش در آینده می‌تواند یک دیالوگ زیباتر برای نمایش فرم باشد
        # فعلا جزئیات را در یک QMessageBox نمایش می‌دهیم
        row = item.row()
        details = []
        for col in range(self.tbl_history.columnCount()):
            header = self.tbl_history.horizontalHeaderItem(col).text()
            cell_item = self.tbl_history.item(row, col)
            value = cell_item.text() if cell_item else ""
            if header != 'ID':
                details.append(f"<b>{header}:</b> {value}")
        
        QtWidgets.QMessageBox.information(self, "جزئیات کامل گزارش", "<br>".join(details))
        
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class NonConformingWidget(QtWidgets.QWidget):
    """ویجت مدیریت اقلام نامنطبق (با رفرش خودکار)."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        self.tbl_rejected = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_rejected)
        layout.addWidget(self.tbl_rejected, 1)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_scrap = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " ثبت به عنوان ضایعات")
        btn_return = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " مرجوع به تامین‌کننده")
        btn_return.setProperty("class", "primary")
        
        btn_layout.addStretch()
        btn_layout.addWidget(btn_scrap)
        btn_layout.addWidget(btn_return)
        layout.addLayout(btn_layout)

        # --- بخش جدید: تعریف و تنظیم تایمر برای رفرش خودکار ---
        self.refresh_timer = QtCore.QTimer(self)
        self.refresh_timer.setInterval(60000) # هر ۶۰ ثانیه
        self.refresh_timer.timeout.connect(self.refresh_data)
        # ---------------------------------------------------------

        btn_return.clicked.connect(self._return_to_supplier)
        btn_scrap.clicked.connect(self._scrap_item)

        self.refresh_data() # اولین اجرا به صورت دستی

    def showEvent(self, event):
        """وقتی ویجت نمایش داده می‌شود، تایمر را فعال می‌کند."""
        super().showEvent(event)
        self.refresh_timer.start()
        print("INFO: Non-Conforming Widget became visible. Auto-refresh timer started.")

    def hideEvent(self, event):
        """وقتی ویجت مخفی می‌شود، تایمر را متوقف می‌کند."""
        super().hideEvent(event)
        self.refresh_timer.stop()
        print("INFO: Non-Conforming Widget hidden. Auto-refresh timer stopped.")

    def refresh_data(self):
        """لیست اقلام رد کیفی شده را از دیتابیس خوانده و در جدول نمایش می‌دهد."""
        try:
            current_selected_id = self._get_selected_stock_id(silent=True)

            items = self.db.get_rejected_stock()
            self.tbl_rejected.setSortingEnabled(False)
            self.tbl_rejected.setRowCount(0)
            headers = ['ID موجودی', 'نام کالا', 'شماره بچ', 'مقدار', 'واحد', 'محل در انبار']
            self.tbl_rejected.setColumnCount(len(headers))
            self.tbl_rejected.setHorizontalHeaderLabels(headers)
            self.tbl_rejected.setRowCount(len(items))

            new_row_to_select = -1
            for r, item in enumerate(items):
                stock_id = item['stock_id']
                if stock_id == current_selected_id:
                    new_row_to_select = r

                self.tbl_rejected.setItem(r, 0, QtWidgets.QTableWidgetItem(str(stock_id)))
                self.tbl_rejected.setItem(r, 1, QtWidgets.QTableWidgetItem(item['item_name']))
                self.tbl_rejected.setItem(r, 2, QtWidgets.QTableWidgetItem(item['batch_no']))
                self.tbl_rejected.setItem(r, 3, NumericTableWidgetItem(str(item['qty'])))
                self.tbl_rejected.setItem(r, 4, QtWidgets.QTableWidgetItem(item.get('unit', '')))
                self.tbl_rejected.setItem(r, 5, QtWidgets.QTableWidgetItem(item['location_label']))
            
            self.tbl_rejected.setColumnHidden(0, True)
            self.tbl_rejected.resizeColumnsToContents()
            self.tbl_rejected.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_rejected, "هیچ کالای رد کیفی شده‌ای برای تعیین تکلیف وجود ندارد.")

            if new_row_to_select != -1:
                self.tbl_rejected.selectRow(new_row_to_select)

            self.tbl_rejected.setSortingEnabled(True)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست اقلام مردود: {e}", "critical")

    def _get_selected_stock_id(self, silent=False):
        """ID ردیف انتخاب شده در جدول را برمی‌گرداند."""
        selected_rows = self.tbl_rejected.selectionModel().selectedRows()
        if not selected_rows:
            if not silent and self.toast:
                self.toast.show_message("لطفاً ابتدا یک ردیف را از جدول انتخاب کنید.", "warning")
            return None
        try:
            return int(self.tbl_rejected.item(selected_rows[0].row(), 0).text())
        except (AttributeError, ValueError):
            return None

    def _return_to_supplier(self):
        """فرآیند تعیین تکلیف یک کالا به عنوان 'مرجوعی' را اجرا می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        notes, ok = QtWidgets.QInputDialog.getText(self, "مرجوع به تامین‌کننده", "توضیحات یا شماره سند مرجوعی را وارد کنید:")
        if ok and notes.strip():
            try:
                self.db.resolve_rejected_stock(stock_id, 'مرجوع به تامین‌کننده', self.user_id, notes)
                if self.toast: self.toast.show_message("✔ کالا با موفقیت به عنوان 'مرجوعی' ثبت و از موجودی خارج شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
        elif ok:
            if self.toast: self.toast.show_message("عملیات لغو شد. وارد کردن توضیحات الزامی است.", "warning")

    def _scrap_item(self):
        """فرآیند تعیین تکلیف یک کالا به عنوان 'ضایعات' را اجرا می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        notes, ok = QtWidgets.QInputDialog.getText(self, "ثبت به عنوان ضایعات", "دلیل ضایعات شدن کالا را وارد کنید:")
        if ok and notes.strip():
            try:
                self.db.resolve_rejected_stock(stock_id, 'ضایعات', self.user_id, notes)
                if self.toast: self.toast.show_message("✔ کالا با موفقیت به عنوان 'ضایعات' ثبت و از موجودی خارج شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
        elif ok:
            if self.toast: self.toast.show_message("عملیات لغو شد. وارد کردن دلیل الزامی است.", "warning")
            
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
class CustomerManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت کامل مشتریان."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_customer_id = None

        self.setWindowTitle("مدیریت مشتریان")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 600)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        list_panel = QtWidgets.QWidget(); list_layout = QtWidgets.QVBoxLayout(list_panel)
        list_layout.addWidget(QtWidgets.QLabel("<b>لیست مشتریان</b>"))
        self.tbl_customers = QtWidgets.QTableWidget()
        parent._style_table(self.tbl_customers)
        self.tbl_customers.itemClicked.connect(self._populate_fields_for_edit)
        list_layout.addWidget(self.tbl_customers)
        splitter.addWidget(list_panel)

        form_panel = QtWidgets.QWidget(); form_layout = QtWidgets.QVBoxLayout(form_panel)
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش مشتری")
        self.form = QtWidgets.QFormLayout(form_group)
        self.form.setSpacing(10)
        
        self.name_edit = QtWidgets.QLineEdit()
        self.contact_edit = QtWidgets.QLineEdit()
        self.phone_edit = QtWidgets.QLineEdit()
        self.email_edit = QtWidgets.QLineEdit()
        self.address_edit = QtWidgets.QTextEdit(); self.address_edit.setFixedHeight(60)
        self.tax_id_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QTextEdit(); self.notes_edit.setFixedHeight(60)
        self.is_active_check = QtWidgets.QCheckBox("فعال"); self.is_active_check.setChecked(True)

        self.form.addRow("نام مشتری/شرکت (*):", self.name_edit)
        self.form.addRow("فرد رابط:", self.contact_edit)
        self.form.addRow("تلفن:", self.phone_edit)
        self.form.addRow("ایمیل:", self.email_edit)
        self.form.addRow("آدرس:", self.address_edit)
        self.form.addRow("کد اقتصادی/شناسه ملی:", self.tax_id_edit)
        self.form.addRow("یادداشت:", self.notes_edit)
        self.form.addRow("وضعیت:", self.is_active_check)
        form_layout.addWidget(form_group)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_save.setProperty("class", "primary")
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف"); btn_delete.setProperty("class", "danger")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن فرم")
        btn_layout.addWidget(btn_save); btn_layout.addWidget(btn_delete); btn_layout.addStretch(); btn_layout.addWidget(btn_clear)
        form_layout.addLayout(btn_layout)
        
        splitter.addWidget(form_panel)
        splitter.setSizes([550, 350])

        btn_save.clicked.connect(self._save_customer)
        btn_delete.clicked.connect(self._delete_customer)
        btn_clear.clicked.connect(self._clear_fields)
        
        self._load_customers()

    def _load_customers(self):
        self.tbl_customers.setRowCount(0)
        customers = self.db.get_all_customers()
        headers = ['ID', 'نام مشتری', 'فرد رابط', 'تلفن', 'وضعیت']
        self.tbl_customers.setColumnCount(len(headers))
        self.tbl_customers.setHorizontalHeaderLabels(headers)
        self.tbl_customers.setColumnHidden(0, True)
        self.tbl_customers.setRowCount(len(customers))
        for r, cust in enumerate(customers):
            self.tbl_customers.setItem(r, 0, QtWidgets.QTableWidgetItem(str(cust['id'])))
            self.tbl_customers.setItem(r, 1, QtWidgets.QTableWidgetItem(cust['name']))
            self.tbl_customers.setItem(r, 2, QtWidgets.QTableWidgetItem(cust.get('contact_person', '')))
            self.tbl_customers.setItem(r, 3, QtWidgets.QTableWidgetItem(cust.get('phone', '')))
            status_item = QtWidgets.QTableWidgetItem("فعال" if cust.get('is_active') else "غیرفعال")
            status_item.setForeground(QtGui.QColor("green") if cust.get('is_active') else QtGui.QColor("red"))
            self.tbl_customers.setItem(r, 4, status_item)
        self.tbl_customers.resizeColumnsToContents()
        self.tbl_customers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.current_customer_id = int(self.tbl_customers.item(row, 0).text())
        customer_details = self.db.execute_query("SELECT * FROM customers WHERE id = %s", (self.current_customer_id,), fetch_one=True)
        if not customer_details: return

        self.name_edit.setText(customer_details.get('name', ''))
        self.contact_edit.setText(customer_details.get('contact_person', ''))
        self.phone_edit.setText(customer_details.get('phone', ''))
        self.email_edit.setText(customer_details.get('email', ''))
        self.address_edit.setPlainText(customer_details.get('address', ''))
        self.tax_id_edit.setText(customer_details.get('tax_id', ''))
        self.notes_edit.setPlainText(customer_details.get('notes', ''))
        self.is_active_check.setChecked(customer_details.get('is_active', True))

    def _clear_fields(self):
        self.current_customer_id = None
        self.tbl_customers.clearSelection()
        for widget in [self.name_edit, self.contact_edit, self.phone_edit, self.email_edit, self.tax_id_edit]: widget.clear()
        for widget in [self.address_edit, self.notes_edit]: widget.clear()
        self.is_active_check.setChecked(True)
        self.name_edit.setFocus()

    def _save_customer(self):
        customer_data = {
            "name": self.name_edit.text().strip(),
            "contact_person": self.contact_edit.text().strip(),
            "phone": self.phone_edit.text().strip(),
            "email": self.email_edit.text().strip(),
            "address": self.address_edit.toPlainText().strip(),
            "tax_id": self.tax_id_edit.text().strip(),
            "notes": self.notes_edit.toPlainText().strip(),
            "is_active": self.is_active_check.isChecked()
        }
        try:
            self.db.add_or_update_customer(customer_data, self.current_customer_id)
            if self.toast: self.toast.show_message("✔ اطلاعات مشتری با موفقیت ذخیره شد.", "success")
            self._load_customers()
            self._clear_fields()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ذخیره‌سازی", str(e))

    def _delete_customer(self):
        if self.current_customer_id is None:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک مشتری را از لیست انتخاب کنید.", "warning")
            return
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف مشتری «{self.name_edit.text()}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_customer(self.current_customer_id)
                if self.toast: self.toast.show_message("✔ مشتری با موفقیت حذف شد.", "info")
                self._load_customers()
                self._clear_fields()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در حذف", f"این مشتری احتمالاً دارای سفارش فروش است و قابل حذف نیست.\n{e}")
                
# کلاس SalesOrderDialog را به طور کامل با این نسخه جایگزین کنید
class SalesOrderDialog(QtWidgets.QDialog):
    """دیالوگ جامع برای ایجاد سفارش فروش (با قابلیت تعیین نوع سفارش)."""
    def __init__(self, db: DB, parent_window):
        super().__init__(parent_window)
        self.db = db
        self.parent_window = parent_window
        self.toast = getattr(parent_window, 'toast', None)
        self.setWindowTitle("ایجاد سفارش فروش جدید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(800, 600)

        main_layout = QtWidgets.QVBoxLayout(self)
        header_group = QtWidgets.QGroupBox("اطلاعات اصلی سفارش")
        form_layout = QtWidgets.QFormLayout(header_group)
        self.customer_combo = QtWidgets.QComboBox()
        self.date_edit = QtWidgets.QLineEdit(to_shamsi(datetime.now()))
        self.date_edit.setInputMask("0000/00/00;_")
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری: توضیحات مربوط به کل سفارش")
        self.order_type_group = QtWidgets.QGroupBox("نوع سفارش")
        order_type_layout = QtWidgets.QHBoxLayout(self.order_type_group)
        self.type_stock = QtWidgets.QRadioButton("فروش از انبار (Stock)")
        self.type_mto = QtWidgets.QRadioButton("سفارش تولید (Make-to-Order)")
        self.type_stock.setChecked(True)
        order_type_layout.addWidget(self.type_stock)
        order_type_layout.addWidget(self.type_mto)
        form_layout.addRow("مشتری (*):", self.customer_combo)
        form_layout.addRow("تاریخ صدور:", self.date_edit)
        form_layout.addRow(self.order_type_group)
        form_layout.addRow("یادداشت:", self.notes_edit)
        main_layout.addWidget(header_group)
        items_group = QtWidgets.QGroupBox("اقلام سفارش")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        self.items_table = QtWidgets.QTableWidget(0, 5)
        self.items_table.setHorizontalHeaderLabels(['ID کالا', 'نام کالا', 'تعداد/مقدار', 'قیمت واحد (ریال)', 'قیمت کل'])
        self.items_table.setColumnHidden(0, True); self.items_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.items_table.itemChanged.connect(self._update_total_price); items_layout.addWidget(self.items_table)
        items_toolbar = QtWidgets.QHBoxLayout(); btn_add_item = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن کالا"); btn_del_item = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف کالا"); items_toolbar.addWidget(btn_add_item); items_toolbar.addWidget(btn_del_item); items_toolbar.addStretch(); self.total_label = QtWidgets.QLabel("<b>مبلغ کل سفارش: 0 ریال</b>"); items_toolbar.addWidget(self.total_label); items_layout.addLayout(items_toolbar); main_layout.addWidget(items_group, 1)
        buttons = QtWidgets.QDialogButtonBox(); btn_cancel = buttons.addButton("انصراف", QtWidgets.QDialogButtonBox.RejectRole); btn_save = buttons.addButton("ذخیره سفارش", QtWidgets.QDialogButtonBox.AcceptRole); btn_save_print = buttons.addButton("ذخیره و صدور پیش‌فاکتور", QtWidgets.QDialogButtonBox.ActionRole); btn_save_print.setProperty("class", "primary"); buttons.rejected.connect(self.reject); btn_save.clicked.connect(self._save_order_and_close); btn_save_print.clicked.connect(self._save_order_and_print); main_layout.addWidget(buttons)
        btn_add_item.clicked.connect(self._add_item_row); btn_del_item.clicked.connect(self._remove_item_row); self._populate_customers()

    def _save_order(self):
        if self.customer_combo.currentIndex() <= 0: self.toast.show_message("لطفاً یک مشتری را انتخاب کنید.", "warning"); return None
        if self.items_table.rowCount() == 0: self.toast.show_message("سفارش فروش باید حداقل شامل یک کالا باشد.", "warning"); return None

        so_data = {
            "customer_id": self.customer_combo.currentData(),
            "issue_date": datetime.now().date(),
            "notes": self.notes_edit.text().strip(),
            "order_type": "MTO" if self.type_mto.isChecked() else "STOCK"
        }
        items_data = []
        for r in range(self.items_table.rowCount()):
            try:
                items_data.append({ "item_id": int(self.items_table.item(r, 0).text()), "quantity": float(self.items_table.item(r, 2).text()), "unit_price": float(self.items_table.item(r, 3).text()) })
            except (ValueError, TypeError, AttributeError): self.toast.show_message(f"اطلاعات در ردیف {r+1} جدول کالاها نامعتبر است.", "error"); return None

        if so_data["order_type"] == "STOCK":
            try:
                with self.db.transaction() as cur:
                    for item in items_data:
                        available_qty = self.db._get_available_stock(item['item_id'], cur)
                        if available_qty < item['quantity']:
                            item_details = self.db.get_item_details(item['item_id']); item_name = item_details.get('name', '')
                            raise ValueError(f"موجودی کالای «{item_name}» برای فروش از انبار کافی نیست. (موجود: {available_qty})")
            except ValueError as e:
                QtWidgets.QMessageBox.warning(self, "موجودی ناکافی", str(e))
                return None

        try:
            so_id = self.db.create_sales_order(so_data, items_data, self.parent_window.user_id)
            self.toast.show_message("✔ سفارش فروش با موفقیت ثبت شد.", "success")
            return so_id
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ثبت سفارش", f"خطا: {e}"); return None

    def _save_order_and_close(self):
        so_id = self._save_order();
        if so_id: self.accept()
    def _save_order_and_print(self):
        so_id = self._save_order();
        if so_id: self.parent_window._generate_proforma_pdf(so_id); self.accept()
    def _populate_customers(self):
        self.customer_combo.addItem("--- انتخاب کنید ---", None); customers = self.db.get_all_customers(active_only=True)
        for cust in customers: self.customer_combo.addItem(cust['name'], cust['id'])
    def _add_item_row(self):
        dlg = ProductSelectionDialog(self.db, self)
        if dlg.exec_() and dlg.selected_product:
            item_data = dlg.selected_product; row_pos = self.items_table.rowCount(); self.items_table.insertRow(row_pos)
            self.items_table.setItem(row_pos, 0, QtWidgets.QTableWidgetItem(str(item_data['id']))); self.items_table.setItem(row_pos, 1, QtWidgets.QTableWidgetItem(item_data['name'])); self.items_table.setItem(row_pos, 2, QtWidgets.QTableWidgetItem("1")); self.items_table.setItem(row_pos, 3, QtWidgets.QTableWidgetItem(str(item_data.get('cost', 0.0)))); total_price_item = QtWidgets.QTableWidgetItem("0"); total_price_item.setFlags(total_price_item.flags() & ~QtCore.Qt.ItemIsEditable); self.items_table.setItem(row_pos, 4, total_price_item); self._update_total_price(); self.items_table.setCurrentCell(row_pos, 2)
    def _remove_item_row(self):
        current_row = self.items_table.currentRow();
        if current_row >= 0: self.items_table.removeRow(current_row); self._update_total_price()
    def _update_total_price(self, item=None):
        if item and item.column() not in [2, 3]: return
        total_order_amount = 0
        for r in range(self.items_table.rowCount()):
            try:
                qty = float(self.items_table.item(r, 2).text()); price = float(self.items_table.item(r, 3).text()); row_total = qty * price
                self.items_table.blockSignals(True); self.items_table.item(r, 4).setText(f"{row_total:,.0f}"); self.items_table.blockSignals(False); total_order_amount += row_total
            except (ValueError, TypeError, AttributeError): continue
        self.total_label.setText(f"<b>مبلغ کل سفارش: {total_order_amount:,.0f} ریال</b>")        
                
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class ProductSelectionDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب یک محصول نهایی از نمای درختی مادر-فرزندی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.selected_product = None
        
        self.setWindowTitle("انتخاب محصول")
        self.setMinimumSize(500, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        self.search_edit = QtWidgets.QLineEdit(placeholderText="جستجوی نام محصول یا پک...")
        self.search_edit.textChanged.connect(self._filter_tree)
        layout.addWidget(self.search_edit)

        self.tree = QtWidgets.QTreeWidget()
        
        self.tree.setAlternatingRowColors(True)
        self.tree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tree.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tree.setStyleSheet("""
            QTreeWidget::item { padding: 8px; }
            QTreeWidget::item:selected { background-color: #e7f1ff; color: #2c3e50; }
            QHeaderView::section { background-color: #ecf0f1; padding: 10px 5px; border-bottom: 2px solid #3498db; font-weight: bold; }
        """)

        self.tree.setHeaderLabels(["محصولات قابل فروش"])
        self.tree.itemDoubleClicked.connect(self.accept_selection)
        layout.addWidget(self.tree)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept_selection)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self._populate_tree()

    def _populate_tree(self):
        """درخت محصولات را با ساختار مادر-فرزندی پر می‌کند."""
        # --- **اصلاح کلیدی: ارسال آرگومان‌های صحیح به متد items_brief** ---
        final_products = self.db.items_brief(category_filter=CATEGORY_FINAL_PRODUCT, limit=10000, offset=0)
        
        items_by_id = {item['id']: dict(item) for item in final_products}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id and parent_id in items_by_id:
                if parent_id not in child_map: child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)
        
        for item_data in sorted(top_level_items, key=lambda x: x['name']):
            parent_item = QtWidgets.QTreeWidgetItem(self.tree)
            parent_item.setText(0, item_data.get('name', ''))
            
            is_parent_product = item_data.get('is_parent_product', False)
            if is_parent_product:
                parent_item.setFlags(parent_item.flags() & ~QtCore.Qt.ItemIsSelectable)
                parent_item.setFont(0, QFont(FONT_FAMILY, 10, QFont.Bold))
            else:
                parent_item.setData(0, QtCore.Qt.UserRole, item_data)

            if item_data['id'] in child_map:
                for child_data in sorted(child_map[item_data['id']], key=lambda x: x['name']):
                    child_item = QtWidgets.QTreeWidgetItem(parent_item)
                    child_item.setText(0, f"  {child_data.get('name', '')}")
                    child_item.setData(0, QtCore.Qt.UserRole, child_data)
        
        self.tree.expandAll()
    
    def _filter_tree(self, text):
        """درخت را بر اساس متن جستجو فیلتر می‌کند."""
        text = text.lower().strip()
        root = self.tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            parent_matches = text in parent_item.text(0).lower()
            
            has_visible_child = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j)
                child_matches = text in child_item.text(0).lower()
                child_item.setHidden(not child_matches)
                if not child_item.isHidden():
                    has_visible_child = True
            
            parent_item.setHidden(not (parent_matches or has_visible_child))

    def accept_selection(self):
        """داده‌های محصول انتخاب شده را ذخیره کرده و دیالوگ را می‌بندد."""
        selected_items = self.tree.selectedItems()
        if not selected_items:
            QtWidgets.QMessageBox.warning(self, "خطا", "لطفاً یک محصول (پک) را انتخاب کنید.")
            return
        
        item_data = selected_items[0].data(0, QtCore.Qt.UserRole)
        if not isinstance(item_data, dict):
            QtWidgets.QMessageBox.warning(self, "خطا", "لطفاً یک پک (زیرمجموعه) را انتخاب کنید، نه محصول مادر.")
            return
            
        self.selected_product = item_data
        self.accept()
                
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class BatchQCInquiryDialog(QtWidgets.QDialog):
    """دیالوگی برای جستجوی پیشرفته و نمایش سوابق کیفی بچ محصول."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.parent_window = parent

        self.setWindowTitle("استعلام سوابق کیفی بچ محصول")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        # بخش جستجوی پیشرفته
        search_group = QtWidgets.QGroupBox("پارامترهای جستجو")
        search_layout = QtWidgets.QHBoxLayout(search_group)
        self.product_search_edit = QtWidgets.QLineEdit(placeholderText="مثال: چسب اپوکسی")
        self.batch_search_edit = QtWidgets.QLineEdit(placeholderText="مثال: P-2501-123")
        self.start_date_edit = QtWidgets.QLineEdit(); self.start_date_edit.setInputMask("0000/00/00;_")
        self.end_date_edit = QtWidgets.QLineEdit(); self.end_date_edit.setInputMask("0000/00/00;_")
        btn_search = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), "جستجو")
        
        search_layout.addWidget(QtWidgets.QLabel("نام محصول:"))
        search_layout.addWidget(self.product_search_edit, 1)
        search_layout.addWidget(QtWidgets.QLabel("شماره بچ:"))
        search_layout.addWidget(self.batch_search_edit, 1)
        search_layout.addWidget(QtWidgets.QLabel("از تاریخ:"))
        search_layout.addWidget(self.start_date_edit)
        search_layout.addWidget(QtWidgets.QLabel("تا تاریخ:"))
        search_layout.addWidget(self.end_date_edit)
        search_layout.addWidget(btn_search)
        layout.addWidget(search_group)

        # جدول نتایج
        self.results_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.results_table)
        layout.addWidget(self.results_table, 1)

        btn_search.clicked.connect(self._search_batch)
        # اتصال کلید Enter در هر فیلد به جستجو
        for editor in [self.product_search_edit, self.batch_search_edit, self.start_date_edit, self.end_date_edit]:
            editor.returnPressed.connect(self._search_batch)

    def _search_batch(self):
        product_name = self.product_search_edit.text().strip()
        batch_no = self.batch_search_edit.text().strip()
        start_date = shamsi_to_gregorian(self.start_date_edit.text())
        end_date = shamsi_to_gregorian(self.end_date_edit.text())

        if not any([product_name, batch_no, start_date, end_date]):
            if self.toast: self.toast.show_message("حداقل یک پارامتر برای جستجو وارد کنید.", "warning")
            return
        
        try:
            records = self.db.search_qc_form_entries(product_name, batch_no, start_date, end_date)
            self.results_table.setRowCount(0)

            if not records:
                set_empty_placeholder(self.results_table, "هیچ گزارش کیفی با این مشخصات یافت نشد.")
                return

            all_keys = set()
            for rec in records:
                if isinstance(rec['data'], dict):
                    all_keys.update(rec['data'].keys())
            
            static_headers = ['تاریخ ثبت', 'ثبت توسط']
            dynamic_headers = sorted(list(all_keys))
            headers = static_headers + dynamic_headers

            self.results_table.setColumnCount(len(headers))
            self.results_table.setHorizontalHeaderLabels(headers)
            self.results_table.setRowCount(len(records))

            for r, rec in enumerate(records):
                self.results_table.setItem(r, 0, QtWidgets.QTableWidgetItem(to_shamsi(rec['submission_date'])))
                self.results_table.setItem(r, 1, QtWidgets.QTableWidgetItem(rec['submitted_by']))
                
                data = rec.get('data', {})
                for c, key in enumerate(dynamic_headers):
                    value = data.get(key, '')
                    self.results_table.setItem(r, 2 + c, QtWidgets.QTableWidgetItem(str(value)))
            
            self.results_table.resizeColumnsToContents()
            self.results_table.horizontalHeader().setSectionResizeMode(headers.index("انتخاب بچ تولید جهت بازرسی"), QtWidgets.QHeaderView.Stretch)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در جستجو: {e}", "critical")
            
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class WarehouseDashboardWidget(QtWidgets.QWidget):
    """داشبورد اختصاصی انبار (نسخه نهایی با طراحی گرافیکی و ساختار دو ستونی)."""
    def __init__(self, db: DB, parent_window=None):
        super().__init__(parent_window)
        self.db = db
        self.parent_window = parent_window
        self.toast = getattr(parent_window, 'toast', None)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15); main_layout.setSpacing(20)

        right_column_layout = QtWidgets.QVBoxLayout(); right_column_layout.setSpacing(20)
        self.card_total_items = self._create_kpi_card("تعداد کل کالاها", "0", "#2980b9", "view-list-tree")
        self.card_shortage = self._create_kpi_card("کالاهای نیازمند سفارش", "0 مورد", "#c0392b", "dialog-warning")
        self.card_expiring = self._create_kpi_card("کالاهای در شرف انقضا", "0 مورد", "#f39c12", "appointment-soon")
        self.card_shortage.clicked.connect(self._show_shortage_items); self.card_expiring.clicked.connect(self._show_expiring_items)
        right_column_layout.addWidget(self.card_total_items); right_column_layout.addWidget(self.card_shortage); right_column_layout.addWidget(self.card_expiring)
        
        transactions_group = QtWidgets.QGroupBox("آخرین تراکنش‌های انبار")
        transactions_layout = QtWidgets.QVBoxLayout(transactions_group)
        self.pinned_table = PinnedTable(self.db, limit=10)
        transactions_layout.addWidget(self.pinned_table); right_column_layout.addWidget(transactions_group, 1)

        left_column_layout = QtWidgets.QVBoxLayout(); left_column_layout.setSpacing(20)
        analysis_group = QtWidgets.QGroupBox("ابزارهای تحلیلی")
        analysis_layout = QtWidgets.QVBoxLayout(analysis_group)
        btn_abc = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-sort-descending"), "   اجرای تحلیل ABC")
        btn_abc.setMinimumHeight(40); btn_abc.clicked.connect(lambda: AbcAnalysisDialog(self.db, self.parent_window).exec_())
        analysis_layout.addWidget(btn_abc); left_column_layout.addWidget(analysis_group)
        
        smo_group = QtWidgets.QGroupBox("گزارش کالاهای راکد (Slow-Moving)")
        smo_layout = QtWidgets.QVBoxLayout(smo_group)
        toolbar = QtWidgets.QHBoxLayout(); toolbar.addWidget(QtWidgets.QLabel("کالاهای بدون جابجایی برای بیش از:"))
        self.days_idle_spinbox = QtWidgets.QSpinBox(); self.days_idle_spinbox.setRange(30, 730); self.days_idle_spinbox.setValue(90); self.days_idle_spinbox.setSuffix(" روز")
        toolbar.addWidget(self.days_idle_spinbox); toolbar.addStretch(); smo_layout.addLayout(toolbar)
        self.tbl_slow_moving = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'): self.parent_window._style_table(self.tbl_slow_moving)
        smo_layout.addWidget(self.tbl_slow_moving); left_column_layout.addWidget(smo_group, 1)
        
        main_layout.addLayout(left_column_layout, 2); main_layout.addLayout(right_column_layout, 1)
        self.days_idle_spinbox.valueChanged.connect(self.refresh_data)

    
    def _create_kpi_card(self, title, value, color, icon_name):
        """A clickable KPI card (Final version with correct layout and styling)."""
        card = ClickableFrame(); card.setObjectName("kpiCard")
        
        card.setStyleSheet(f"""
            QFrame#kpiCard {{
                background-color: {color};
                border-radius: 8px;
            }}
            QFrame#kpiCard:hover {{
                background-color: {QtGui.QColor(color).lighter(115).name()};
            }}
            QFrame#kpiCard QLabel {{
                color: white;
                background-color: transparent;
                border: none;
            }}
            QLabel#kpiTitle {{
                font-size: 11pt;
                font-weight: bold;
            }}
            QLabel#kpiValue {{
                font-size: 20pt;
                font-weight: bold;
            }}
        """)
        
        card_layout = QtWidgets.QHBoxLayout(card)
        card_layout.setContentsMargins(20, 15, 20, 15)
        card_layout.setSpacing(15)

        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(32, 32))
        
        text_layout = QtWidgets.QVBoxLayout(); text_layout.setSpacing(0)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setObjectName("kpiTitle")
        title_label.setAlignment(QtCore.Qt.AlignVCenter)
        
        value_label = QtWidgets.QLabel(value)
        value_label.setObjectName("kpiValue")
        value_label.setAlignment(QtCore.Qt.AlignCenter)
        
        text_layout.addWidget(title_label)
        text_layout.addWidget(value_label)
        
        # **Final Fix: The order of adding widgets is corrected for RTL layout**
        card_layout.addWidget(icon_label) 
        card_layout.addLayout(text_layout, 1)
            
        card.value_label = value_label
        return card
    
        
        
        
# در کلاس WarehouseDashboardWidget، این متد را جایگزین کنید
    def refresh_data(self):
        """تمام داده‌های داشبورد انبار را بارگذاری و بروزرسانی می‌کند (با نمایش نام مادر)."""
        # ... (بخش رفرش کارت‌های KPI بدون تغییر باقی می‌ماند) ...
        try:
            cnt, _ = self.db.stats()
            low_items = self.db.min_alert()
            exp_items = self.db.exp_alert()

            self.card_total_items.value_label.setText(str(cnt))
            self.card_shortage.value_label.setText(f"{len(low_items)} مورد")
            self.card_expiring.value_label.setText(f"{len(exp_items)} مورد")
        except Exception as e:
            print(f"Error refreshing KPI cards: {e}")

        if hasattr(self, 'pinned_table'):
            last_id = self.db.get_setting('last_cleared_trans_id', '0')
            self.pinned_table.refresh(since_id=int(last_id))

        # رفرش جدول کالاهای راکد
        table = self.tbl_slow_moving
        days_idle = self.days_idle_spinbox.value()
        try:
            records = self.db.get_slow_moving_stock(days_idle)
            table.setRowCount(0)
            headers = ['نام کالا', 'شماره بچ', 'مقدار موجود', 'آخرین جابجایی']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(records))

            for r, rec in enumerate(records):
                # --- اصلاح کلیدی: ترکیب نام مادر و فرزند ---
                full_item_name = rec['item_name']
                if rec.get('parent_name'):
                    full_item_name = f"{rec['parent_name']} - {rec['item_name']}"
                # -------------------------------------------
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(full_item_name))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(rec['batch_no']))
                table.setItem(r, 2, NumericTableWidgetItem(str(rec['qty'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(rec.get('last_moved_at'))))

            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, f"هیچ کالای راکدی (با بیش از {days_idle} روز عدم جابجایی) یافت نشد.")
        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری کالاهای راکد: {e}", "critical")
            
            
    def _show_shortage_items(self):
        """کاربر را به صفحه کالاها برده و فیلتر کمبود موجودی را اعمال می‌کند."""
        if not hasattr(self.parent_window, 'pg_items'): return
        self.parent_window.pages.setCurrentWidget(self.parent_window.pg_items)
        QtCore.QTimer.singleShot(50, self.parent_window._filter_for_shortage)

    def _show_expiring_items(self):
        """یک دیالوگ برای نمایش لیست کامل کالاهای در شرف انقضا باز می‌کند."""
        expiring_items = self.db.exp_alert()
        if not expiring_items:
            if self.toast: self.toast.show_message("هیچ کالایی در شرف انقضا یافت نشد.", "info")
            return
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("کالاهای در شرف انقضا"); dlg.setMinimumWidth(500)
        layout = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(expiring_items), 3)
        table.setHorizontalHeaderLabels(['نام کالا', 'شماره بچ', 'تاریخ انقضا'])
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for r, item in enumerate(expiring_items):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(item['name'])); table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['batch_no'])); table.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(item['expiry_date'])))
        layout.addWidget(table)
        dlg.exec_()
                
                    
                        
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class AbcAnalysisDialog(QtWidgets.QDialog):
    """دیالوگی برای تنظیم، اجرا و نمایش گزارش تحلیل ABC (نسخه اصلاح شده)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent

        self.setWindowTitle("گزارش تحلیلی ABC موجودی انبار")
        self.setMinimumSize(800, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        settings_group = QtWidgets.QGroupBox("تنظیمات تحلیل")
        settings_layout = QtWidgets.QHBoxLayout(settings_group)
        settings_layout.addWidget(QtWidgets.QLabel("تحلیل بر اساس:"))
        self.mode_combo = QtWidgets.QComboBox()
        self.mode_combo.addItems(["ارزش ریالی (Value)", "تعداد تراکنش خروج (Movement)"])
        settings_layout.addWidget(self.mode_combo)
        
        settings_layout.addWidget(QtWidgets.QLabel("در بازه زمانی:"))
        self.period_spinbox = QtWidgets.QSpinBox()
        self.period_spinbox.setRange(30, 730); self.period_spinbox.setValue(90); self.period_spinbox.setSuffix(" روز گذشته")
        settings_layout.addWidget(self.period_spinbox)
        
        btn_run = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), "اجرای تحلیل")
        btn_run.setProperty("class", "primary")
        settings_layout.addStretch(); settings_layout.addWidget(btn_run)
        layout.addWidget(settings_group)

        self.tbl_report = QtWidgets.QTableWidget()
        self.tbl_report.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers) # <<<<<<< اصلاح: جدول فقط خواندنی شد
        add_filter_export_tools(self.tbl_report, layout)
        layout.addWidget(self.tbl_report, 1)

        btn_run.clicked.connect(self._run_analysis)
        self._run_analysis()

    def _run_analysis(self):
        """تحلیل را اجرا کرده و جدول را با نام کامل محصول پر می‌کند."""
        mode = 'value' if self.mode_combo.currentIndex() == 0 else 'movement'
        period = self.period_spinbox.value()
        
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            records = self.db.get_abc_analysis_data(period, mode)
            self.tbl_report.setRowCount(0)
            
            headers = ['کلاس', 'نام کالا', 'دسته', 'معیار تحلیل', 'درصد تجمعی']
            self.tbl_report.setColumnCount(len(headers)); self.tbl_report.setHorizontalHeaderLabels(headers)
            self.tbl_report.setRowCount(len(records))

            class_colors = {'A': QtGui.QColor("#f8d7da"), 'B': QtGui.QColor("#fff3cd"), 'C': QtGui.QColor("#d1e7dd")}

            for r, rec in enumerate(records):
                # --- اصلاح کلیدی: ترکیب نام مادر و فرزند ---
                full_item_name = rec['name']
                if rec.get('parent_name'):
                    full_item_name = f"{rec['parent_name']} - {rec['name']}"
                # -------------------------------------------
                
                abc_class = rec.get('abc_class', '')
                measure_value = rec.get('total_value', rec.get('total_movements', 0))
                
                self.tbl_report.setItem(r, 0, QtWidgets.QTableWidgetItem(abc_class))
                self.tbl_report.setItem(r, 1, QtWidgets.QTableWidgetItem(full_item_name))
                self.tbl_report.setItem(r, 2, QtWidgets.QTableWidgetItem(rec['category']))
                self.tbl_report.setItem(r, 3, NumericTableWidgetItem(f"{measure_value:,.2f}"))
                self.tbl_report.setItem(r, 4, NumericTableWidgetItem(f"{rec.get('cumulative_percentage', 0):.2%}"))

                bg_color = class_colors.get(abc_class)
                if bg_color:
                    for c in range(len(headers)):
                        self.tbl_report.item(r, c).setBackground(bg_color)
            
            self.tbl_report.resizeColumnsToContents()
            self.tbl_report.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_report, "هیچ داده‌ای برای تحلیل در بازه زمانی مشخص شده یافت نشد.")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
# کلاس WarehouseLayoutWidget را به طور کامل با این نسخه جایگزین کنید

class WarehouseLayoutWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش و ویرایش گرافیکی چیدمان انبار (نسخه 2.0 با UI بهبود یافته)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.scene = QtWidgets.QGraphicsScene()
        self.view = QtWidgets.QGraphicsView(self.scene)
        self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.scene.setBackgroundBrush(QtGui.QBrush(QtGui.QColor("#f1f2f6"))) # رنگ پس‌زمینه بهتر

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        toolbar = QtWidgets.QHBoxLayout()
        toolbar.addWidget(QtWidgets.QLabel("<b>نقشه حرارتی:</b>"))
        self.heatmap_combo = QtWidgets.QComboBox()
        self.heatmap_combo.addItems(["غیرفعال", "فراوانی برداشت", "حجم موجودی", "کالاهای راکد"])
        toolbar.addWidget(self.heatmap_combo)
        toolbar.addStretch()

        # --- بخش جدید: ابزارهای ناوبری ---
        btn_zoom_in = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-in"), "")
        btn_zoom_out = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-out"), "")
        btn_fit_view = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-fit-best"), "")
        btn_zoom_in.setFixedSize(30, 30); btn_zoom_out.setFixedSize(30, 30); btn_fit_view.setFixedSize(30, 30)
        btn_zoom_in.setToolTip("بزرگ‌نمایی")
        btn_zoom_out.setToolTip("کوچک‌نمایی")
        btn_fit_view.setToolTip("نمایش کامل نقشه")
        toolbar.addWidget(btn_zoom_in)
        toolbar.addWidget(btn_zoom_out)
        toolbar.addWidget(btn_fit_view)
        # ------------------------------------
        
        btn_refresh = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), "")
        btn_refresh.setFixedSize(30, 30); btn_refresh.setToolTip("بارگذاری مجدد نقشه")
        toolbar.addWidget(btn_refresh)
        layout.addLayout(toolbar)

        layout.addWidget(self.view)

        btn_refresh.clicked.connect(self.refresh_layout)
        self.heatmap_combo.currentIndexChanged.connect(self.refresh_layout)
        btn_zoom_in.clicked.connect(lambda: self.view.scale(1.2, 1.2))
        btn_zoom_out.clicked.connect(lambda: self.view.scale(1/1.2, 1/1.2))
        btn_fit_view.clicked.connect(lambda: self.view.fitInView(self.scene.itemsBoundingRect(), QtCore.Qt.KeepAspectRatio))

        self.refresh_layout()

    def refresh_layout(self):
        """چیدمان انبار را از دیتابیس خوانده و آیتم‌های گرافیکی را روی نقشه ترسیم می‌کند."""
        self.scene.clear()
        locations = self.db.list_locations()
        if not locations: return

        for loc in locations:
            interactive_item = InteractiveRackItem(loc, self)
            self.scene.addItem(interactive_item)
            
                        
                        
# کلاس InteractiveRackItem را به طور کامل با این نسخه جایگزین کنید

class InteractiveRackItem(QtWidgets.QGraphicsRectItem):
    """
    نسخه 2.0 (طراحی گرافیکی):
    - یک آیتم گرافیکی زیبا و خوانا برای نمایش قفسه در نقشه انبار.
    """
    def __init__(self, location_data, parent_widget):
        # آیتم اصلی به عنوان یک کانتینر نامرئی عمل می‌کند
        super().__init__(location_data['pos_x'], location_data['pos_y'], location_data['width'], location_data['height'])
        self.location_data = location_data
        self.parent_widget = parent_widget

        # تنظیمات اصلی آیتم برای تعامل
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | QtWidgets.QGraphicsItem.ItemIsSelectable | QtWidgets.QGraphicsItem.ItemSendsScenePositionChanges)
        self.setPen(QtGui.QPen(QtCore.Qt.NoPen)) # کانتینر اصلی بدون حاشیه است

        # بدنه اصلی قفسه
        self.body = QtWidgets.QGraphicsRectItem(0, 0, location_data['width'], location_data['height'], self)
        self.body.setBrush(QtGui.QBrush(QtGui.QColor("#dfe4ea")))
        self.body.setPen(QtGui.QPen(QtGui.QColor("#808e9b"), 1))

        # هدر رنگی بالای قفسه
        header_height = 25
        self.header = QtWidgets.QGraphicsRectItem(0, 0, location_data['width'], header_height, self)
        self.header.setBrush(QtGui.QBrush(QtGui.QColor("#57606f")))
        self.header.setPen(QtGui.QPen(QtCore.Qt.NoPen))
        
        # متن نام قفسه
        self.text_item = QtWidgets.QGraphicsTextItem(self.location_data['rack'], self)
        font = QFont(FONT_FAMILY, 10, QFont.Bold)
        self.text_item.setFont(font)
        self.text_item.setDefaultTextColor(QtCore.Qt.white)
        # قرار دادن متن در وسط هدر
        text_rect = self.text_item.boundingRect()
        self.text_item.setPos((location_data['width'] - text_rect.width()) / 2, (header_height - text_rect.height()) / 2)

        self.setToolTip(f"{self.location_data['loc_label']}\nمختصات: ({self.location_data['pos_x']:.0f}, {self.location_data['pos_y']:.0f})")

    def mouseReleaseEvent(self, event):
        """پس از رها کردن آیتم، موقعیت جدید آن را در دیتابیس ذخیره می‌کند."""
        super().mouseReleaseEvent(event)
        new_pos = self.scenePos()
        
        # فقط در صورتی که موقعیت واقعا تغییر کرده، در دیتابیس ذخیره کن
        if int(new_pos.x()) != int(self.location_data['pos_x']) or int(new_pos.y()) != int(self.location_data['pos_y']):
            self.location_data['pos_x'] = new_pos.x()
            self.location_data['pos_y'] = new_pos.y()
            self.parent_widget.db.update_location_position(self.location_data['id'], new_pos.x(), new_pos.y())
            self.setToolTip(f"{self.location_data['loc_label']}\nمختصات: ({new_pos.x():.0f}, {new_pos.y():.0f})")
            if self.parent_widget.toast:
                self.parent_widget.toast.show_message(f"موقعیت {self.location_data['loc_label']} به‌روز شد.", "info")
                
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
class PurchaseOrderDetailDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش جزئیات کامل یک سفارش خرید."""
    def __init__(self, db: DB, po_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.po_id = po_id
        self.parent_window = parent

        self.setWindowTitle(f"جزئیات سفارش خرید")
        self.setMinimumSize(750, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        # بخش اطلاعات اصلی
        header_group = QtWidgets.QGroupBox("مشخصات سفارش")
        form_layout = QtWidgets.QFormLayout(header_group)
        self.lbl_po_number = QtWidgets.QLabel("...")
        self.lbl_supplier = QtWidgets.QLabel("...")
        self.lbl_issue_date = QtWidgets.QLabel("...")
        self.lbl_status = QtWidgets.QLabel("...")
        self.lbl_total_amount = QtWidgets.QLabel("...")
        
        form_layout.addRow("شماره سفارش (PO):", self.lbl_po_number)
        form_layout.addRow("تامین‌کننده:", self.lbl_supplier)
        form_layout.addRow("تاریخ صدور:", self.lbl_issue_date)
        form_layout.addRow("وضعیت:", self.lbl_status)
        form_layout.addRow("مبلغ کل (ریال):", self.lbl_total_amount)
        layout.addWidget(header_group)

        # بخش اقلام سفارش
        items_group = QtWidgets.QGroupBox("اقلام سفارش")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        self.tbl_items = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_items)
        items_layout.addWidget(self.tbl_items)
        layout.addWidget(items_group, 1)

        self._load_data()

    def _load_data(self):
        """داده‌های هدر و اقلام سفارش را از دیتابیس خوانده و نمایش می‌دهد."""
        po_details = self.db.get_po_details(self.po_id)
        if not po_details:
            self.close()
            return

        self.setWindowTitle(f"جزئیات سفارش خرید: {po_details.get('po_number')}")
        self.lbl_po_number.setText(f"<b>{po_details.get('po_number')}</b>")
        self.lbl_supplier.setText(po_details.get('supplier_name', ''))
        self.lbl_issue_date.setText(to_shamsi(po_details.get('issue_date')))
        self.lbl_status.setText(f"<b>{po_details.get('status')}</b>")
        self.lbl_total_amount.setText(f"{po_details.get('total_amount', 0):,.0f}")

        line_items = self.db.get_po_line_items(self.po_id)
        headers = ['نام کالا', 'مقدار', 'واحد', 'قیمت واحد', 'قیمت کل']
        self.tbl_items.setColumnCount(len(headers))
        self.tbl_items.setHorizontalHeaderLabels(headers)
        self.tbl_items.setRowCount(len(line_items))

        for r, item in enumerate(line_items):
            quantity = item.get('quantity', 0)
            unit_price = item.get('unit_price', 0)
            total_price = quantity * unit_price
            
            self.tbl_items.setItem(r, 0, QtWidgets.QTableWidgetItem(item.get('item_name')))
            self.tbl_items.setItem(r, 1, NumericTableWidgetItem(str(quantity)))
            self.tbl_items.setItem(r, 2, QtWidgets.QTableWidgetItem(item.get('unit', '')))
            self.tbl_items.setItem(r, 3, NumericTableWidgetItem(f"{unit_price:,.0f}"))
            self.tbl_items.setItem(r, 4, NumericTableWidgetItem(f"{total_price:,.0f}"))

        self.tbl_items.resizeColumnsToContents()
        self.tbl_items.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
                
                                
# این دو کلاس را به طور کامل با نسخه‌های قبلی جایگزین کنید

class SalesChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش گرافیکی روند فروش (نسخه نهایی با قابلیت کلیک)."""
    dateClicked = QtCore.pyqtSignal(dt.date)
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(10, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        self.df = None # تعریف اولیه به عنوان متغیر کلاس
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.canvas)
        
        self.canvas.mpl_connect('pick_event', self._on_pick)
        self.refresh_data()

    def refresh_data(self):
        self.ax.clear()
        try:
            sales_data = self.db.get_sales_summary_by_day(days_history=30)
            if sales_data and pd:
                self.df = pd.DataFrame([dict(row) for row in sales_data]) # <<-- اصلاح: استفاده از self.df
                self.df['report_date'] = pd.to_datetime(self.df['report_date'])
                self.df['shamsi_date_str'] = self.df['report_date'].apply(lambda d: to_shamsi(d).split(' ')[0])

                # آرگومان 'picker=5' نقاط داده را قابل کلیک می‌کند
                self.ax.plot(self.df['shamsi_date_str'], self.df['total_sales'], marker='o', linestyle='-', color='#0d6efd', picker=5)
                self.ax.set_title(fa("روند فروش ۳۰ روز گذشته (به ریال)"), fontsize=14, weight='bold')
                self.ax.set_ylabel(fa("مبلغ فروش روزانه"))
                self.ax.grid(axis='y', linestyle='--', alpha=0.7)
                self.ax.tick_params(axis='x', rotation=45, labelsize=9)
                formatter = mpl.ticker.FuncFormatter(lambda x, p: format(int(x), ','))
                self.ax.get_yaxis().set_major_formatter(formatter)
                self.figure.tight_layout()
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش در نمودار فروش یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating sales chart: {e}")
            self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')
        self.canvas.draw()
        
# در کلاس SalesChartWidget، این متد را جایگزین کنید
    def _on_pick(self, event):
        """کلیک روی نقاط داده نمودار را مدیریت می‌کند."""
        # --- اصلاح کلیدی: بررسی وجود دیتافریم قبل از هر کاری ---
        if self.df is None or self.df.empty or not isinstance(event.artist, mpl.lines.Line2D): return
        try:
            ind = event.ind[0]
            clicked_date = self.df['report_date'].iloc[ind].date()
            self.dateClicked.emit(clicked_date)
        except (IndexError, AttributeError) as e:
            print(f"Could not process pick event: {e}")
            
                              
class TopProductsChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش نمودار ۵ محصول پرفروش (نسخه نهایی با رفع خطا)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(5, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.canvas)
        self.refresh_data()

    def refresh_data(self):
        self.ax.clear()
        try:
            top_products = self.db.get_sales_summary_by_product(days_history=30, top_n=5)
            if top_products and pd:
                df = pd.DataFrame(top_products)
                # --- *** اصلاح کلیدی: بررسی خالی نبودن دیتافریم *** ---
                if not df.empty:
                    product_labels = [fa(name) for name in df['product_name']]
                    bars = self.ax.barh(product_labels, df['total_quantity'], color='#8e44ad')
                    
                    self.ax.set_title(fa("۵ محصول پرفروش (بر اساس تعداد)"), fontsize=12, weight='bold')
                    self.ax.set_xlabel(fa("تعداد کل فروخته شده در ۳۰ روز گذشته"))
                    self.ax.invert_yaxis()
                    self.ax.bar_label(bars, fmt='{:,.0f}', padding=3)
                else:
                    self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش یافت نشد."), ha='center', va='center')
                # --- *********************************************** ---
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating top products chart: {e}")
            self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')

        self.figure.tight_layout()
        self.canvas.draw()
                    
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class ProductionChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش گرافیکی روند تولید در داشبورد مدیرعامل."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(10, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.canvas)
        self.refresh_data()

    # در کلاس ProductionChartWidget، این متد را جایگزین کنید
    def refresh_data(self):
        """داده‌های تولید را از دیتابیس خوانده و نمودار را مجدداً ترسیم می‌کند."""
        self.ax.clear()
        try:
            prod_data = self.db.get_production_summary_by_day(days_history=30)
            if prod_data and pd:
                # --- *** اصلاح کلیدی: تبدیل صریح به لیست دیکشنری‌ها *** ---
                df = pd.DataFrame([dict(row) for row in prod_data])
                df['report_date'] = pd.to_datetime(df['report_date'])
                df['shamsi_date_str'] = df['report_date'].apply(lambda d: to_shamsi(d))

                bars = self.ax.bar(df['shamsi_date_str'], df['total_production'], color='#1abc9c')
                self.ax.set_title(fa("روند تولید ۳۰ روز گذشته (محصولات نهایی)"), fontsize=14, weight='bold'); self.ax.set_ylabel(fa("مقدار تولید روزانه (واحد اصلی)")); self.ax.grid(axis='y', linestyle='--', alpha=0.7); self.ax.tick_params(axis='x', rotation=45, labelsize=9)
                formatter = mpl.ticker.FuncFormatter(lambda x, p: format(int(x), ',')); self.ax.get_yaxis().set_major_formatter(formatter)
                self.ax.bar_label(bars, fmt='{:,.0f}', padding=3)
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش در نمودار تولید یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating production chart: {e}"); self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')
        self.figure.tight_layout(); self.canvas.draw()
    
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
        
        # کلاس ProfitabilityChartWidget را به طور کامل با این نسخه جایگزین کنید
class ProfitabilityChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش نمودار تحلیل سودآوری (نسخه اصلاح شده)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(10, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        
        layout = QtWidgets.QVBoxLayout(self); layout.addWidget(self.canvas)
        self.refresh_data()

    def refresh_data(self):
        self.ax.clear()
        try:
            sales_data = self.db.get_sales_summary_by_day(days_history=30)
            cogs_data = self.db.get_cogs_summary_by_day(days_history=30)
            if sales_data and cogs_data and pd:
                df_sales = pd.DataFrame(sales_data); df_cogs = pd.DataFrame(cogs_data)
                df_sales['shamsi_date_str'] = pd.to_datetime(df_sales['report_date']).apply(lambda d: to_shamsi(d))
                
                self.ax.plot(df_sales['shamsi_date_str'], df_sales['total_sales'], marker='o', linestyle='-', color='#0d6efd', label=fa('فروش کل'))
                self.ax.plot(df_sales['shamsi_date_str'], df_cogs['total_cogs'], marker='x', linestyle='--', color='#dc3545', label=fa('بهای تمام شده'))
                
                self.ax.set_title(fa("تحلیل سودآوری ۳۰ روز گذشته"), fontsize=14, weight='bold')
                self.ax.set_ylabel(fa("مبلغ (ریال)"))
                self.ax.grid(True, linestyle='--', alpha=0.6)
                self.ax.tick_params(axis='x', rotation=45, labelsize=9) # <<<< اصلاح: چرخش برچسب‌ها
                self.ax.legend(prop={'family': FONT_FAMILY_MATPLOTLIB, 'size': 10})

                formatter = mpl.ticker.FuncFormatter(lambda x, p: format(int(x), ','))
                self.ax.get_yaxis().set_major_formatter(formatter)
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating profitability chart: {e}"); self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')
        self.figure.tight_layout(); self.canvas.draw()
        
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class FormulaBuilderWidget(QtWidgets.QWidget):
    """یک ویجت بصری و تعاملی برای ساخت فرمول‌های محاسباتی."""
    formulaChanged = QtCore.pyqtSignal(str)

    def __init__(self, available_fields: list, current_formula: str, parent=None):
        super().__init__(parent)
        self.available_fields = available_fields
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(8)

        self.formula_display = QtWidgets.QLineEdit(current_formula)
        self.formula_display.setReadOnly(True)
        self.formula_display.setAlignment(QtCore.Qt.AlignLeft)
        self.formula_display.setStyleSheet("background-color: #e9ecef;")
        main_layout.addWidget(self.formula_display)

        builder_layout = QtWidgets.QHBoxLayout()

        # پنل فیلدهای قابل انتخاب
        fields_group = QtWidgets.QGroupBox("فیلدهای عددی فرم")
        fields_layout = QtWidgets.QVBoxLayout(fields_group)
        self.fields_list = QtWidgets.QListWidget()
        self.fields_list.addItems(self.available_fields)
        self.fields_list.itemDoubleClicked.connect(self._add_field_to_formula)
        fields_layout.addWidget(self.fields_list)
        
        # پنل دکمه‌های عملیاتی
        ops_group = QtWidgets.QGroupBox("عملگرها")
        ops_layout = QtWidgets.QGridLayout(ops_group)
        ops = ['+', '-', '*', '/', '(', ')']
        positions = [(i, j) for i in range(3) for j in range(2)]
        for position, op in zip(positions, ops):
            btn = QtWidgets.QPushButton(op)
            btn.setFixedSize(40, 40)
            btn.clicked.connect(lambda _, o=op: self._add_operator_to_formula(f" {o} "))
            ops_layout.addWidget(btn, *position)
        
        btn_clear = QtWidgets.QPushButton("پاک کردن")
        btn_clear.clicked.connect(self.formula_display.clear)

        builder_layout.addWidget(fields_group, 2) # 2/3 فضا
        builder_layout.addWidget(ops_group, 1)    # 1/3 فضا
        main_layout.addLayout(builder_layout)
        main_layout.addWidget(btn_clear)

        self.formula_display.textChanged.connect(self.formulaChanged)

    def _add_field_to_formula(self, item):
        field_name = item.text()
        current_text = self.formula_display.text()
        self.formula_display.setText(current_text + f"[{field_name}]")

    def _add_operator_to_formula(self, operator):
        current_text = self.formula_display.text()
        self.formula_display.setText(current_text + operator)

    def get_formula(self):
        return self.formula_display.text().strip()
    
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
class ProformaPreviewDialog(QtWidgets.QDialog):
    """دیالوگی برای پیش‌نمایش اطلاعات پیش‌فاکتور قبل از شروع فرآیند."""
# در کلاس ProformaPreviewDialog، متد __init__ را جایگزین کنید
    def __init__(self, invoice_data: dict, parent=None):
        super().__init__(parent)
        header = invoice_data.get('header', {})
        self.setWindowTitle(f"پیش‌نمایش پیش‌فاکتور برای: {header.get('customer_name')}")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        customer_group = QtWidgets.QGroupBox("مشخصات خریدار")
        form_layout = QtWidgets.QFormLayout(customer_group)
        form_layout.addRow("شماره سفارش:", QtWidgets.QLabel(f"<b>{header.get('so_number')}</b>"))
        form_layout.addRow("نام شرکت:", QtWidgets.QLabel(header.get('customer_name', '')))
        form_layout.addRow("آدرس:", QtWidgets.QLabel(header.get('address', '')))
        form_layout.addRow("کد اقتصادی:", QtWidgets.QLabel(header.get('tax_id', '')))
        layout.addWidget(customer_group)
        
        items_group = QtWidgets.QGroupBox("اقلام پیش‌فاکتور")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        items_table = QtWidgets.QTableWidget()
        parent._style_table(items_table)
        
        headers = ['شرح کالا', 'تعداد', 'قیمت واحد', 'قیمت کل']
        items_table.setColumnCount(len(headers)); items_table.setHorizontalHeaderLabels(headers)
        
        line_items = invoice_data.get('items', [])
        items_table.setRowCount(len(line_items))
        total_amount = 0
        for r, item in enumerate(line_items):
            total_price = item['quantity'] * item['unit_price']
            total_amount += total_price
            # --- *** اصلاح کلیدی اینجاست: استفاده از فیلد جدید full_item_name *** ---
            items_table.setItem(r, 0, QtWidgets.QTableWidgetItem(item['full_item_name']))
            items_table.setItem(r, 1, NumericTableWidgetItem(str(item['quantity'])))
            items_table.setItem(r, 2, NumericTableWidgetItem(f"{item['unit_price']:,.0f}"))
            items_table.setItem(r, 3, NumericTableWidgetItem(f"{total_price:,.0f}"))
        
        items_table.resizeColumnsToContents()
        items_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        items_layout.addWidget(items_table)
        layout.addWidget(items_group)

        footer_layout = QtWidgets.QHBoxLayout()
        total_label = QtWidgets.QLabel(f"<b>مبلغ کل: {total_amount:,.0f} ریال</b>")
        total_label.setFont(QFont(FONT_FAMILY, 12, QFont.Bold))
        footer_layout.addWidget(total_label)
        footer_layout.addStretch()
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("✔ تایید و شروع فرآیند")
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setProperty("class", "primary")
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        footer_layout.addWidget(buttons)
        layout.addLayout(footer_layout)
        
        
# این کلاس کاملا جدید را به انتهای فایل اضافه کنید
class SystemStatusDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش اطلاعات و دسترسی‌های کاربر فعلی جهت دیباگ."""
    def __init__(self, user_info: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle("گزارش وضعیت سیستم و کاربر فعلی")
        self.setMinimumSize(500, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        form_layout.addRow("نام کاربری:", QtWidgets.QLabel(f"<b>{user_info.get('username', '---')}</b>"))
        form_layout.addRow("نقش:", QtWidgets.QLabel(f"<b>{user_info.get('role_name', '---')}</b>"))
        layout.addLayout(form_layout)
        
        perms_group = QtWidgets.QGroupBox("لیست دسترسی‌های فعال این نقش")
        perms_layout = QtWidgets.QVBoxLayout(perms_group)
        
        perms_list_widget = QtWidgets.QListWidget()
        permissions = sorted(user_info.get('permissions', []))
        if permissions:
            perms_list_widget.addItems(permissions)
        else:
            perms_list_widget.addItem("هیچ دسترسی فعالی یافت نشد!")

        perms_layout.addWidget(perms_list_widget)
        layout.addWidget(perms_group)
        
# این کلاس کاملا جدید را به فایل اضافه کنید
class NotificationButton(QtWidgets.QPushButton):
    """یک دکمه اعلان هوشمند و مستقل که ظاهر و انیمیشن خودش را مدیریت می‌کند."""
    def __init__(self, parent=None):
        super().__init__("  کارتابل", parent)
        self.animation = None
        
        # تلاش برای بارگذاری آیکون سفارشی با قابلیت جایگزینی (Fallback)
        icon_path = BASE_DIR / 'icons' / 'bell.png'
        icon = QtGui.QIcon(str(icon_path))
        if icon.isNull():
            print("WARNING: 'bell.png' not found or invalid. Falling back to theme icon.")
            icon = QtGui.QIcon.fromTheme("dialog-information")
        
        self.setIcon(icon)
        self.setIconSize(QtCore.QSize(24, 24))
        self.setProperty("class", "sidebar-button")

    def update_count(self, count: int):
        """تعداد اعلان‌ها را گرفته و ظاهر و انیمیشن دکمه را به‌روز می‌کند."""
        self.setText(f"  کارتابل ({count})" if count > 0 else "  کارتابل")
        
        if count > 0:
            if self.animation is None:
                self.animation = QtCore.QSequentialAnimationGroup(self)
                anim1 = QtCore.QPropertyAnimation(self, b"iconSize"); anim1.setDuration(300); anim1.setStartValue(QtCore.QSize(24, 24)); anim1.setEndValue(QtCore.QSize(28, 28)); anim1.setEasingCurve(QtCore.QEasingCurve.OutCubic)
                anim2 = QtCore.QPropertyAnimation(self, b"iconSize"); anim2.setDuration(500); anim2.setStartValue(QtCore.QSize(28, 28)); anim2.setEndValue(QtCore.QSize(24, 24)); anim2.setEasingCurve(QtCore.QEasingCurve.InOutSine)
                self.animation.addAnimation(anim1); self.animation.addAnimation(anim2)
                self.animation.setLoopCount(-1)

            if self.animation.state() != QtCore.QAbstractAnimation.Running:
                self.animation.start()

            self.setStyleSheet("""
                QPushButton { color: #1abc9c; background-color: #ecf0f1; border: none; text-align: right;
                padding: 13px 22px; font-size: 11pt; font-weight: bold;
                border-right: 5px solid #1abc9c; }
                QPushButton:hover { background-color: #ffffff; }
            """)
        else:
            if self.animation and self.animation.state() == QtCore.QAbstractAnimation.Running:
                self.animation.stop()
                self.setIconSize(QtCore.QSize(24, 24))
            self.setStyleSheet("") # بازگشت به استایل پیش‌فرض کلاس خودش
            
# این کلاس جدید را برای مدیریت سیگنال‌ها اضافه کنید
class DBsignals(QtCore.QObject):
    dataChanged = QtCore.pyqtSignal(str) # سیگنالی که یک رشته (کلید) را منتشر می‌کند
    
class PurchasingWorkbenchWidget(QtWidgets.QWidget):
    """
    میزکار بازمهندسی‌شده بازرگانی (V4، هماهنگ با PostgreSQL):
      - مرکز استعلام (گروه/اقلام/کوئوت‌ها)
      - لیست کارپرداز
      - مرکز سفارش (آماده سفارش → صدور PO، POهای باز → دریافت)
    """
    def __init__(self, db, user_id: int, parent_window):
        super().__init__(parent_window)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent_window
        self.toast = getattr(parent_window, 'toast', None)

        self.current_pr_id: int | None = None
        self.current_group_id: int | None = None

        # --- Tabs ---
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)

        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setObjectName("interfaceTabWidget")
        main_layout.addWidget(self.tabs)

        sourcing_page = self._create_sourcing_tab()
        agent_page = self._create_agent_list_tab()
        ordering_page = self._create_ordering_tab()

        self.tabs.addTab(sourcing_page, "مرکز استعلام (Sourcing)")
        self.tabs.addTab(agent_page, "لیست خرید کارپرداز")
        self.tabs.addTab(ordering_page, "مرکز سفارش (Ordering)")

        # Tab change → refresh
        self.tabs.currentChanged.connect(self.refresh_active_tab)

        # بوت‌استرپ و وایرینگ + اولین لود
        self.init_purchasing_workbench()

    # ------------------------- Bootstrapping / Wiring -------------------------

    def init_purchasing_workbench(self):
        """بوت‌استرپ DB + اتصال سیگنال‌ها + اولین بارگذاری نماها."""
        try:
            if self.db:
                try:
                    self.db.bootstrap_purchasing_runtime()
                except Exception:
                    pass
            self.wire_purchasing_ui()
            self.refresh_purchasing_views()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Purchasing Init Error", str(e))

    # BEGIN REWRITE: UI.PurchasingWorkbenchWidget.wire_purchasing_ui
    def wire_purchasing_ui(self):
        """وصل‌کردن سیگنال‌ها (idempotent)."""
        if getattr(self, "_purchasing_ui_wired", False):
            return
        # تغییر انتخاب گروه‌های استعلام و اقلام
        if hasattr(self, 'tbl_sourcing_groups') and self.tbl_sourcing_groups:
            self.tbl_sourcing_groups.itemSelectionChanged.connect(self._on_sourcing_group_selected)
        if hasattr(self, 'tbl_sourcing_items') and self.tbl_sourcing_items:
            self.tbl_sourcing_items.itemSelectionChanged.connect(self._on_sourcing_item_selected)

        # تغییر انتخاب PO باز → لود آیتم‌ها
        if hasattr(self, 'tbl_open_pos') and self.tbl_open_pos:
            self.tbl_open_pos.itemSelectionChanged.connect(self._on_open_pos_selection_changed)

        # دکمه‌های Ordering
        if hasattr(self, 'btn_create_po_for_supplier') and self.btn_create_po_for_supplier:
            self.btn_create_po_for_supplier.clicked.connect(lambda: self._on_click_create_po_for_supplier(creator_user_id=self.user_id))
        if hasattr(self, 'btn_receive_po') and self.btn_receive_po:
            # قبل از دریافت، دیالوگ شماره رسید/تاریخ را باز کن
            self.btn_receive_po.clicked.connect(self._on_click_receive_po)

        # تایمر KPI (هر 30 ثانیه)
        try:
            self._kpi_timer = QtCore.QTimer(self)
            self._kpi_timer.setInterval(30_000)
            self._kpi_timer.timeout.connect(self._refresh_purchasing_kpis)
            self._kpi_timer.start()
        except Exception:
            pass

        self._purchasing_ui_wired = True

    # BEGIN ADD: UI.PurchasingWorkbenchWidget._prompt_receipt_meta
    def _prompt_receipt_meta(self) -> tuple[str | None, str | None] | None:
        """دیالوگ ساده برای دریافت «شماره رسید (DN)» و «تاریخ/ساعت دریافت».
        خروجی: (receipt_no, received_at_str) یا None اگر کاربر انصراف داد.
        """
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("ثبت رسید تحویل")
        dlg.setMinimumWidth(360)
        dlg.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        form = QtWidgets.QFormLayout(dlg)
        txt_no = QtWidgets.QLineEdit(); txt_no.setPlaceholderText("مثلاً DN-1404-000123")
        dt = QtWidgets.QDateTimeEdit(QtCore.QDateTime.currentDateTime())
        dt.setCalendarPopup(True)
        dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        form.addRow("شماره رسید:", txt_no)
        form.addRow("تاریخ/ساعت دریافت:", dt)

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        btns.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت")
        btns.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        form.addRow(btns)

        btns.accepted.connect(dlg.accept)
        btns.rejected.connect(dlg.reject)

        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return None
        receipt_no = (txt_no.text() or "").strip() or None
        received_at = dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        return receipt_no, received_at
    # END ADD: UI.PurchasingWorkbenchWidget._prompt_receipt_meta
    
    # BEGIN ADD: UI.PurchasingWorkbenchWidget._on_click_receive_po
    def _on_click_receive_po(self) -> None:
        """هندلر دکمهٔ «ثبت دریافت»: DN/تاریخ را می‌گیرد و دریافت را ثبت می‌کند."""
        meta = self._prompt_receipt_meta()
        if meta is None:
            return
        receipt_no, received_at = meta
        # با پارامترهای جدید، همان متد فعلی را صدا بزن
        self._receive_current_po(receiver_id=self.user_id, receipt_no=receipt_no, received_at=received_at)
    # END ADD: UI.PurchasingWorkbenchWidget._on_click_receive_po

    def refresh_purchasing_views(self):
        """بازآوری هم‌زمان نماهای اصلی."""
        try:
            self._load_sourcing_groups()
        except Exception:
            pass
        try:
            self._load_agent_list()
        except Exception:
            pass
        try:
            self._load_requests_ready_for_ordering()
            self._load_open_purchase_orders()
            # اگر PO انتخاب است، آیتم‌هایش را آپدیت کنیم
            if hasattr(self, 'tbl_open_pos') and self.tbl_open_pos.currentRow() >= 0:
                self._on_open_pos_selection_changed()
        except Exception:
            pass
        try:
            self._refresh_purchasing_kpis()
        except Exception:
            pass

    # ------------------------- Tab navigation -------------------------

    def refresh_active_tab(self):
        idx = self.tabs.currentIndex()
        if idx == 0:
            self._load_sourcing_groups()
        elif idx == 1:
            self._load_agent_list()
        elif idx == 2:
            self._load_requests_ready_for_ordering()

    # ------------------------- Sourcing Tab -------------------------

    def _create_sourcing_tab(self) -> QtWidgets.QWidget:
        page = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(page)

        splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)

        # گروه‌ها
        groups_group = QtWidgets.QGroupBox("۱. فرم‌های در انتظار استعلام")
        groups_layout = QtWidgets.QVBoxLayout(groups_group)
        self.tbl_sourcing_groups = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_sourcing_groups)
        groups_layout.addWidget(self.tbl_sourcing_groups)
        splitter.addWidget(groups_group)

        # اقلام + کوئوت‌ها
        items_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        items_group = QtWidgets.QGroupBox("۲. اقلام فرم (برای اقدام، یک قلم را انتخاب کنید)")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        self.tbl_sourcing_items = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_sourcing_items)
        items_layout.addWidget(self.tbl_sourcing_items)
        # اکشن ارجاع به کارپرداز
        item_actions = QtWidgets.QHBoxLayout()
        btn_assign_agent = QtWidgets.QPushButton("ارجاع به کارپرداز")
        item_actions.addStretch()
        item_actions.addWidget(btn_assign_agent)
        btn_assign_agent.clicked.connect(self._assign_to_agent_action)
        items_layout.addLayout(item_actions)
        items_splitter.addWidget(items_group)

        quotes_group = QtWidgets.QGroupBox("۳. پیشنهاد قیمت‌ها")
        quotes_layout = QtWidgets.QVBoxLayout(quotes_group)
        self.tbl_quotes = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_quotes)
        quotes_layout.addWidget(self.tbl_quotes)
        q_buttons = QtWidgets.QHBoxLayout()
        btn_add_quote = QtWidgets.QPushButton("افزودن پیشنهاد")
        btn_select_quote = QtWidgets.QPushButton("انتخاب برنده")
        btn_select_quote.setProperty("class", "primary")
        q_buttons.addStretch()
        q_buttons.addWidget(btn_add_quote)
        q_buttons.addWidget(btn_select_quote)
        quotes_layout.addLayout(q_buttons)
        btn_add_quote.clicked.connect(self._add_quote_action)
        btn_select_quote.clicked.connect(self._select_quote_action)
        items_splitter.addWidget(quotes_group)

        items_splitter.setSizes([600, 400])
        splitter.addWidget(items_splitter)
        splitter.setSizes([200, 500])

        layout.addWidget(splitter)
        return page

    # BEGIN REWRITE: UI.PurchasingWorkbenchWidget._load_sourcing_groups
    def _load_sourcing_groups(self, limit: int = 500):
        """
        فرم‌های در انتظار استعلام (نمای بالا) را لود می‌کند.
        ستون‌های فرم: #، شماره فرم فیزیکی، درخواست‌کننده، واحد، تاییدکننده، تاریخ/ساعت تایید، تعداد اقلام
        """
        from PyQt5 import QtWidgets, QtCore
        tbl = getattr(self, 'tbl_sourcing_groups', None)
        lst = getattr(self, 'lw_sourcing_groups', None)
        if tbl is None and lst is None:
            return

        # دریافت داده
        try:
            rows = self.db.list_pr_groups_for_sourcing(limit=limit) or []
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای دریافت گروه‌ها", f"لود گروه‌ها ناموفق بود:\n{e}")
            rows = []

        # Table
        if tbl is not None:
            tbl.setUpdatesEnabled(False)
            try:
                headers = ["#", "شمارهٔ فرم فیزیکی", "درخواست‌کننده", "واحد", "تاییدکننده", "تاریخ/ساعت تأیید", "تعداد اقلام"]
                tbl.clear()
                tbl.setColumnCount(len(headers))
                tbl.setHorizontalHeaderLabels(headers)
                tbl.setRowCount(len(rows))

                # برای تاریخ شمسی با ساعت
                try:
                    from inventory import to_shamsi  # اگر ماژول‌بندی شده
                except Exception:
                    to_shamsi = globals().get('to_shamsi', lambda dt, include_time=False: (dt or ""))

                for r, row in enumerate(rows):
                    key   = row.get("grp_key")
                    phys  = row.get("physical_request_no") or '---'
                    req   = row.get("requester_name") or '-'
                    dep   = row.get("dept_name") or ''
                    appr  = row.get("approver_name") or ''
                    apprt = row.get("approved_at")
                    try:
                        apprt_txt = to_shamsi(apprt, include_time=True) if apprt else ""
                    except Exception:
                        apprt_txt = str(apprt or "")
                    cnt   = int(row.get("items_count") or 0)

                    it0 = QtWidgets.QTableWidgetItem(str(r+1)); it0.setData(QtCore.Qt.UserRole, key); it0.setFlags(it0.flags() ^ QtCore.Qt.ItemIsEditable)
                    tbl.setItem(r, 0, it0)
                    for c, val in enumerate([phys, req, dep, appr, apprt_txt, str(cnt)], start=1):
                        it = QtWidgets.QTableWidgetItem(val)
                        it.setFlags(it.flags() ^ QtCore.Qt.ItemIsEditable)
                        tbl.setItem(r, c, it)

                hh = tbl.horizontalHeader()
                try:
                    hh.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)  # #
                    hh.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)  # شماره
                    hh.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)          # درخواست‌کننده
                    hh.setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)          # واحد
                    hh.setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents) # تاییدکننده
                    hh.setSectionResizeMode(5, QtWidgets.QHeaderView.ResizeToContents) # تاریخ/ساعت
                    hh.setSectionResizeMode(6, QtWidgets.QHeaderView.ResizeToContents) # تعداد
                except Exception:
                    pass

                tbl.resizeRowsToContents()

                def _open():
                    try:
                        idxs = tbl.selectionModel().selectedRows()
                        if not idxs: return
                        r = idxs[0].row()
                        key = tbl.item(r, 0).data(QtCore.Qt.UserRole)
                        if key is not None:
                            self._load_sourcing_items(int(key))
                    except Exception:
                        pass
                try: tbl.itemDoubleClicked.disconnect()
                except Exception: pass
                tbl.itemDoubleClicked.connect(lambda *_: _open())
            finally:
                tbl.setUpdatesEnabled(True)

        # List (در صورت وجود)
        if lst is not None:
            lst.clear()
            for row in rows:
                phys = row.get("physical_request_no") or '---'
                req  = row.get("requester_name") or '-'
                dep  = row.get("dept_name") or ''
                cnt  = int(row.get("items_count") or 0)
                it = QtWidgets.QListWidgetItem(f"{phys} — {req} ({dep}) [{cnt}]")
                it.setData(QtCore.Qt.UserRole, row.get("grp_key"))
                lst.addItem(it)
    # END REWRITE: UI.PurchasingWorkbenchWidget._load_sourcing_groups

    def _on_sourcing_group_selected(self):
        selected = self.tbl_sourcing_groups.selectedItems()
        if not selected:
            self.current_group_id = None
            self.tbl_sourcing_items.setRowCount(0)
            return
        self.current_group_id = int(self.tbl_sourcing_groups.item(selected[0].row(), 0).text())
        self._load_sourcing_items(self.current_group_id)

    # BEGIN REWRITE: UI.PurchasingWorkbenchWidget._load_sourcing_items
    def _load_sourcing_items(self, group_key: int):
        """
        اقلام فرم انتخاب‌شده را لود می‌کند (فقط ستون‌های «قلم»، نه «فرم»).
        ستون‌ها: [ID(hidden), کالا, مقدار, فوریت نهایی, مشخصات/یادداشت, پیوست‌ها]
        """
        from PyQt5 import QtWidgets, QtCore
        table = self.tbl_sourcing_items
        self.current_pr_id = None
        self.tbl_quotes.setRowCount(0)

        headers = ["ID", "کالا", "مقدار", "فوریت نهایی", "مشخصات و یادداشت", "پیوست‌ها"]
        table.setUpdatesEnabled(False)
        try:
            table.clear()
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(0)

            items = self.db.list_pr_items_for_sourcing(group_key) or []
            table.setRowCount(len(items))

            for r, item in enumerate(items):
                # ID (پنهان)
                it_id = QtWidgets.QTableWidgetItem(str(item.get('id') or ""))
                it_id.setFlags(it_id.flags() ^ QtCore.Qt.ItemIsEditable)
                table.setItem(r, 0, it_id)

                # کالا
                it_name = QtWidgets.QTableWidgetItem(item.get('item_name') or "")
                it_name.setFlags(it_name.flags() ^ QtCore.Qt.ItemIsEditable)
                table.setItem(r, 1, it_name)

                # مقدار
                val = item.get('requested_qty', "")
                it_qty = QtWidgets.QTableWidgetItem("" if val in (None, "") else str(val))
                it_qty.setFlags(it_qty.flags() ^ QtCore.Qt.ItemIsEditable)
                table.setItem(r, 2, it_qty)

                # فوریت نهایی
                it_urg = QtWidgets.QTableWidgetItem(item.get('final_urgency') or "")
                it_urg.setFlags(it_urg.flags() ^ QtCore.Qt.ItemIsEditable)
                table.setItem(r, 3, it_urg)

                # مشخصات/یادداشت (Preview + Tooltip)
                specs = item.get('specs') or ""
                notes = item.get('notes') or ""
                base  = (specs or notes)
                prev  = base[:80] + ("..." if len(base) > 80 else "")
                it_notes = QtWidgets.QTableWidgetItem(prev)
                it_notes.setToolTip(f"مشخصات:\n{specs or '-'}\n\nیادداشت:\n{notes or '-'}")
                it_notes.setFlags(it_notes.flags() ^ QtCore.Qt.ItemIsEditable)
                table.setItem(r, 4, it_notes)

                # پیوست‌ها (دکمه)
                cnt = int(item.get('attachments_count') or 0)
                btn = QtWidgets.QPushButton(f"{cnt} فایل")
                btn.setEnabled(cnt > 0)
                if cnt > 0:
                    from functools import partial
                    try:
                        btn.clicked.connect(partial(self.parent_window._show_pr_attachments, int(item.get('id'))))
                    except Exception:
                        btn.setEnabled(False)
                table.setCellWidget(r, 5, btn)

                # نگه‌داری آخرین PR انتخابی
                try:
                    self.current_pr_id = int(item.get('id'))
                except Exception:
                    pass

            # ستون‌بندی معقول (جلوگیری از «جمع شدن»)
            table.setColumnHidden(0, True)
            hh = table.horizontalHeader()
            try:
                hh.setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)        # کالا
                hh.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)# مقدار
                hh.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)# فوریت
                hh.setSectionResizeMode(4, QtWidgets.QHeaderView.Stretch)        # مشخصات/یادداشت
                hh.setSectionResizeMode(5, QtWidgets.QHeaderView.ResizeToContents)# پیوست‌ها
            except Exception:
                pass

            table.resizeRowsToContents()
            set_empty_placeholder(table, "برای مشاهده اقلام، یک فرم را از جدول بالا انتخاب کنید.")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در بارگذاری اقلام فرم:\n{e}")
        finally:
            table.setUpdatesEnabled(True)
    # END REWRITE: UI.PurchasingWorkbenchWidget._load_sourcing_items

    def _on_sourcing_item_selected(self):
        selected = self.tbl_sourcing_items.selectedItems()
        if not selected:
            self.current_pr_id = None
            self.tbl_quotes.setRowCount(0)
            return
        self.current_pr_id = int(self.tbl_sourcing_items.item(selected[0].row(), 0).text())
        self._load_quotes_for_current_pr()

    def _load_quotes_for_current_pr(self):
        if not self.current_pr_id:
            self.tbl_quotes.setRowCount(0)
            return

        rows = self.get_supplier_quotes(self.current_pr_id)
        table = self.tbl_quotes
        table.setSortingEnabled(False)

        headers = ["ID", "تامین‌کننده", "قیمت واحد", "زمان تحویل (روز)", "یادداشت"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setRowCount(len(rows))

        for r, q in enumerate(rows):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(q.get('id', ''))))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(q.get('supplier_name', '')))
            try:
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(f"{float(q.get('unit_price', 0)):,.0f}"))
            except Exception:
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(str(q.get('unit_price', ''))))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(str(q.get('lead_time_days', ''))))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(q.get('notes', '')))

        table.setColumnHidden(0, True)
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        try:
            set_empty_placeholder(table, "هنوز پیشنهادی ثبت نشده است.")
        except Exception:
            pass
        table.setSortingEnabled(True)
        
    # BEGIN ADD: UI.PurchasingWorkbenchWidget.get_supplier_quotes
    def get_supplier_quotes(self, pr_id: int) -> list[dict]:
        """
        کوئوت‌های تامین‌کننده برای یک PR را از لایهٔ DB می‌خواند و
        برای نمایش در جدول، نرمال‌سازی می‌کند.
        """
        try:
            rows = self.db.list_quotes_for_pr(pr_id) or []
            out: list[dict] = []
            for q in rows:
                out.append({
                    "id":             q.get("id") or q.get("quote_id"),
                    "supplier_name":  q.get("supplier_name", ""),
                    "unit_price":     q.get("unit_price", 0),
                    "currency":       q.get("currency", ""),
                    "lead_time_days": (q.get("lead_time_days")
                                    if q.get("lead_time_days") is not None
                                    else q.get("lead_time", 0)),
                    "min_order_qty":  q.get("min_order_qty", 0),
                    "is_winner":      1 if (q.get("is_winner") or q.get("is_selected")) else 0,
                    "notes":          q.get("notes", "")
                })
            return out
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در خواندن پیشنهادها", str(e))
            return []
    # END ADD: UI.PurchasingWorkbenchWidget.get_supplier_quotes

        
    def _load_supplier_quotes_for_selected_pr(self):
        """
        روکش سازگاری: PR انتخاب‌شده را از جدول‌های موجود کشف می‌کند و
        با فراخوانی _load_quotes_for_current_pr جدول کوئوت‌ها را به‌روز می‌نماید.
        اولویت: tbl_actionable_prs → tbl_sourcing_items.
        """
        try:
            pr_id = None

            # حالت 1: اگر جدول PRهای قابل اقدام وجود دارد
            if hasattr(self, 'tbl_actionable_prs') and getattr(self, 'tbl_actionable_prs'):
                try:
                    row = self.tbl_actionable_prs.currentRow()
                    if row is not None and row >= 0:
                        pr_item = self.tbl_actionable_prs.item(row, 0)
                        if pr_item and pr_item.text().strip():
                            pr_id = int(pr_item.text())
                except Exception:
                    pr_id = None

            # حالت 2: اگر در تب استعلام روی اقلام فرم هستیم
            if pr_id is None and hasattr(self, 'tbl_sourcing_items') and getattr(self, 'tbl_sourcing_items'):
                try:
                    row = self.tbl_sourcing_items.currentRow()
                    if row is not None and row >= 0:
                        pr_item = self.tbl_sourcing_items.item(row, 0)
                        if pr_item and pr_item.text().strip():
                            pr_id = int(pr_item.text())
                except Exception:
                    pr_id = None

            # ست کردن PR جاری و بارگذاری کوئوت‌ها
            self.current_pr_id = pr_id
            if pr_id and hasattr(self, '_load_quotes_for_current_pr'):
                self._load_quotes_for_current_pr()
            else:
                if hasattr(self, 'tbl_quotes') and getattr(self, 'tbl_quotes'):
                    self.tbl_quotes.setRowCount(0)
        except Exception:
            # از قطع UX جلوگیری می‌کنیم؛ لاگ در صورت نیاز
            pass
        
    def _load_requests_ready_for_po(self):
        """سازگاری عقب‌رو: بارگذاری «آماده سفارش» با متد واحد جدید."""
        try:
            self._load_requests_ready_for_ordering()
        except Exception as e:
            try:
                QtWidgets.QMessageBox.critical(self, "خطا در بارگذاری آماده سفارش", str(e))
            except Exception:
                pass

    def _add_quote_action(self):
        """دیالوگ افزودن کوئوت → فراخوانی DB.add_supplier_quote (PostgreSQL)."""
        if not self.current_pr_id:
            if self.toast: self.toast.show_message("ابتدا یک قلم کالا را از لیست بالا انتخاب کنید.", "warning")
            else: QtWidgets.QMessageBox.information(self, "افزودن پیشنهاد", "ابتدا یک قلم کالا را انتخاب کنید.")
            return
        dlg = AddQuoteDialog(self.db, self)
        if dlg.exec_() and (data := dlg.get_data()):
            try:
                currency = data.get('currency') or 'IRR'
                self.db.add_supplier_quote(
                    self.current_pr_id,
                    data['supplier_id'],
                    float(data['unit_price']),
                    currency,
                    int(data.get('lead_time') or 0) if data.get('lead_time') is not None else None,
                    float(data.get('min_order_qty')) if data.get('min_order_qty') is not None else None,
                    data.get('notes', ''),
                    self.user_id
                )
                if self.toast: self.toast.show_message("✔ پیشنهاد قیمت ثبت شد.", "success")
                self._load_quotes_for_current_pr()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت پیشنهاد: {e}")

    def _select_quote_action(self):
        selected_quote = self.tbl_quotes.selectedItems()
        if not self.current_pr_id or not selected_quote:
            self.toast.show_message("لطفاً یک قلم کالا و سپس یک پیشنهاد قیمت را انتخاب کنید.", "warning")
            return

        quote_id = int(self.tbl_quotes.item(selected_quote[0].row(), 0).text())

        try:
            # نام واحد و سِمانتیک استاندارد
            self.db.select_quote_winner(self.current_pr_id, quote_id, self.user_id)

            # بازخورد و به‌روزرسانی
            self.toast.show_message("✔ برنده انتخاب شد. درخواست به مرکز سفارش منتقل شد.", "success")
            self._load_sourcing_groups()
            self._load_requests_ready_for_ordering()

            # سوییچ صحیح به تب Ordering (ایندکس ۲)
            QtCore.QTimer.singleShot(100, lambda: self.tabs.setCurrentIndex(2))
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در انتخاب برنده: {e}")

    # ------------------------- Agent List Tab -------------------------

    def _create_agent_list_tab(self) -> QtWidgets.QWidget:
        page = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(page)
        toolbar = QtWidgets.QHBoxLayout()
        btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-export"), "تهیه خروجی اکسل برای کارپرداز")
        toolbar.addStretch()
        toolbar.addWidget(btn_export)
        layout.addLayout(toolbar)

        self.tbl_agent_purchases = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_agent_purchases)
        layout.addWidget(self.tbl_agent_purchases)

        btn_export.clicked.connect(lambda: export_table_to_excel(self.tbl_agent_purchases, self))
        return page

    def _load_agent_list(self):
        table = self.tbl_agent_purchases
        table.setRowCount(0)
        items = self.db.list_prs_for_agent() or []
        headers = ["کالا", "مقدار", "واحد", "مشخصات دقیق", "یادداشت", "درخواست‌دهنده", "واحد"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setRowCount(len(items))
        for r, item in enumerate(items):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(item.get('item_name', '')))
            table.setItem(r, 1, NumericTableWidgetItem(str(item.get('requested_qty', ''))))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(item.get('unit_name', '')))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(item.get('specs', '')))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(item.get('notes', '')))
            table.setItem(r, 5, QtWidgets.QTableWidgetItem(item.get('requester_name', '')))
            table.setItem(r, 6, QtWidgets.QTableWidgetItem(item.get('dept_name', '')))
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(table, "هیچ درخواستی برای کارپرداز ارجاع داده نشده است.")

    def _assign_to_agent_action(self):
        """ارجاع قلم انتخاب‌شده به کارپرداز و ریفرش تب‌ها در صورت موفقیت."""
        if not self.current_pr_id:
            if self.toast: self.toast.show_message("لطفاً یک قلم کالا را برای ارجاع انتخاب کنید.", "warning")
            else: QtWidgets.QMessageBox.information(self, "ارجاع", "یک قلم را انتخاب کنید.")
            return
        try:
            success = self.db.assign_pr_to_agent(self.current_pr_id, self.user_id)
            if success:
                if self.toast: self.toast.show_message("✔ درخواست به لیست کارپرداز منتقل شد.", "success")
                self._load_sourcing_groups()
                self._load_agent_list()
            else:
                if self.toast:
                    self.toast.show_message("! عملیات ناموفق بود. شاید قبلاً پردازش شده. لیست به‌روزرسانی شد.", "warning", msec=8000)
                self._load_sourcing_groups()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ارجاع به کارپرداز: {e}")

    # ------------------------- Ordering Tab -------------------------

    def _create_ordering_tab(self) -> QtWidgets.QWidget:
        """
        سه بخش:
          1) PRهای آماده سفارش (tbl_ready_for_order) + دکمه صدور PO
          2) POهای باز (tbl_open_pos)
          3) اقلام PO انتخاب‌شده (tbl_po_items) + دکمه دریافت
        """
        page = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout(page)

        top_group = QtWidgets.QGroupBox("درخواست‌های آماده برای سفارش")
        top_layout = QtWidgets.QVBoxLayout(top_group)
        self.tbl_ready_for_order = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_ready_for_order)
        top_layout.addWidget(self.tbl_ready_for_order)
        btns = QtWidgets.QHBoxLayout()
        self.btn_create_po_for_supplier = QtWidgets.QPushButton("صدور PO برای تامین‌کننده انتخابی")
        self.btn_create_po_for_supplier.setProperty("class", "primary")
        self.btn_create_po_for_supplier.setMinimumHeight(34)
        btns.addStretch()
        btns.addWidget(self.btn_create_po_for_supplier)
        top_layout.addLayout(btns)

        bottom_split = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        open_group = QtWidgets.QGroupBox("سفارش‌های باز")
        open_layout = QtWidgets.QVBoxLayout(open_group)
        self.tbl_open_pos = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_open_pos)
        open_layout.addWidget(self.tbl_open_pos)

        items_group = QtWidgets.QGroupBox("اقلام سفارش (برای دریافت انتخاب کنید)")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        self.tbl_po_items = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.tbl_po_items)
        items_layout.addWidget(self.tbl_po_items)
        recv_bar = QtWidgets.QHBoxLayout()
        self.btn_receive_po = QtWidgets.QPushButton("ثبت دریافت")
        self.btn_receive_po.setMinimumHeight(34)
        recv_bar.addStretch()
        recv_bar.addWidget(self.btn_receive_po)
        items_layout.addLayout(recv_bar)

        bottom_split.addWidget(open_group)
        bottom_split.addWidget(items_group)
        bottom_split.setSizes([500, 500])

        vbox.addWidget(top_group)
        vbox.addWidget(bottom_split)
        return page

    def _load_requests_ready_for_ordering(self):
        """PRهای آمادهٔ سفارش را در جدول مربوطه نشان می‌دهد (با ستون پنهان SUP#)."""
        if not hasattr(self, 'tbl_ready_for_order'):
            return
        t = self.tbl_ready_for_order
        t.setSortingEnabled(False)
        headers = ['PR', 'کالا', 'تامین‌کننده', 'مقدار', 'قیمت واحد', 'ارز', 'LeadTime', 'Quote#', 'SUP#']
        t.setColumnCount(len(headers))
        t.setHorizontalHeaderLabels(headers)
        rows = self.db.get_requests_ready_for_ordering() or []
        t.setRowCount(len(rows))
        for r, x in enumerate(rows):
            t.setItem(r, 0, QtWidgets.QTableWidgetItem(str(x['pr_id'])))
            t.setItem(r, 1, QtWidgets.QTableWidgetItem(str(x.get('item_name', ''))))
            t.setItem(r, 2, QtWidgets.QTableWidgetItem(str(x.get('supplier_name', ''))))
            t.setItem(r, 3, QtWidgets.QTableWidgetItem(str(x.get('requested_qty', ''))))
            t.setItem(r, 4, QtWidgets.QTableWidgetItem(str(x.get('unit_price', ''))))
            t.setItem(r, 5, QtWidgets.QTableWidgetItem(str(x.get('currency', ''))))
            t.setItem(r, 6, QtWidgets.QTableWidgetItem(str(x.get('lead_time_days', ''))))
            t.setItem(r, 7, QtWidgets.QTableWidgetItem(str(x.get('quote_id', ''))))
            t.setItem(r, 8, QtWidgets.QTableWidgetItem(str(x.get('supplier_id', ''))))  # ستون پنهان
        t.setColumnHidden(0, True)   # PR
        t.setColumnHidden(7, True)   # Quote#
        t.setColumnHidden(8, True)   # SUP#
        t.resizeColumnsToContents()
        t.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        try:
            set_empty_placeholder(t, "فعلاً چیزی برای سفارش وجود ندارد.")
        except Exception:
            pass
        t.setSortingEnabled(True)

    def _on_click_create_po_for_supplier(self, creator_user_id: int | None = None):
        """هندلر دکمه «صدور PO برای تامین‌کننده انتخابی» (از جدول آماده سفارش)."""
        try:
            self._ui_create_po_for_current_supplier(creator_user_id=creator_user_id)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در صدور PO", str(e))

    def _ui_create_po_for_current_supplier(self, creator_user_id: int | None = None):
        """
        بر اساس انتخاب فعلی در جدول «آماده سفارش»، همهٔ QuoteIDهای متعلق به همان تامین‌کننده را
        جمع‌آوری کرده و یک PO تجمیعی صادر می‌کند.
        انتظار: self.tbl_ready_for_order با ستون‌های پنهان SUP# (ایندکس 8) و Quote# (ایندکس 7).
        """
        if not hasattr(self, 'tbl_ready_for_order'):
            return

        t = self.tbl_ready_for_order
        sel = t.currentRow()
        if sel < 0:
            QtWidgets.QMessageBox.information(self, "صدور PO", "لطفاً یک ردیف از «آماده سفارش» را انتخاب کنید.")
            return

        try:
            supplier_id = int(t.item(sel, 8).text())  # SUP#
        except Exception:
            QtWidgets.QMessageBox.critical(self, "صدور PO", "شناسهٔ تامین‌کننده در دسترس نیست.")
            return

        quote_ids: list[int] = []
        for r in range(t.rowCount()):
            try:
                sup_r = int(t.item(r, 8).text())
                if sup_r == supplier_id:
                    qid = t.item(r, 7)
                    if qid and qid.text().strip():
                        quote_ids.append(int(qid.text()))
            except Exception:
                continue

        if not quote_ids:
            QtWidgets.QMessageBox.information(self, "صدور PO", "هیچ QuoteIDی برای این تامین‌کننده پیدا نشد.")
            return

        try:
            res = self.db.create_purchase_order_for_supplier(supplier_id, quote_ids, creator_user_id)
            order_no = (res or {}).get('order_no') or (res or {}).get('po_no') or str((res or {}).get('po_id', ''))
            QtWidgets.QMessageBox.information(self, "صدور PO", f"سفارش خرید با موفقیت ایجاد شد (PO {order_no}).")
            # تازه‌سازی لیست‌ها
            self._load_requests_ready_for_ordering()
            self._load_open_purchase_orders()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در صدور PO", str(e))

    def _load_open_purchase_orders(self):
        """POهای باز را برای دریافت نمایش می‌دهد."""
        if not hasattr(self, 'tbl_open_pos'):
            return
        t = self.tbl_open_pos
        t.setSortingEnabled(False)
        headers = ['PO', 'شماره سفارش', 'تامین‌کننده', 'وضعیت', 'تعداد اقلام', 'جمع مبلغ']
        t.setColumnCount(len(headers))
        t.setHorizontalHeaderLabels(headers)
        rows = self.db.get_open_purchase_orders() or []
        t.setRowCount(len(rows))
        for r, x in enumerate(rows):
            t.setItem(r, 0, QtWidgets.QTableWidgetItem(str(x['po_id'])))
            t.setItem(r, 1, QtWidgets.QTableWidgetItem(str(x.get('order_no', ''))))
            t.setItem(r, 2, QtWidgets.QTableWidgetItem(str(x.get('supplier_name', ''))))
            t.setItem(r, 3, QtWidgets.QTableWidgetItem(str(x.get('status', ''))))
            t.setItem(r, 4, QtWidgets.QTableWidgetItem(str(x.get('item_count', ''))))
            t.setItem(r, 5, QtWidgets.QTableWidgetItem(str(x.get('total_amount', ''))))
        t.setColumnHidden(0, True)
        t.resizeColumnsToContents()
        t.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        try:
            set_empty_placeholder(t, "هیچ PO بازی برای دریافت وجود ندارد.")
        except Exception:
            pass
        t.setSortingEnabled(True)

    def _on_open_pos_selection_changed(self):
        """با تغییر انتخاب PO، آیتم‌های همان PO را برای دریافت بارگذاری کن."""
        if not hasattr(self, 'tbl_open_pos') or not self.tbl_open_pos:
            return
        row = self.tbl_open_pos.currentRow()
        if row < 0:
            return
        po_id_item = self.tbl_open_pos.item(row, 0)
        if not po_id_item:
            return
        po_id = int(po_id_item.text())
        self._load_po_items_for_receive(po_id)

    def _load_po_items_for_receive(self, po_id: int):
        """آیتم‌های یک PO را برای دریافت بار می‌کند."""
        if not hasattr(self, 'tbl_po_items'):
            return
        t = self.tbl_po_items
        t.setSortingEnabled(False)
        headers = ['POI', 'کالا', 'سفارش‌شده', 'دریافت‌شده', 'باقیمانده', 'قیمت واحد']
        t.setColumnCount(len(headers))
        t.setHorizontalHeaderLabels(headers)
        rows = self.db.get_po_items_by_po_id(po_id) or []
        t.setRowCount(len(rows))
        for r, x in enumerate(rows):
            t.setItem(r, 0, QtWidgets.QTableWidgetItem(str(x['po_item_id'])))
            t.setItem(r, 1, QtWidgets.QTableWidgetItem(str(x.get('item_name', ''))))
            t.setItem(r, 2, NumericTableWidgetItem(str(x.get('ordered_qty', ''))))
            t.setItem(r, 3, NumericTableWidgetItem(str(x.get('received_qty', ''))))
            t.setItem(r, 4, NumericTableWidgetItem(str(x.get('remaining_qty', ''))))
            t.setItem(r, 5, NumericTableWidgetItem(str(x.get('unit_price', ''))))
        t.setColumnHidden(0, True)
        t.resizeColumnsToContents()
        t.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        t.setSortingEnabled(True)

    # BEGIN REWRITE: UI.PurchasingWorkbenchWidget._receive_current_po
    def _receive_current_po(self, receiver_id: int, receipt_no: str | None = None, received_at: str | None = None):
        """ثبت دریافت بر اساس مقدار «باقیمانده» (قابل ویرایش توسط کاربر).
        - سازگار عقب‌رو: پارامتر جدید `received_at` اختیاری است.
        - DN و تاریخ دریافت به DB پاس داده می‌شود.
        """
        if not hasattr(self, 'tbl_open_pos') or not hasattr(self, 'tbl_po_items'):
            return
        tpos = self.tbl_open_pos
        sel = tpos.currentRow()
        if sel < 0:
            QtWidgets.QMessageBox.information(self, "دریافت", "هیچ POیی انتخاب نشده.")
            return
        po_id = int(tpos.item(sel, 0).text())

        t = self.tbl_po_items
        items = []
        for r in range(t.rowCount()):
            try:
                poi_id = int(t.item(r, 0).text())
                ordered = float(t.item(r, 2).text()) if t.item(r, 2) else 0
                received = float(t.item(r, 3).text()) if t.item(r, 3) else 0
                remain = max(0.0, ordered - received)
                qty = remain
                if qty > 0:
                    items.append({'po_item_id': poi_id, 'qty': qty})
            except Exception:
                continue

        if not items:
            QtWidgets.QMessageBox.information(self, "دریافت", "هیچ مقداری برای دریافت وارد نشده.")
            return

        try:
            _ = self.db.receive_purchase_order(po_id, receiver_id, items, receipt_no=receipt_no, received_at=received_at)
            QtWidgets.QMessageBox.information(self, "دریافت", "دریافت با موفقیت ثبت شد.")
            # تازه‌سازی جداول
            self._load_open_purchase_orders()
            self._load_po_items_for_receive(po_id)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در دریافت", str(e))
    # END REWRITE: UI.PurchasingWorkbenchWidget._receive_current_po
    # ------------------------- KPI / Helpers -------------------------

    def _refresh_purchasing_kpis(self):
        """
        KPIها را از DB می‌خواند و در برچسب‌های UI قرار می‌دهد.
        انتظار: self.db و برچسب‌هایی مثل lbl_kpi_actionable/lbl_kpi_ready/lbl_kpi_open/lbl_kpi_partial
        اگر برچسب‌ها موجود نبودند، بی‌سروصدا رد می‌شود.
        """
        try:
            k = self.db.get_purchasing_kpis()
        except Exception:
            return

        def _set(lbl_name, val):
            if hasattr(self, lbl_name) and getattr(self, lbl_name):
                try:
                    getattr(self, lbl_name).setText(str(val))
                except Exception:
                    pass

        _set('lbl_kpi_actionable', k.get('actionable_prs', 0))
        _set('lbl_kpi_ready',      k.get('ready_for_ordering', 0))
        _set('lbl_kpi_open',       k.get('open_pos', 0))
        _set('lbl_kpi_partial',    k.get('partial_pos', 0))

    # ------------------------- Backward-compat shims -------------------------

    def _ui_mark_quote_winner(self, approver_user_id: int | None = None):
        """
        نگه‌داشته برای سازگاری: انتخاب برنده بر اساس انتخاب فعلی در tbl_sourcing_items/tbl_quotes.
        """
        if not hasattr(self, 'tbl_sourcing_items') or not hasattr(self, 'tbl_quotes'):
            return
        pr_row = self.tbl_sourcing_items.currentRow()
        qt_row = self.tbl_quotes.currentRow()
        if pr_row < 0 or qt_row < 0:
            QtWidgets.QMessageBox.information(self, "انتخاب برنده", "لطفاً یک PR و یک کوئوت را انتخاب کنید.")
            return
        pr_id = int(self.tbl_sourcing_items.item(pr_row, 0).text())
        quote_id = int(self.tbl_quotes.item(qt_row, 0).text())
        try:
            self.db.select_quote_winner(pr_id, quote_id, approver_user_id)
            QtWidgets.QMessageBox.information(self, "انتخاب برنده", "تأمین‌کننده برنده ثبت شد.")
            self._load_quotes_for_current_pr()
            self._load_requests_ready_for_ordering()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", str(e))

    def _on_actionable_pr_selection_changed(self):
        """
        با تغییر انتخاب PR، لیست کوئوت‌های مربوطه را بارگذاری می‌کند.
        """
        try:
            self._load_supplier_quotes_for_selected_pr()
        except Exception as e:
            # لاگ خطا برای اشکال‌زدایی بدون قطع UX
            print(f"_on_actionable_pr_selection_changed error: {e}")

    def _issue_aggregated_po_action(self):
        """
        نگه‌داشته برای سازگاری با کد قدیمی (درخت تأمین‌کننده).
        اکنون به اکشن جدید «صدور PO برای تامین‌کننده انتخابی» هدایت می‌شود.
        """
        self._on_click_create_po_for_supplier(creator_user_id=self.user_id)

        
                    
class TraceabilityDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش گزارش ردیابی و دارای ابزار دیباگ."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ابزار ردیابی محصول به تامین‌کننده")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        search_layout = QtWidgets.QHBoxLayout()
        self.batch_input = QtWidgets.QLineEdit(placeholderText="شماره بچ محصول نهایی (بسته‌بندی شده) یا محصول فله را وارد کنید...")
        search_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), "ردیابی کن")
        search_btn.setProperty("class", "primary")
        
        # --- دکمه جدید دیباگ ---
        debug_btn = QtWidgets.QPushButton("دیباگ لاگ")
        debug_btn.setStyleSheet("background-color: #f39c12; color: white;") # Orange color
        
        search_layout.addWidget(self.batch_input, 1)
        search_layout.addWidget(search_btn)
        search_layout.addWidget(debug_btn) # افزودن دکمه به layout
        layout.addLayout(search_layout)

        self.results_tree = QtWidgets.QTreeWidget()
        self.results_tree.setHeaderLabels(["شرح ردیابی", "جزئیات"])
        self.results_tree.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.results_tree)

        search_btn.clicked.connect(self._run_trace)
        debug_btn.clicked.connect(self._debug_log) # اتصال دکمه جدید
        self.batch_input.returnPressed.connect(self._run_trace)

    def _debug_log(self):
        """تابع جدید برای اجرای عملیات دیباگ."""
        batch_no = self.batch_input.text().strip()
        if not batch_no:
            print("DEBUG: Please enter a batch number first.")
            return
        print(f"\n--- DEBUGGING TRACEABILITY FOR BATCH: {batch_no} ---")
        log_content = self.db.debug_get_packing_audit_log(batch_no)
        
        # چاپ نتیجه در کنسول
        print("--- RAW AUDIT LOG CONTENT ---")
        print(log_content)
        print("-----------------------------")
        
        QtWidgets.QMessageBox.information(self, "دیباگ", "نتیجه دیباگ در کنسول چاپ شد. لطفاً آن را برای تحلیل ارسال کنید.")

    def _run_trace(self):
        self.results_tree.clear()
        batch_no = self.batch_input.text().strip()
        if not batch_no: return

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            full_report = self.db.get_full_traceability_report(batch_no)
            if not full_report:
                QtWidgets.QTreeWidgetItem(self.results_tree, ["هیچ سابقه‌ای برای این بچ یافت نشد."])
                return

            root_item = QtWidgets.QTreeWidgetItem(self.results_tree, [f"نتایج ردیابی برای بچ ورودی: {batch_no}"])
            root_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))

            for bulk_batch, raw_materials in full_report.items():
                bulk_item = QtWidgets.QTreeWidgetItem(root_item, [f"ساخته شده از محصول فله با بچ: {bulk_batch}"])
                bulk_item.setIcon(0, QtGui.QIcon.fromTheme("lab-flask"))
                
                if not raw_materials:
                    QtWidgets.QTreeWidgetItem(bulk_item, ["مواد اولیه برای این بچ فله یافت نشد."])
                    continue
                
                for material in raw_materials:
                    material_item = QtWidgets.QTreeWidgetItem(bulk_item, [material['raw_material_name'], f"بچ: {material['raw_batch']}"])
                    supplier_name = material.get('supplier_name') or "نامشخص (موجودی اولیه)"
                    QtWidgets.QTreeWidgetItem(material_item, ["تامین‌کننده", supplier_name])
                    if material.get('po_number'):
                        QtWidgets.QTreeWidgetItem(material_item, ["شماره سفارش خرید", material['po_number']])

            self.results_tree.expandAll()
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
                                    
            
    
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ProductionStockDetailDialog(QtWidgets.QDialog):
    """
    دیالوگی اختصاصی برای نمایش جزئیات موجودی یک کالا فقط در انبار تولید.
    """
    def __init__(self, db: DB, item_id: int, item_name: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"جزئیات موجودی در انبار تولید: {item_name}")
        self.setMinimumWidth(550)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(table)
        
        headers = ["شماره بچ", "تاریخ انقضا", "مقدار موجود", "واحد"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        
        stock_details = self.db.get_stock_details_for_item_in_warehouse(item_id, 'Production')
        table.setRowCount(len(stock_details))

        for r, detail in enumerate(stock_details):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(detail['batch_no']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(to_shamsi(detail.get('expiry_date'))))
            table.setItem(r, 2, NumericTableWidgetItem(str(detail['qty'])))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(detail.get('unit', '')))
        
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(table)
        
            
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ProductionWorkbenchDialog(QtWidgets.QDialog):
    """میزکار هوشمند برای برنامه‌ریزی تولید."""
    def __init__(self, db: DB, user_id: int, production_order_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.production_order_id = production_order_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)
        self.requirements_data = [] # برای نگهداری اطلاعات نیازمندی‌ها

        # خواندن اطلاعات سفارش از دیتابیس
        order_details = self.db.execute_query("SELECT po.*, i.name as item_name FROM production_orders po JOIN items i ON po.item_id = i.id WHERE po.id = %s", (self.production_order_id,), fetch_one=True)
        self.order_data = dict(order_details) if order_details else {}

        self.setWindowTitle(f"میزکار برنامه‌ریزی برای سفارش: {self.order_data.get('item_name', '')}")
        self.setMinimumSize(900, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel(f"<b>بررسی نیازمندی‌ها برای تولید {self.order_data.get('quantity', 0)} پک از محصول:</b>"))
        
        self.requirements_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.requirements_table)
        layout.addWidget(self.requirements_table)

        self.pack_button = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("utilities-x-archive"), "موجودی کافیست، شروع عملیات بسته‌بندی")
        self.pack_button.setProperty("class", "primary")
        self.pack_button.setMinimumHeight(40)
        self.pack_button.setEnabled(False) # در ابتدا غیرفعال است
        self.pack_button.clicked.connect(self._start_packing_process)
        layout.addWidget(self.pack_button)
        
        self._load_requirements()

    def _load_requirements(self):
        """نیازمندی‌های سفارش (مواد فله و لوازم بسته‌بندی) را محاسبه و نمایش می‌دهد."""
        pack_item_details = self.db.get_item_details(self.order_data.get('item_id'))
        if not pack_item_details or not pack_item_details.get('parent_item_id'):
            self.toast.show_message("این سفارش به یک محصول مادر متصل نیست.", "critical", msec=10000)
            self.close(); return

        parent_item_details = self.db.get_item_details(pack_item_details['parent_item_id'])
        if not parent_item_details:
             QtWidgets.QMessageBox.critical(self, "خطای داده", "محصول مادر مرتبط با این پک یافت نشد."); self.close(); return
        
        # گام ۱: تشخیص نوع محصول (تک یا دوجزئی) از روی اطلاعات محصول مادر
        is_two_component_product = parent_item_details.get('is_two_component', False)
        
        bulk_components_to_process = []
        total_ratio_parts = 0

        # گام ۲: پیدا کردن فرمول‌های فعال بر اساس نوع محصول
        if is_two_component_product:
            master_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'MASTER' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            if not master_recipe:
                QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"برای محصول دوجزئی «{parent_item_details['name']}» یک «دستور ساخت مادر» فعال تعریف نشده است."); self.close(); return
            
            # خواندن نسبت اختلاط از فرمول مادر
            properties = master_recipe.get('properties', {});
            if isinstance(properties, str) and properties: properties = json.loads(properties)
            mix_ratio = properties.get('mix_ratio', {}); ratio_a = mix_ratio.get('A', 0); ratio_b = mix_ratio.get('B', 0)
            total_ratio_parts = ratio_a + ratio_b
            if total_ratio_parts <= 0:
                 QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"نسبت اختلاط در دستور ساخت مادر برای محصول «{parent_item_details['name']}» به درستی تعریف نشده است."); self.close(); return
            
            part_a_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'A' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            part_b_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'B' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            
            if not part_a_recipe or not part_b_recipe: 
                QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"برای محصول «{parent_item_details['name']}» فرمول ساخت فعال برای پارت A یا B تعریف نشده است."); self.close(); return
            
            bulk_components_to_process.append({'recipe': part_a_recipe, 'ratio': ratio_a})
            bulk_components_to_process.append({'recipe': part_b_recipe, 'ratio': ratio_b})
        else: # محصول تک‌جزئی
            single_part_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'P' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            if not single_part_recipe: 
                QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"هیچ فرمول ساخت فعال (تک جزئی - پارت P) برای محصول «{parent_item_details['name']}» تعریف نشده است."); self.close(); return
            total_ratio_parts = 1.0
            bulk_components_to_process.append({'recipe': single_part_recipe, 'ratio': 1.0})

        # گام ۳: پیدا کردن لیست لوازم بسته‌بندی
        packaging_bom = self.db.get_bom_for_product(pack_item_details['name'])

        # گام ۴: پر کردن جدول نیازمندی‌ها
        headers = ["نوع جزء", "نام جزء", "مقدار مورد نیاز", "موجودی در دسترس (کف کارگاه)", "کسری", "اقدام"]
        self.requirements_table.setColumnCount(len(headers)); self.requirements_table.setHorizontalHeaderLabels(headers)
        all_requirements_met = True
        
        # افزودن ردیف برای مواد فله
        for comp_data in bulk_components_to_process:
            bulk_item_id = comp_data['recipe'].get('produces_item_id')
            if not bulk_item_id:
                all_requirements_met = False
                continue # اگر فرمول به محصول خروجی متصل نباشد
                
            bulk_item_details = self.db.get_item_details(bulk_item_id)
            if not bulk_item_details:
                all_requirements_met = False
                continue

            r = self.requirements_table.rowCount(); self.requirements_table.insertRow(r)
            required_qty = (pack_item_details.get('net_weight', 0) / total_ratio_parts) * comp_data['ratio'] * self.order_data['quantity']
            available_qty = self.db.get_item_stock_in_warehouse(bulk_item_details['id'], PRODUCTION_WAREHOUSE_NAME)
            deficit = max(0, required_qty - available_qty)

            if deficit > 0: all_requirements_met = False
                
            self.requirements_data.append({'component_details': bulk_item_details, 'required_qty': required_qty, 'is_bulk': True})
            
            self.requirements_table.setItem(r, 0, QtWidgets.QTableWidgetItem("محصول فله"))
            self.requirements_table.setItem(r, 1, QtWidgets.QTableWidgetItem(bulk_item_details['name']))
            self.requirements_table.setItem(r, 2, NumericTableWidgetItem(f"{required_qty:.3f}"))
            self.requirements_table.setItem(r, 3, NumericTableWidgetItem(f"{available_qty:.3f}"))
            
            deficit_item = NumericTableWidgetItem(f"{deficit:.3f}"); 
            if deficit > 0: deficit_item.setBackground(QtGui.QColor("#fff3cd"))
            self.requirements_table.setItem(r, 4, deficit_item)
            
            if deficit > 0:
                btn_produce = QtWidgets.QPushButton("شروع تولید..."); btn_produce.setProperty("class", "danger")
                btn_produce.clicked.connect(lambda _, d=bulk_item_details, q=deficit: self._trigger_bulk_production(d, q))
                self.requirements_table.setCellWidget(r, 5, btn_produce)
            else:
                ok_item = QtWidgets.QTableWidgetItem("✔"); ok_item.setForeground(QtGui.QColor("green"))
                self.requirements_table.setItem(r, 5, ok_item)

        # افزودن ردیف برای لوازم بسته‌بندی
        for item in packaging_bom:
            comp_details = self.db.get_item_details(item['component_item_id'])
            if not comp_details or comp_details['category'] != CATEGORY_PACKAGING: continue
            
            r = self.requirements_table.rowCount(); self.requirements_table.insertRow(r)
            required_qty = item['quantity'] * self.order_data['quantity']
            available_qty = self.db.get_item_stock_in_warehouse(comp_details['id'], PRODUCTION_WAREHOUSE_NAME)
            deficit = max(0, required_qty - available_qty)

            if deficit > 0: all_requirements_met = False

            self.requirements_data.append({'component_details': comp_details, 'required_qty': required_qty, 'is_bulk': False})

            self.requirements_table.setItem(r, 0, QtWidgets.QTableWidgetItem("لوازم بسته‌بندی"))
            self.requirements_table.setItem(r, 1, QtWidgets.QTableWidgetItem(comp_details['name']))
            self.requirements_table.setItem(r, 2, NumericTableWidgetItem(f"{required_qty:.3f}"))
            self.requirements_table.setItem(r, 3, NumericTableWidgetItem(f"{available_qty:.3f}"))
            
            deficit_item = NumericTableWidgetItem(f"{deficit:.3f}"); 
            if deficit > 0: deficit_item.setBackground(QtGui.QColor("#fff3cd"))
            self.requirements_table.setItem(r, 4, deficit_item)
            
            if deficit > 0:
                btn_request = QtWidgets.QPushButton("درخواست از انبار")
                # بررسی اینکه آیا درخواست فعال از قبل وجود دارد یا خیر
                if not self.db.does_active_material_request_exist(self.production_order_id, comp_details['id']):
                    btn_request.clicked.connect(lambda _, d=comp_details, q=deficit, b=btn_request: self._request_supply_from_warehouse(d, q, b))
                else:
                    btn_request.setText("درخواست ارسال شده")
                    btn_request.setEnabled(False)
                self.requirements_table.setCellWidget(r, 5, btn_request)
            else:
                ok_item = QtWidgets.QTableWidgetItem("✔"); ok_item.setForeground(QtGui.QColor("green"))
                self.requirements_table.setItem(r, 5, ok_item)

        self.pack_button.setEnabled(all_requirements_met)
        self.requirements_table.resizeColumnsToContents()
        self.requirements_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        
    def _request_supply_from_warehouse(self, component_details: dict, required_qty: float, sender_button: QtWidgets.QPushButton):
        """یک درخواست مواد اولیه برای لوازم بسته‌بندی کسری، به انبار ارسال می‌کند."""
        try:
            self.db.submit_material_request(
                item_id=component_details['id'], 
                requested_qty=required_qty, 
                requester_id=self.user_id,
                notes=f"درخواست خودکار از میزکار تولید برای سفارش شماره {self.production_order_id}"
            )
            self.toast.show_message(f"✔ درخواست برای «{component_details['name']}» به کارتابل انبار ارسال شد.", "success")
            if sender_button:
                sender_button.setText("درخواست ارسال شده")
                sender_button.setEnabled(False)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ثبت درخواست", f"خطا: {e}")

    def _trigger_bulk_production(self, bulk_item_details: dict, needed_qty: float):
        """کاربر را به فرم گزارش تولید هدایت می‌کند تا برای کسری محصول فله، تولید جدیدی ثبت کند."""
        min_batch_size, ok = QtWidgets.QInputDialog.getDouble(self, "حداقل بچ تولید", f"برای «{bulk_item_details['name']}» حداقل چه مقداری باید تولید شود؟\n(نیاز فعلی سفارش: {needed_qty:.3f})", 250.0, needed_qty, 10000, 2)
        if ok and min_batch_size > 0:
            prefill_data = {
                'product_name': bulk_item_details['name'],
                'quantity': min_batch_size,
                'linked_pack_order_id': self.production_order_id # اتصال به سفارش پک مادر
            }
            # فراخوانی متد اصلی پنجره مادر برای باز کردن دیالوگ تولید
            self.parent_window._open_report_production_dialog(prefill_data=prefill_data)
            self.close() # بستن میزکار فعلی

    def _start_packing_process(self):
        """پلن مصرف را ساخته، به کاربر نمایش داده و در صورت تایید، عملیات را در دیتابیس اجرا می‌کند."""
        # این متد در گام بعدی تکمیل خواهد شد
        self.toast.show_message("منطق نهایی بسته‌بندی در مرحله بعد پیاده‌سازی می‌شود.", "info")
        
        
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید

class ManageDepartmentRolesDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت تخصیص نقش‌ها به واحدهای سازمانی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id = None

        self.setWindowTitle("مدیریت نقش‌های واحدها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 500)

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # پنل چپ: لیست واحدها
        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel)
        left_layout.addWidget(QtWidgets.QLabel("<b>۱. واحد سازمانی را انتخاب کنید:</b>"))
        self.dept_list = QtWidgets.QListWidget()
        self.dept_list.itemSelectionChanged.connect(self._on_department_selected)
        left_layout.addWidget(self.dept_list)
        splitter.addWidget(left_panel)
        
        # پنل راست: لیست نقش‌ها با چک‌باکس
        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel)
        self.roles_label = QtWidgets.QLabel("<b>۲. نقش‌های مجاز را مشخص کنید:</b>")
        right_layout.addWidget(self.roles_label)
        self.roles_table = QtWidgets.QTableWidget(0, 2)
        self.roles_table.setHorizontalHeaderLabels(['نام نقش', 'مجاز است؟'])
        self.roles_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        right_layout.addWidget(self.roles_table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات برای این واحد")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_assignments)
        right_layout.addWidget(btn_save)
        splitter.addWidget(right_panel)
        
        main_layout.addWidget(splitter)
        
        self._load_departments()
        self._load_all_roles()

    def _load_departments(self):
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            item = QtWidgets.QListWidgetItem(dept['name'])
            item.setData(Qt.UserRole, dept['id'])
            self.dept_list.addItem(item)
            
    def _load_all_roles(self):
        all_roles = self.db.get_all_roles()
        self.roles_table.setRowCount(len(all_roles))
        for r, role in enumerate(all_roles):
            name_item = QtWidgets.QTableWidgetItem(role['name'])
            name_item.setData(Qt.UserRole, role['id'])
            name_item.setFlags(name_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.roles_table.setItem(r, 0, name_item)
            
            checkbox_widget = QtWidgets.QWidget()
            chk_layout = QtWidgets.QHBoxLayout(checkbox_widget)
            chk_box = QtWidgets.QCheckBox()
            chk_layout.addWidget(chk_box)
            chk_layout.setAlignment(QtCore.Qt.AlignCenter)
            self.roles_table.setCellWidget(r, 1, checkbox_widget)
        self.roles_table.setEnabled(False)

    def _on_department_selected(self):
        selected = self.dept_list.selectedItems()
        if not selected:
            self.current_dept_id = None
            self.roles_table.setEnabled(False)
            return
            
        self.current_dept_id = selected[0].data(Qt.UserRole)
        self.roles_table.setEnabled(True)
        self.roles_label.setText(f"<b>۲. نقش‌های مجاز برای «{selected[0].text()}»:</b>")
        
        assigned_role_ids = self.db.get_role_ids_for_department(self.current_dept_id)
        
        for r in range(self.roles_table.rowCount()):
            role_id = self.roles_table.item(r, 0).data(Qt.UserRole)
            chk_box = self.roles_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            chk_box.setChecked(role_id in assigned_role_ids)

    def _save_assignments(self):
        if self.current_dept_id is None:
            self.toast.show_message("لطفاً ابتدا یک واحد سازمانی را انتخاب کنید.", "warning")
            return
        
        selected_role_ids = []
        for r in range(self.roles_table.rowCount()):
            chk_box = self.roles_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            if chk_box.isChecked():
                selected_role_ids.append(self.roles_table.item(r, 0).data(Qt.UserRole))

        try:
            self.db.update_roles_for_department(self.current_dept_id, selected_role_ids)
            self.toast.show_message("✔ ارتباط نقش‌ها و واحد با موفقیت ذخیره شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
            
# این کلاس کاملا جدید را به انتهای فایل اضافه کنید

class SystemOperationMappingDialog(QtWidgets.QDialog):
    """پنجره‌ای برای اتصال بصری عملیات‌های سیستمی به فرآیندهای QA."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)

        # دیکشنری اصلی عملیات‌های سیستمی
        self.SYSTEM_OPERATIONS = {
            'DISPATCH_CENTER_START_PROCESS': "شروع فرآیند از مرکز ارسال"
            # در آینده می‌توانید عملیات‌های دیگر را به این دیکشنری اضافه کنید
        }

        self.setWindowTitle("اتصال فرآیندها به عملیات سیستمی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(750, 400)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر عملیات سیستم، مشخص کنید کدام فرآیند باید اجرا شود:"))

        self.table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(self.table)
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(['عملیات سیستمی', 'فرآیند تخصیص یافته'])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره اتصالات")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_mappings)
        layout.addWidget(btn_save)
        
        self._load_data()

    def _load_data(self):
        active_workflows = self.db.get_active_workflows()
        current_mappings = self.db.execute_query("SELECT operation_key, workflow_id FROM system_operation_mappings")
        mappings_map = {m['operation_key']: m['workflow_id'] for m in current_mappings}

        self.table.setRowCount(len(self.SYSTEM_OPERATIONS))
        for r, (op_key, op_desc) in enumerate(self.SYSTEM_OPERATIONS.items()):
            op_item = QtWidgets.QTableWidgetItem(op_desc)
            op_item.setData(Qt.UserRole, op_key)
            op_item.setFlags(op_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.table.setItem(r, 0, op_item)

            combo = QtWidgets.QComboBox()
            combo.addItem("--- هیچ فرآیندی متصل نیست ---", None)
            for wf in active_workflows:
                combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])
            
            if op_key in mappings_map:
                workflow_id = mappings_map[op_key]
                index = combo.findData(workflow_id)
                if index != -1:
                    combo.setCurrentIndex(index)

            self.table.setCellWidget(r, 1, combo)

    def _save_mappings(self):
        mappings_to_save = {}
        for r in range(self.table.rowCount()):
            op_key = self.table.item(r, 0).data(Qt.UserRole)
            combo = self.table.cellWidget(r, 1)
            workflow_id = combo.currentData()
            if workflow_id is not None:
                 mappings_to_save[op_key] = workflow_id
        
        try:
            # یک متد جدید در DB برای این کار می‌سازیم
            self.db.save_system_operation_mappings(mappings_to_save)
            if self.toast: self.toast.show_message("✔ اتصالات عملیات با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی اتصالات:\n{e}")
            
# کلاس PackingDialog را به طور کامل با این نسخه هوشمند و جدید جایگزین کنید
class PackingDialog(QtWidgets.QDialog):
    """
    نسخه 3.0 (هوشمند): پنجره بسته‌بندی دستی که نیازمندی‌ها را به صورت خودکار از دستور ساخت فعال محاسبه می‌کند.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)
        self.setWindowTitle("ثبت بسته‌بندی محصول (دستی)")
        self.setMinimumSize(800, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.requirements = []

        main_layout = QtWidgets.QVBoxLayout(self); main_layout.setSpacing(15)
        
        # بخش ۱: ورودی‌های اصلی کاربر
        input_group = QtWidgets.QGroupBox("مشخصات تولید")
        form_layout = QtWidgets.QFormLayout(input_group)
        self.output_sku_combo = QtWidgets.QComboBox()
        self.pack_count_edit = QtWidgets.QLineEdit("1"); self.pack_count_edit.setValidator(QtGui.QIntValidator(1, 10000))
        self.output_batch_edit = QtWidgets.QLineEdit(); self.output_batch_edit.setReadOnly(True)
        form_layout.addRow("انتخاب پک نهایی (*):", self.output_sku_combo)
        form_layout.addRow("تعداد پک برای تولید (*):", self.pack_count_edit)
        form_layout.addRow("شماره بچ نهایی (خودکار):", self.output_batch_edit)
        main_layout.addWidget(input_group)

        # بخش ۲: نیازمندی‌های محاسبه شده
        req_group = QtWidgets.QGroupBox("نیازمندی‌های محاسبه شده (بر اساس فرمول فعال)")
        req_layout = QtWidgets.QVBoxLayout(req_group)
        self.req_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'): self.parent_window._style_table(self.req_table)
        req_layout.addWidget(self.req_table)
        main_layout.addWidget(req_group, 1)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.ok_button = buttons.button(QtWidgets.QDialogButtonBox.Ok); self.ok_button.setText("شروع عملیات بسته‌بندی")
        self.ok_button.setProperty("class", "primary"); self.ok_button.setEnabled(False)
        buttons.accepted.connect(self._start_packing_process)
        buttons.rejected.connect(self.reject)
        main_layout.addWidget(buttons)

        self.output_sku_combo.currentIndexChanged.connect(self._calculate_requirements)
        self.pack_count_edit.textChanged.connect(self._calculate_requirements)
        self._setup_sku_combo()

    def _setup_sku_combo(self):
        # این متد فقط پک‌های نهایی که به یک محصول مادر متصل هستند را لیست می‌کند
        query = "SELECT i.*, p.name as parent_name, p.is_two_component FROM items i JOIN items p ON i.parent_item_id = p.id WHERE i.category = %s AND p.is_parent_product = TRUE ORDER BY p.name, i.name"
        all_packs = self.db.execute_query(query, (CATEGORY_FINAL_PRODUCT,))
        self.output_sku_combo.addItem("--- یک پک را انتخاب کنید ---", None)
        for pack in all_packs:
            display_text = f"{pack['parent_name']} / {pack['name']} (SKU: {pack.get('sku', 'ندارد')})"
            self.output_sku_combo.addItem(display_text, dict(pack))

    # BEGIN REWRITE: PackingDialog._calculate_requirements
    def _calculate_requirements(self):
        self.requirements.clear()
        self.req_table.setRowCount(0)
        self.ok_button.setEnabled(False)

        pack_details = self.output_sku_combo.currentData()
        try:
            num_packs = int(self.pack_count_edit.text())
        except (ValueError, TypeError):
            num_packs = 0

        if not pack_details or num_packs <= 0:
            return

        # شماره بچ خروجی را جلوتر پیشنهاد بده
        self.output_batch_edit.setText(
            self.db.get_next_packed_batch_no(pack_details.get('sku', 'NOSKU'))
        )

        from PyQt5.QtCore import Qt
        try:
            QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)

            # --- تشخیص دو‌جزئی بودن از «مادر»، نه از خود پک ---
            parent_id = pack_details.get('parent_item_id')
            if not parent_id:
                # تلاش برای گرفتن از خود آیتم پک (id یا SKU)
                pack_id = pack_details.get('id') or pack_details.get('item_id')
                row_parent = None
                if pack_id:
                    row_parent = self.db.execute_query(
                        "SELECT parent_item_id FROM items WHERE id = %s",
                        (pack_id,),
                        fetch_one=True
                    )
                elif pack_details.get('sku'):
                    row_parent = self.db.execute_query(
                        "SELECT parent_item_id FROM items WHERE TRIM(sku)=TRIM(%s) LIMIT 1",
                        (pack_details['sku'],),
                        fetch_one=True
                    )
                parent_id = (row_parent or {}).get('parent_item_id')

            parent_row = self.db.execute_query(
                "SELECT is_two_component FROM items WHERE id = %s",
                (parent_id,),
                fetch_one=True
            ) if parent_id else None
            is_two_comp = bool(parent_row and parent_row.get('is_two_component', False))

            # ---------------- محاسبهٔ نیاز فله ----------------
            if is_two_comp:
                # دستور ساخت مادر (برای نسبت اختلاط)
                master_recipe = self.db.execute_query(
                    "SELECT properties FROM recipes "
                    "WHERE parent_product_id = %s AND part_type IN ('MASTER','MIX','M') AND status = 'ACTIVE' "
                    "LIMIT 1",
                    (parent_id,),
                    fetch_one=True
                )
                props = {}
                if master_recipe and master_recipe.get('properties') is not None:
                    props = json.loads(master_recipe['properties']) \
                            if isinstance(master_recipe['properties'], str) \
                            else (master_recipe['properties'] or {})

                mix_ratio = props.get('mix_ratio') or props.get('mix') or {}
                ra = mix_ratio.get('A', mix_ratio.get('a', props.get('ratio_a')))
                rb = mix_ratio.get('B', mix_ratio.get('b', props.get('ratio_b')))

                # پشتیبانی از رشته‌های «a:b»
                def _to_float(v):
                    if v is None:
                        return 0.0
                    if isinstance(v, (int, float)):
                        return float(v)
                    s = str(v).strip()
                    trans = str.maketrans("۰۱۲۳۴۵۶۷۸۹٠١٢٣٤٥٦٧٨٩", "01234567890123456789")
                    s = s.translate(trans).replace(',', '.')
                    m = re.match(r'^\s*(\d+(?:\.\d+)?)\s*[:/]\s*(\d+(?:\.\d+)?)\s*$', s)
                    if m:
                        return float(m.group(1)), float(m.group(2))
                    try:
                        return float(s)
                    except Exception:
                        return 0.0

                if isinstance(ra, str) and (':' in ra or '/' in ra):
                    ra, rb = _to_float(ra)
                ratio_a = float(_to_float(ra) or 0.0)
                ratio_b = float(_to_float(rb) or 0.0)
                total_ratio = ratio_a + ratio_b
                if total_ratio <= 0:
                    raise ValueError("نسبت اختلاط در دستور ساخت مادر صفر است.")

                # فرمول‌های فعال پارت A و B
                part_a = self.db.execute_query(
                    "SELECT produces_item_id FROM recipes "
                    "WHERE parent_product_id = %s AND part_type = 'A' AND status = 'ACTIVE' "
                    "LIMIT 1",
                    (parent_id,),
                    fetch_one=True
                )
                part_b = self.db.execute_query(
                    "SELECT produces_item_id FROM recipes "
                    "WHERE parent_product_id = %s AND part_type = 'B' AND status = 'ACTIVE' "
                    "LIMIT 1",
                    (parent_id,),
                    fetch_one=True
                )
                if not part_a or not part_a.get('produces_item_id') or \
                not part_b or not part_b.get('produces_item_id'):
                    raise ValueError("فرمول فعال برای پارت A یا B یافت نشد.")

                need_bulk_total = float(pack_details.get('net_weight', 0.0) or 0.0) * num_packs
                need_a = (need_bulk_total / total_ratio) * ratio_a
                need_b = (need_bulk_total / total_ratio) * ratio_b

                self.requirements.append({'item_id': part_a['produces_item_id'], 'required_qty': need_a, 'type': 'BULK'})
                self.requirements.append({'item_id': part_b['produces_item_id'], 'required_qty': need_b, 'type': 'BULK'})

            else:
                # تک‌جزئی → پارت P
                part_p = self.db.execute_query(
                    "SELECT produces_item_id FROM recipes "
                    "WHERE parent_product_id = %s AND part_type = 'P' AND status = 'ACTIVE' "
                    "LIMIT 1",
                    (parent_id,),
                    fetch_one=True
                )
                if not part_p or not part_p.get('produces_item_id'):
                    raise ValueError("فرمول فعال (پارت P) برای این محصول یافت نشد.")

                need_bulk_total = float(pack_details.get('net_weight', 0.0) or 0.0) * num_packs
                self.requirements.append({'item_id': part_p['produces_item_id'], 'required_qty': need_bulk_total, 'type': 'BULK'})

            # ---------------- نیاز اقلام بسته‌بندی (BOM) ----------------
            packaging_bom = self.db.get_bom_for_product(pack_details['name'])
            for row in packaging_bom or []:
                self.requirements.append({
                    'item_id': row['component_item_id'],
                    'required_qty': float(row['quantity']) * num_packs,
                    'type': 'PACK'
                })

            # --- کمک‌کار: موجودی فله در «انبار تولید» با فالبک نام‌های رایج ---
            def _available_in_production(item_id: int) -> float:
                # 1) تلاش با نام ثابت
                row = self.db.execute_query(
                    """
                    SELECT COALESCE(SUM(s.qty), 0) AS total_qty
                    FROM stock s
                    JOIN locations l ON s.location_id = l.id
                    JOIN warehouses w ON l.warehouse_id = w.id
                    WHERE s.item_id = %s AND w.name = %s
                    """,
                    (item_id, PRODUCTION_WAREHOUSE_NAME),
                    fetch_one=True
                )
                avail = float((row or {}).get('total_qty', 0) or 0)
                if avail > 0:
                    return avail
                # 2) نام‌های رایج جایگزین (برای دیتابیس‌های فارسی)
                for alt in ('انبار تولید', 'کف کارگاه', 'Production', 'Workshop', 'Production Floor'):
                    if alt == PRODUCTION_WAREHOUSE_NAME:
                        continue
                    row = self.db.execute_query(
                        """
                        SELECT COALESCE(SUM(s.qty), 0) AS total_qty
                        FROM stock s
                        JOIN locations l ON s.location_id = l.id
                        JOIN warehouses w ON l.warehouse_id = w.id
                        WHERE s.item_id = %s AND w.name = %s
                        """,
                        (item_id, alt),
                        fetch_one=True
                    )
                    avail = float((row or {}).get('total_qty', 0) or 0)
                    if avail > 0:
                        return avail
                # 3) فالبک نهایی: مجموع کل انبارها (برای نمایش)
                row = self.db.execute_query(
                    "SELECT COALESCE(SUM(qty),0) AS total_qty FROM stock WHERE item_id = %s",
                    (item_id,),
                    fetch_one=True
                )
                return float((row or {}).get('total_qty', 0) or 0)

            # ---------------- پر کردن جدول و کنترل کفایت ----------------
            self.req_table.setColumnCount(5)
            self.req_table.setHorizontalHeaderLabels(["نوع", "نام کالا", "نیاز", "موجودی", "وضعیت"])
            self.req_table.setRowCount(len(self.requirements))

            all_ok = True
            for r, req in enumerate(self.requirements):
                # نام کالا
                item = self.db.execute_query(
                    "SELECT name FROM items WHERE id = %s",
                    (req['item_id'],),
                    fetch_one=True
                ) or {'name': '---'}

                # موجودی: فله = انبار تولید | لوازم بسته‌بندی = مجموع کل
                if req['type'] == 'BULK':
                    available = _available_in_production(req['item_id'])
                else:
                    row = self.db.execute_query(
                        "SELECT COALESCE(SUM(qty),0) AS total_qty FROM stock WHERE item_id = %s",
                        (req['item_id'],),
                        fetch_one=True
                    )
                    available = float((row or {}).get('total_qty', 0) or 0)

                is_sufficient = (available + 1e-9) >= float(req['required_qty'])

                # ردیف جدول
                self.req_table.setItem(r, 0, QtWidgets.QTableWidgetItem("فله" if req['type'] == 'BULK' else "بسته‌بندی"))
                self.req_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['name']))
                self.req_table.setItem(r, 2, NumericTableWidgetItem(f"{req['required_qty']:.3f}"))
                self.req_table.setItem(r, 3, NumericTableWidgetItem(f"{available:.3f}"))

                status_item = QtWidgets.QTableWidgetItem("✔ موجود کافی" if is_sufficient else "⛔ کمبود")
                status_item.setForeground(QtGui.QColor("green" if is_sufficient else "red"))
                self.req_table.setItem(r, 4, status_item)

                all_ok &= is_sufficient

            self.req_table.resizeColumnsToContents()
            self.req_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            self.ok_button.setEnabled(all_ok)

        except Exception as e:
            self.toast.show_message(f"خطا در محاسبه نیازمندی‌ها: {e}", "critical")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
    # END REWRITE: PackingDialog._calculate_requirements

    def _start_packing_process(self):
        pack_details = self.output_sku_combo.currentData()
        num_packs = int(self.pack_count_edit.text())
        final_batch_no = self.output_batch_edit.text()

        components_plan = []
        all_exp_dates = []
        try:
            for req in self.requirements:
                pick_plan = self.db.get_fifo_pick_plan(req['item_id'], req['required_qty'], PRODUCTION_WAREHOUSE_NAME)
                components_plan.extend(pick_plan)
                if req['type'] == 'BULK':
                    for pick in pick_plan:
                        if pick.get('expiry_date'): all_exp_dates.append(pick['expiry_date'])
            
            final_expiry = min(all_exp_dates) if all_exp_dates else dt.date.today() + dt.timedelta(days=730)
            
            packing_data = {
                "production_order_id": None, # چون این بسته‌بندی دستی است
                "components_plan": components_plan,
                "output_product": { "item_id": pack_details['id'], "name": pack_details['name'], "qty": num_packs, "batch": final_batch_no, "expiry_date": final_expiry }
            }

            self.db.execute_packing_plan_from_production(packing_data, self.parent_window.user_id)
            self.toast.show_message("✔ عملیات بسته‌بندی دستی با موفقیت ثبت شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند بسته‌بندی با خطا مواجه شد:\n{e}")
            

        
            
        

# [CLASS: UI.QuickUrgencyChooser] — انتخاب فوریت (بازه‌های زمان‌بندی استاندارد)
class QuickUrgencyChooser(QtWidgets.QDialog):
    """
    انتخاب فوریت نهایی برای PRها توسط مدیرعامل.
    خروجی: code در {NOW,U1,U2,U3,NORMAL}
    """
    CODES = [
        ("NOW",    "آنی (تا ۲۴ ساعت)"),
        ("U1",     "فوریت ۱ (۱ تا ۷ روز)"),
        ("U2",     "فوریت ۲ (۸ تا ۱۴ روز)"),
        ("U3",     "فوریت ۳ (۱۵ تا ۳۰ روز)"),
        ("NORMAL", "عادی (۳۰ تا ۹۰ روز)")
    ]
    def __init__(self, parent=None, default_code: str | None = None):
        super().__init__(parent)
        self.setWindowTitle("تعیین فوریت نهایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        form = QtWidgets.QFormLayout(self)
        self.cmb = QtWidgets.QComboBox()
        for code, label in self.CODES:
            self.cmb.addItem(label, code)
        if default_code:
            ix = max(0, self.cmb.findData(default_code))
            self.cmb.setCurrentIndex(ix)
        form.addRow("فوریت نهایی:", self.cmb)

        self.chk_skip = QtWidgets.QCheckBox("بدون تغییر فوریت (فقط تایید شود)")
        form.addRow(self.chk_skip)

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        btns.accepted.connect(self.accept); btns.rejected.connect(self.reject)
        form.addRow(btns)

    def result_code(self) -> str | None:
        return None if self.chk_skip.isChecked() else self.cmb.currentData()

# این کلاس را به طور کامل با نسخه فعلی جایگزین کنید
class DeptHeadApprovalDialog(QtWidgets.QDialog):
    """
    نسخه نهایی (V3):
    - تمام جزئیات فرم شامل مشخصات، یادداشت و پیوست‌ها را نمایش می‌دهد.
    - اتصال دکمه پیوست‌ها به کنترلر اصلی برنامه اصلاح شده است.
    """
    def __init__(self, db: DB, group_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.group_id = group_id
        self.outcome = None
        
        details = self.db.get_pr_group_details_for_approval(self.group_id)
        header = details.get('header', {})
        items = details.get('items', [])

        self.setWindowTitle(f"بررسی فرم درخواست خرید شماره: {header.get('physical_request_no', group_id)}")
        self.setMinimumSize(950, 600) # افزایش اندازه برای نمایش بهتر ستون‌ها
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        form_info = QtWidgets.QFormLayout()
        form_info.addRow("واحد درخواست‌دهنده:", QtWidgets.QLabel(f"<b>{header.get('dept_name', '')}</b>"))
        form_info.addRow("کاربر درخواست‌دهنده:", QtWidgets.QLabel(f"<b>{header.get('requester_name', '')}</b>"))
        layout.addLayout(form_info)

        items_group = QtWidgets.QGroupBox("اقلام درخواست شده در این فرم")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        table = QtWidgets.QTableWidget(len(items), 7) # تعداد ستون‌ها افزایش یافت
        table.setHorizontalHeaderLabels(['نام کالا', 'مقدار', 'واحد', 'فوریت پیشنهادی', 'مشخصات فنی', 'یادداشت درخواست‌کننده', 'پیوست‌ها'])
        table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        
        for r, item in enumerate(items):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(item.get('item_name', '')))
            table.setItem(r, 1, NumericTableWidgetItem(str(item.get('requested_qty', ''))))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(item.get('unit_name', '')))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(item.get('urgency_suggested', '')))
            
            # نمایش کامل مشخصات و یادداشت‌ها با Tooltip
            specs_item = QtWidgets.QTableWidgetItem(item.get('specs', ''))
            specs_item.setToolTip(item.get('specs', ''))
            table.setItem(r, 4, specs_item)
            
            notes_item = QtWidgets.QTableWidgetItem(item.get('notes', ''))
            notes_item.setToolTip(item.get('notes', ''))
            table.setItem(r, 5, notes_item)
            
            # اتصال دکمه پیوست‌ها
            attach_count = item.get('attachments_count', 0)
            btn_attach = QtWidgets.QPushButton(f"({attach_count})")
            btn_attach.setIcon(QtGui.QIcon.fromTheme("mail-attachment"))
            if attach_count > 0 and hasattr(self.parent(), '_show_pr_attachments'):
                btn_attach.clicked.connect(partial(self.parent()._show_pr_attachments, item['id']))
            else:
                btn_attach.setEnabled(False)
            table.setCellWidget(r, 6, btn_attach)

        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        table.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.Stretch)
        table.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.Stretch)
        items_layout.addWidget(table)
        layout.addWidget(items_group)

        buttons = QtWidgets.QDialogButtonBox()
        btn_reject = buttons.addButton("رد کل فرم", QtWidgets.QDialogButtonBox.RejectRole)
        btn_approve = buttons.addButton("تایید کل فرم و ارسال برای مدیرعامل", QtWidgets.QDialogButtonBox.AcceptRole)
        btn_approve.setProperty("class", "primary")
        layout.addWidget(buttons)

        btn_approve.clicked.connect(self._approve_action)
        btn_reject.clicked.connect(self._reject_action)

    def _approve_action(self):
        self.outcome = "APPROVED"
        self.accept()

    def _reject_action(self):
        self.outcome = "REJECTED"
        self.accept()

    def get_outcome(self):
        return self.outcome
        
# این کلاس را به طور کامل با نسخه فعلی جایگزین کنید
class AttachmentsViewDialog(QtWidgets.QDialog):
    """
    نسخه نهایی (V2):
    - باگ مربوط به نام ویجت (list_widget) برطرف شده است.
    - اکنون لیست فایل‌ها را به درستی از پایگاه داده خوانده و نمایش می‌دهد.
    """
    def __init__(self, db: DB, pr_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"پیوست‌های درخواست خرید شماره {pr_id}")
        self.setMinimumWidth(450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای ذخیره فایل روی کامپیوتر خود، روی آن دابل کلیک کنید:"))

        self.list_widget = QtWidgets.QListWidget()
        layout.addWidget(self.list_widget)

        try:
            attachments = self.db.get_pr_attachments(pr_id)
            if attachments:
                for att in attachments:
                    item = QtWidgets.QListWidgetItem(QtGui.QIcon.fromTheme("document-open"), att['filename'])
                    item.setData(QtCore.Qt.UserRole, att['id'])
                    # --- اصلاح کلیدی و نهایی اینجاست ---
                    self.list_widget.addItem(item)
            else:
                self.list_widget.addItem("هیچ فایلی برای این درخواست پیوست نشده است.")
        except Exception as e:
            print(f"Error loading attachments: {e}")
            self.list_widget.addItem(f"خطا در بارگذاری فایل‌ها: {e}")

        self.list_widget.itemDoubleClicked.connect(self._download_attachment)

    def _download_attachment(self, item):
        attachment_id = item.data(QtCore.Qt.UserRole)
        if not isinstance(attachment_id, int): return

        try:
            attachment_data = self.db.get_pr_attachment_data(attachment_id)
            if not attachment_data:
                QtWidgets.QMessageBox.warning(self, "خطا", "فایل در پایگاه داده یافت نشد.")
                return

            file_name = attachment_data['filename']
            file_content = attachment_data['file_data']

            path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "ذخیره فایل پیوست", file_name)
            if path:
                with open(path, 'wb') as f:
                    f.write(file_content)
                if hasattr(self.parent(), 'toast'):
                    self.parent().toast.show_message("✔ فایل با موفقیت ذخیره شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در دانلود فایل", str(e))
            
class DocTransFormDialog(QtWidgets.QDialog):
    """
    فرم سند چند‌قلمه برای تراکنش‌های هم‌نوع (ورود/خروج/برگشت/ضایعات).
    - برای افزودن هر قلم از TransactionDialog موجود استفاده می‌کند تا همه‌چیز مطابق زیرساخت فعلی بماند.
    - در پایان، هر ردیف را با db.add_trans_extended ثبت می‌کند (شماره سند مشترک).
    """
    def __init__(self, db, user_id, t_type: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.t_type = t_type

        self.setWindowTitle(f"سند {self.t_type} - چند قلم")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(800)

        main = QtWidgets.QVBoxLayout(self)
        head = QtWidgets.QHBoxLayout()
        main.addLayout(head)

        self.e_doc = QtWidgets.QLineEdit()
        self.e_doc.setPlaceholderText("شماره سند (اجباری)")
        head.addWidget(QtWidgets.QLabel("شماره سند:"))
        head.addWidget(self.e_doc, 1)

        self.lbl_count = QtWidgets.QLabel("تعداد اقلام: 0")
        head.addWidget(self.lbl_count)

        # جدول اقلام
        self.table = QtWidgets.QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["کالا", "شرح موجودی/لوکیشن", "مقدار", "بچ", "انقضا", "یادداشت"])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for c in (2, 3, 4, 5):
            self.table.horizontalHeader().setSectionResizeMode(c, QtWidgets.QHeaderView.ResizeToContents)
        main.addWidget(self.table, 1)

        # دکمه‌ها
        btns = QtWidgets.QHBoxLayout()
        main.addLayout(btns)
        self.btn_add = QtWidgets.QPushButton("➕ افزودن قلم")
        self.btn_edit = QtWidgets.QPushButton("✏️ ویرایش قلم")
        self.btn_del = QtWidgets.QPushButton("🗑 حذف قلم")
        btns.addWidget(self.btn_add)
        btns.addWidget(self.btn_edit)
        btns.addWidget(self.btn_del)
        btns.addStretch()
        self.btn_save = QtWidgets.QPushButton("✅ ثبت نهایی")
        self.btn_save.setProperty("class", "primary")
        self.btn_cancel = QtWidgets.QPushButton("انصراف")
        btns.addWidget(self.btn_save)
        btns.addWidget(self.btn_cancel)

        # دادهٔ خام هر ردیف (dict از TransactionDialog)
        self._rows = []

        # اتصال‌ها
        self.btn_add.clicked.connect(self._add_row)
        self.btn_edit.clicked.connect(self._edit_selected_row)
        self.btn_del.clicked.connect(self._delete_selected_row)
        self.btn_save.clicked.connect(self._save_all)
        self.btn_cancel.clicked.connect(self.reject)

    # امکان پیش‌پر کردن شماره سند از بیرون
    def set_doc_no(self, doc_no: str):
        self.e_doc.setText(str(doc_no or "").strip())

    # امکان افزودن اولیه با پیش‌انتخاب کالا/مقدار (اختیاری)
    def add_prefilled(self, item_id=None, qty=None):
        self._add_row(prefill={"item_id": item_id, "qty": qty})

    def _add_row(self, prefill=None):
        dlg = TransactionDialog(self.db, self.user_id, self.t_type, self, item_id=(prefill or {}).get("item_id"))
        # پیش‌پر کردن شماره سند/مقدار
        if self.e_doc.text().strip():
            try:
                dlg.e_no.setText(self.e_doc.text().strip())
            except Exception:
                pass
        if prefill and prefill.get("qty") is not None:
            try:
                dlg.e_qty.setText(str(prefill["qty"]))
            except Exception:
                pass

        def _on_ok(data: dict):
            # شماره سند را تحمیل می‌کنیم تا همهٔ اقلام یک doc_no مشترک داشته باشند
            data = dict(data)
            data["doc_no"] = self.e_doc.text().strip() or data.get("doc_no", "")
            # نمایش در جدول
            self._rows.append(data)
            self._append_row_to_table(data)
            self._update_count()

        dlg.transaction_data_ready.connect(_on_ok)
        dlg.exec_()

    def _edit_selected_row(self):
        r = self.table.currentRow()
        if r < 0 or r >= len(self._rows):
            QtWidgets.QMessageBox.information(self, "انتخاب لازم", "لطفاً یک ردیف را انتخاب کنید.")
            return

        # باز کردن دوباره TransactionDialog با داده‌های همان ردیف برای ویرایش
        current = self._rows[r]
        dlg = TransactionDialog(self.db, self.user_id, self.t_type, self, item_id=current.get("item_id"))
        try:
            dlg.e_no.setText(self.e_doc.text().strip() or (current.get("doc_no") or ""))
        except Exception:
            pass
        try:
            dlg.e_qty.setText(str(current.get("qty", "")))
        except Exception:
            pass
        try:
            # اگر ورود/برگشت بوده، batch/expiry/loc در کنترل‌های ورود هستند
            # اگر خروج بوده، در c_stock_record انتخاب می‌شود (اما چون از API فعلی استفاده می‌کنیم، ساده‌تر: کاربر دوباره انتخاب کند)
            pass
        except Exception:
            pass

        def _on_ok(data: dict):
            data = dict(data)
            data["doc_no"] = self.e_doc.text().strip() or data.get("doc_no", "")
            self._rows[r] = data
            self._refresh_table()

        dlg.transaction_data_ready.connect(_on_ok)
        dlg.exec_()

    def _delete_selected_row(self):
        r = self.table.currentRow()
        if r < 0 or r >= len(self._rows):
            return
        del self._rows[r]
        self._refresh_table()
        self._update_count()

    def _append_row_to_table(self, d: dict):
        r = self.table.rowCount()
        self.table.insertRow(r)

        item_name = ""
        try:
            rec = self.db.execute_query("SELECT name FROM items WHERE id=%s", (d.get("item_id"),), fetch_one=True)
            item_name = rec['name'] if rec else ""
        except Exception:
            pass

        # شرح موجودی/لوکیشن برای نمایش
        loc_txt = ""
        try:
            loc_rec = self.db.execute_query(
                "SELECT w.name || ' | ' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label "
                "FROM locations l JOIN warehouses w ON l.warehouse_id=w.id WHERE l.id=%s",
                (d.get("loc_id"),), fetch_one=True
            )
            loc_txt = loc_rec['loc_label'] if loc_rec else ""
        except Exception:
            pass

        qty = str(d.get("qty", ""))
        batch_no = d.get("batch_no") or ""
        exp = to_shamsi(d.get("expiry_date"))
        note = d.get("notes") or ""

        vals = [item_name, loc_txt, qty, batch_no, exp, note]
        for c, val in enumerate(vals):
            it = QtWidgets.QTableWidgetItem(val)
            it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
            self.table.setItem(r, c, it)

    def _refresh_table(self):
        self.table.setRowCount(0)
        for d in self._rows:
            self._append_row_to_table(d)

    def _update_count(self):
        self.lbl_count.setText(f"تعداد اقلام: {len(self._rows)}")

    def _save_all(self):
        doc_no = self.e_doc.text().strip()
        if not doc_no:
            QtWidgets.QMessageBox.warning(self, "شماره سند لازم است", "لطفاً شماره سند را وارد کنید.")
            return
        if not self._rows:
            QtWidgets.QMessageBox.information(self, "لیست خالی", "ابتدا حداقل یک قلم اضافه کنید.")
            return

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        try:
            for d in self._rows:
                # اطمینان از doc_no مشترک
                d = dict(d)
                d["doc_no"] = doc_no
                # زیرساخت فعلی ثبت تراکنش (همانی که اکنون همه جا استفاده می‌شود)
                self.db.add_trans_extended(d, self.user_id)  # ← API موجود (حفظ امکانات) 
            # موفقیت
            toast = getattr(self.parent(), 'toast', None)
            if toast:
                toast.show_message(f"✔ {len(self._rows)} ردیف با شماره سند «{doc_no}» ثبت شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"اشکال در ثبت سند:\n{e}")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
# --- NEW UI: ConversionPatternDialog & ExecuteConversionDialog ----------------
from PyQt5 import QtWidgets, QtCore, QtGui
from datetime import date



class ExecuteConversionDialog(QtWidgets.QDialog):
    """یک پنجره برای ساخت الگو (بالا) و اجرای تبدیل (پایین)."""
    def __init__(self, db: 'DB', user_id: int, parent=None):
        super().__init__(parent)
        from PyQt5 import QtWidgets, QtCore, QtGui
        from PyQt5.QtCore import Qt

        self.db, self.user_id = db, user_id
        self.setWindowTitle("تبدیل A → B (ساخت الگو + اجرا)")
        self.setMinimumWidth(640)

        root = QtWidgets.QVBoxLayout(self); root.setSpacing(10)

        # --- بخش ساخت الگو ---------------------------------------------------
        grp_new = QtWidgets.QGroupBox("ساخت الگوی جدید (اختیاری)")
        f = QtWidgets.QFormLayout(grp_new); f.setSpacing(8)

        self.e_pat_name = QtWidgets.QLineEdit()
        self.c_src_raw  = QtWidgets.QComboBox(); self.c_src_raw.setEditable(True)
        self.c_dest_all = QtWidgets.QComboBox(); self.c_dest_all.setEditable(True)  # اسم را نگه می‌داریم تا بقیه کدها نشکنند
        self.e_pat_notes = QtWidgets.QLineEdit()

        # فقط «مواد اولیه» برای هر دو کامبو
        raw_items = self.db.execute_query("SELECT id, name FROM items WHERE category='مواد اولیه' ORDER BY name") or []
        self.c_src_raw.clear(); self.c_dest_all.clear()
        for it in raw_items:
            self.c_src_raw.addItem(it['name'], it['id'])
            self.c_dest_all.addItem(it['name'], it['id'])

        f.addRow("نام/کد الگو:", self.e_pat_name)
        f.addRow("A (مواد اولیه):", self.c_src_raw)
        f.addRow("B (مواد اولیه):", self.c_dest_all)
        f.addRow("توضیح (اختیاری):", self.e_pat_notes)

        btn_save_pat = QtWidgets.QPushButton("ثبت الگو")
        btn_save_pat.clicked.connect(self._save_pattern)
        f.addRow(btn_save_pat)

        root.addWidget(grp_new)

        # --- بخش اجرای تبدیل -------------------------------------------------
        grp_run = QtWidgets.QGroupBox("اجرای تبدیل")
        v = QtWidgets.QVBoxLayout(grp_run); v.setSpacing(8)
        form = QtWidgets.QFormLayout(); form.setSpacing(8); v.addLayout(form)

        self.c_pat = QtWidgets.QComboBox(); self.c_pat.setEditable(True)
        self.lbl_ab = QtWidgets.QLabel("A → B")
        self.e_amount_a = QtWidgets.QLineEdit()
        self.e_amount_a.setValidator(QtGui.QDoubleValidator(0.0001, 1e12, 3))
        self.c_src_batch = QtWidgets.QComboBox(); self.c_src_batch.setEnabled(False)
        self.lbl_dest_batch_preview = QtWidgets.QLabel("بچ B (اتوماتیک): RE-—")

        form.addRow("الگوی انتخابی:", self.c_pat)
        form.addRow("A→B:", self.lbl_ab)
        form.addRow("مقدار A (واحد همان A):", self.e_amount_a)
        form.addRow("از بچِ A:", self.c_src_batch)
        form.addRow("پیش‌نمایش بچ B:", self.lbl_dest_batch_preview)

        # متدهای کمکی قبلی همین کلاس
        self._reload_patterns()

        # سیم‌کشی امن رویدادها
        self.c_pat.currentIndexChanged.connect(self._on_pat_change)
        # اولین بار
        self._on_pat_change()

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        btns.accepted.connect(self._run); btns.rejected.connect(self.reject)
        v.addWidget(btns)

        root.addWidget(grp_run)
        self._update_preview_batch()

    # FIX: PROD-LOC-CANONICAL (2025-09-24)
    def _fmt_jalali(self, d) -> str:
        """
        نمایش شمسی برای UI. اگر تبدیلگر داخلی پروژه موجود بود از آن استفاده می‌کند،
        وگرنه همان تاریخ میلادی را برمی‌گرداند (بی‌سروصدا).
        """
        # اگر Utility داخلی دارید
        try:
            if hasattr(self.db, "to_jalali_str"):
                return self.db.to_jalali_str(d)
        except Exception:
            pass
        # بدون وابستگی اضافه
        try:
            import jdatetime
            if d:
                from datetime import date, datetime as _dt
                if isinstance(d, str):
                    d = _dt.strptime(d[:10], "%Y-%m-%d").date()
                if isinstance(d, date):
                    jd = jdatetime.date.fromgregorian(date=d)
                    return f"{jd.year:04d}-{jd.month:02d}-{jd.day:02d}"
        except Exception:
            pass
        return (str(d) if d else "")

    # FIX: PROD-LOC-CANONICAL (2025-09-24)
    def _load_source_batches_for_A(self):
        """
        کمبوباکس بچ‌های A را فقط از لوکیشن تولید پر می‌کند.
        منبع حقیقت: db.get_production_floor_location()
        """
        self.c_src_batch.clear()

        # از الگوی انتخابی، A را می‌خوانیم
        idx = self.c_pat.currentIndex()
        if idx < 0 or idx >= len(self._patterns):
            self.c_src_batch.addItem("— ابتدا الگو را انتخاب کنید —", None)
            self.c_src_batch.setEnabled(False)
            return
        item_id = int(self._patterns[idx]['src_item_id'])

        # لوکیشن تولید قطعی
        prod_loc_id = self.db.get_production_floor_location()

        # فقط بچ‌های همان لوکیشن
        rows = self.db.execute_query("""
            SELECT s.batch_no,
                   s.expiry_date,
                   s.location_id AS loc_id,
                   SUM(s.qty) AS qty
            FROM stock s
            WHERE s.item_id = %s
              AND s.location_id = %s
              AND COALESCE(s.qty,0) > 0
            GROUP BY s.batch_no, s.expiry_date, s.location_id
            HAVING SUM(s.qty) > 0
            ORDER BY s.expiry_date NULLS LAST, s.batch_no
        """, (item_id, prod_loc_id)) or []

        if not rows:
            self.c_src_batch.addItem("— انبار تولید موجودی ندارد —", None)
            self.c_src_batch.setEnabled(False)
            return

        self.c_src_batch.setEnabled(True)
        for r in rows:
            bn  = r.get('batch_no') or ''
            ex  = r.get('expiry_date')
            qty = float(r.get('qty') or 0)
            label = f"{bn or 'بدون بچ'} | موجودی:{qty:g}"
            if ex:
                label += f" | انقضا:{self._fmt_jalali(ex)}"
            # data: (batch_no, expiry_date, loc_id)
            self.c_src_batch.addItem(label, (bn, ex, int(r.get('loc_id'))))

    # ذخیرهٔ الگو (بدون نسبت/افت)
    def _save_pattern(self):
        name = self.e_pat_name.text().strip()
        if not name:
            QtWidgets.QMessageBox.warning(self, "ورودی ناقص", "نام/کد الگو را وارد کن.")
            return
        src_id  = self.c_src_raw.currentData()
        dest_id = self.c_dest_all.currentData()
        if not src_id or not dest_id or int(src_id) == int(dest_id):
            QtWidgets.QMessageBox.warning(self, "انتخاب نامعتبر", "A و B باید انتخاب و متفاوت باشند.")
            return
        try:
            new_id = self.db.create_conversion_pattern(
                name, int(src_id), int(dest_id), self.user_id, self.e_pat_notes.text().strip()
            )
            QtWidgets.QMessageBox.information(self, "ثبت شد", f"الگو با شناسه {new_id} ثبت شد.")
            self._reload_patterns(select_id=new_id)
            # پاک‌سازی فرم ساخت
            self.e_pat_name.clear(); self.e_pat_notes.clear()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", str(e))

    # بارگذاری/تازه‌سازی لیست الگوها
    def _reload_patterns(self, select_id: int = None):
        self._patterns = self.db.list_conversion_patterns(only_active=True) or []
        self.c_pat.clear()
        for p in self._patterns:
            self.c_pat.addItem(f"{p['name']} | {p['src_name']} → {p['dest_name']}", p['id'])
        if select_id:
            idx = next((i for i, p in enumerate(self._patterns) if int(p['id']) == int(select_id)), -1)
            if idx >= 0:
                self.c_pat.setCurrentIndex(idx)

    def _on_pat_change(self):
        """
        وقتی الگو عوض می‌شود:
          1) عنوان A→B را می‌سازیم.
          2) بچ‌های A را فقط از لوکیشن تولید (منبع واحد) بارگذاری می‌کنیم.
        """
        idx = self.c_pat.currentIndex()
        if idx < 0 or idx >= len(self._patterns):
            self.lbl_ab.setText("A → B")
            self.c_src_batch.clear()
            self.c_src_batch.addItem("— ابتدا الگو را انتخاب کنید —", None)
            self.c_src_batch.setEnabled(False)
            return

        pat = self._patterns[idx]
        self.lbl_ab.setText(f"{pat['src_name']} → {pat['dest_name']}")
        # فقط همین: همه‌چیز را از منبع قطعی بخوان
        self._load_source_batches_for_A()

    def _run(self):
        """
        اجرای تبدیل با چک «فقط انبار تولید».
        اگر کاربر با ترفند، بچ غیرتولیدی بفرستد، اینجا متوقف می‌شود.
        """
        idx = self.c_pat.currentIndex()
        if idx < 0 or idx >= len(self._patterns):
            QtWidgets.QMessageBox.warning(self, "انتخاب نامعتبر", "یک الگو انتخاب کن.")
            return
        pat = self._patterns[idx]
        try:
            amt_a = float(self.e_amount_a.text() or 0)
        except Exception:
            amt_a = 0
        if amt_a <= 0:
            QtWidgets.QMessageBox.warning(self, "ورودی نامعتبر", "مقدار A باید بزرگتر از صفر باشد.")
            return

        data = self.c_src_batch.currentData()
        if data:
            src_bn, src_ex, src_loc_id = data
        else:
            src_bn, src_ex, src_loc_id = None, None, None

        # باید انبار تولید باشد (منبع واحد حقیقت)
        prod_loc_id = self.db.get_production_floor_location()
        if not prod_loc_id:
            QtWidgets.QMessageBox.critical(self, "خطا", "لوکیشن «انبار تولید» تعریف نشده است.")
            return
        if src_loc_id and int(src_loc_id) != int(prod_loc_id):
            QtWidgets.QMessageBox.warning(self, "انبار نامعتبر", "فقط انتخاب از «انبار تولید» مجاز است.")
            return

        try:
            # نام‌های کلیدواژه مطابق امضای جدید (و سازگار با گذشته)
            res = self.db.execute_conversion(
                int(pat['id']), amt_a, self.user_id,
                src_batch_no=src_bn, src_expiry_date=src_ex
            )
            QtWidgets.QMessageBox.information(
                self, "انجام شد",
                f"تبدیل ثبت شد.\nسند: {res.get('doc_no')}\n"
                f"A مصرف‌شده: {res.get('amount_a')}\nB تولیدشده: {res.get('amount_b')}\n"
                f"بچ B: {res.get('batch_b')}"
            )
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", str(e))

    def _update_preview_batch(self):
        try:
            import jdatetime as jd
            jnow = jd.datetime.now()
            mm = f"{jnow.month:02d}"; yy = f"{jnow.year % 100:02d}"
            # فقط پیش‌نمایش است؛ تولید نهایی در DB انجام می‌شود
            self.lbl_dest_batch_preview.setText(f"RE-{mm}{yy}-???")
        except Exception:
            self.lbl_dest_batch_preview.setText("RE-—")


                        

class MainWindow(QtWidgets.QMainWindow):
    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def __init__(self, db: DB, user_info: dict, parent=None):
        super().__init__(parent)
        
        # [FUNC: UI.MainWindow.__init__] — مقداردهی اولیهٔ ارجاع‌ها
        self.tab_pr_approvals: QtWidgets.QWidget | None = None
        self.pr_approvals_layout: QtWidgets.QVBoxLayout | None = None
        self.tbl_pr_approvals: QtWidgets.QTableWidget | None = None
        self.cmb_pr_scope = None
        self.edt_pr_search = None
        self.btn_pr_refresh = None

        

        self.db = db
                # همگام‌سازی خودکار دسترسی‌ها با کُد
        try:
            self.db.sync_permissions_with_source()
            self.db.normalize_permission_aliases()
        except Exception as _e:
            print('WARN permission sync/normalize:', _e)
            
                # بعد از self._apply_permissions_to_ui()
        try:
            self._apply_production_confidentiality_policy()
        except Exception as _e_conf:
            print('WARN: confidentiality policy not applied:', _e_conf)

        
        self.pending_focus_trans_id = None

        self.user_info = user_info; self.user_id = user_info.get('id'); self.user = user_info.get('username'); self.role = user_info.get('role_name'); self.user_dashboards = user_info.get('dashboards', []); self.permissions = set(user_info.get('permissions', [])); self.trans_delegate = CustomColorDelegate(self); self.bom_buttons = []; self.notification_panel = NotificationPanel(self.db, self); self.notification_animation = None; self.notifications_cache = []
        
        self.prod_interface_page = None; self.requests_page_tab = None; self.deliveries_page_tab = None; self.returns_page_tab = None; self.prod_page_loaded = False

        if not self.user_id:
            QtWidgets.QMessageBox.critical(None, "خطای بحرانی", "اطلاعات کاربر به درستی بارگذاری نشد. برنامه بسته می‌شود."); sys.exit()

        self.setWindowTitle('انبار MEGATITE'); self.setMinimumSize(1280, 800); self.setFont(QFont(FONT_FAMILY, 11)); self.toast = Toast(self); self.restart_on_close = False; self.refresh_mutex = QtCore.QMutex()

        central = QtWidgets.QWidget(); self.setCentralWidget(central); central.setLayoutDirection(QtCore.Qt.RightToLeft); layout = QtWidgets.QHBoxLayout(central); layout.setContentsMargins(0, 0, 0, 0)
        
        sidebar = QtWidgets.QFrame(); sidebar.setFixedWidth(220); sidebar.setObjectName("sidebar"); sb_lay = QtWidgets.QVBoxLayout(sidebar); sb_lay.setAlignment(Qt.AlignTop); sb_lay.setSpacing(5); sb_lay.setContentsMargins(0, 15, 0, 15); logo = QtWidgets.QLabel("MEGATITE"); logo.setFont(QFont(FONT_TITLE, 24)); logo.setAlignment(Qt.AlignCenter); logo.setStyleSheet("color:white; padding: 10px; background: transparent;"); sb_lay.addWidget(logo)

        self.pg_dash = QtWidgets.QWidget(); self.pg_items = QtWidgets.QWidget(); self.pg_trans = QtWidgets.QWidget(); self.pg_purchasing = QtWidgets.QWidget(); self.pg_qa = QtWidgets.QWidget(); self.pg_qc = QtWidgets.QWidget(); self.pg_sales = QtWidgets.QWidget(); self.pg_prod = QtWidgets.QWidget(); self.pg_inventory = QtWidgets.QWidget(); self.pg_kanban = QtWidgets.QWidget(); self.pg_communications = QtWidgets.QWidget(); self.pg_tracker = QtWidgets.QWidget(); self.pg_forms = QtWidgets.QWidget(); self.pg_settings = QtWidgets.QWidget()
        self.pages = QtWidgets.QStackedWidget()
        for page in [self.pg_dash, self.pg_items, self.pg_trans, self.pg_purchasing, self.pg_qa, self.pg_qc, self.pg_sales, self.pg_prod, self.pg_inventory, self.pg_kanban, self.pg_communications, self.pg_tracker, self.pg_forms, self.pg_settings]: self.pages.addWidget(page)

        self.sidebar_buttons = []; self.page_map = {}
        buttons_map = [
            ('داشبورد', QtWidgets.QStyle.SP_ComputerIcon, self.pg_dash, 'page:view:dashboard'), ('کالاها و دارایی‌ها', QtWidgets.QStyle.SP_DirOpenIcon, self.pg_items, 'page:view:items'),
            ('تراکنش‌ها', QtWidgets.QStyle.SP_BrowserReload, self.pg_trans, 'page:view:transactions'), ('بازرگانی', QtWidgets.QStyle.SP_DialogYesButton, self.pg_purchasing, 'page:view:purchasing'),
            ('تضمین کیفیت (QA)', QtWidgets.QStyle.SP_FileDialogDetailedView, self.pg_qa, 'page:view:qa'), ('کنترل کیفیت (QC)', QtWidgets.QStyle.SP_DialogApplyButton, self.pg_qc, 'page:view:qc'),
            ('فروش', QtWidgets.QStyle.SP_DialogHelpButton, self.pg_sales, 'page:view:sales'), ('مدیریت تولید', QtWidgets.QStyle.SP_ToolBarHorizontalExtensionButton, self.pg_prod, 'page:view:production'),
            ('انبارگردانی', QtWidgets.QStyle.SP_FileDialogListView, self.pg_inventory, 'page:view:inventory'), ('فرم‌ها', QtWidgets.QStyle.SP_FileIcon, self.pg_forms, 'page:view:forms'),
            ('تنظیمات و ابزارها', QtWidgets.QStyle.SP_FileDialogInfoView, self.pg_settings, 'page:view:settings')
        ]
        for text, style_icon, page, required_perm in buttons_map:
            if self.has_permission(required_perm):
                btn = QtWidgets.QPushButton(f"  {text}")
                # --- *** این خط باید حتما وجود داشته باشد *** ---
                btn.setLayoutDirection(QtCore.Qt.RightToLeft)
                # --- ************************************* ---
                icon = self.style().standardIcon(style_icon); btn.setIcon(icon); btn.setIconSize(QtCore.QSize(20, 20)); btn.setProperty("class", "sidebar-button"); btn.clicked.connect(lambda _, p=page: self.pages.setCurrentWidget(p)); sb_lay.addWidget(btn); self.sidebar_buttons.append(btn); self.page_map[page] = btn
        
        sb_lay.addStretch()
        btn_exit = QtWidgets.QPushButton("  خروج از برنامه")
        # --- *** این خط برای دکمه خروج نیز اعمال شود *** ---
        btn_exit.setLayoutDirection(QtCore.Qt.RightToLeft)
        # --- ****************************************** ---
        btn_exit.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_DialogCloseButton)); btn_exit.setIconSize(QtCore.QSize(20, 20)); btn_exit.setProperty("class", "sidebar-button"); btn_exit.clicked.connect(self.close); sb_lay.addWidget(btn_exit); self.sidebar_buttons.append(btn_exit)
        layout.addWidget(sidebar); layout.addWidget(self.pages, 1)
        
        self.pages.currentChanged.connect(self._on_page_changed)
        self._build_all_pages()
        if self.page_map: self.pages.setCurrentWidget(next(iter(self.page_map.keys())))
        self._on_page_changed(self.pages.currentIndex())
        self._load_app_data(); self.setup_auto_backup_timer();  self._is_refreshing = False
        if hasattr(self.db, 'signals') and hasattr(self.db.signals, 'dataChanged'):
            self.db.signals.dataChanged.connect(self.on_data_changed)
        QtCore.QTimer.singleShot(50, self.refresh_all)
        # مثال: پس از ساخت صفحات و سایر singleShotها در __init__:
        QtCore.QTimer.singleShot(200, self.ensure_yesterday_snapshot_on_first_run)

        
    def _open_pr_approval_center(self):
        """مرکز تایید درخواست خرید را باز می‌کند (اگر ماژول در برنامه تعریف شده باشد)."""
        try:
            if hasattr(self, "open_purchasing_approval_center"):
                return self.open_purchasing_approval_center()
            if hasattr(self, "purchasing_workbench_open_manager_tab"):
                return self.purchasing_workbench_open_manager_tab()
            # Fallback: پیام راهنما
            QtWidgets.QMessageBox.information(self, "راهنما", "مرکز تایید PR از ماژول بازرگانی در دسترس است.")
        except Exception as e:
            logger.exception("open_pr_approval_center failed: %s", e)
            QtWidgets.QMessageBox.critical(self, "خطا", f"بازکردن مرکز تایید PR ناموفق بود:\n{e}")
            
        # --- Delegate برای سانسور متن ستون‌های حساس وقتی اجازهٔ دیدن فرمول نیست ---
    class ConfidentialDelegate(QtWidgets.QStyledItemDelegate):
        def __init__(self, can_view_callable, mask_cols, parent=None):
            super().__init__(parent)
            self._can_view = can_view_callable
            self._mask_cols = set(mask_cols)

        def paint(self, painter, option, index):
            try:
                if index.column() in self._mask_cols and not self._can_view():
                    opt = QtWidgets.QStyleOptionViewItem(option)
                    self.initStyleOption(opt, index)
                    opt.text = "محرمانه"
                    style = option.widget.style() if option.widget else QtWidgets.QApplication.style()
                    style.drawControl(QtWidgets.QStyle.CE_ItemViewItem, opt, painter)
                    return
            except Exception:
                pass
            super().paint(painter, option, index)

    def _can_view_production_formulas(self):
        # ادمین یا کسی که این پرمیژن را دارد، می‌تواند فرمول/BOM را ببیند
        return bool(getattr(self, 'role', None) == 'Admin' or self.has_permission('production:formula:view'))

    def _apply_production_confidentiality_policy(self):
        """
        روی جدول‌های صفحهٔ تولید، ستون‌های «فرمول/BOM/بچ» را اگر اجازه نباشد، محرمانه نشان می‌دهد.
        ستون‌ها با خواندن عنوان هدر شناسایی می‌شوند.
        """
        try:
            from PyQt5 import QtCore, QtWidgets
        except Exception:
            from PySide2 import QtCore, QtWidgets

        if not hasattr(self, 'pg_prod') or self.pg_prod is None:
            return

        # تمام TableView/TableWidget های داخل صفحه تولید
        tables = list(self.pg_prod.findChildren(QtWidgets.QTableView)) + list(self.pg_prod.findChildren(QtWidgets.QTableWidget))
        if not tables:
            return

        keywords = ['فرمول', 'bom', 'recipe', 'formula', 'فرمول ساخت', 'بچ']  # عناوین احتمالی هدر
        for tv in tables:
            model = tv.model()
            if not model:
                continue
            try:
                cols = model.columnCount()
            except Exception:
                continue
            mask_cols = []
            for c in range(cols):
                try:
                    header = str(model.headerData(c, QtCore.Qt.Horizontal))
                except Exception:
                    header = ''
                h = (header or '').strip().lower()
                if any(k in h for k in keywords):
                    mask_cols.append(c)
            if mask_cols:
                delegate = self.ConfidentialDelegate(self._can_view_production_formulas, mask_cols, tv)
                tv.setItemDelegate(delegate)

        
    def _dismiss_notification(self, action_key, action_data):
        try:
            try:
                self._mark_notification_read(action_key, action_data, only_read=False)
            except Exception:
                pass
            before = len(getattr(self, "notifications_cache", []) or [])
            self.notifications_cache = [
                n for n in (self.notifications_cache or [])
                if not (n.get("action_key") == action_key and n.get("action_data") == action_data)
            ]
            # ثبت دائمی
            try:
                if hasattr(self, "db") and self.db:
                    self.db.mark_notification_dismissed(action_key, action_data)
            except Exception as e:
                if globals().get('DEBUG_NOTIF', False):
                    print(f"[TRACE:NOTIF:store] dismiss-fail err={e}")

            # رندر
            if len(self.notifications_cache) != before:
                try:
                    self._update_notification_count()
                except Exception:
                    pass
                try:
                    if hasattr(self, "notification_panel") and self.notification_panel:
                        if globals().get('DEBUG_NOTIF', False):
                            print(f"[TRACE:NOTIF:render] showing={len(self.notifications_cache)}")
                        self.notification_panel._load_notifications()
                except Exception:
                    pass
        except Exception:
            pass

                        
                                                


    def _mark_notification_read(self, action_key, action_data, *, only_read=True):
        """Update notification state after interaction."""
        key = f"{action_key}:{action_data if action_data is not None else ''}"

        cache = self.notifications_cache or []
        notif_kind = None
        updated = False
        for notif in cache:
            if notif.get("action_key") == action_key and notif.get("action_data") == action_data:
                notif_kind = notif.get('kind')
                if not notif.get("is_read"):
                    notif["is_read"] = True
                    updated = True
                break

        resolved_flag = False
        needs_count_refresh = (not only_read) or updated

        if hasattr(self, "db") and self.db:
            try:
                self.db.mark_notification_read(action_key, action_data)
            except Exception as e:
                if globals().get('DEBUG_NOTIF', False):
                    print(f"[TRACE:NOTIF:store] read-fail err={e}")
            if not only_read and notif_kind == 'internal':
                try:
                    self.db.mark_notification_resolved(action_key, action_data)
                    resolved_flag = True
                except Exception as e:
                    if globals().get('DEBUG_NOTIF', False):
                        print(f"[TRACE:NOTIF:store] resolve-fail err={e}")

        if globals().get('DEBUG_NOTIF', False):
            actions = ['read']
            if not only_read:
                actions.append('dismiss')
            if resolved_flag:
                actions.append('resolve')
            print(f"[TRACE:NOTIF:click] kind={notif_kind or 'unknown'} actions={'|'.join(actions)} id={key}")

        if needs_count_refresh:
            try:
                self._update_notification_count()
            except Exception:
                pass

    def on_data_changed(self, change_key: str):
        """اسلات رصد تغییرات داده؛ روی طیف وسیع‌تری از سیگنال‌ها رفرش می‌زند."""
        try:
            k = (change_key or "").upper()
            # سیگنال‌های رایج که پس از رسیدگی به تسک‌ها ارسال می‌شوند
            triggers = (
                "NOTIFICATIONS",              # شامل NOTIFICATIONS_CHANGED هم می‌شود
                "TASKS_CHANGED",
                "PURCHASING_LISTS_CHANGED",
                "MY_REQUESTS_TRACKING_CHANGED"
            )
            if any(t in k for t in triggers):
                self.refresh_all()
        except Exception:
            # UI نباید به خاطر سیگنال بد کرش کند
            pass
                    
    def _build_qa_page(self):
        """صفحه QA را به «مدیریت دسترسی‌ها و چارت سازمانی» تبدیل می‌کند."""
        # پاک‌سازی چیدمان قبلی صفحه
        if self.pg_qa.layout() is not None:
            while self.pg_qa.layout().count():
                item = self.pg_qa.layout().takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # هدر استاندارد صفحه
        layout = self.create_page_layout(self.pg_qa, "مدیریت کاربران، نقش‌ها و چارت سازمانی")

        # --- وضعیت پیش‌نیازهای سازمانی
        ok, msg, cnt = self._ensure_org_prereqs(silent=True)
        if not isinstance(cnt, dict):
            cnt = {}
        depts = cnt.get('org_units', 0)
        users = cnt.get('users', 0)
        roles = cnt.get('roles', 0)

        status_label = QtWidgets.QLabel(
            f"وضعیت فعلی — واحدها: {depts}  |  کاربران: {users}  |  نقش‌ها: {roles}"
            if ok else f"پیش‌نیازها ناقص است: {msg}"
        )
        status_label.setStyleSheet("color:#6c757d;")
        layout.addWidget(status_label)

        # --- کارت «کاربران و دسترسی‌ها»
        box_access = QtWidgets.QGroupBox("کاربران و دسترسی‌ها")
        v1 = QtWidgets.QVBoxLayout(box_access)

        btn_users = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-users"), "   مدیریت کاربران")
        btn_roles = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("preferences-system"), "   مدیریت نقش‌ها")
        btn_wizard = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("tools-wizard"), "   ویزارد راه‌اندازی سازمان")

        for b in (btn_users, btn_roles, btn_wizard):
            b.setMinimumHeight(36)
            b.setProperty("class", "primary")
            v1.addWidget(b)

        # اتصال رویدادها
        # - User Manager
        btn_users.clicked.connect(self._open_user_manager)  # وجود دارد
        # - Role Manager
        btn_roles.clicked.connect(lambda: RoleManagerDialog(self.db, self).exec_())  # وجود دارد
        # - Org Setup Wizard
        btn_wizard.clicked.connect(self._run_org_setup_sequence)  # وجود دارد

        layout.addWidget(box_access)

        # --- کارت «چارت سازمانی»
        box_org = QtWidgets.QGroupBox("چارت سازمانی")
        v2 = QtWidgets.QVBoxLayout(box_org)

        btn_org = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("x-office-address-book"), "   مدیریت چارت سازمانی")
        btn_org.setMinimumHeight(36)
        btn_org.setProperty("class", "primary")
        v2.addWidget(btn_org)

        # - Org Chart Manager
        btn_org.clicked.connect(self._open_org_chart_manager)  # وجود دارد

        layout.addWidget(box_org)

        # جای خالی پایین صفحه
        layout.addStretch()
        

            
    def _ensure_org_prereqs(self, silent: bool = False):
        """
        پیش‌نیازهای سازمانی را چک می‌کند: Org Units, Users, Roles
        خروجی: (ok: bool, msg: str, counts: dict)
        - بدون وابستگی به نام دقیق جدول؛ چند نام رایج را تلاش می‌کند.
        """
        def _safe_count(sqls):
            for q in sqls:
                try:
                    r = self.db.execute_query(q, fetch_one=True)
                    if r and 'cnt' in r:
                        return int(r['cnt'])
                except Exception:
                    continue
            return 0

        # تلاش برای شمارش با چند نام رایج جدول
        dept_cnt = _safe_count([
            "SELECT COUNT(*) AS cnt FROM org_units",
            "SELECT COUNT(*) AS cnt FROM departments",
            "SELECT COUNT(*) AS cnt FROM org_departments",
        ])
        user_cnt = _safe_count([
            "SELECT COUNT(*) AS cnt FROM users",
            "SELECT COUNT(*) AS cnt FROM app_users",
        ])
        role_cnt = _safe_count([
            "SELECT COUNT(*) AS cnt FROM roles",
            "SELECT COUNT(*) AS cnt FROM app_roles",
        ])

        ok = (dept_cnt > 0 and user_cnt > 0 and role_cnt > 0)
        missing = []
        if dept_cnt == 0: missing.append("چارت سازمانی (دپارتمان/واحد)")
        if user_cnt == 0: missing.append("کاربران")
        if role_cnt == 0: missing.append("نقش‌ها/دسترسی‌ها")

        msg = ""
        if not ok:
            msg = "برای ادامه، ابتدا این موارد را تنظیم کن:\n- " + "\n- ".join(missing)

        if (not ok) and (not silent):
            QtWidgets.QMessageBox.warning(self, "پیش‌نیازهای سازمانی ناقص", msg)

        return ok, msg, {"org_units": dept_cnt, "users": user_cnt, "roles": role_cnt}

    def _run_org_setup_sequence(self):
        """
        ویزارد بسیار ساده (گام‌به‌گام) برای تنظیم: Org → Users → Roles
        از دیالوگ‌های موجود پروژه استفاده می‌کند؛ اگر نبودند، پیام راهنما می‌دهد.
        """
        # اگر مجوز مدیریت کاربران/سازمان را نداریم، سریع خارج شو
        if not self.has_permission('settings:manage_users'):
            QtWidgets.QMessageBox.warning(self, "دسترسی کافی نیست",
                                        "برای راه‌اندازی سازمان باید مجوز «مدیریت کاربران/سازمان» داشته باشید.")
            return

        # 1) چارت سازمانی
        answer = QtWidgets.QMessageBox.question(
            self, "گام ۱ از ۳ — چارت سازمانی",
            "اول چارت سازمانی را تنظیم می‌کنیم (افزودن دپارتمان/واحد، سرپرست‌ها و...). ادامه بدهم؟",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if answer == QtWidgets.QMessageBox.Yes:
            if hasattr(self, "_open_org_chart_manager"):
                self._open_org_chart_manager()
            else:
                # تلاش مستقیم به نام‌های محتمل دیالوگ
                Dlg = globals().get('OrgChartManagerDialog') or globals().get('OrganizationChartDialog')
                if Dlg: Dlg(self.db, self).exec_()
                else: QtWidgets.QMessageBox.information(self, "راهنما", "از مسیر «تنظیمات و ابزارها → چارت سازمانی» وارد شوید.")

        # 2) کاربران
        answer = QtWidgets.QMessageBox.question(
            self, "گام ۲ از ۳ — کاربران",
            "حالا کاربران سیستم را اضافه/ویرایش کنیم؟ (نام، ایمیل، واحد سازمانی، وضعیت فعال)",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if answer == QtWidgets.QMessageBox.Yes:
            if hasattr(self, "_open_user_manager"):
                self._open_user_manager()
            else:
                Dlg = globals().get('UserManagerDialog') or globals().get('UsersManagerDialog')
                if Dlg: Dlg(self.db, self).exec_()
                else: QtWidgets.QMessageBox.information(self, "راهنما", "از مسیر «تنظیمات و ابزارها → کاربران» وارد شوید.")

        # 3) نقش‌ها/دسترسی‌ها
        answer = QtWidgets.QMessageBox.question(
            self, "گام ۳ از ۳ — نقش‌ها/دسترسی‌ها",
            "در نهایت نقش‌ها (Role) و مجوزها را تعریف و به کاربران اختصاص بدهیم؟",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if answer == QtWidgets.QMessageBox.Yes:
            if hasattr(self, "_open_role_manager"):
                self._open_role_manager()
            else:
                Dlg = globals().get('RoleManagerDialog') or globals().get('RolesManagerDialog')
                if Dlg: Dlg(self.db, self).exec_()
                else: QtWidgets.QMessageBox.information(self, "راهنما", "از مسیر «تنظیمات و ابزارها → نقش‌ها/دسترسی‌ها» وارد شوید.")

        # جمع‌بندی و رفرش
        ok, _, cnt = self._ensure_org_prereqs(silent=True)
        if ok:
            QtWidgets.QMessageBox.information(self, "آماده!",
                "پیش‌نیازهای سازمانی تکمیل شد. حالا می‌توانی فرآیندها را طراحی و رویدادها را متصل کنی.")
        else:
            QtWidgets.QMessageBox.warning(self, "هنوز ناقص", 
                "برخی موارد هنوز کامل نیست. هر زمان آماده شدی دوباره این ویزارد را اجرا کن.")
            

        
                                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_qc_page(self):
        """صفحه اصلی ماژول کنترل کیفیت را با کنترل دسترسی کامل بر روی تب‌ها می‌سازد."""
        layout = self.create_page_layout(self.pg_qc, "مرکز کنترل کیفیت (QC)")
        
        self.qc_tabs = QtWidgets.QTabWidget()
        self.qc_tabs.setObjectName("interfaceTabWidget")
        layout.addWidget(self.qc_tabs)

        if self.has_permission('qc:manage_quarantine'):
            self.incoming_qc_widget = IncomingQCWidget(self.db, self.user_id, self)
            self.qc_tabs.addTab(self.incoming_qc_widget, "بازرسی کالاهای ورودی")
        
        if self.has_permission('qc:view_history'):
            self.qc_history_widget = QCHistoryWidget(self.db, self.user_id, self)
            self.qc_tabs.addTab(self.qc_history_widget, "بایگانی گزارش‌های کیفی")
        
        if self.has_permission('qc:resolve_nonconforming'):
            self.non_conforming_widget = NonConformingWidget(self.db, self.user_id, self)
            self.qc_tabs.addTab(self.non_conforming_widget, "مدیریت اقلام نامنطبق")

        if self.qc_tabs.count() == 0:
            no_access_label = QtWidgets.QLabel("شما به هیچ‌یک از بخش‌های کنترل کیفیت دسترسی ندارید.")
            no_access_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(no_access_label)
            self.qc_tabs.setVisible(False)
                        
                    
        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _refresh_qc_page(self):
        """داده‌های صفحه کنترل کیفیت را رفرش می‌کند."""
        if hasattr(self, 'incoming_qc_widget'):
            self.incoming_qc_widget.refresh_data()
        if hasattr(self, 'qc_history_widget'):
            self.qc_history_widget.search_records()
        if hasattr(self, 'non_conforming_widget'): # <<<<<<< این خط جدید را اضافه کن
            self.non_conforming_widget.refresh_data()
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_sales_page(self):
        """صفحه اصلی ماژول فروش را با کنترل دسترسی کامل بر روی تمام عملکردها می‌سازد."""
        layout = self.create_page_layout(self.pg_sales, "مرکز مدیریت فروش")
        
        self.sales_tabs = QtWidgets.QTabWidget()
        self.sales_tabs.setObjectName("interfaceTabWidget")
        self.sales_tabs.currentChanged.connect(self._on_sales_tab_changed)
        layout.addWidget(self.sales_tabs)

        # تب اول: تاریخچه سفارشات
        so_history_page = QtWidgets.QWidget()
        so_history_layout = QtWidgets.QVBoxLayout(so_history_page)
        so_history_layout.setContentsMargins(0, 10, 0, 0)
        
        toolbar = QtWidgets.QFrame(); toolbar_layout = QtWidgets.QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(0, 0, 0, 10)
        
        # --- *** بخش جدید و امنیتی: کنترل دسترسی برای هر دکمه *** ---
        if self.has_permission('sales:create_order'):
            btn_new_order = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " ثبت سفارش فروش جدید"); btn_new_order.setProperty("class", "primary"); btn_new_order.setMinimumHeight(35); btn_new_order.clicked.connect(self._open_sales_order_dialog)
            toolbar_layout.addWidget(btn_new_order)
        
        if self.has_permission('sales:manage_customers'):
            btn_manage_customers = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-users"), " مدیریت مشتریان"); btn_manage_customers.setMinimumHeight(35); btn_manage_customers.clicked.connect(lambda: CustomerManagerDialog(self.db, self).exec_())
            toolbar_layout.addWidget(btn_manage_customers)

        if self.has_permission('sales:inquire_qc'):
            btn_qc_inquiry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-information"), " استعلام سوابق کیفی بچ"); btn_qc_inquiry.setMinimumHeight(35); btn_qc_inquiry.clicked.connect(self._open_batch_qc_inquiry_dialog)
            toolbar_layout.addWidget(btn_qc_inquiry)

        toolbar_layout.addSpacing(20)

        if self.has_permission('sales:start_proforma_process'):
            btn_start_proforma = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), " ایجاد پیش‌فاکتور برای سفارش")
            btn_start_proforma.setMinimumHeight(35)
            toolbar_layout.addWidget(btn_start_proforma)
        # --- ****************************************************** ---

        toolbar_layout.addStretch()
        so_history_layout.addWidget(toolbar)

        info_label = QtWidgets.QLabel(" برای تهیه خروجی PDF، روی سفارش مورد نظر راست-کلیک کنید.")
        info_label.setStyleSheet("color: #2c3e50; font-style: italic; background-color: #e7f1ff; border: 1px solid #b3d1ff; border-radius: 4px; padding: 6px; margin-bottom: 5px;")
        so_history_layout.addWidget(info_label)

        self.tbl_sales_orders = QtWidgets.QTableWidget()
        self.tbl_sales_orders.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_sales_orders.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tbl_sales_orders.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tbl_sales_orders.customContextMenuRequested.connect(self._show_sales_order_context_menu)
        add_filter_export_tools(self.tbl_sales_orders, so_history_layout)
        so_history_layout.addWidget(self.tbl_sales_orders, 1)
        self.sales_tabs.addTab(so_history_page, "تاریخچه سفارشات فروش")

        # تب دوم: کارتابل پیش‌فاکتورها
        proforma_page = QtWidgets.QWidget()
        proforma_layout = QtWidgets.QVBoxLayout(proforma_page)
        proforma_layout.setContentsMargins(0, 10, 0, 0)
        self.tbl_proforma_history = QtWidgets.QTableWidget()
        self._style_table(self.tbl_proforma_history)
        proforma_layout.addWidget(self.tbl_proforma_history, 1)
        self.sales_tabs.addTab(proforma_page, "پیش‌فاکتورهای در جریان")
        
                                                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _refresh_proforma_history(self):
        """جدول تاریخچه پیش‌فاکتورها را در صفحه فروش رفرش می‌کند."""
        if not hasattr(self, 'tbl_proforma_history'): return
        table = self.tbl_proforma_history
        table.setRowCount(0)
        
        try:
            records = self.db.get_proforma_invoice_history(self.user_id)
            headers = ["شماره سفارش", "مشتری", "تاریخ شروع فرآیند", "مرحله فعلی"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(records))
            
            for r, rec in enumerate(records):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(rec['so_number']))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(rec['customer_name']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(rec['started_at'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(rec.get('current_step', rec.get('process_status'))))
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ پیش‌فاکتوری توسط شما در جریان نیست.")
        except Exception as e:
            print(f"Error loading proforma history: {e}")
            
                        
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _on_sales_tab_changed(self, index=None):
        """با تغییر تب در صفحه فروش، محتوای آن را رفرش می‌کند."""
        if not hasattr(self, 'sales_tabs'): return

        current_tab_text = self.sales_tabs.tabText(self.sales_tabs.currentIndex())
        if current_tab_text == "تاریخچه سفارشات فروش":
            if hasattr(self, '_refresh_sales_page'):
                self._refresh_sales_page()
        elif current_tab_text == "پیش‌فاکتورهای در جریان":
            if hasattr(self, '_refresh_proforma_history'):
                self._refresh_proforma_history()
                                                        
                        
                            
                                    
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _refresh_sales_page(self):
        """داده‌های صفحه فروش را به همراه ستون جدید "مرحله فرآیند" رفرش می‌کند."""
        if not hasattr(self, 'tbl_sales_orders'): return
        table = self.tbl_sales_orders
        table.setRowCount(0)
        
        try:
            orders = self.db.get_all_sales_orders()
            # --- *** افزودن ستون جدید به هدرها *** ---
            headers = ["ID", "شماره سفارش", "مشتری", "کالاهای سفارش", "حجم فروش (تعداد)", "مبلغ کل (ریال)", "تاریخ", "وضعیت تولید", "مرحله فرآیند"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(orders))

            for r, order in enumerate(orders):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['so_number']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(order['customer_name']))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(order.get('items_list', '')))
                table.setItem(r, 4, NumericTableWidgetItem(str(order.get('total_quantity', 0))))
                table.setItem(r, 5, NumericTableWidgetItem(f"{order.get('total_amount', 0):,.0f}"))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(to_shamsi(order['issue_date'])))
                table.setItem(r, 7, QtWidgets.QTableWidgetItem(order['status']))
                
                # --- *** پر کردن ستون جدید *** ---
                workflow_step = order.get('current_workflow_step')
                step_item = QtWidgets.QTableWidgetItem(workflow_step if workflow_step else '---')
                if workflow_step: # هایلایت کردن برای جلب توجه
                    step_item.setBackground(QtGui.QColor("#e7f1ff"))
                    step_item.setForeground(QtGui.QColor("#0d6efd"))
                table.setItem(r, 8, step_item)
                # --- ************************* ---

            table.setColumnHidden(0, True); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ سفارش فروشی تا کنون ثبت نشده است.")
        except Exception as e:
            print(f"Error loading sales orders: {e}")
            
            
            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _show_sales_order_context_menu(self, pos):
        """منوی راست‌کلیک را برای جدول سفارشات فروش با کنترل دسترسی نمایش می‌دهد."""
        table = self.tbl_sales_orders
        selected_item = table.itemAt(pos)
        if not selected_item:
            return

        menu = QtWidgets.QMenu(self)
        
        # --- *** بخش جدید و امنیتی: کنترل دسترسی برای هر اکشن منو *** ---
        added_action = False
        if self.has_permission('sales:export_pdf'):
            pdf_action = menu.addAction(QtGui.QIcon.fromTheme("document-export"), "تهیه خروجی PDF پیش‌فاکتور")
            action = menu.exec_(table.mapToGlobal(pos))
            
            if action == pdf_action:
                row = selected_item.row()
                so_id = int(table.item(row, 0).text())
                self._generate_proforma_pdf(so_id)
            added_action = True
        # --- ******************************************************* ---
        
        if not added_action:
            # اگر کاربر هیچ دسترسی مرتبطی نداشت، یک آیتم غیرفعال نمایش بده
            menu.addAction("هیچ عملیاتی مجاز نیست").setEnabled(False)
            menu.exec_(table.mapToGlobal(pos))
            
            
    def get_open_sales_orders(self):
        """
        رَپر ساده برای تأمین داده‌ی جدول سفارش‌های فروش باز.
        از DB می‌خواند و همان لیست دیکشنری‌ها را برمی‌گرداند.
        """
        try:
            return self.db.get_open_sales_orders()
        except Exception as e:
            # اگر توست/لاگر داری، همین‌جا هم پیام بده که UI خاموش نشود
            print(f"ERROR: get_open_sales_orders failed: {e}")
            return []

            
            
    def _generate_proforma_pdf(self, so_id: int):
        """داده‌های یک سفارش را گرفته و از آن یک فایل PDF پیش‌فاکتور تولید می‌کند."""
        invoice_data = self.db.get_invoice_data_for_sales_order(so_id)
        if not invoice_data:
            self.toast.show_message("اطلاعات سفارش برای ساخت PDF یافت نشد.", "error")
            return

        so_number = invoice_data.get('header', {}).get('so_number', 'invoice')
        default_path = f"{so_number}.pdf"
        
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "ذخیره فایل PDF پیش‌فاکتور", default_path, "PDF Files (*.pdf)")
        
        if file_path:
            try:
                # فراخوانی تابع سراسری که قبلاً نوشتیم
                create_invoice_pdf(invoice_data, file_path)
                self.toast.show_message("✔ فایل PDF پیش‌فاکتور با موفقیت ذخیره شد.", "success")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در ساخت PDF", f"یک خطای پیش‌بینی نشده رخ داد:\n{e}")
                print(traceback.format_exc())
            
                                    
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _open_batch_qc_inquiry_dialog(self):
        """دیالوگ استعلام سوابق کیفی را برای واحد فروش باز می‌کند."""
        if self.has_permission('page:view:sales'):
            dlg = BatchQCInquiryDialog(self.db, self)
            dlg.exec_()
        else:
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _open_sales_order_dialog(self):
        """دیالوگ ثبت سفارش فروش را باز کرده و در صورت تایید، جدول را رفرش می‌کند."""
        if not self.has_permission('page:view:sales'):
            self.toast.show_message("شما دسترسی لازم برای ثبت سفارش را ندارید.", "error")
            return
            
        # ارسال self (پنجره اصلی) به دیالوگ برای دسترسی به toast و سایر متدها
        dlg = SalesOrderDialog(self.db, self)
        
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            # در منطق جدید، ذخیره‌سازی داخل خود دیالوگ انجام می‌شود.
            # ما در اینجا فقط باید صفحه را برای نمایش سفارش جدید، رفرش کنیم.
            self._refresh_sales_page()
                                                                    
                                

                    
    def _open_org_chart_manager(self):
        """دیالوگ مدیریت چارت سازمانی را باز می‌کند."""
        if self.has_permission('settings:manage_users'): # دسترسی موقت
            OrgChartManagerDialog(self.db, self).exec_()
        else:
            self.toast.show_message("شما دسترسی لازم برای مدیریت چارت سازمانی را ندارید.", "error")

    
# در کلاس MainWindow، این متد را جایگزین کنید
    def _open_qa_forms_manager(self):
        """دیالوگ مدیریت فرم‌های اختصاصی QA را با استفاده از فرم‌ساز پیشرفته باز می‌کند."""
        if self.has_permission('qa:manage_forms'):
            # فراخوانی دیالوگ مدیریتی جدید و کامل
            dlg = ManageQaFormsDialog(self.db, self.user_id, self.role, self)
            dlg.exec_()
            # پس از بسته شدن دیالوگ، ممکن است لازم باشد لیست فرم‌ها در طراح فرآیند رفرش شود
            # بنابراین یک رفرش کلی انجام می‌دهیم
            self.refresh_all()
        else:
            self.toast.show_message("شما دسترسی لازم برای مدیریت فرم‌های QA را ندارید.", "error")
                            

        
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _show_po_details(self, item: QtWidgets.QTableWidgetItem):
        """دیالوگ جزئیات را برای سفارش خرید انتخاب شده باز می‌کند."""
        try:
            po_id = int(self.tbl_purchase_orders.item(item.row(), 0).text())
            dlg = PurchaseOrderDetailDialog(self.db, po_id, self)
            dlg.exec_()
        except (AttributeError, ValueError):
            # اگر روی ردیف نامعتبر کلیک شد، کاری نکن
            return

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_purchasing_page(self):
        """صفحه ماژول بازرگانی را با استفاده از میزکار هوشمند جدید می‌سازد."""
        layout = self.create_page_layout(self.pg_purchasing, "مدیریت بازرگانی و تامین")
        
        self.purchasing_tabs = QtWidgets.QTabWidget()
        self.purchasing_tabs.setObjectName("interfaceTabWidget")
        layout.addWidget(self.purchasing_tabs)

        # تب اول: میزکار اصلی بازرگانی
        self.purchasing_workbench_widget = PurchasingWorkbenchWidget(self.db, self.user_id, self)
        self.purchasing_tabs.addTab(self.purchasing_workbench_widget, "میزکار بازرگانی")

        # تب دوم: تاریخچه کلی سفارشات خرید
        po_history_page = QtWidgets.QWidget()
        po_history_layout = QtWidgets.QVBoxLayout(po_history_page)
        po_history_layout.setContentsMargins(0, 10, 0, 0)
        self.tbl_purchase_orders = QtWidgets.QTableWidget()
        self._style_table(self.tbl_purchase_orders)
        self.tbl_purchase_orders.itemDoubleClicked.connect(self._show_po_details)
        add_filter_export_tools(self.tbl_purchase_orders, po_history_layout)
        po_history_layout.addWidget(self.tbl_purchase_orders)
        self.purchasing_tabs.addTab(po_history_page, "تاریخچه سفارشات خرید")

        # تب سوم: داشبورد ارزیابی تامین‌کنندگان
        performance_page = QtWidgets.QWidget()
        performance_layout = QtWidgets.QVBoxLayout(performance_page)
        performance_layout.setContentsMargins(0, 10, 0, 0)
        toolbar = QtWidgets.QHBoxLayout()
        toolbar.addStretch()
        btn_manage_suppliers = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-users"), " مدیریت لیست تامین‌کنندگان")
        btn_manage_suppliers.setMinimumHeight(35)
        btn_manage_suppliers.clicked.connect(lambda: SupplierManagerDialog(self.db, self).exec_())
        toolbar.addWidget(btn_manage_suppliers)
        performance_layout.addLayout(toolbar)
        self.tbl_supplier_performance = QtWidgets.QTableWidget()
        self._style_table(self.tbl_supplier_performance)
        performance_layout.addWidget(self.tbl_supplier_performance)
        self.purchasing_tabs.addTab(performance_page, "داشبورد ارزیابی تامین‌کنندگان")
                        
                
        # این متد جدید را به کلاس MainWindow اضافه کنید

    def _load_supplier_performance(self):
        """داده‌های عملکرد کیفی تامین‌کنندگان را بارگذاری و در جدول مربوطه نمایش می‌دهد."""
        if not hasattr(self, 'tbl_supplier_performance'): return
        table = self.tbl_supplier_performance
        table.setRowCount(0)
        
        try:
            records = self.db.get_supplier_performance_data()
            headers = ['نام تامین‌کننده', 'تعداد کل بچ‌های دریافتی', 'تعداد بچ‌های رد شده', 'نرخ رد کیفی (%)']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(records))

            for r, rec in enumerate(records):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(rec['supplier_name']))
                table.setItem(r, 1, NumericTableWidgetItem(str(rec['total_batches'])))
                table.setItem(r, 2, NumericTableWidgetItem(str(rec['rejected_batches'])))
                
                rate_item = NumericTableWidgetItem(f"{rec['rejection_rate']:.2f} %")
                # رنگ‌آمیزی بر اساس نرخ رد کیفی
                if rec['rejection_rate'] > 10:
                    rate_item.setBackground(QtGui.QColor("#f8d7da")) # قرمز
                elif rec['rejection_rate'] > 5:
                    rate_item.setBackground(QtGui.QColor("#fff3cd")) # زرد
                table.setItem(r, 3, rate_item)

            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "داده‌ای برای ارزیابی عملکرد تامین‌کنندگان یافت نشد.")
        except Exception as e:
            print(f"Error loading supplier performance data: {e}")
            
                    
    def _add_quote_action(self):
        """دیالوگ افزودن پیشنهاد قیمت را برای درخواست انتخاب شده، باز می‌کند."""
        if not hasattr(self, 'tbl_actionable_prs'): return
        
        selected_pr = self.tbl_actionable_prs.selectedItems()
        if not selected_pr:
            self.toast.show_message("ابتدا یک درخواست خرید را از جدول بالا انتخاب کنید.", "warning")
            return
            
        request_id = int(self.tbl_actionable_prs.item(selected_pr[0].row(), 0).text())
        
        dlg = AddQuoteDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            quote_data = dlg.get_data()
            if quote_data:
                quote_data['request_id'] = request_id
                try:
                    self.db.add_quote(quote_data, self.user_id)
                    self.toast.show_message("✔ پیشنهاد قیمت جدید با موفقیت ثبت شد.", "success")
                    # رفرش کردن هر دو جدول در میزکار
                    self._load_actionable_purchase_requests()
                    self._load_quotes_for_pr(request_id)
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت پیشنهاد قیمت:\n{e}")
                    
    #
    # این متد جدید را به کلاس MainWindow اضافه کنید
    #
    def _select_quote_action(self):
        """پیشنهاد قیمت انتخاب شده را به عنوان برنده ثبت کرده و وضعیت درخواست را به‌روز می‌کند."""
        if not hasattr(self, 'tbl_actionable_prs') or not hasattr(self, 'tbl_quotes'): return

        selected_pr_items = self.tbl_actionable_prs.selectedItems()
        selected_quote_items = self.tbl_quotes.selectedItems()

        if not selected_pr_items or not selected_quote_items:
            self.toast.show_message("لطفاً هم درخواست خرید (از جدول بالا) و هم پیشنهاد برنده (از جدول پایین) را انتخاب کنید.", "warning")
            return
            
        try:
            request_id = int(self.tbl_actionable_prs.item(selected_pr_items[0].row(), 0).text())
            quote_id = int(self.tbl_quotes.item(selected_quote_items[0].row(), 0).text())
        except (ValueError, AttributeError):
            self.toast.show_message("انتخاب شما معتبر نیست.", "error")
            return

        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", "آیا از انتخاب این پیشنهاد به عنوان برنده و ارسال درخواست برای مرحله بعد اطمینان دارید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.select_winning_quote(request_id, quote_id, self.user_id)
                self.toast.show_message("✔ پیشنهاد برنده با موفقیت انتخاب شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند انتخاب برنده با خطا مواجه شد:\n{e}")
        
    def _on_pr_selected(self):
        """با انتخاب یک درخواست، لیست پیشنهادهای آن را بارگذاری و وضعیت دکمه PO را به‌روز می‌کند."""
        selected = self.tbl_actionable_prs.selectedItems()
        self.btn_issue_po.setEnabled(False) # غیرفعال کردن دکمه به صورت پیش‌فرض
        if not selected:
            self.tbl_quotes.setRowCount(0)
            return
            
        row = selected[0].row()
        request_id = int(self.tbl_actionable_prs.item(row, 0).text())
        status = self.tbl_actionable_prs.item(row, 4).text()
        
        # فقط اگر وضعیت "تامین‌کننده انتخاب شد" بود، دکمه فعال شود
        if status == 'تامین‌کننده انتخاب شد':
            self.btn_issue_po.setEnabled(True)
            
        self._load_quotes_for_pr(request_id)
            
# در کلاس MainWindow، این متد را جایگزین کنید

    def _process_task_action(self, item: QtWidgets.QTableWidgetItem):
        """با دابل کلیک روی یک کار، فقط دیالوگ اقدام (تایید/رد) را باز می‌کند؛ آیتم «تاریخچه فرآیند» حذف شد."""
        task_data = item.tableWidget().item(item.row(), 0).data(Qt.UserRole)
        if not task_data:
            return

        menu = QtWidgets.QMenu(self)
        action_perform = menu.addAction(QtGui.QIcon.fromTheme("system-run"), "انجام اقدام (تایید/رد)")

        action = menu.exec_(QtGui.QCursor.pos())
        if action == action_perform:
            self._process_task_action_from_data(task_data)
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _process_task_action_from_data(self, task_data: dict):
        """پنجره اقدام را برای یک وظیفه مشخص باز کرده و نتیجه را به موتور گردش کار ارسال می‌کند."""
        if not task_data: return

        # این بخش بدون تغییر باقی می‌ماند
        if "فوریت" in task_data.get('step_name', ''):
            dlg = SetUrgencyDialog(self)
            if dlg.exec_():
                try:
                    self.db.set_purchase_request_urgency(request_id=task_data['related_record_id'], urgency=dlg.get_urgency(), user_id=self.user_id)
                    self.toast.show_message("✔ فوریت خرید با موفقیت ثبت شد.", "success"); self.refresh_all()
                except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا در پردازش", f"عملیات با خطا مواجه شد:\n{e}")
            return

        dlg = ProcessActionDialog(task_data, self)
        
        # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
        # ما فقط زمانی فرآیند را ادامه می‌دهیم که کاربر یکی از دکمه‌های اصلی را زده باشد
        # و دیالوگ با موفقیت (accept) بسته شده باشد.
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            result = dlg.get_data()
            if result and result.get("outcome"):
                # تابع _execute_workflow_action را با مقادیر جدید فراخوانی می‌کنیم
                self._execute_workflow_action(
                    task_data=task_data, 
                    outcome_str=result["outcome"], 
                    reason=result["reason"]
                )

    def _execute_workflow_action(self, task_data: dict, outcome_str: str, reason: str = ""):
        """
        رَپر سبک برای نگاشت نتیجهٔ دیالوگ به متدهای approvals موجود (بدون وابستگی به موتور workflow).
        outcome_str یکی از: 'APPROVED' / 'REJECTED' / 'REWORK'
        """
        if not task_data:
            return

        # نگاشت outcome به تصمیم
        outcome = (outcome_str or "").strip().upper()
        if outcome == "APPROVED":
            decision = "APPROVE"
        else:
            # 'REJECTED' یا 'REWORK' → رد
            decision = "REJECT"

        stage = (task_data.get("workflow_name") or "").strip().upper()
        pr_id = task_data.get("related_record_id") or task_data.get("pr_id")
        appr_id = task_data.get("appr_id") or task_data.get("approval_id")

        if stage in ("DEPT_MANAGER", "COMMERCE"):
            # استفاده از Bulk برای سازگاری
            decisions = [{
                "approval_id": appr_id,
                "pr_id": pr_id,
                "decision": decision,
                "comment": reason or ""
            }]
            res = self.db.decide_manager_approvals_bulk(decisions, decided_by_user_id=self.user_id)
            # رفرش UI پس از اقدام
            self.toast.show_message("✔ اقدام ثبت شد.", "success")
            self.refresh_all()
            return

        if stage == "CEO":
            decisions = [{
                "pr_id": pr_id,
                "approve": (decision == "APPROVE"),
                "final_urgency": None,
                "note": reason or ""
            }]
            res = self.db.decide_ceo_approvals_bulk(decisions, self.user_id)
            self.toast.show_message("✔ اقدام مدیرعامل ثبت شد.", "success")
            self.refresh_all()
            return

        # پیش‌فرض ایمن: تلاش با مسیر مدیر واحد
        decisions = [{
            "approval_id": appr_id,
            "pr_id": pr_id,
            "decision": decision,
            "comment": reason or ""
        }]
        self.db.decide_manager_approvals_bulk(decisions, decided_by_user_id=self.user_id)
        self.toast.show_message("✔ اقدام ثبت شد.", "success")
        self.refresh_all()

                                    
            
        
    def _open_my_purchase_requests(self):
        dlg = MyPurchaseRequestsDialog(self.db, self.user_id, self)
        dlg.exec_()
        
                                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_pending_purchase_requests(self):
        """جدول کارتابل درخواست‌های خرید را بر اساس نقش کاربر فعلی و موتور فرآیند بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_my_pending_tasks'): return
        
        table = self.tbl_my_pending_tasks
        table.setRowCount(0)
        try:
            user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
            if not user_role_id_rec or not user_role_id_rec['role_id']:
                set_empty_placeholder(table, "نقش شما برای مشاهده درخواست‌ها تعریف نشده است.")
                return

            # فقط تسک‌های مربوط به خرید را فیلتر می‌کنیم
            all_tasks = self.db.get_pending_tasks_for_user_role(self.user_id, user_role_id_rec['role_id'])
            purchase_tasks = [t for t in all_tasks if t.get('related_table_name') == 'purchase_requests']
            
            headers = ['ID', 'نام کالا', 'مقدار', 'درخواست‌دهنده', 'تاریخ', 'یادداشت', 'مرحله فعلی']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(purchase_tasks))

            for r, task in enumerate(purchase_tasks):
                details = task.get('details', {})
                pr_id = task.get('related_record_id')
                
                # یک آیتم اصلی می‌سازیم و کل داده تسک را در آن ذخیره می‌کنیم
                id_item = QtWidgets.QTableWidgetItem(str(pr_id))
                id_item.setData(Qt.UserRole, task)
                table.setItem(r, 0, id_item)
                
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(details.get('item_name', '')))
                table.setItem(r, 2, NumericTableWidgetItem(str(details.get('qty', ''))))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(details.get('requester', '')))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(task.get('started_at'))))
                # یادداشت‌ها را باید از خود رکورد اصلی خواند
                # (این بخش در آینده می‌تواند بهینه‌تر شود)
                pr_rec = self.db.execute_query("SELECT notes FROM purchase_requests WHERE id=%s", (pr_id,), fetch_one=True)
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(pr_rec.get('notes', '') if pr_rec else ''))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(task.get('step_name', '')))
            
            table.setColumnHidden(0, True); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ درخواست خریدی در کارتابل شما وجود ندارد.")
        except Exception as e:
            print(f"Error loading purchase requests: {e}")
            
    
                                                

# در کلاس MainWindow، این متد را جایگزین کنید
    def _approve_selected_pr(self):
        """درخواست خرید انتخاب شده را برای ارسال به مدیر واحد، تایید اولیه می‌کند."""
        if not hasattr(self, 'tbl_purchase_requests'): return
        
        selected_rows = self.tbl_purchase_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را برای تایید انتخاب کنید.", "warning")
            return
            
        row = selected_rows[0].row()
        request_id = int(self.tbl_purchase_requests.item(row, 0).text())
        item_name = self.tbl_purchase_requests.item(row, 1).text()

        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا از تایید اولیه درخواست خرید برای «{item_name}» و ارسال آن برای مدیر واحد مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.process_purchase_request(request_id, self.user_id, is_approved=True)
                self.toast.show_message("✔ درخواست خرید با موفقیت برای تایید مدیر واحد ارسال شد.", "success")
                self._load_pending_purchase_requests() # رفرش کردن لیست
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند تایید با خطا مواجه شد:\n{e}")
                
                
    def _reject_selected_pr(self):
        """درخواست خرید انتخاب شده را پس از دریافت دلیل، رد می‌کند."""
        if not hasattr(self, 'tbl_purchase_requests'): return
        
        selected_rows = self.tbl_purchase_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را برای رد کردن انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        request_id = int(self.tbl_purchase_requests.item(row, 0).text())
        item_name = self.tbl_purchase_requests.item(row, 1).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد درخواست", f"لطفاً دلیل رد کردن درخواست برای «{item_name}» را وارد کنید:")
        if ok and reason.strip():
            try:
                self.db.process_purchase_request(request_id, self.user_id, is_approved=False, reason=reason.strip())
                self.toast.show_message("✖ درخواست خرید رد شد.", "info")
                self._load_pending_purchase_requests() # رفرش کردن لیست
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "warning")
            
    def _augment_qa_page_with_command_center(self, parent_layout=None):
        return            
    # --- [OPTIONAL-HOOK] استفاده‌ی سریع از Orchestrator در MainWindow -------------
    
    # ─────────────────────────────────────────────────────────────────────────────
    # [NEW in MainWindow] گِیت ساده‌ی UI قبل از تغییر وضعیت
    # ─────────────────────────────────────────────────────────────────────────────
    

                
                                    
    # BEGIN REWRITE: MainWindow._build_all_pages
    def _build_all_pages(self):
            """Builds all pages of the application."""
            # The line "self.notification_buttons.clear()" has been removed from here.
            
            self._build_dashboard_page()
            self._build_items_page()
            self._build_trans_page()
            self._build_purchasing_page()
            self._build_qa_page()
            self._augment_qa_page_with_command_center()

            self._build_qc_page() # <<< --- اصلاح کلیدی اینجاست: فراخوانی تابع فراموش شده
            self._build_production_page()
            # ------------------------------------------------------------------
            self._build_inventory_page()
            self._build_kanban_page()
            self._build_communications_page()
            self._build_forms_page()
            self._build_settings_page()
    # END REWRITE: MainWindow._build_all_pages
    
    def ensure_yesterday_snapshot_on_first_run(self):
        """
        یک‌بار پس از بالا آمدن برنامه:
        - اسکیما/ستون‌های جدول اسنپ‌شات را تضمین می‌کند (اگر نبود بسازد/مهاجرت دهد).
        - اگر برای "امروز" اسنپ‌شات داریم → هیچ کاری نکن.
        - اگر نداریم → اسنپ‌شات امروز را می‌سازیم (نمایندهٔ موجودی پایانِ دیروز).
        """
        import datetime as _dt
        try:
            # تضمین اسکیما (این خط خطای «column kind does not exist» را از بین می‌برد)
            if hasattr(self.db, "ensure_inventory_snapshot_schema"):
                self.db.ensure_inventory_snapshot_schema()

            today = _dt.date.today().isoformat()

            # اگر امروز قبلاً اسنپ‌شات داریم، تمام
            has_today = False
            cols = set(self.db._get_existing_columns("inventory_daily_snapshot"))
            if {"snap_date"}.issubset(cols):
                row = self.db.execute_query(
                    "SELECT 1 FROM inventory_daily_snapshot WHERE snap_date=%s LIMIT 1",
                    (today,), fetch_one=True
                )
                has_today = bool(row)

            if has_today:
                return  # فقط یک بار در روز

            # ساخت اسنپ‌شات امروز (نمایندهٔ پایان دیروز)
            if hasattr(self.db, "materialize_snapshot_for_date"):
                self.db.materialize_snapshot_for_date(today)

            # پیام کوچک (غیراجباری)
            try:
                self.statusBar().showMessage(f"اسنپ‌شات موجودی برای {today} ثبت شد.", 5000)
            except Exception:
                pass

        except Exception as e:
            from PyQt5 import QtWidgets
            QtWidgets.QMessageBox.warning(self, "ثبت اسنپ‌شات روزانه", str(e))

        
                                            
    def _build_forms_page(self):
            layout = self.create_page_layout(self.pg_forms, "مدیریت فرم‌ها")
            # --- اصلاح کلیدی اینجاست ---
            main_widget = FormsPage(self.db, self.user, self._viewer(), self) # آرگومان self اضافه شد
            # --- پایان اصلاح ---
            layout.addWidget(main_widget)        

    # BEGIN REWRITE: MainWindow.create_page_layout
    def create_page_layout(self, page_widget, title: str, show_back_button=False) -> QtWidgets.QVBoxLayout:
        """
        هدر صفحه + دکمه‌های عمومی (فیلتر/ریست/اکسل) را می‌سازد و لایه‌ی صفحه را برمی‌گرداند.
        هیچ‌یک از امکانات قبلی حذف نشده؛ فقط یک نوار ابزار کوچک اضافه شده است.
        """
        from PyQt5 import QtWidgets, QtCore, QtGui

        # پاک‌سازی لایه‌ی قبلی صفحه (در صورت وجود)
        if page_widget.layout() is not None:
            QtWidgets.QWidget().setLayout(page_widget.layout())

        page_layout = QtWidgets.QVBoxLayout(page_widget)
        page_layout.setContentsMargins(20, 15, 20, 20)
        page_layout.setSpacing(15)

        # --- هدر قبلی (بدون تغییر) ---
        header_layout = QtWidgets.QHBoxLayout()
        header_layout.setContentsMargins(0, 0, 0, 10)

        title_label = QtWidgets.QLabel(title)
        title_label.setProperty("class", "title")
        header_layout.addWidget(title_label)

        if show_back_button:
            btn_back = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " بازگشت به داشبورد")
            btn_back.setProperty("class", "primary")
            btn_back.setMinimumHeight(35)
            btn_back.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_dash))
            header_layout.addWidget(btn_back)
            header_layout.addSpacing(20)

        header_layout.addStretch()

        btn_notifications = QtWidgets.QPushButton()
        btn_notifications.setToolTip("کارتابل اعلانات و موارد نیازمند اقدام")
        btn_notifications.setFixedSize(55, 40)
        btn_notifications.setObjectName("notificationButtonHeader")
        btn_notifications.clicked.connect(self._open_notifications_dialog)
        icon_path = BASE_DIR / 'icons' / 'bell.png'
        icon = QtGui.QIcon(str(icon_path)) if (BASE_DIR / 'icons' / 'bell.png').exists() else QtGui.QIcon.fromTheme("dialog-information")
        btn_notifications.setIcon(icon)
        btn_notifications.setIconSize(QtCore.QSize(26, 26))

        user_icon = QtWidgets.QLabel()
        user_icon.setPixmap(QtGui.QIcon.fromTheme("user-identity").pixmap(22, 22))
        user_label = QtWidgets.QLabel(f"کاربر: <b>{self.user}</b>")
        user_label.setStyleSheet("background-color: transparent;")

        logout_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-log-out"), " خروج از حساب")
        logout_btn.clicked.connect(self._logout)

        header_layout.addWidget(btn_notifications)
        header_layout.addSpacing(15)
        header_layout.addWidget(user_icon)
        header_layout.addWidget(user_label)
        header_layout.addSpacing(15)
        header_layout.addWidget(logout_btn)

        page_layout.addLayout(header_layout)

        # --- نوار ابزار عمومی: فیلتر / ریست / خروجی اکسل ---
        tools_bar = QtWidgets.QHBoxLayout()
        tools_bar.setContentsMargins(0, 0, 0, 0)
        tools_bar.setSpacing(8)

        btn_filter = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), " فیلتر پیشرفته")
        btn_reset  = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), " ریست فیلترها")
        btn_excel  = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل")

        # کمی یکدست‌سازی ظاهری
        for b in (btn_filter, btn_reset, btn_excel):
            b.setMinimumHeight(32)

        tools_bar.addStretch()
        tools_bar.addWidget(btn_filter)
        tools_bar.addWidget(btn_reset)
        tools_bar.addWidget(btn_excel)
        # نوار ابزار را زیر هدر بگذار
        page_layout.addLayout(tools_bar)

        # --- جداکننده (مثل قبل) ---
        separator = QtWidgets.QFrame()
        separator.setFrameShape(QtWidgets.QFrame.HLine)
        separator.setFrameShadow(QtWidgets.QFrame.Sunken)
        separator.setStyleSheet("background-color: #dfe6e9;")
        page_layout.addWidget(separator)

        # ====== توابع کمکی محلی برای تشخیص ویجت فعال صفحه ======
        def _visible_tables_and_trees(root: QtWidgets.QWidget):
            """همه‌ی Table/Treeهای قابل مشاهده‌ی این صفحه را بده."""
            tables = [w for w in root.findChildren(QtWidgets.QTableWidget) if w.isVisible()]
            trees  = [w for w in root.findChildren(QtWidgets.QTreeWidget) if w.isVisible()]
            return tables + trees

        def _active_view():
            """
            سعی می‌کند «جدول/درختِ اصلیِ همین صفحه» را پیدا کند:
            - اگر المانی فوکوس دارد، همان.
            - وگرنه اولین Table/Tree قابل مشاهده.
            """
            # اگر فوکوس روی Table/Tree است، همان را برگردان
            fw = page_widget.focusWidget()
            if isinstance(fw, (QtWidgets.QTableWidget, QtWidgets.QTreeWidget)) and fw.isVisible():
                return fw
            # وگرنه اولین مورد قابل مشاهده
            candidates = _visible_tables_and_trees(page_widget)
            return candidates[0] if candidates else None

        # ====== رویدادهای دکمه‌ها ======
        def _open_filter():
            target = _active_view()
            if not target:
                QtWidgets.QMessageBox.information(self, "بدون داده", "در این صفحه جدول/درخت فعالی برای فیلتر کردن پیدا نشد.")
                return
            # از دیالوگ فیلتر موجود استفاده می‌کنیم (زیرساخت فعلی)
            try:
                dlg = FilterDialog(target, self, on_finish=lambda: None)
                dlg.exec_()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"باز کردن فیلتر پیشرفته ممکن نشد:\n{e}")

        def _reset_filters():
            target = _active_view()
            if not target:
                return
            # علامت فیلترهای پیشرفته‌ی قبلی (اگر بود) را پاک کن
            if hasattr(target, "_active_filters"):
                try:
                    target._active_filters = []
                except Exception:
                    pass
            # نمای جدول
            if isinstance(target, QtWidgets.QTableWidget):
                for r in range(target.rowCount()):
                    target.setRowHidden(r, False)
            # نمای درخت
            if isinstance(target, QtWidgets.QTreeWidget):
                it = QtWidgets.QTreeWidgetItemIterator(target, QtWidgets.QTreeWidgetItemIterator.All)
                while it.value():
                    it.value().setHidden(False)
                    it += 1

        def _export_excel():
            target = _active_view()
            if not target:
                QtWidgets.QMessageBox.information(self, "بدون داده", "در این صفحه جدول/درختی برای خروجی اکسل نیست.")
                return
            # از تابع/متد موجود استفاده می‌کنیم
            try:
                # در کلاس MainWindow متد wrap موجود است
                self.export_table_to_excel(target)
            except Exception:
                # اگر متد wrap نبود، از تابع عمومی صدا بزن
                try:
                    export_table_to_excel(target, self)
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خروجی اکسل ناموفق بود:\n{e}")

        btn_filter.clicked.connect(_open_filter)
        btn_reset.clicked.connect(_reset_filters)
        btn_excel.clicked.connect(_export_excel)

        return page_layout
    # END REWRITE: MainWindow.create_page_layout
            
        
            
            
        
                
    def _build_communications_page(self):
        """صفحه اختصاصی و تمام-صفحه مرکز ارتباطات داخلی را می‌سازد."""
        layout = self.create_page_layout(self.pg_communications, "مرکز ارتباطات داخلی", show_back_button=True)
        
        main_widget = QtWidgets.QWidget()
        main_layout = QtWidgets.QVBoxLayout(main_widget)
        
        actions_layout = QtWidgets.QHBoxLayout()
        btn_new_memo = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-message-new"), "ارسال نامه جدید")
        btn_new_memo.setProperty("class", "primary"); btn_new_memo.setMinimumHeight(40)
        btn_new_memo.clicked.connect(self._open_memo_dialog)
        actions_layout.addStretch(); actions_layout.addWidget(btn_new_memo)
        main_layout.addLayout(actions_layout)

        self.comm_page_widget = CommunicationWidget(self.db, self.user_id, self)
        main_layout.addWidget(self.comm_page_widget)
        
        layout.addWidget(main_widget)

                
            
# این متد را در کلاس MainWindow جایگزین کنید
    def _open_notifications_dialog(self):
        """پنل کشویی اعلانات را باز می‌کند."""
        button = self.sender()
        if button:
            self.notification_panel.show_panel(button)
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _update_notification_count(self):
        """تعداد اعلانات باز را شمارش کرده و روی دکمه اعلان صفحه فعال، انیمیشن تپش را کنترل می‌کند."""
        cache = self.notifications_cache or []
        open_count = len(cache)
        unread_count = sum(1 for n in cache if not n.get("is_read"))
        if globals().get('DEBUG_NOTIF', False):
            print(f"[TRACE:NOTIF:counter] unread={unread_count} open={open_count} shown_badge={open_count}")
        current_page = self.pages.currentWidget()
        if not current_page:
            return
        btn = current_page.findChild(QtWidgets.QPushButton, "notificationButtonHeader")
        if not btn:
            return
        btn.setText(str(open_count) if open_count > 0 else "")
        if open_count > 0:
            if self.notification_animation is None:
                self.notification_animation = QtCore.QSequentialAnimationGroup(self)
                anim1 = QtCore.QPropertyAnimation(btn, b"iconSize"); anim1.setDuration(350); anim1.setStartValue(QtCore.QSize(26, 26)); anim1.setEndValue(QtCore.QSize(38, 38)); anim1.setEasingCurve(QtCore.QEasingCurve.OutQuad)
                anim2 = QtCore.QPropertyAnimation(btn, b"iconSize"); anim2.setDuration(1000); anim2.setStartValue(QtCore.QSize(38, 38)); anim2.setEndValue(QtCore.QSize(26, 26)); anim2.setEasingCurve(QtCore.QEasingCurve.OutBounce)
                self.notification_animation.addAnimation(anim1); self.notification_animation.addAnimation(anim2)
                self.notification_animation.setLoopCount(-1)
            if self.notification_animation.state() != QtCore.QAbstractAnimation.Running:
                self.notification_animation.start()
            btn.setStyleSheet("""
                QPushButton { background-color: #e74c3c; color: white; border-radius: 8px; font-weight: bold; padding: 0 8px; }
                QPushButton:hover { background-color: #c0392b; }
            """)
        else:
            if self.notification_animation and self.notification_animation.state() == QtCore.QAbstractAnimation.Running:
                self.notification_animation.stop()
                btn.setIconSize(QtCore.QSize(26, 26))
            btn.setStyleSheet("""
                QPushButton { background-color: transparent; border: none; }
                QPushButton:hover { background-color: #dfe6e9; border-radius: 4px; }
            """)
# این متد را جایگزین _open_notifications_dialog کنید
    def _toggle_notification_panel(self):
        """پنل کشویی اعلانات را زیر دکمه سراسری نوار کناری باز می‌کند."""
        self.notification_panel.show_panel(self.sidebar_notification_button)
            
                                                                    
    # در کلاس MainWindow جایگزین کامل


    def _handle_notification_action(self, action_key, action_data):
        """
        هدایت امن اعلان‌ها:
        - اولویت با صفحه «ارتباط با تولید» و تب‌هایش
        - اگر ساختار جدید نبود، به ساختار قدیمی (pg_trans + interface_tabs) می‌افتیم
        - ⚠ هیچ اعلان اینجا حذف نمی‌شود؛ حذف فقط بعد از انجام موفق عملیات در DB
        """

        def safe_toast(msg, level='info'):
            if hasattr(self, 'toast') and hasattr(self.toast, 'show_message'):
                try:
                    self.toast.show_message(msg, level)
                except Exception:
                    pass

        def _dbg_nav(msg):
            if globals().get('DEBUG_NOTIF', False):
                print(f"[TRACE:NOTIF:nav] {msg}")

        def _trace_nav(route, ok, reason='-'):
            if globals().get('DEBUG_NOTIF', False):
                print(f'[TRACE:NOTIF:navigate] target="{route}" ok={str(ok).lower()} reason={reason}')

        tab_code_map = {
            'FULFILL_REQUEST': 'requests',
            'APPROVE_DELIVERY': 'deliveries',
            'APPROVE_RETURN': 'returns'
        }

        def select_comm_tab(tab_code: str | None):
            base_switched = False
            last_reason = 'no-pages'
            try:
                if hasattr(self, 'pages') and hasattr(self, 'pg_communications'):
                    self.pages.setCurrentWidget(self.pg_communications)
                    base_switched = True
                    last_reason = 'pg_communications'
                    _dbg_nav("switched to pg_communications")
                    widget = getattr(self, 'comm_page_widget', None)
                    if widget and hasattr(widget, 'select_tab'):
                        if widget.select_tab(tab_code):
                            return True, 'comm_widget'
                    for tabs_attr in ('communications_tabs', 'prod_tabs', 'tab_widget_comm'):
                        tabs = getattr(self, tabs_attr, None)
                        if tabs:
                            name_map = {
                                'requests': ('requests_tab', 'tab_requests', 'page_requests'),
                                'deliveries': ('deliveries_tab', 'tab_deliveries', 'page_deliveries'),
                                'returns': ('returns_tab', 'tab_returns', 'page_returns'),
                            }
                            target_names = name_map.get(tab_code or '', ())
                            for n in target_names:
                                w = getattr(self, n, None)
                                if w:
                                    try:
                                        tabs.setCurrentWidget(w)
                                        _dbg_nav(f"selected comm tab via {tabs_attr} -> {n}")
                                        return True, f'{tabs_attr}->{n}'
                                    except Exception:
                                        pass
                    if tab_code is None:
                        return True, 'pg_communications'
            except Exception:
                last_reason = 'error_pg_communications'

            try:
                if hasattr(self, 'pages') and hasattr(self, 'pg_trans'):
                    self.pages.setCurrentWidget(self.pg_trans)
                    base_switched = True or base_switched
                    last_reason = 'pg_trans'
                    _dbg_nav("fallback to pg_trans")
                    if hasattr(self, 'tab_widget_trans') and hasattr(self, 'prod_interface_page'):
                        try:
                            self.tab_widget_trans.setCurrentWidget(self.prod_interface_page)
                            _dbg_nav("selected prod_interface_page in tab_widget_trans")
                        except Exception:
                            pass
                    if hasattr(self, 'interface_tabs'):
                        target_attr_map = {
                            'requests': 'requests_page_tab',
                            'deliveries': 'deliveries_page_tab',
                            'returns': 'returns_page_tab'
                        }
                        target_attr = target_attr_map.get(tab_code or '', None)
                        if target_attr:
                            page_obj = getattr(self, target_attr, None)
                            if page_obj is not None:
                                try:
                                    self.interface_tabs.setCurrentWidget(page_obj)
                                    _dbg_nav(f"selected old tab via interface_tabs -> {target_attr}")
                                    return True, f'interface_tabs->{target_attr}'
                                except Exception:
                                    pass
                    if tab_code is None:
                        return True, 'pg_trans'
            except Exception:
                last_reason = 'error_pg_trans'

            if base_switched:
                return True, last_reason
            return False, last_reason

        if action_key == 'VIEW_MEMO':
            nav_ok, nav_reason = select_comm_tab(None)
            opened = False
            if hasattr(self, 'comm_page_widget') and hasattr(self.comm_page_widget, 'open_memo_from_notification'):
                try:
                    opened = self.comm_page_widget.open_memo_from_notification(action_data)
                except Exception as exc:
                    safe_toast(f'باز کردن نامه ناموفق بود: {exc}', 'error')
            if not opened:
                safe_toast('نامه داخلی برای نمایش پیدا نشد.', 'warning')
            final_ok = nav_ok or opened
            final_reason = f"nav={nav_reason};memo={'ok' if opened else 'missing'}"
            _trace_nav('ارتباط با تولید', final_ok, final_reason)
            if hasattr(self, 'notification_panel'):
                self.notification_panel.hide()
            return

        if action_key == 'VIEW_COMMUNICATIONS':
            nav_ok, nav_reason = select_comm_tab(None)
            if not nav_ok:
                safe_toast("صفحهٔ «ارتباط با تولید» در دسترس نیست.", "warning")
            _trace_nav('ارتباط با تولید', nav_ok, nav_reason)
            if hasattr(self, 'notification_panel'):
                self.notification_panel.hide()
            return

        if action_key in ('FULFILL_REQUEST', 'APPROVE_DELIVERY', 'APPROVE_RETURN'):
            tab_code = tab_code_map[action_key]
            nav_ok, nav_reason = select_comm_tab(tab_code)
            if globals().get('DEBUG_NOTIF', False) and action_key == 'FULFILL_REQUEST':
                print("[TRACE:NOTIF:click] kind=material_request route=ارتباط با تولید/requests")
            if not nav_ok:
                safe_toast("پنجره/تب مقصد برای نقش شما در دسترس نیست.", "warning")
            _trace_nav('ارتباط با تولید', nav_ok, nav_reason)
            if hasattr(self, 'notification_panel'):
                self.notification_panel.hide()
            return

        if action_key == 'APPROVE_TRANSFER':
            nav_ok, nav_reason = select_comm_tab('deliveries')
            dialog_opened = False
            if hasattr(self, '_open_approve_material_dialog'):
                try:
                    self._open_approve_material_dialog(preselect_id=action_data)
                    dialog_opened = True
                except Exception as exc:
                    safe_toast(f'باز کردن فرم دریافت مواد ناموفق بود: {exc}', 'error')
            final_ok = dialog_opened or nav_ok
            final_reason = f"nav={nav_reason};dialog={'ok' if dialog_opened else 'skip'}"
            _trace_nav('ارتباط با تولید', final_ok, final_reason)
            if not final_ok:
                safe_toast("فرم دریافت مواد در دسترس نیست.", "warning")
            if hasattr(self, 'notification_panel'):
                self.notification_panel.hide()
            return

        if action_key == 'APPROVE_VOID':
            nav_ok, nav_reason = select_comm_tab('returns')
            dialog_ok = False
            try:
                if hasattr(self, '_open_approve_void_dialog'):
                    self._open_approve_void_dialog()
                    dialog_ok = True
                else:
                    safe_toast('پنجره مدیریت ابطال در این نسخه فعال نیست.', 'warning')
            except Exception as exc:
                safe_toast(f'باز کردن مرکز ابطال ناموفق بود: {exc}', 'error')
            final_ok = dialog_ok or nav_ok
            final_reason = f"nav={nav_reason};dialog={'ok' if dialog_ok else 'skip'}"
            _trace_nav('ارتباط با تولید', final_ok, final_reason)
            if hasattr(self, 'notification_panel'):
                self.notification_panel.hide()
            return

        safe_toast("اکشن اعلان نامعتبر است یا پشتیبانی نمی‌شود.", "warning")
        if hasattr(self, 'notification_panel'):
            self.notification_panel.hide()

    def _build_inventory_page(self):
        """
        نسخه نهایی (اصلاح شده):
        - استایل تب‌ها برای حل قطعی مشکل عرض، به صورت مستقیم اعمال شده است.
        """
        layout = self.create_page_layout(self.pg_inventory, "مدیریت انبارگردانی")
        
        action_bar = QtWidgets.QHBoxLayout()
        if self.has_permission('inventory:start_count'):
            btn_start_count = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " شروع انبارگردانی جدید")
            btn_start_count.setProperty("class", "primary"); btn_start_count.setMinimumHeight(35)
            btn_start_count.clicked.connect(self._start_new_count)
            action_bar.addWidget(btn_start_count)
        
        action_bar.addStretch()
        layout.addLayout(action_bar)
        
        self.inventory_tabs = QtWidgets.QTabWidget()
        self.inventory_tabs.setObjectName("interfaceTabWidget")

        # --- اصلاح کلیدی و نهایی: استفاده از همان روش موفق صفحه تولید ---
        # یک استایل مستقیم که حداقل عرض و پدینگ مناسب را به تب‌ها می‌دهد.
        self.inventory_tabs.setStyleSheet("QTabBar::tab { min-width: 220px; padding: 10px; }")

        layout.addWidget(self.inventory_tabs, 1)

        # تب اول: شمارش‌های در حال انجام
        open_counts_page = QtWidgets.QWidget()
        open_counts_layout = QtWidgets.QVBoxLayout(open_counts_page)
        open_counts_layout.setContentsMargins(0, 10, 0, 0)
        self.tbl_open_counts = QtWidgets.QTableWidget()
        self._style_table(self.tbl_open_counts)
        self.tbl_open_counts.itemDoubleClicked.connect(self._open_count_sheet)
        open_counts_layout.addWidget(self.tbl_open_counts)
        self.inventory_tabs.addTab(open_counts_page, "شمارش‌های در حال انجام")

        # تب دوم: شمارش‌های منتظر بازبینی
        if self.has_permission('inventory:review_count'):
            review_counts_page = QtWidgets.QWidget()
            review_counts_layout = QtWidgets.QVBoxLayout(review_counts_page)
            review_counts_layout.setContentsMargins(0, 10, 0, 0)
            self.tbl_review_counts = QtWidgets.QTableWidget()
            self._style_table(self.tbl_review_counts)
            self.tbl_review_counts.itemDoubleClicked.connect(self._open_count_sheet)
            review_counts_layout.addWidget(self.tbl_review_counts)
            self.inventory_tabs.addTab(review_counts_page, "شمارش‌های منتظر بازبینی")
                                                                    
    def _open_count_sheet(self, item: QtWidgets.QTableWidgetItem):
            """
            نسخه ۲.۰ (هوشمند):
            - این متد حالا به جای یک جدول ثابت، با هر جدولی که به آن متصل شود کار می‌کند.
            - با استفاده از item.tableWidget()، منبع کلیک را تشخیص داده و اطلاعات را از آن می‌خواند.
            """
            if not item: return
            
            table = item.tableWidget() # تشخیص خودکار جدول منبع
            if not table: return

            try:
                row = item.row()
                count_id = int(table.item(row, 0).text())
                status = table.item(row, 2).text()
            except (AttributeError, ValueError, TypeError) as e:
                print(f"Could not get count details from table: {e}")
                return
            
            # بقیه منطق بدون تغییر باقی می‌ماند
            if status == 'OPEN':
                if not self.has_permission('inventory_count:perform'):
                    self.toast.show_message("شما دسترسی لازم برای انجام شمارش را ندارید.", "error")
                    return
                dlg = CountSheetDialog(self.db, self.user_id, count_id, self)
                if dlg.exec_():
                    self._load_open_counts()
                    self._load_review_counts() # ممکن است یک آیتم از باز به بازبینی برود
            
            elif status == 'REVIEW':
                if not self.has_permission('inventory_count:review'):
                    self.toast.show_message("شما دسترسی لازم برای بازبینی این سند را ندارید.", "error")
                    return
                dlg = ReviewCountDialog(self.db, self.user_id, count_id, self)
                if dlg.exec_():
                    # بعد از بازبینی، یک آیتم از لیست بازبینی حذف می‌شود
                    self._load_review_counts()
            else:
                self.toast.show_message(f"این سند در وضعیت '{status}' قرار دارد و عملیات بیشتری روی آن ممکن نیست.", "info")
                        
        
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _start_new_count(self):
        """دیالوگ شروع شمارش جدید را باز کرده و در صورت تایید، سند را در دیتابیس ایجاد می‌کند."""
        # جلوگیری از شروع شمارش جدید وقتی یک شمارش باز وجود دارد (برای آینده)
        # if self.db.has_open_count():
        #     QtWidgets.QMessageBox.warning(self, "خطا", "یک انبارگردانی باز وجود دارد. ابتدا آن را ببندید.")
        #     return

        dlg = StartCountDialog(self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            count_type, notes = dlg.get_data()
            try:
                count_id = self.db.create_new_count_session(count_type, notes, self.user_id)
                self.toast.show_message(f"✔ انبارگردانی جدید با ID={count_id} شروع شد.")
                self._load_counts_list() # رفرش کردن لیست برای نمایش سند جدید
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد سند انبارگردانی:\n{e}")
                
    def _load_open_counts(self):
            """جدول شمارش‌های باز را بارگذاری می‌کند."""
            if not hasattr(self, 'tbl_open_counts'): return
            
            table = self.tbl_open_counts
            table.setRowCount(0)
            sessions = [s for s in self.db.get_count_sessions() if s.get('status') == 'OPEN']
            
            headers = ["ID سند", "نوع شمارش", "وضعیت", "تاریخ ایجاد", "ایجاد کننده"]
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setColumnHidden(0, True)
            table.setRowCount(len(sessions))

            for r, session in enumerate(sessions):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(session['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(session.get('type', '')))
                status_item = QtWidgets.QTableWidgetItem(session.get('status', ''))
                status_item.setForeground(QtGui.QColor('#2980b9'))
                status_item.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
                table.setItem(r, 2, status_item)
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(session.get('created_at'))))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(session.get('created_by', '')))
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _load_review_counts(self):
        """جدول شمارش‌های منتظر بازبینی را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_review_counts'): return

        table = self.tbl_review_counts
        table.setRowCount(0)
        sessions = [s for s in self.db.get_count_sessions() if s.get('status') == 'REVIEW']

        headers = ["ID سند", "نوع شمارش", "وضعیت", "تاریخ ایجاد", "شمارشگر"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setColumnHidden(0, True)
        table.setRowCount(len(sessions))

        for r, session in enumerate(sessions):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(session['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(session.get('type', '')))
            status_item = QtWidgets.QTableWidgetItem(session.get('status', ''))
            status_item.setForeground(QtGui.QColor('#fd7e14')) # Orange color for review
            status_item.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
            table.setItem(r, 2, status_item)
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(session.get('created_at'))))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(session.get('created_by', '')))
            
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        
    def _create_kpi_card(self, title, value, color, icon_name):
        """یک ویجت KPI گرافیکی و قابل کلیک برای داشبورد می‌سازد."""
        card = ClickableFrame()
        card.setObjectName("kpiCard")
        
        card.setStyleSheet(f"""
            QFrame#kpiCard {{
                background-color: {color};
                border-radius: 8px;
            }}
            QFrame#kpiCard:hover {{
                background-color: {QtGui.QColor(color).lighter(115).name()};
            }}
            QFrame#kpiCard QLabel {{
                color: white;
                background-color: transparent;
                border: none;
            }}
        """)
        
        card_layout = QtWidgets.QHBoxLayout(card)
        card_layout.setContentsMargins(20, 15, 20, 15)
        card_layout.setSpacing(15)

        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(32, 32))
        
        text_layout = QtWidgets.QVBoxLayout(); text_layout.setSpacing(0)
        title_label = QtWidgets.QLabel(title); title_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        value_label = QtWidgets.QLabel(value); value_label.setFont(QFont(FONT_FAMILY, 18, QFont.Bold))
        text_layout.addWidget(title_label); text_layout.addWidget(value_label)
        
        card_layout.addLayout(text_layout, 1)
        card_layout.addWidget(icon_label)
            
        card.value_label = value_label
        return card

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _build_dashboard_page(self):
        """داشبورد را به صورت پویا بر اساس لیست داشبوردهای مجاز کاربر ایجاد می‌کند."""
        base_layout = self.create_page_layout(self.pg_dash, "داشبورد")
        
        if base_layout.count() > 2:
            item = base_layout.takeAt(2)
            if item and item.widget():
                item.widget().deleteLater()

        dashboard_keys = self.user_dashboards
        
        if self.role == 'Admin':
            dashboard_keys = ["DEFAULT", "WAREHOUSE", "PURCHASING", "CEO"]

        if not dashboard_keys:
            base_layout.addWidget(self._build_standard_user_panel())
            return
        
        if len(dashboard_keys) == 1:
            key = dashboard_keys[0]
            builder_func = getattr(self, f"_build_{key.lower()}_dashboard", self._build_standard_user_panel)
            base_layout.addWidget(builder_func())
            return

        container_widget = QtWidgets.QWidget()
        container_layout = QtWidgets.QVBoxLayout(container_widget)
        
        selector_layout = QtWidgets.QHBoxLayout()
        selector_layout.addWidget(QtWidgets.QLabel("<b>نمایش داشبورد:</b>"))
        dashboard_selector = QtWidgets.QComboBox()
        selector_layout.addWidget(dashboard_selector)
        selector_layout.addStretch()
        container_layout.addLayout(selector_layout)

        dashboard_stack = QtWidgets.QStackedWidget()
        container_layout.addWidget(dashboard_stack)
        
        DASHBOARD_NAME_MAP = {
            "DEFAULT": "پنل کاربری استاندارد",
            "WAREHOUSE": "داشبورد انبار",
            "PURCHASING": "داشبورد بازرگانی",
            "CEO": "داشبورد مدیرعامل"
        }

        for key in dashboard_keys:
            if key in DASHBOARD_NAME_MAP:
                builder_func = getattr(self, f"_build_{key.lower()}_dashboard", self._build_standard_user_panel)
                dashboard_widget = builder_func()
                dashboard_stack.addWidget(dashboard_widget)
                dashboard_selector.addItem(DASHBOARD_NAME_MAP[key], key)
            
        dashboard_selector.currentIndexChanged.connect(dashboard_stack.setCurrentIndex)
        
        # --- *** اصلاح کلیدی اینجاست *** ---
        # علاوه بر تغییر صفحه، تابع رفرش را هم فراخوانی می‌کنیم.
        dashboard_selector.currentIndexChanged.connect(self._refresh_dashboard_page)
        
        base_layout.addWidget(container_widget)
                        
        #
    def _build_admin_dashboard_container(self):
        """ویجت کانتینر ویژه داشبورد ادمین که شامل منوی جابجایی است را می‌سازد."""
        admin_dash_widget = QtWidgets.QWidget()
        admin_layout = QtWidgets.QVBoxLayout(admin_dash_widget)
        
        selector_layout = QtWidgets.QHBoxLayout()
        selector_layout.addWidget(QtWidgets.QLabel("<b>نمایش داشبورد به عنوان:</b>"))
        self.dashboard_selector = QtWidgets.QComboBox()
        selector_layout.addWidget(self.dashboard_selector)
        selector_layout.addStretch()
        admin_layout.addLayout(selector_layout)

        self.admin_dashboard_stack = QtWidgets.QStackedWidget()
        admin_layout.addWidget(self.admin_dashboard_stack)
        
        # تمام داشبوردهای موجود را می‌سازیم و به استک و کمبوباکس اضافه می‌کنیم
        dashboards = {
            "پنل کاربری استاندارد": self._build_standard_user_panel(),
            "داشبورد انبار": self._build_warehouse_dashboard(),
            "داشبورد بازرگانی": self._build_purchasing_dashboard(),
            "داشبورد مدیرعامل": self._build_ceo_dashboard(),
        }
        for name, widget in dashboards.items():
            self.admin_dashboard_stack.addWidget(widget)
            self.dashboard_selector.addItem(name)
            
        self.dashboard_selector.currentIndexChanged.connect(self.admin_dashboard_stack.setCurrentIndex)
        return admin_dash_widget
                        
            
                                            
    # BEGIN REWRITE: MainWindow._build_ceo_dashboard
    def _build_ceo_dashboard(self) -> QtWidgets.QWidget:
        """
        داشبورد مدیرعامل (V2):
        - Master/Detail با QSplitter
        - لیست فرم‌های PR در انتظار تصمیم مدیرعامل + اقلام فرم انتخاب‌شده
        - دکمهٔ ثبت نهایی تصمیمات
        - نوار ابزار بالا برای رفرش
        """
        dashboard_container = QtWidgets.QWidget()
        main_layout = QtWidgets.QVBoxLayout(dashboard_container)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)

        # — نوار ابزار بالا (Refresh)
        topbar = QtWidgets.QHBoxLayout()
        topbar.addStretch(1)
        btn_reload = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), "↻ بارگذاری فرم‌ها")
        btn_reload.setMinimumHeight(34)
        if hasattr(self, "_load_ceo_groups"):
            btn_reload.clicked.connect(self._load_ceo_groups)
        topbar.addWidget(btn_reload)
        main_layout.addLayout(topbar)

        # — Splitter عمودی
        splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)

        # --- بخش بالا: لیست فرم‌های PR در انتظار مدیرعامل
        groups_group = QtWidgets.QGroupBox("۱. فرم‌های درخواست خرید در انتظار تصمیم مدیرعامل")
        groups_layout = QtWidgets.QVBoxLayout(groups_group)

        self.tbl_ceo_groups = QtWidgets.QTableWidget()
        if hasattr(self, "_style_table"):
            self._style_table(self.tbl_ceo_groups)
        self.tbl_ceo_groups.setColumnCount(6)
        self.tbl_ceo_groups.setHorizontalHeaderLabels(["#", "کالا/عنوان", "درخواست‌دهنده", "جمع مقدار", "وضعیت PR", "وضعیت صف"])
        self.tbl_ceo_groups.horizontalHeader().setStretchLastSection(True)
        self.tbl_ceo_groups.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_ceo_groups.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tbl_ceo_groups.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl_ceo_groups.verticalHeader().setVisible(False)

        if hasattr(self, "_on_ceo_group_selected"):
            self.tbl_ceo_groups.itemSelectionChanged.connect(self._on_ceo_group_selected)

        groups_layout.addWidget(self.tbl_ceo_groups)
        splitter.addWidget(groups_group)

        # --- بخش پایین: اقلام فرم انتخاب‌شده + اقدام‌ها
        items_group = QtWidgets.QGroupBox("۲. اقلام فرم انتخاب‌شده (برای هر قلم تصمیم‌گیری کنید)")
        items_layout = QtWidgets.QVBoxLayout(items_group)

        self.tbl_ceo_items = QtWidgets.QTableWidget()
        if hasattr(self, "_style_table"):
            self._style_table(self.tbl_ceo_items)
        self.tbl_ceo_items.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_ceo_items.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.tbl_ceo_items.setEditTriggers(QtWidgets.QAbstractItemView.DoubleClicked | QtWidgets.QAbstractItemView.SelectedClicked)
        self.tbl_ceo_items.verticalHeader().setVisible(False)
        self.tbl_ceo_items.horizontalHeader().setStretchLastSection(True)
        items_layout.addWidget(self.tbl_ceo_items)

        actions_layout = QtWidgets.QHBoxLayout()
        actions_layout.addStretch(1)
        btn_finalize = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "ثبت نهایی تصمیمات برای این فرم")
        btn_finalize.setProperty("class", "primary")
        btn_finalize.setMinimumHeight(40)
        if hasattr(self, "_submit_ceo_decisions"):
            btn_finalize.clicked.connect(self._submit_ceo_decisions)
        actions_layout.addWidget(btn_finalize)
        items_layout.addLayout(actions_layout)

        splitter.addWidget(items_group)
        splitter.setSizes([260, 460])

        main_layout.addWidget(splitter)

        # بارگذاری اولیه (اگر متدش موجود است)
        try:
            if hasattr(self, "_load_ceo_groups"):
                self._load_ceo_groups()
        except Exception:
            pass

        return dashboard_container
    # END REWRITE: MainWindow._build_ceo_dashboard
    
    # این متد را در کلاس MainWindow به طور کامل جایگزین کنید
    def _reload_ceo_groups(self):
        """لیست فرم‌های (گروه‌های) PR که منتظر تایید مدیرعامل هستند را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_ceo_groups'): return
        table = self.tbl_ceo_groups
        table.setRowCount(0)
        
        try:
            # --- اصلاح کلیدی: فراخوانی متد DB با پارامتر صحیح و بدون only_mine ---
            groups = self.db.list_pr_group_headers_for_ceo(manager_id=self.user_id)
            
            headers = ['ID گروه', 'شماره فیزیکی', 'درخواست‌دهنده', 'واحد', 'تعداد اقلام', 'فوریت']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(groups))

            for r, group in enumerate(groups):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(group['grp_key'])))
                # --- اصلاح: استفاده از فیلد form_no که در کوئری شما وجود داشت ---
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(group.get('form_no', '---')))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(group.get('requester_name', '')))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(group.get('dept_name', '')))
                table.setItem(r, 4, NumericTableWidgetItem(str(group.get('items_count', 0))))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(group.get('urgency_max', '')))
            
            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ فرم جدیدی برای تایید شما وجود ندارد.")
            
            if len(groups) > 0:
                table.selectRow(0)
            else:
                if hasattr(self, 'tbl_ceo_items'): self.tbl_ceo_items.setRowCount(0)
                
        except Exception as e:
            print(f"Error loading CEO PR groups: {e}")
            # نمایش خطا به کاربر برای دیباگ بهتر
            QtWidgets.QMessageBox.critical(self, "خطا در بارگذاری گروه‌ها", str(e))
                                
# این متد را در کلاس MainWindow به طور کامل جایگزین کنید
    def _on_ceo_group_selected(self):
        """با انتخاب یک فرم، اقلام آن را در جدول پایینی بارگذاری می‌کند (نسخه نهایی و امن)."""
        print("DEBUG: _on_ceo_group_selected triggered.")
        if not hasattr(self, 'tbl_ceo_groups'): return
        
        selected_rows = self.tbl_ceo_groups.selectionModel().selectedRows()
        if not selected_rows:
            if hasattr(self, 'tbl_ceo_items'): self.tbl_ceo_items.setRowCount(0)
            print("DEBUG: No row selected.")
            return
            
        try:
            item = self.tbl_ceo_groups.item(selected_rows[0].row(), 0)
            if item and item.text() and item.text().isdigit():
                grp_key = int(item.text())
                print(f"DEBUG: Selected group key: {grp_key}")
                self._reload_ceo_group_items(grp_key)
            else:
                if hasattr(self, 'tbl_ceo_items'): self.tbl_ceo_items.setRowCount(0)
                print("DEBUG: Selected item has no valid group key.")
        except Exception as e:
            print(f"CRITICAL ERROR in _on_ceo_group_selected: {e}")
            if hasattr(self, 'tbl_ceo_items'): self.tbl_ceo_items.setRowCount(0)
        
                                
    # این متد را در کلاس MainWindow به طور کامل جایگزین کنید
    def _reload_ceo_group_items(self, group_key: int):
        """اقلام مربوط به یک گروه PR خاص را با تمام جزئیات در میزکار مدیرعامل بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_ceo_items'): return
        table = self.tbl_ceo_items
        table.setRowCount(0)

        try:
            items = self.db.list_pr_group_items_for_ceo(group_key)
            
            # --- اصلاح: افزودن ستون‌های جدید و کامل‌تر کردن هدر ---
            headers = [
                "PR ID", "تایید/رد", "نام کالا", "مقدار درخواستی", "مقدار نهایی", 
                "فوریت پیشنهادی", "فوریت نهایی", "مشخصات و یادداشت", "پیوست‌ها",
                "تایید کننده", "تاریخ و ساعت تایید" # <-- ستون‌های جدید
            ]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(items))

            for r, item in enumerate(items):
                full_name = f"{item.get('parent_name')} / {item.get('item_name')}" if item.get('parent_name') else item.get('item_name')
                
                # ستون‌های اطلاعاتی
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(full_name))
                table.setItem(r, 3, NumericTableWidgetItem(str(item['requested_qty'])))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(item.get('urgency_suggested', 'عادی')))

                # ویجت‌های تعاملی
                chk_widget = QtWidgets.QWidget(); chk_layout = QtWidgets.QHBoxLayout(chk_widget); chk_box = QtWidgets.QCheckBox(); chk_box.setChecked(True); chk_layout.addWidget(chk_box); chk_layout.setAlignment(QtCore.Qt.AlignCenter); chk_layout.setContentsMargins(0,0,0,0)
                table.setCellWidget(r, 1, chk_widget)
                
                qty_spinbox = QtWidgets.QDoubleSpinBox(); qty_spinbox.setDecimals(3); qty_spinbox.setRange(0.0, 1e12); qty_spinbox.setValue(item.get('requested_qty', 0))
                table.setCellWidget(r, 4, qty_spinbox)
                
                urgency_combo = QtWidgets.QComboBox(); urgency_combo.addItems(["-- بدون تغییر --"] + ReplenishmentDialog.URGENCY_CHOICES)
                table.setCellWidget(r, 6, urgency_combo)
                
                # مشخصات و یادداشت
                full_notes = f"مشخصات فنی:\n{item.get('specs', '-')}\n\nیادداشت درخواست‌دهنده:\n{item.get('notes', '-')}"
                notes_preview = (item.get('specs') or item.get('notes') or "")[:60] + "..."
                notes_item = QtWidgets.QTableWidgetItem(notes_preview); notes_item.setToolTip(full_notes)
                table.setItem(r, 7, notes_item)
                
                # پیوست‌ها
                attach_count = item.get('attachments_count', 0)
                btn_attach = QtWidgets.QPushButton(f"({attach_count})"); btn_attach.setIcon(QtGui.QIcon.fromTheme("mail-attachment"))
                if attach_count > 0: btn_attach.clicked.connect(partial(self._show_pr_attachments, item['id']))
                else: btn_attach.setEnabled(False)
                table.setCellWidget(r, 8, btn_attach)

                # --- ستون‌های جدید برای اطلاعات تایید ---
                table.setItem(r, 9, QtWidgets.QTableWidgetItem(item.get('approver_name', '---')))
                table.setItem(r, 10, QtWidgets.QTableWidgetItem(to_shamsi(item.get('approved_at'), include_time=True)))

            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(7, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "برای مشاهده اقلام، یک فرم را از جدول بالا انتخاب کنید.")
            
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای داخلی", f"خطا در بارگذاری اقلام فرم:\n{e}")
                                    
    # 2. این متد را به کلاس MainWindow اضافه کنید (اگر از قبل وجود ندارد)
    def _show_pr_attachments(self, pr_id: int):
        """دیالوگ نمایش پیوست‌ها را برای یک درخواست خرید مشخص باز می‌کند."""
        if not pr_id: return
        AttachmentsViewDialog(self.db, pr_id, self).exec_()
       
                    
    # BEGIN REWRITE: UI.MainWindow._submit_ceo_decisions
    def _submit_ceo_decisions(self):
        """
        ثبت نهایی تصمیمات مدیرعامل روی اقلام جدول پایین.
        نکتهٔ مهم: فراخوانی DB باید approver_id را به صورت keyword دریافت کند.
        """
        from PyQt5 import QtWidgets, QtCore

        # جدول اقلام مدیرعامل
        t = getattr(self, 'tbl_ceo_items', None)
        if t is None or t.rowCount() == 0:
            try:
                self.toast.show_message("هیچ قلمی برای پردازش در جدول وجود ندارد.", "info")
            except Exception:
                QtWidgets.QMessageBox.information(self, "اطلاعات", "هیچ قلمی برای پردازش در جدول وجود ندارد.")
            return

        # اگر Progress نمی‌خواهید، می‌توانید این بلاک را حذف کنید
        progress = QtWidgets.QProgressDialog("در حال جمع‌آوری تصمیمات...", "لغو", 0, t.rowCount(), self)
        progress.setWindowModality(QtCore.Qt.WindowModal)
        progress.setMinimumDuration(0)
        progress.setAutoClose(True)

        try:
            decisions = []
            for row in range(t.rowCount()):
                progress.setValue(row)
                QtWidgets.QApplication.processEvents(QtCore.QEventLoop.AllEvents, 25)

                # ستون‌های مورد انتظار باید روی جدول تعریف شده باشند:
                # pr_id (مخفی/نمایشی)، chk_approve (QCheckBox)، spn_new_qty (QDoubleSpinBox)، cmb_urgency (QComboBox)
                try:
                    pr_id_item = t.item(row, 0)  # فرض: ستون 0 = pr_id (یا از data(role) می‌خوانیم)
                    pr_id = int(pr_id_item.data(QtCore.Qt.UserRole) or pr_id_item.text())
                except Exception:
                    # اگر قالب ستون فرق دارد، اینجا تغییر دهید
                    continue

                # چک‌باکس تأیید
                try:
                    w_approve = t.cellWidget(row, 1)
                    approve = bool(w_approve.isChecked()) if w_approve is not None else False
                except Exception:
                    approve = False

                # مقدار نهایی (مدیرعامل می‌تواند مقدار را اصلاح کند)
                try:
                    w_qty = t.cellWidget(row, 2)
                    new_qty = float(w_qty.value()) if w_qty is not None else None
                except Exception:
                    new_qty = None

                # فوریت نهایی (ترجیحاً گزینهٔ Combo)
                try:
                    w_urg = t.cellWidget(row, 3)
                    final_urgency = w_urg.currentText() if w_urg is not None else None
                except Exception:
                    final_urgency = None

                decisions.append({
                    "pr_id": pr_id,
                    "approve": approve,
                    "new_qty": new_qty,
                    "final_urgency": final_urgency,
                    "rejection_note": "" if approve else "رد شده توسط مدیرعامل از طریق داشبورد"
                })

            if not decisions:
                try:
                    self.toast.show_message("هیچ تصمیمی برای ثبت یافت نشد.", "info")
                except Exception:
                    QtWidgets.QMessageBox.information(self, "اطلاعات", "هیچ تصمیمی برای ثبت یافت نشد.")
                return

            progress.setLabelText("در حال ثبت تصمیمات...")
            QtWidgets.QApplication.processEvents(QtCore.QEventLoop.AllEvents, 25)

            # ⛳️ نکتهٔ کلیدی: approver_id باید «کلیدواژه‌ای» ارسال شود تا تهی نشود.
            # قبلاً احتمالاً به‌صورت پوزیشنی فرستاده می‌شد و None می‌رسید.
            result = self.db.decide_ceo_approvals_bulk(decisions=decisions, approver_id=self.user_id)

            # پس از ثبت تصمیمات، ابلاغِ خودکار به بازرگانی برای اقلام تاییدشده
            try:
                approved_pr_ids = sorted({d.get('pr_id') for d in decisions if d.get('approve') and d.get('pr_id')})
                if approved_pr_ids:
                    # طبق خواستهٔ کاربر: ادامهٔ کار بعد از تغییر/تأیید اقلام، به‌صورت خودکار به بازرگانی برود
                    self.db.ensure_prs_sent_to_commerce(approved_pr_ids, user_id=self.user_id)
            except Exception as _e:
                # جریان اصلی را متوقف نکنیم؛ فقط اطلاع غیرمزاحم بدهیم
                try:
                    self.toast.show_message('ابلاغ خودکار به بازرگانی با خطا مواجه شد، اما تصمیمات ثبت شد.', 'warning')
                except Exception:
                    pass

            # خروجی مقاوم: اگر dict بود، affected را بخوان؛ اگر int بود، همان را بگیر.
            affected = result.get("affected") if isinstance(result, dict) else int(result or 0)

            try:
                self.toast.show_message(f"✔ تصمیمات شما برای {affected} قلم ثبت شد.", "success")
            except Exception:
                QtWidgets.QMessageBox.information(self, "موفق", f"تصمیمات شما برای {affected} قلم ثبت شد.")

            # رفرش‌های لازم پس از ثبت
            try:
                if hasattr(self, "_reload_ceo_groups"):
                    self._reload_ceo_groups()
            except Exception:
                pass
            try:
                if hasattr(self, "_load_sourcing_groups"):
                    self._load_sourcing_groups()
            except Exception:
                pass
            try:
                if hasattr(self, "signals") and self.signals:
                    self.signals.dataChanged.emit()
            except Exception:
                pass

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"ثبت تصمیمات با خطا مواجه شد:\n{e}")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            progress.reset()
    # END REWRITE: UI.MainWindow._submit_ceo_decisions
                                            
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_my_tasks(self, table_widget: QtWidgets.QTableWidget):
        """
        نسخه نهایی (هوشمند و داده-محور):
        کارتابل را با تمام وظایف کاربر پر کرده و جزئیات هر وظیفه را به صورت هوشمند نمایش می‌دهد.
        """
        if not table_widget: return
        table_widget.setRowCount(0)
        
        try:
            user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
            role_id = user_role_id_rec['role_id'] if user_role_id_rec else None
            if not role_id:
                set_empty_placeholder(table_widget, "نقش شما برای مشاهده کارتابل تعریف نشده است.")
                return

            tasks = self.db.get_pending_tasks_for_user_role(self.user_id, role_id)
            
            if hasattr(self, 'purch_card_tasks'):
                self.purch_card_tasks.value_label.setText(f"{len(tasks)} مورد")

            headers = ['ID', 'نوع فرآیند', 'مرحله فعلی', 'جزئیات', 'تاریخ ایجاد', 'ارجاع از طرف']
            table_widget.setColumnCount(len(headers)); table_widget.setHorizontalHeaderLabels(headers)
            table_widget.setRowCount(len(tasks))

            for r, task in enumerate(tasks):
                details_text = "جزئیات نامشخص"
                details_json = task.get('details', {})
                
                # --- *** بخش جدید و هوشمند برای نمایش جزئیات غنی *** ---
                if task['related_table_name'] == 'purchase_requests':
                    details_text = f"درخواست خرید برای «{details_json.get('item_name')}» به مقدار {details_json.get('qty')} توسط {details_json.get('requester')}"
                elif task['related_table_name'] == 'stock':
                    details_text = f"کالای «{details_json.get('item_name')}» (بچ: {details_json.get('batch_no')}) به دلیل '{details_json.get('reason')}' رد شده است."
                # ... در آینده می‌توان برای انواع دیگر نیز به اینجا اضافه کرد ...
                # --- ************************************************** ---

                item_id = QtWidgets.QTableWidgetItem(str(task['process_instance_id']))
                item_id.setData(Qt.UserRole, task)
                table_widget.setItem(r, 0, item_id)
                table_widget.setItem(r, 1, QtWidgets.QTableWidgetItem(task['workflow_name']))
                table_widget.setItem(r, 2, QtWidgets.QTableWidgetItem(task['step_name']))
                table_widget.setItem(r, 3, QtWidgets.QTableWidgetItem(details_text))
                table_widget.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(task['started_at'])))
                
                delegation_text = f"به نیابت از {task['original_approver_role']}" if task.get('is_delegated') else "مستقیم"
                table_widget.setItem(r, 5, QtWidgets.QTableWidgetItem(delegation_text))

            table_widget.setColumnHidden(0, True); table_widget.resizeColumnsToContents()
            table_widget.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table_widget, "هیچ کار جدیدی در کارتابل شما وجود ندارد.")
        except Exception as e:
            print(f"Error loading pending tasks into widget {table_widget.objectName()}: {e}")
            
                        
            

# در کلاس MainWindow، این متد را با نسخه زیر جایگزین کنید
    def _build_warehouse_dashboard(self):
        """داشبورد اختصاصی انبار را ساخته و سیگنال آن را به کنترل‌کننده متصل می‌کند."""
        if not hasattr(self, 'warehouse_dashboard_widget_instance'):
            self.warehouse_dashboard_widget_instance = WarehouseDashboardWidget(self.db, self)
            # --- *** اتصال سیگنال داشبورد به متد کنترل‌کننده در MainWindow *** ---
        return self.warehouse_dashboard_widget_instance

                        
# این سه متد جدید را به کلاس MainWindow اضافه کنید

    def _create_kpi_widget(self, title, icon_name, color):
        """یک ویجت KPI گرافیکی برای داشبورد می‌سازد."""
        widget = QtWidgets.QFrame()
        widget.setObjectName("kpiCard")
        widget.setStyleSheet(f"#kpiCard {{ background-color: {color}; border-radius: 8px; }}")
        
        layout = QtWidgets.QVBoxLayout(widget)
        layout.setContentsMargins(15, 10, 15, 10)
        
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(24, 24))
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("color: white; font-weight: bold; background: transparent;")
        
        value_label = QtWidgets.QLabel("0")
        value_label.setStyleSheet("color: white; font-size: 18pt; font-weight: bold; background: transparent;")
        
        top_layout = QtWidgets.QHBoxLayout()
        top_layout.addWidget(icon_label); top_layout.addStretch(); top_layout.addWidget(title_label)
        
        layout.addLayout(top_layout)
        layout.addWidget(value_label, 0, QtCore.Qt.AlignRight)
        
        widget.value_label = value_label
        return widget

                    
# این سه متد جدید را به کلاس MainWindow اضافه کنید

    def _create_kpi_widget(self, title, icon_name, color):
        """یک ویجت KPI گرافیکی برای داشبورد می‌سازد."""
        widget = QtWidgets.QFrame()
        widget.setObjectName("kpiCard")
        widget.setStyleSheet(f"#kpiCard {{ background-color: {color}; border-radius: 8px; }}")
        
        layout = QtWidgets.QVBoxLayout(widget)
        layout.setContentsMargins(15, 10, 15, 10)
        
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(24, 24))
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("color: white; font-weight: bold; background: transparent;")
        
        value_label = QtWidgets.QLabel("0")
        value_label.setStyleSheet("color: white; font-size: 18pt; font-weight: bold; background: transparent;")
        
        top_layout = QtWidgets.QHBoxLayout()
        top_layout.addWidget(icon_label); top_layout.addStretch(); top_layout.addWidget(title_label)
        
        layout.addLayout(top_layout)
        layout.addWidget(value_label, 0, QtCore.Qt.AlignRight)
        
        widget.value_label = value_label
        return widget
    

    # BEGIN REWRITE: MainWindow._build_standard_user_panel
    def _build_standard_user_panel(self):
        """داشبورد عملیاتی و هوشمند برای کاربر استاندارد (بدون مرکز تأمین در داشبورد)."""
        panel = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(panel)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(20)

        # — بخش ۱: کارت‌های KPI
        kpi_layout = QtWidgets.QHBoxLayout()
        self.std_card_tasks = self._create_kpi_widget("کارهای جدید", "view-process-tasks", "#3498db")
        self.std_card_memos = self._create_kpi_widget("پیام‌های خوانده نشده", "mail-mark-unread", "#1abc9c")
        kpi_layout.addWidget(self.std_card_tasks)
        kpi_layout.addWidget(self.std_card_memos)
        kpi_layout.addStretch(1)
        layout.addLayout(kpi_layout)

        # — بخش ۲: مرکز اقدامات پویا (نقش‌محور)
        self.actions_card = CardWidget("مرکز اقدامات", "system-run", "#27ae60")
        self.actions_layout = QtWidgets.QHBoxLayout()
        self.actions_card.setContentLayout(self.actions_layout)
        layout.addWidget(self.actions_card)

        def _mk_btn(icon_name: str, text: str, slot):
            btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme(icon_name), f" {text}")
            btn.setMinimumHeight(40)
            if callable(slot):
                btn.clicked.connect(slot)
            return btn

        # ⚠️ حذف شد: «مرکز تأمین هوشمند» از داشبورد (فقط باید در بخش کالاها باشد)
        # if hasattr(self, "_open_replenishment_center"): ...  ← عمداً اضافه نمی‌کنیم

        # 2.1 «پیگیری درخواست‌های من (PR)»
        if hasattr(self, "_open_my_purchase_requests"):
            self.actions_layout.addWidget(_mk_btn("view-list-details", "پیگیری درخواست‌های من (PR)", self._open_my_purchase_requests))

        # 2.2 «پیگیری درخواست‌های واحد من» — فقط برای مدیر واحد
        is_dept_manager = False
        try:
            # اگر سیستم مجوز دارید، از همین استفاده کن
            is_dept_manager = bool(self._has_permission("pr:dept:track"))
        except Exception:
            is_dept_manager = False
        if is_dept_manager:
            # متد پیشنهادی: _open_dept_purchase_requests (اگر داشتی وصل میشه؛ وگرنه پیام می‌ده)
            if hasattr(self, "_open_dept_purchase_requests"):
                self.actions_layout.addWidget(_mk_btn("system-search", "پیگیری درخواست‌های واحد من", self._open_dept_purchase_requests))
            else:
                def _warn_no_dept_tracker():
                    QtWidgets.QMessageBox.information(self, "اطلاع",
                        "ماژول «پیگیری درخواست‌های واحد» هنوز متصل نشده است.")
                self.actions_layout.addWidget(_mk_btn("system-search", "پیگیری درخواست‌های واحد من", _warn_no_dept_tracker))

        # 2.3 «مرکز تأیید PR (مدیر واحد)» — ربطی به پیگیری ندارد، اما مخصوص مدیر واحد بماند
        can_approve = False
        try:
            can_approve = bool(self._has_permission("pr:approve"))
        except Exception:
            can_approve = False
        if can_approve and hasattr(self, "_open_pr_approvals_center"):
            self.actions_layout.addWidget(_mk_btn("emblem-important", "مرکز تأیید PR (مدیر واحد)", self._open_pr_approvals_center))

        self.actions_layout.addStretch(1)

        # — بخش ۳: کارتابل وظایف
        user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
        role_id = user_role_id_rec['role_id'] if user_role_id_rec else None
        if role_id:
            self.standard_tasks_widget = TasksWidget(self.db, self.user_id, role_id, self, "آخرین وظایف شما (برای اقدام دابل کلیک کنید)")
            if hasattr(self, "_handle_task_activation"):
                self.standard_tasks_widget.task_activated.connect(self._handle_task_activation)
            layout.addWidget(self.standard_tasks_widget, 1)

        # — بخش ۴: دسترسی‌های سریع
        quick_nav_card = CardWidget("دسترسی‌های سریع", "go-jump", "#34495e")
        quick_nav_layout = QtWidgets.QHBoxLayout()

        btn_kanban = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-kanban"), " مدیر وظایف شخصی (کانبان)")
        btn_kanban.setMinimumHeight(40)
        if hasattr(self, "pages") and hasattr(self, "pg_kanban"):
            btn_kanban.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_kanban))

        btn_comms = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-message-new"), " مرکز ارتباطات")
        btn_comms.setMinimumHeight(40)
        if hasattr(self, "pages") and hasattr(self, "pg_communications"):
            btn_comms.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_communications))

        btn_tracker = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), " ردیاب فرآیند")
        btn_tracker.setMinimumHeight(40)
        if hasattr(self, "pages") and hasattr(self, "pg_tracker"):
            btn_tracker.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_tracker))

        for btn in (btn_kanban, btn_comms, btn_tracker):
            quick_nav_layout.addWidget(btn)

        quick_nav_card.setContentLayout(quick_nav_layout)
        layout.addWidget(quick_nav_card)

        return panel
    # END REWRITE: MainWindow._build_standard_user_panel
    
    def _handle_task_activation(self, task_data: dict):
        """
        نسخه نهایی (V3):
        - پشتیبانی از تسک‌های purchase_request_groups و purchase_requests
        - اتصال مستقیم به دیالوگ تایید مدیر واحد (بدون وابستگی به workflow)
        - تغییر کم‌خطر و قابل برگشت؛ رفتار بیرونی حفظ می‌شود.
        """
        from PyQt5 import QtWidgets

        # 1) حالت موجود: تسک روی گروه فرم است
        if task_data.get('related_table_name') == 'purchase_request_groups':
            group_id = task_data.get('related_record_id')
            dlg = DeptHeadApprovalDialog(self.db, int(group_id), self)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                outcome = dlg.get_outcome()
                try:
                    if outcome == "APPROVED":
                        self.db.approve_pr_group_by_dept_head(int(group_id), self.user_id)
                        if hasattr(self, "toast"): self.toast.show_message("✔ فرم تایید و برای مدیرعامل ارسال شد.", "success")
                    elif outcome == "REJECTED":
                        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد فرم", "لطفاً دلیل رد کردن کل فرم را وارد کنید:")
                        if ok and reason:
                            self.db.reject_pr_group_by_dept_head(int(group_id), self.user_id, reason)
                            if hasattr(self, "toast"): self.toast.show_message("✖ فرم رد شد و به درخواست‌دهنده بازگشت.", "info")
                        else:
                            if hasattr(self, "toast"): self.toast.show_message("عملیات رد کردن لغو شد.", "warning")
                    if hasattr(self, "refresh_all"): self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند با خطا مواجه شد:\n{e}")
            return

        # 2) حالت جدید: تسک روی یک PR تکی است → group_id را پیدا کن و همان مسیر را برو
        if task_data.get('related_table_name') == 'purchase_requests':
            try:
                pr_id = int(task_data.get('related_record_id') or 0)
            except Exception:
                pr_id = 0
            if not pr_id:
                QtWidgets.QMessageBox.warning(self, "شناسه نامعتبر", "شناسه درخواست خرید نامعتبر است.")
                return

            # ابتدا از جزئیات خود تسک تلاش می‌کنیم
            details = task_data.get('details') or {}
            group_id = details.get('group_key') or details.get('group_id')

            # اگر نبود، از DB اسنپ‌شات گروه را می‌گیریم
            if not group_id and hasattr(self.db, "get_pr_group_snapshot"):
                snap = self.db.get_pr_group_snapshot(pr_id)
                group_id = (snap or {}).get('group_id')

            if not group_id:
                QtWidgets.QMessageBox.information(self, "اطلاع", "برای این ردیف، فرم گروهی پیدا نشد.")
                return

            dlg = DeptHeadApprovalDialog(self.db, int(group_id), self)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                outcome = dlg.get_outcome()
                try:
                    if outcome == "APPROVED":
                        self.db.approve_pr_group_by_dept_head(int(group_id), self.user_id)
                        if hasattr(self, "toast"): self.toast.show_message("✔ فرم تایید و برای مدیرعامل ارسال شد.", "success")
                    elif outcome == "REJECTED":
                        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد فرم", "لطفاً دلیل رد کردن کل فرم را وارد کنید:")
                        if ok and reason:
                            self.db.reject_pr_group_by_dept_head(int(group_id), self.user_id, reason)
                            if hasattr(self, "toast"): self.toast.show_message("✖ فرم رد شد و به درخواست‌دهنده بازگشت.", "info")
                        else:
                            if hasattr(self, "toast"): self.toast.show_message("عملیات رد کردن لغو شد.", "warning")
                    if hasattr(self, "refresh_all"): self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند با خطا مواجه شد:\n{e}")
            return

        # 3) سایر تسک‌ها → روال عمومی قبلی
        if hasattr(self, "_process_task_action_from_data"):
            self._process_task_action_from_data(task_data)
        elif hasattr(self, "_process_task_action"):
            self._process_task_action()  # امضای قدیمی؛ بدون آرگومان

                            
    def _build_kanban_page(self):
        """صفحه اختصاصی و تمام-صفحه مدیر وظایف کانبان را می‌سازد."""
        layout = self.create_page_layout(self.pg_kanban, "مدیر وظایف من (کانبان)", show_back_button=True)
        
        user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
        role_id = user_role_id_rec['role_id'] if user_role_id_rec else None
        
        if role_id:
            self.kanban_board_page_widget = KanbanBoardWidget(self.db, self.user_id, role_id, self)
            layout.addWidget(self.kanban_board_page_widget)
        else:
            layout.addWidget(QtWidgets.QLabel("نقش شما برای مشاهده وظایف تعریف نشده است."))
            
                            
    def _open_memo_dialog(self):
        """دیالوگ نوشتن نامه جدید را باز می‌کند."""
        dlg = MemoDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    self.db.create_memo(self.user_id, data['subject'], data['body'], data['to_user_ids'], data['cc_user_ids'])
                    self.toast.show_message("✔ نامه با موفقیت ارسال شد.", "success")
                    if hasattr(self, 'comm_widget'): # رفرش کردن ویجت ارتباطات
                        self.comm_widget.refresh_sent()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ارسال نامه:\n{e}")

    
# این متد کاملا جدید را به کلاس MainWindow اضافه کنید
    def _initiate_pr_from_internal_request(self):
        """
        گردش کار ایجاد درخواست خرید توسط انباردار برای یک درخواست داخلی ناموجود را مدیریت می‌کند.
        """
        # این متد باید از داخل کارتابل انباردار فراخوانی شود
        # ما در اینجا فرض می‌کنیم که یک جدول به نام self.tbl_internal_requests در کارتابل انباردار وجود دارد
        table = self.tbl_internal_requests # شما باید این را به نام واقعی جدول در UI خود تغییر دهید
        selected_rows = table.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست نیازمند تامین را انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        status = table.item(row, table.columnCount() - 1).text() # فرض می‌کنیم وضعیت آخرین ستون است
        
        if status != TransactionStatus.IR_PENDING_PURCHASE.value:
            self.toast.show_message("این عملیات فقط برای درخواست‌های 'نیازمند تامین کالا' مجاز است.", "info")
            return

        try:
            item_id = int(table.item(row, 0).data(Qt.UserRole)['item_id']) # خواندن داده از آیتم جدول
            item_name = table.item(row, 1).text()
            quantity = float(table.item(row, 2).text())
            original_request_id = int(table.item(row, 0).text())
        except (AttributeError, ValueError, KeyError):
            self.toast.show_message("اطلاعات ردیف انتخاب شده معتبر نیست.", "error")
            return

        # باز کردن دیالوگ آشنای مرکز تامین کالا با کالای از پیش انتخاب شده
        self._open_replenishment_center(preselected_item_id=item_id)
        
        # در آینده می‌توان پس از ایجاد موفقیت‌آمیز PR، وضعیت درخواست داخلی اصلی را به "در حال تامین" تغییر داد.
                
                                                    
            

        
        # اتصال سیگنال دیالوگ به یک تابع کنترلر
        def on_trans_created(trans_data):
            try:
                # ابتدا تراکنش خروج را ثبت می‌کنیم
                trans_id = self.db.add_trans_extended(trans_data, self.user_id)
                # سپس وضعیت درخواست داخلی را آپدیت می‌کنیم
                self.db.fulfill_internal_request(req_data['id'], trans_id, self.user_id)
                self.toast.show_message("✔ کالا با موفقیت تحویل و از انبار خارج شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند با خطا مواجه شد:\n{e}")

        dlg.transaction_data_ready.connect(on_trans_created)
        dlg.exec_()
                                        
    # این متد را در کلاس MainWindow جایگزین کنید
    def _build_purchasing_dashboard(self):
        """داشبورد اختصاصی بازرگانی را ایجاد می‌کند."""
        panel = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(panel)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)

        kpi_layout = QtWidgets.QHBoxLayout()
        kpi_layout.setSpacing(20)

        # --- اصلاح کلیدی در دو خط زیر انجام شده است ---
        self.purch_card_tasks = self._create_kpi_card("کارهای منتظر اقدام", "0", "#3498db", "view-process-tasks")
        self.purch_card_suppliers = self._create_kpi_card("تامین‌کنندگان فعال", "0", "#1abc9c", "system-users")

        kpi_layout.addWidget(self.purch_card_tasks)
        kpi_layout.addWidget(self.purch_card_suppliers)
        kpi_layout.addStretch()
        layout.addLayout(kpi_layout)

        tasks_group = QtWidgets.QGroupBox("کارتابل وظایف من (برای اقدام دابل کلیک کنید)")
        tasks_layout = QtWidgets.QVBoxLayout(tasks_group)
        self.purchasing_tasks_table = QtWidgets.QTableWidget()
        self._style_table(self.purchasing_tasks_table)
        self.purchasing_tasks_table.itemDoubleClicked.connect(self._process_task_action)
        tasks_layout.addWidget(self.purchasing_tasks_table)
        layout.addWidget(tasks_group, 1)
        return panel
    

        
        
    def _refresh_dashboard(self):
        # اطمینان از وجود ویجت‌ها قبل از استفاده
        if not hasattr(self, 'card_total_items'):
            return

        # --- بخش اول: آمار تعدادی برای کارت‌های KPI (کد اصلی شما، بدون تغییر) ---
        cnt, _ = self.db.stats()
        low_items = self.db.min_alert()
        exp_items = self.db.exp_alert()

        self.card_total_items.value_label.setText(str(cnt))
        self.card_shortage.value_label.setText(f"{len(low_items)} مورد")
        self.card_expiring.value_label.setText(f"{len(exp_items)} مورد")

        # --- بخش دوم: آمار ارزش ریالی برای نمودار دایره‌ای (کد اصلی شما، بدون تغییر) ---
        value_stats = self.db.get_category_value_stats()
        cats_for_pie = [(c['category'], c['total_value']) for c in value_stats if c.get('total_value') and c['total_value'] > 0]
        
        # پاک کردن ویجت‌های قبلی
        while self.pie_frame_layout.count():
            child = self.pie_frame_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        if cats_for_pie:
            pie_chart = Pie(cats_for_pie, self._goto_cat)
            self.pie_frame_layout.addWidget(pie_chart)
        else:
            no_data_label = QtWidgets.QLabel("ارزش ریالی برای نمایش در نمودار ثبت نشده است.")
            no_data_label.setAlignment(Qt.AlignCenter)
            no_data_label.setWordWrap(True)
            self.pie_frame_layout.addWidget(no_data_label)
        
        # --- بخش سوم و کلیدی: به‌روزرسانی هوشمند جدول آخرین تراکنش‌ها ---
        # ۱. خواندن آخرین ID پاکسازی شده از تنظیمات دیتابیس
        last_id = self.db.get_setting('last_cleared_trans_id', '0')
        
        # ۲. رفرش کردن جدول با استفاده از این ID
        # متد refresh در PinnedTable حالا یک ورودی قبول می‌کند
        self.pinned_table.refresh(since_id=int(last_id))
        
    # این متد جدید را به کلاس MainWindow اضافه کنید

    # <<< FIX
    def _clear_dashboard_transactions(self):
        """آخرین ID تراکنش را در تنظیمات ذخیره می‌کند تا داشبورد پاک شود."""
        max_id = 0
        # به‌جای self.db._conn از تراکنشِ یک‌دست‌شده استفاده می‌کنیم
        with self.db.transaction() as cur:
            # اسم ستون رو واضح گذاشتم تا با Cursor دیکشنری‌محور سازگار باشه
            cur.execute("SELECT MAX(id) AS max_id FROM trans")
            row = cur.fetchone()
            if row and row.get('max_id') is not None:
                max_id = row['max_id']

        self.db.set_setting('last_cleared_trans_id', str(max_id))
        self._refresh_dashboard()
        self.toast.show_message("✔ لیست تراکنش‌های داشبورد پاکسازی شد.")
        
                
    def _logout(self):
        """برای خروج از حساب کاربری و بازگشت به صفحه لاگین"""
        self.restart_on_close = True # یک فلگ برای حلقه main
        self.close()
            
    # این دو متد جدید را به انتهای کلاس MainWindow اضافه کنید

    def _show_shortage_items(self):
        """کاربر را به صفحه کالاها برده و فیلتر کمبود موجودی را به صورت امن اعمال می‌کند."""
        # --- اصلاح کلیدی: بررسی وجود جدول قبل از هر اقدامی ---
        if not hasattr(self, 'tbl_items'):
            self.toast.show_message("شما به صفحه مدیریت کالاها دسترسی ندارید.", "error")
            return
            
        self.pages.setCurrentWidget(self.pg_items)
        # تاخیر کوچک برای اطمینان از نمایش کامل صفحه قبل از اعمال فیلتر
        QtCore.QTimer.singleShot(50, self._filter_for_shortage)

# در کلاس MainWindow، این متد را جایگزین کنید

    def _show_expiring_items(self):
        """یک دیالوگ برای نمایش لیست کامل کالاهای در شرف انقضا باز می‌کند."""
        expiring_items = self.db.exp_alert() # مقدار پیش‌فرض روز از دیتابیس خوانده می‌شود
        if not expiring_items:
            self.toast.show_message("هیچ کالایی در شرف انقضا یافت نشد.", "info")
            return

        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("کالاهای در شرف انقضا")
        dlg.setMinimumWidth(400)
        
        layout = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(expiring_items), 3)
        table.setHorizontalHeaderLabels(['نام کالا', 'شماره بچ', 'تاریخ انقضا'])
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
        for r, item in enumerate(expiring_items):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(item['name']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['batch_no']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(item['expiry_date'])))
        
        layout.addWidget(table)
        dlg.exec_()
                
# در کلاس MainWindow، این متد را جایگزین کنید

    def _filter_for_shortage(self):
        """منطق اصلی فیلتر کردن کالاهای نیازمند سفارش در نمای درختی."""
        # --- اصلاح کلیدی: پیدا کردن درخت فعال در تب فعلی ---
        if not hasattr(self, 'items_category_tabs'): return
        active_tree = self.items_category_tabs.currentWidget()
        if not isinstance(active_tree, QtWidgets.QTreeWidget): return

        # پیدا کردن ایندکس ستون‌ها از روی هدر
        headers = [active_tree.headerItem().text(i) for i in range(active_tree.columnCount())]
        try:
            qty_col_idx = headers.index('مقدار موجودی')
            min_col_idx = headers.index('حد سفارش')
        except ValueError:
            print("خطای برنامه‌نویسی: ستون‌های مورد نیاز در درخت کالاها یافت نشد.")
            return

        # پیمایش تمام آیتم‌ها در درخت (شامل فرزندان)
        iterator = QtWidgets.QTreeWidgetItemIterator(active_tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            try:
                # فقط آیتم‌هایی که داده کالا دارند را بررسی کن (نه آیتم‌های دسته‌بندی)
                item_data = item.data(0, Qt.UserRole)
                if isinstance(item_data, dict):
                    qty_text = item.text(qty_col_idx)
                    min_text = item.text(min_col_idx)
                    
                    is_short = float(qty_text) < float(min_text) and float(min_text) > 0
                    item.setHidden(not is_short)
                else:
                    # اگر آیتم والد (دسته‌بندی) بود، فعلا مخفی کن
                    item.setHidden(True)
            except (ValueError, AttributeError):
                item.setHidden(True)
            iterator += 1
        
        # نمایش مجدد آیتم‌های والدی که فرزندان قابل نمایش دارند
        root = active_tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            has_visible_child = False
            for j in range(parent_item.childCount()):
                if not parent_item.child(j).isHidden():
                    has_visible_child = True
                    break
            parent_item.setHidden(not has_visible_child)        
                    
    def _filter_for_expiring(self):
        """منطق اصلی فیلتر کردن کالاهای در شرف انقضا."""
        # در طراحی جدید، ستون تاریخ انقضا در نمای اصلی نیست.
        # پس ما باید لیست نام‌ها را از دیتابیس بگیریم و با ستون نام کالا مقایسه کنیم.
        expiring_names = self.db.exp_alert(days=30)
        if not expiring_names:
            QtWidgets.QMessageBox.information(self, "وضعیت", "هیچ کالایی در شرف انقضا (۳۰ روز آینده) یافت نشد.")
            return

        headers = [self.tbl_items.horizontalHeaderItem(i).text() for i in range(self.tbl_items.columnCount())]
        try:
            # پیدا کردن داینامیک ایندکس ستون 'نام کالا'
            name_col_idx = headers.index('نام کالا')
        except ValueError:
            print("خطای برنامه‌نویسی: ستون 'نام کالا' در جدول کالاها یافت نشد.")
            return
            
        for r in range(self.tbl_items.rowCount()):
            name_item = self.tbl_items.item(r, name_col_idx)
            if name_item and name_item.text() in expiring_names:
                self.tbl_items.setRowHidden(r, False)
            else:
                self.tbl_items.setRowHidden(r, True)# در کلاس MainWindow

# در کلاس MainWindow، این متد جدید را اضافه کنید
    def _show_asset_history(self, item: QtWidgets.QTreeWidgetItem):
        """با دابل کلیک روی یک دارایی، دیالوگ تاریخچه آن را نمایش می‌دهد."""
        if not item or item.parent() is None: # فقط روی آیتم‌های فرزند (خود دارایی) کار کند
            return
            
        try:
            # استخراج کد دارایی از متن آیتم
            asset_code_name = item.text(0).strip()
            asset_code = asset_code_name.split('(')[-1].replace(')', '').strip()
            
            # پیدا کردن اطلاعات کامل دارایی از دیتابیس
            asset_data = self.db.execute_query("SELECT * FROM assets WHERE code = %s", (asset_code,), fetch_one=True)
            if not asset_data:
                self.toast.show_message("اطلاعات دارایی یافت نشد.", "error")
                return

            # باز کردن دیالوگ جدید
            AssetHistoryDialog(self.db, asset_data['id'], asset_data['name'], self).exec_()

        except (IndexError, AttributeError) as e:
            print(f"Could not parse asset info from tree item: {e}")

# این سه متد را جایگزین متد _build_items_page قبلی کنید

    def _build_items_page(self):
        """
        متد اصلی و بازنویسی شده: مسئولیت اصلی آن فقط ساخت TabWidget و افزودن پنل‌هاست.
        """
        page_layout = self.create_page_layout(self.pg_items, "کالاها و دارایی‌ها")

        main_tab_widget = QtWidgets.QTabWidget()
        main_tab_widget.setObjectName("itemsAssetsTabs")
        main_tab_widget.setStyleSheet("QTabBar::tab { min-width: 150px; padding: 10px; }")
        
        # ساخت پنل‌ها با استفاده از متدهای کمکی جدید
        items_panel = self._build_items_panel()
        assets_panel = self._build_assets_panel()
        
        main_tab_widget.addTab(items_panel, "مدیریت کالاها")
        main_tab_widget.addTab(assets_panel, "مدیریت دارایی‌ها")
        
        page_layout.addWidget(main_tab_widget, 1)

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_items_panel(self) -> QtWidgets.QWidget:
        """
        (نسخه نهایی و بازنویسی شده)
        - پنل کامل مدیریت کالاها را با منطق فیلتر داخلی و قابل اعتماد ایجاد می‌کند.
        """
        items_panel_widget = QtWidgets.QWidget()
        items_panel_layout = QtWidgets.QHBoxLayout(items_panel_widget)
        items_panel_layout.setContentsMargins(0, 10, 0, 0)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        items_panel_layout.addWidget(splitter)

        def _filter_current_tree(text: str):
            try:
                if not hasattr(self, 'items_category_tabs'): return
                active_tab_widget = self.items_category_tabs.currentWidget()
                if not active_tab_widget: return
                tree = active_tab_widget.findChild(QtWidgets.QTreeWidget)
                if not tree: return

                search_text = text.strip().lower()
                
                iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
                while iterator.value():
                    item = iterator.value()
                    item.setHidden(True)
                    iterator += 1

                if not search_text:
                    iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
                    while iterator.value():
                        iterator.value().setHidden(False)
                        iterator += 1
                    return

                matching_items = tree.findItems(search_text, QtCore.Qt.MatchContains | QtCore.Qt.MatchRecursive, 0)
                
                for item in matching_items:
                    item.setHidden(False)
                    parent = item.parent()
                    if parent:
                        parent.setHidden(False)

            except Exception as e:
                print(f"Error during filter: {e}")

        self.details_panel = QtWidgets.QFrame(); self.details_panel.setFrameShape(QtWidgets.QFrame.StyledPanel); self.details_panel.setFixedWidth(320); self.details_panel_layout = QtWidgets.QVBoxLayout(self.details_panel); self.details_panel_layout.setContentsMargins(0, 0, 0, 0); self.details_stack = QtWidgets.QStackedWidget(); self.details_panel_layout.addWidget(self.details_stack); self.details_placeholder = QtWidgets.QLabel("برای مشاهده جزئیات کامل،\nیک کالا را از لیست انتخاب کنید."); self.details_placeholder.setAlignment(Qt.AlignCenter); self.details_placeholder.setStyleSheet("color: #7f8c8d; font-style: italic; margin: 20px;"); self.details_stack.addWidget(self.details_placeholder); self.details_container = QtWidgets.QWidget(); details_container_layout = QtWidgets.QVBoxLayout(self.details_container); details_container_layout.setContentsMargins(0, 0, 0, 0); details_container_layout.setSpacing(0); self.details_stack.addWidget(self.details_container); scroll_area = QtWidgets.QScrollArea(); scroll_area.setWidgetResizable(True); scroll_area.setStyleSheet("QScrollArea { border: none; background: transparent; }"); self.details_form_widget = QtWidgets.QWidget(); self.details_form_layout = QtWidgets.QFormLayout(self.details_form_widget); self.details_form_layout.setSpacing(12); self.details_form_layout.setContentsMargins(15, 15, 15, 15); scroll_area.setWidget(self.details_form_widget); details_container_layout.addWidget(scroll_area, 1); self.action_bar = QtWidgets.QFrame(); self.action_bar.setObjectName("actionBar"); self.action_bar.setStyleSheet("#actionBar { border-top: 1px solid #dfe6e9; padding-top: 10px; }"); self.action_bar.setFixedHeight(60); self.action_bar_layout = QtWidgets.QHBoxLayout(self.action_bar); self.action_bar_layout.setContentsMargins(15, 0, 15, 10); self.action_bar_layout.setSpacing(8); details_container_layout.addWidget(self.action_bar);

        table_container = QtWidgets.QWidget()
        table_layout = QtWidgets.QVBoxLayout(table_container)
        table_layout.setContentsMargins(0,0,0,0)
        items_toolbar_layout = QtWidgets.QHBoxLayout()
        if self.has_permission('items:create'):
            btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن کالای جدید"); btn_add.setProperty("class", "primary"); btn_add.setMinimumHeight(35); btn_add.clicked.connect(self._add_item); items_toolbar_layout.addWidget(btn_add)
        if self.has_permission('warehouse:fulfill_request'):
            btn_replenish = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-process-tasks"), " مرکز تامین کالا"); btn_replenish.setMinimumHeight(35); btn_replenish.clicked.connect(self._open_replenishment_center); items_toolbar_layout.addWidget(btn_replenish)
       #btn_fefo_report = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-sort-ascending"), " گزارش FEFO"); btn_fefo_report.setMinimumHeight(35); btn_fefo_report.clicked.connect(lambda: FefoReportDialog(self.db, self).exec_()); items_toolbar_layout.addWidget(btn_fefo_report)
        items_toolbar_layout.addSpacing(20)
        
        self.search_items = QtWidgets.QLineEdit(placeholderText="جستجوی سریع در تب فعلی..."); self.search_items.setMinimumHeight(35)
        self.search_items.textChanged.connect(_filter_current_tree)
        items_toolbar_layout.addWidget(self.search_items, 1); items_toolbar_layout.addStretch();
        
        if self.has_permission('items:recalc_minmax'):
            btn_recalc = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), " بازمحاسبه Min/Max"); btn_recalc.setMinimumHeight(35); btn_recalc.clicked.connect(self._recalc_minmax); items_toolbar_layout.addWidget(btn_recalc)
        table_layout.addLayout(items_toolbar_layout)

        self.items_category_tabs = QtWidgets.QTabWidget(); self.items_category_tabs.setObjectName("interfaceTabWidget")
        table_layout.addWidget(self.items_category_tabs)

        self.pagination_controls = {}
        self.item_page_state = {}
        self.item_trees = {}
        self.ITEMS_PER_PAGE = 50
        
        # --- *** اصلاح کلیدی: افزودن "محصول فله" به لیست تب‌ها *** ---
        categories_to_display = [CATEGORY_FINAL_PRODUCT, CATEGORY_BULK_PRODUCT, CATEGORY_RAW_MATERIAL, CATEGORY_PACKAGING, CATEGORY_CONSUMABLES]

        for fa_name in categories_to_display:
            page_widget = QtWidgets.QWidget()
            page_layout_inner = QtWidgets.QVBoxLayout(page_widget)
            page_layout_inner.setContentsMargins(0, 0, 0, 0)
            tree = QtWidgets.QTreeWidget()
            tree.setObjectName(fa_name) 
            self._style_tree(tree)
            tree.itemClicked.connect(self._show_item_details_panel)
            tree.setContextMenuPolicy(Qt.CustomContextMenu)
            tree.customContextMenuRequested.connect(self._show_items_table_context_menu)
            pagination_widget, controls = self._create_pagination_controls(fa_name)
            self.pagination_controls[fa_name] = controls
            page_layout_inner.addWidget(tree, 1)
            page_layout_inner.addWidget(pagination_widget)
            self.items_category_tabs.addTab(page_widget, fa_name)
            self.item_trees[fa_name] = tree

        self.items_category_tabs.currentChanged.connect(self._on_items_tab_changed)
        
        splitter.addWidget(self.details_panel); splitter.addWidget(table_container); splitter.setSizes([320, 700])
        return items_panel_widget
    
    
    def _build_assets_panel(self) -> QtWidgets.QWidget:
        """(متد کمکی جدید) پنل کامل مدیریت دارایی‌ها را ایجاد کرده و برمی‌گرداند."""
        assets_page_widget = QtWidgets.QWidget()
        assets_layout = QtWidgets.QVBoxLayout(assets_page_widget); assets_layout.setContentsMargins(0, 10, 0, 0); assets_toolbar = QtWidgets.QHBoxLayout();
        if self.has_permission('assets:create'):
            btn_add_asset = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " تعریف دارایی"); btn_add_asset.setProperty("class", "primary"); btn_add_asset.setMinimumHeight(35); btn_add_asset.clicked.connect(self._add_new_asset_action); assets_toolbar.addWidget(btn_add_asset)
        if self.has_permission('assets:edit'):
            btn_edit_asset = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), " ویرایش دارایی"); btn_edit_asset.setMinimumHeight(35); btn_edit_asset.clicked.connect(self._edit_asset_action); assets_toolbar.addWidget(btn_edit_asset)
        assets_toolbar.addStretch(); view_mode_group = QtWidgets.QGroupBox("نمایش بر اساس:"); view_mode_layout = QtWidgets.QHBoxLayout(view_mode_group); self.asset_view_by_status = QtWidgets.QRadioButton("وضعیت"); self.asset_view_by_employee = QtWidgets.QRadioButton("پرسنل"); self.asset_view_by_status.setChecked(True); view_mode_layout.addWidget(self.asset_view_by_status); view_mode_layout.addWidget(self.asset_view_by_employee); assets_toolbar.addWidget(view_mode_group); assets_layout.addLayout(assets_toolbar)
        
        self.tbl_assets = QtWidgets.QTreeWidget()
        self._style_tree(self.tbl_assets)
        self.tbl_assets.itemDoubleClicked.connect(self._show_asset_history)
        self.tbl_assets.setHeaderLabels(['کد / نام دارایی', 'برند', 'مدل', 'ارزش ریالی'])
        self.tbl_assets.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, 4): self.tbl_assets.header().setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        
        assets_layout.addWidget(self.tbl_assets)
        self.asset_view_by_status.toggled.connect(self._load_assets_table)
        return assets_page_widget
    
    # این متد را در کلاس MainWindow جایگزین کنید
    def _refresh_purchasing_page(self):
        """داده‌های تب فعال در صفحه بازرگانی را رفرش می‌کند."""
        if not hasattr(self, 'purchasing_tabs'): return
        
        current_tab_index = self.purchasing_tabs.currentIndex()
        
        if current_tab_index == 0: # میزکار بازرگانی
            if hasattr(self, 'purchasing_workbench_widget'):
                self.purchasing_workbench_widget.refresh_active_tab()
        elif current_tab_index == 1: # تاریخچه سفارشات
            if hasattr(self, '_load_purchase_orders'):
                self._load_purchase_orders()
        elif current_tab_index == 2: # ارزیابی تامین‌کنندگان
            if hasattr(self, '_load_supplier_performance'):
                self._load_supplier_performance()
                                    
    def _on_page_changed(self, index):
        """با تغییر صفحه، محتوای آن را رفرش می‌کند (نسخه نهایی و کامل)."""
        page = self.pages.widget(index)
        button_to_activate = self.page_map.get(page)
        if button_to_activate: self._update_sidebar_style(button_to_activate)

        if hasattr(self, '_update_notification_count'):
            self._update_notification_count()

        if page == self.pg_dash:
            if hasattr(self, '_refresh_dashboard_page'): self._refresh_dashboard_page()
        elif page == self.pg_items:
            self._on_items_tab_changed(self.items_category_tabs.currentIndex())
            if hasattr(self, '_load_assets_table'): self._load_assets_table()
        elif page == self.pg_trans:
            if hasattr(self, '_load_trans'): self._load_trans()
        elif page == self.pg_prod:
            if hasattr(self, '_refresh_production_page_data'): self._refresh_production_page_data()
        elif page == self.pg_inventory:
            if hasattr(self, '_load_open_counts'): self._load_open_counts()
            if hasattr(self, '_load_review_counts'): self._load_review_counts()
        elif page == self.pg_purchasing:
            if hasattr(self, '_refresh_purchasing_page'): self._refresh_purchasing_page()
        elif page == self.pg_qc:
            if hasattr(self, '_refresh_qc_page'): self._refresh_qc_page()
        elif page == self.pg_sales:
            # --- **اصلاح کلیدی: تضمین ساخته شدن صفحه قبل از رفرش** ---
            if self.pg_sales.layout() is None or not self.pg_sales.layout().count():
                self._build_sales_page()
            self._on_sales_tab_changed()
        elif page == self.pg_kanban:
            if hasattr(self, 'kanban_board_page_widget'): self.kanban_board_page_widget.refresh_board()
        elif page == self.pg_communications:
            if hasattr(self, 'comm_page_widget'): self.comm_page_widget.refresh_inbox(); self.comm_page_widget.refresh_sent()
        elif page == self.pg_tracker:
            if hasattr(self, 'tracker_page_widget'): self.tracker_page_widget.refresh_history()
    
        
    def _on_items_tab_changed(self, index):
        """اسلات صحیح برای سیگنال currentChanged که index را دریافت می‌کند."""
        if not hasattr(self, 'items_category_tabs') or index == -1: return
        
        category_fa_name = self.items_category_tabs.tabText(index)
        if not category_fa_name: return

        self._load_items_for_page(category_fa_name)

    def _load_items_for_page(self, category_fa_name: str):
        """داده‌های یک صفحه مشخص از یک دسته را خوانده و جدول را پر می‌کند."""
        if category_fa_name not in self.item_page_state:
            total_items = self.db.get_items_count_by_category(category_fa_name)
            total_pages = (total_items + self.ITEMS_PER_PAGE - 1) // self.ITEMS_PER_PAGE if self.ITEMS_PER_PAGE > 0 else 0
            self.item_page_state[category_fa_name] = {'current_page': 1, 'total_pages': total_pages, 'total_items': total_items}
        
        state = self.item_page_state[category_fa_name]
        offset = (state['current_page'] - 1) * self.ITEMS_PER_PAGE
        
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            items_for_page = self.db.items_brief(category_fa_name, self.ITEMS_PER_PAGE, offset)
            self._populate_item_tree(self.item_trees[category_fa_name], items_for_page)
            self._update_pagination_ui(category_fa_name)
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()

# در کلاس MainWindow، این متد را جایگزین کنید

    # BEGIN REWRITE: MainWindow._populate_item_tree
    def _populate_item_tree(self, tree: QtWidgets.QTreeWidget, items: list):
        """یک ویجت درختی مشخص را با لیست کالاهای داده‌شده پر می‌کند (بدون گیرکردن زیرِ لیبلِ 'لیست خالی')."""
        # 0) آماده‌سازی انتخاب‌پذیری ردیف‌ها
        tree.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tree.setSortingEnabled(False)

        # 1) پاک‌سازی محتوا
        tree.clear()

        # 2) اگر قبلاً لیبلِ جایگزین ساخته شده، همین اول پنهانش کن تا روی آیتم‌های جدید نیفته
        if hasattr(tree, "_empty_lbl"):
            try:
                tree._empty_lbl.hide()
            except Exception:
                pass

        # 3) هدرها را هر بار صریح تنظیم کن (بعد از clear لازم است)
        headers = ['کالا (پک/محصول مادر)', 'دسته', 'مقدار موجودی', 'واحد', 'حد سفارش', 'ID']
        tree.setHeaderLabels(headers)
        header = tree.header()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, len(headers)):
            header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        # ستون ID برای استفاده داخلی پنهان می‌ماند
        tree.setColumnHidden(headers.index('ID'), True)

        # 4) اگر لیست خالی بود، لیبل جایگزین را نمایش بده و برگرد
        if not items:
            set_empty_placeholder(tree, "هیچ کالایی در این دسته یافت نشد.")
            return

        # 5) ساخت ساختار درخت (ریشه/فرزند) بر اساس parent_item_id
        items_by_id = {item['id']: dict(item) for item in items}
        child_map = {}
        top_level_items = []
        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id and parent_id in items_by_id:
                child_map.setdefault(parent_id, []).append(item_data)
            else:
                top_level_items.append(item_data)

        # 6) پر کردن درخت
        tree.setUpdatesEnabled(False)
        for item_data in top_level_items:
            parent_item = NumericTreeWidgetItem(tree)
            parent_item.setText(0, item_data.get('name', ''))
            parent_item.setText(1, item_data.get('category', ''))
            parent_item.setText(2, str(item_data.get('non_prod_qty', 0)))
            parent_item.setText(3, item_data.get('unit', ''))
            parent_item.setText(4, str(item_data.get('min_qty', 0)))
            parent_item.setText(5, str(item_data.get('id')))
            parent_item.setData(0, Qt.UserRole, item_data)

            # هایلایت کمبود
            if (item_data.get('min_qty', 0) or 0) > 0 and (item_data.get('non_prod_qty', 0) or 0) < (item_data.get('min_qty', 0) or 0):
                parent_item.setBackground(0, QtGui.QColor("#fff2f2"))

            # فرزندان
            for child_data in child_map.get(item_data['id'], []):
                child_item = NumericTreeWidgetItem(parent_item)
                child_item.setText(0, child_data.get('name', ''))
                child_item.setText(1, child_data.get('category', ''))
                child_item.setText(2, str(child_data.get('non_prod_qty', 0)))
                child_item.setText(3, child_data.get('unit', ''))
                child_item.setText(4, str(child_data.get('min_qty', 0)))
                child_item.setText(5, str(child_data.get('id')))
                child_item.setData(0, Qt.UserRole, child_data)
                if (child_data.get('min_qty', 0) or 0) > 0 and (child_data.get('non_prod_qty', 0) or 0) < (child_data.get('min_qty', 0) or 0):
                    child_item.setBackground(0, QtGui.QColor("#fff2f2"))

        tree.setUpdatesEnabled(True)
        tree.expandAll()
        tree.setSortingEnabled(True)

        # 7) اطمینان از پنهان بودن لیبلِ «لیست خالی» وقتی آیتم داریم
        if hasattr(tree, "_empty_lbl"):
            try:
                tree._empty_lbl.hide()
            except Exception:
                pass
    # END REWRITE: MainWindow._populate_item_tree
                        
            
    # این ۴ متد کاملا جدید را به کلاس MainWindow اضافه کنید
    def _create_pagination_controls(self, category_name):
        widget = QtWidgets.QWidget()
        layout = QtWidgets.QHBoxLayout(widget)
        layout.setContentsMargins(0, 5, 0, 0)

        btn_prev = QtWidgets.QPushButton("« قبلی")
        btn_next = QtWidgets.QPushButton("بعدی »")
        lbl_status = QtWidgets.QLabel("صفحه ۰ از ۰")

        layout.addStretch()
        layout.addWidget(btn_prev)
        layout.addWidget(lbl_status)
        layout.addWidget(btn_next)
        layout.addStretch()

        controls = {'prev': btn_prev, 'next': btn_next, 'label': lbl_status}
        btn_prev.clicked.connect(lambda: self._change_item_page(category_name, -1))
        btn_next.clicked.connect(lambda: self._change_item_page(category_name, 1))

        return widget, controls

    
    
    def _update_pagination_ui(self, category_fa_name: str):
        state = self.item_page_state[category_fa_name]
        controls = self.pagination_controls[category_fa_name]

        controls['label'].setText(f"صفحه {state['current_page']} از {state['total_pages']}")
        controls['prev'].setEnabled(state['current_page'] > 1)
        controls['next'].setEnabled(state['current_page'] < state['total_pages'])

    # این متد را با نسخه ساده شده زیر جایگزین کنید
    def _change_item_page(self, category_fa_name: str, delta: int):
        state = self.item_page_state.get(category_fa_name)
        if not state: return
        
        new_page = state['current_page'] + delta
        if 1 <= new_page <= state['total_pages']:
            state['current_page'] = new_page
            self._load_items_for_page(category_fa_name)
        
            

    def _load_active_items_tab_data(self):
        """داده‌های تب فعال فعلی را به صورت مستقیم و مسدودکننده (Blocking) بارگذاری می‌کند."""
        if not hasattr(self, 'items_category_tabs'): return
        
        current_index = self.items_category_tabs.currentIndex()
        if current_index == -1: return

        category_fa_name = self.items_category_tabs.tabText(current_index)
        
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            # فراخوانی مستقیم متد بارگذاری صفحه
            self._load_items_for_page(category_fa_name)
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()

                            
                    
    # [FUNC: MainWindow._open_replenishment_center] — بازکردن نسخهٔ جدید دیالوگ (بدون attach قدیمی)
    def _open_replenishment_center(self, preselected_item_id=None):
        """پنجرهٔ جدید «مرکز هوشمند تأمین کالا» را باز می‌کند."""
        dlg = ReplenishmentDialog(self.db, self.user_id, self, preselected_item_id)
        dlg.exec_()

                            

        
            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _load_assets_table(self):
        if not hasattr(self, 'tbl_assets'): return
        tree = self.tbl_assets
        tree.clear()
        try:
            if self.asset_view_by_status.isChecked():
                tree.setHeaderLabels(['کد / نام دارایی', 'برند', 'مدل', 'ارزش ریالی'])
                all_assets = self.db.execute_query("SELECT * FROM assets ORDER BY name")
                if not all_assets: tree.addTopLevelItem(QtWidgets.QTreeWidgetItem(["هیچ دارایی ثبت نشده است."])); return
                grouped_assets = {}
                for asset in all_assets:
                    status = asset.get('status', 'نامشخص')
                    if status not in grouped_assets: grouped_assets[status] = []
                    grouped_assets[status].append(asset)
                for status, assets_in_group in sorted(grouped_assets.items()):
                    parent_item = QtWidgets.QTreeWidgetItem(tree, [f"{status} ({len(assets_in_group)} مورد)"])
                    parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
                    for asset in assets_in_group:
                        child_item = QtWidgets.QTreeWidgetItem(parent_item)
                        child_item.setText(0, f"  {asset['name']} ({asset['code']})")
                        child_item.setText(1, asset.get('brand', ''))
                        child_item.setText(2, asset.get('model', ''))
                        cost_str = f"{asset.get('cost', 0):,.0f}"
                        child_item.setText(3, cost_str)
                        child_item.setTextAlignment(3, Qt.AlignRight | Qt.AlignVCenter)
                        # --- *** اصلاح کلیدی اینجاست *** ---
                        child_item.setToolTip(0, "برای مشاهده تاریخچه کامل، روی این ردیف دابل کلیک کنید")
            else:
                tree.setHeaderLabels(['نام شخص / دارایی', 'کد', 'برند', 'مدل'])
                assigned_assets = self.db.get_assets_by_assignee()
                if not assigned_assets: tree.addTopLevelItem(QtWidgets.QTreeWidgetItem(["هیچ دارایی در اختیار پرسنل نیست."])); return
                grouped_by_employee = {}
                for asset in assigned_assets:
                    employee = asset.get('employee_name', 'نامشخص').strip();
                    if not employee: employee = "نامشخص"
                    if employee not in grouped_by_employee: grouped_by_employee[employee] = []
                    grouped_by_employee[employee].append(asset)
                for employee, assets in sorted(grouped_by_employee.items()):
                    parent_item = QtWidgets.QTreeWidgetItem(tree, [f"{employee} ({len(assets)} مورد)"]); parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
                    for asset in assets:
                        child_item = QtWidgets.QTreeWidgetItem(parent_item, [f"  {asset['name']}", asset['code'], asset['brand'], asset['model']])
                        # --- *** اصلاح کلیدی اینجاست *** ---
                        child_item.setToolTip(0, "برای مشاهده تاریخچه کامل، روی این ردیف دابل کلیک کنید")

            tree.expandAll()
        except Exception as e:
            print(f"Error loading assets table: {e}")
            tree.addTopLevelItem(QtWidgets.QTreeWidgetItem([f"خطا در بارگذاری دارایی‌ها: {e}"]))
                        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _edit_asset_action(self):
        """دیالوگ ویرایش را برای دارایی انتخاب شده در درخت، باز می‌کند."""
        selected_items = self.tbl_assets.selectedItems()
        if not selected_items:
            self.toast.show_message("لطفاً ابتدا یک دارایی را برای ویرایش از لیست انتخاب کنید.", "warning")
            return
            
        item = selected_items[0]
        if item.parent() is None: # اگر روی گروه کلیک شده بود، کاری نکن
            return

        asset_code_name = item.text(0).strip()
        asset_code = asset_code_name.split('(')[-1].replace(')', '').strip()
        asset_data = self.db.execute_query("SELECT * FROM assets WHERE code = %s", (asset_code,), fetch_one=True)
        if not asset_data:
            self.toast.show_message("اطلاعات دارایی در دیتابیس یافت نشد.", "error")
            return

        dlg = AddAssetDialog(self.db, asset_data=dict(asset_data), parent=self)
        if dlg.exec_():
            updated_data = dlg.get_data()
            if updated_data:
                try:
                    self.db.add_asset(
                        code=updated_data['code'], name=updated_data['name'], brand=updated_data['brand'],
                        model=updated_data['model'], cost=updated_data['cost'], user_id=self.user_id
                    )
                    self.toast.show_message("✔ دارایی با موفقیت ویرایش شد.", "success")
                    self._load_assets_table()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ویرایش دارایی: {e}")
            
                                    
                                
                                                                                    
    def _get_selected_asset_id(self):
        """ID دارایی انتخاب شده در جدول دارایی‌ها را برمی‌گرداند. در صورت عدم انتخاب، None برمی‌گرداند."""
        selected_rows = self.tbl_assets.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً ابتدا یک دارایی را از جدول انتخاب کنید.", "warning")
            return None
        try:
            asset_id = int(self.tbl_assets.item(selected_rows[0].row(), 0).text())
            return asset_id
        except (AttributeError, ValueError, IndexError):
            return None
        
    # --- REPLACE in MainWindow ---
    def _add_filter_export_tools(self, target_widget, target_layout, quick_filter_widget=None, custom_filter_dialog_class=None):
        """Toolbar with quick-search, advanced filter, export to Excel, and filter status."""
        bar = QtWidgets.QHBoxLayout()
        search_edit = QtWidgets.QLineEdit(); search_edit.setPlaceholderText("جستجوی سریع در تمام ستون‌ها"); search_edit.setMinimumHeight(30)
        btn_filter = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), " فیلتر پیشرفته")
        btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل")
        bar.addWidget(search_edit, 1); bar.addWidget(btn_filter); bar.addWidget(btn_export)
        target_layout.insertLayout(0, bar)

        # status chip
        filter_status_widget = QtWidgets.QFrame(); filter_status_widget.setObjectName("filterStatus")
        filter_status_layout = QtWidgets.QHBoxLayout(filter_status_widget); filter_status_layout.setContentsMargins(10, 5, 10, 5)
        filter_status_icon = QtWidgets.QLabel("ℹ️"); filter_status_label = QtWidgets.QLabel("")
        filter_status_layout.addWidget(filter_status_icon); filter_status_layout.addWidget(filter_status_label, 1)
        btn_clear_quick = QtWidgets.QPushButton("حذف فیلترها"); btn_clear_quick.setProperty("class", "danger")
        filter_status_layout.addWidget(btn_clear_quick)
        filter_status_widget.setStyleSheet("#filterStatus { background-color: #e7f1ff; border: 1px solid #b3d1ff; border-radius: 4px; }")
        target_layout.insertWidget(1, filter_status_widget)

        def get_active_widget():
            if hasattr(target_widget, 'currentWidget'): return target_widget.currentWidget()
            return target_widget

        def update_filter_status():
            table = get_active_widget()
            total_items = 0; visible_items = 0
            is_advanced_filtered = hasattr(table, '_active_filters') and table._active_filters
            is_quick_filtered = bool(search_edit.text().strip())
            is_filtered = is_advanced_filtered or is_quick_filtered

            if isinstance(table, QtWidgets.QTableWidget):
                total_items = table.rowCount()
                if total_items > 0:
                    visible_items = total_items - sum(1 for r in range(total_items) if table.isRowHidden(r))
            elif isinstance(table, QtWidgets.QTreeWidget):
                it = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
                while it.value():
                    if it.value().parent():
                        total_items += 1
                        if not it.value().isHidden(): visible_items += 1
                    it += 1

            if is_filtered:
                filter_type_text = "فیلتر پیشرفته" if is_advanced_filtered else "جستجوی سریع"
                filter_status_label.setText(f"<b>{filter_type_text} فعال است:</b> نمایش {visible_items} از {total_items} رکورد.")
                filter_status_widget.show()
            else:
                filter_status_widget.hide()

        def open_filter_dialog():
            active = get_active_widget()
            dlg_class = custom_filter_dialog_class or FilterDialog
            dlg = dlg_class(active, active.parent(), on_finish=update_filter_status)
            dlg.exec_()

        def reset_all_filters():
            table = get_active_widget()
            if hasattr(table, '_active_filters'): table._active_filters = []
            search_edit.clear()
            if isinstance(table, QtWidgets.QTableWidget):
                for r in range(table.rowCount()): table.setRowHidden(r, False)
            elif isinstance(table, QtWidgets.QTreeWidget):
                it = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
                while it.value(): it.value().setHidden(False); it += 1
            update_filter_status()

        search_edit.textChanged.connect(lambda text: self._quick_filter_table(get_active_widget(), text))
        btn_filter.clicked.connect(open_filter_dialog)
        btn_export.clicked.connect(lambda: self.export_table_to_excel(get_active_widget(), get_active_widget().parent()))
        btn_clear_quick.clicked.connect(reset_all_filters)
        search_edit.textChanged.connect(update_filter_status)

                            
    # BEGIN REWRITE: MainWindow._build_trans_page (fixed wiring + left align)
    def _build_trans_page(self):
        from PyQt5 import QtWidgets, QtCore, QtGui

        self.pg_trans.setObjectName("page_transactions")
        self.pg_trans.setStyleSheet("""
    #page_transactions QTabWidget QTabBar::tab{min-height:42px;padding:12px 20px;min-width:160px;}
    #page_transactions QTabWidget::pane{border:none;}
    #page_transactions QTableView::item,#page_transactions QTableWidget::item{padding:10px 14px;}
    #page_transactions QHeaderView::section{padding:8px 12px;}
    #page_transactions QLineEdit,#page_transactions QComboBox,#page_transactions QSpinBox,
    #page_transactions QDoubleSpinBox,#page_transactions QTextEdit,#page_transactions QPlainTextEdit{
    min-height:38px;padding:8px 12px;
    }
    """)
        layout = self.create_page_layout(self.pg_trans, "تاریخچه و عملیات انبار")

        # --- نوار ابزار بالایی ---
        toolbar = QtWidgets.QFrame(); tl = QtWidgets.QHBoxLayout(toolbar)
        tl.setContentsMargins(0,0,10,10); tl.setSpacing(10)
        if self.has_permission('transactions:create_entry'):
            b_in = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " ثبت ورود")
            b_in.setProperty("class","primary"); b_in.clicked.connect(lambda: self._new_trans("ورود")); tl.addWidget(b_in)
        if self.has_permission('transactions:create_exit'):
            b_out = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " ثبت خروج")
            b_out.setProperty("class","primary"); b_out.clicked.connect(lambda: self._new_trans("خروج")); tl.addWidget(b_out)
        if self.has_permission('transactions:transfer'):
            b_tr = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-next"), " ثبت انتقال")
            b_tr.clicked.connect(self._transfer_generic); tl.addWidget(b_tr)
        if (self.has_permission('transactions:create_other')
            or self.has_permission('purchasing:receive_po')
            or self.has_permission('transactions:create_entry')):
            b_other = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-more"), " سایر تراکنش‌ها")
            menu = QtWidgets.QMenu(self)
            if self.has_permission('transactions:create_other'):
                menu.addAction("ثبت برگشت").triggered.connect(lambda: self._new_trans("برگشت"))
                menu.addAction("ثبت ضایعات").triggered.connect(lambda: self._new_trans("ضایعات"))
            if self.has_permission('purchasing:receive_po') or self.has_permission('transactions:create_entry'):
                menu.addAction("ورود (از سفارش خرید)").triggered.connect(self._open_po_selection_dialog)
            b_other.setMenu(menu); tl.addWidget(b_other)
        if self.has_permission('transactions:void'):
            b_void = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " ابطال تراکنش")
            b_void.clicked.connect(self._void_master_action); tl.addWidget(b_void)
        tl.addStretch()
        self.view_mode_check = QtWidgets.QCheckBox("نمایش بر اساس سند")
        try: self.view_mode_check.setFont(QtGui.QFont(FONT_FAMILY, 10, QtGui.QFont.Bold))
        except Exception: pass
        self.view_mode_check.stateChanged.connect(self._toggle_trans_view)
        tl.addWidget(self.view_mode_check)
        layout.insertWidget(2, toolbar)

        # --- تب‌ها ---
        self.tab_widget_trans = QtWidgets.QTabWidget()
        try:
            bar = self.tab_widget_trans.tabBar()
            bar.setElideMode(QtCore.Qt.ElideNone); bar.setExpanding(False); bar.setUsesScrollButtons(True)
        except Exception: pass
        self.tab_widget_trans.setStyleSheet((self.tab_widget_trans.styleSheet() or "")
            + " QTabBar::tab{ padding:8px 18px; min-height:32px; } ")
        layout.addWidget(self.tab_widget_trans)

        self.trans_views = {}

        # --- تب‌های عمومی ---
        for tp in ('همه','ورود','خروج','برگشت','انتقال','اصلاح انبارگردانی','ورود از تولید','خروج به تولید','ابطال','ضایعات'):
            w = QtWidgets.QWidget(); v = QtWidgets.QVBoxLayout(w); v.setContentsMargins(0,10,0,0)
            stack = QtWidgets.QStackedWidget()
            table = QtWidgets.QTableWidget(); self._style_table(table); stack.addWidget(table)
            tree  = QtWidgets.QTreeWidget();  self._style_tree(tree);   stack.addWidget(tree)
            stack.setCurrentWidget(table); v.addWidget(stack)
            self.trans_views[tp] = {'stack': stack, 'table': table, 'tree': tree}
            self.tab_widget_trans.addTab(w, tp)

        # --- «تاریخچه دارایی» ---
        w_hist = QtWidgets.QWidget(); v_hist = QtWidgets.QVBoxLayout(w_hist); v_hist.setContentsMargins(0,10,0,0)
        tbl_hist = QtWidgets.QTableWidget(); self._style_table(tbl_hist); v_hist.addWidget(tbl_hist)
        self.trans_views['تاریخچه دارایی'] = {'stack': None, 'table': tbl_hist, 'tree': None}
        self.tab_widget_trans.addTab(w_hist, 'تاریخچه دارایی')

        # --- تب مادر «ارتباط با تولید» ---
        prod_tab = QtWidgets.QWidget()
        prod_layout = QtWidgets.QVBoxLayout(prod_tab); prod_layout.setContentsMargins(0,10,0,0)
        self.production_inner_tabs = QtWidgets.QTabWidget(); self.production_inner_tabs.setObjectName("mainProdTabs")
        try:
            inner_bar = self.production_inner_tabs.tabBar()
            inner_bar.setElideMode(QtCore.Qt.ElideNone); inner_bar.setUsesScrollButtons(True)
        except Exception: pass

        # 1) درخواست‌های مواد اولیه
        w_req = QtWidgets.QWidget(); v = QtWidgets.QVBoxLayout(w_req); v.setContentsMargins(0,10,0,0)
        self.tbl_material_requests = QtWidgets.QTableWidget(); self._style_table(self.tbl_material_requests)
        v.addWidget(self.tbl_material_requests)
        self.trans_views['درخواست‌های مواد اولیه'] = {'stack': None, 'table': self.tbl_material_requests, 'tree': None}
        self.production_inner_tabs.addTab(w_req, 'درخواست‌های مواد اولیه')

        # 2) محصولات منتظر تایید
        w_del = QtWidgets.QWidget(); v = QtWidgets.QVBoxLayout(w_del); v.setContentsMargins(0,10,0,0)
        self.tbl_pending_deliveries = QtWidgets.QTableWidget(); self._style_table(self.tbl_pending_deliveries)
        v.addWidget(self.tbl_pending_deliveries)
        self.trans_views['محصولات منتظر تایید'] = {'stack': None, 'table': self.tbl_pending_deliveries, 'tree': None}
        self.production_inner_tabs.addTab(w_del, 'محصولات منتظر تایید')

        # 3) کالاهای برگشتی از تولید
        w_ret = QtWidgets.QWidget(); v = QtWidgets.QVBoxLayout(w_ret); v.setContentsMargins(0,10,0,0)

        # جدول: فول‌عرض + انتخاب سطری + Stretch برای همه ستون‌ها
        self.tbl_material_returns = QtWidgets.QTableWidget(); self._style_table(self.tbl_material_returns)
        try:
            self.tbl_material_returns.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            self.tbl_material_returns.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
            self.tbl_material_returns.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
            hdr = self.tbl_material_returns.horizontalHeader()
            hdr.setStretchLastSection(True)
            hdr.setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        except Exception: pass
        v.addWidget(self.tbl_material_returns)

        # نوار دکمه‌ها: پایین، سمت چپ
        ret_bar = QtWidgets.QFrame()
        hb = QtWidgets.QHBoxLayout(ret_bar)
        hb.setContentsMargins(0,8,0,0); hb.setSpacing(8)
        # اجباری: چیدمان چپ‌به‌راست و ترازِ چپ
        ret_bar.setLayoutDirection(QtCore.Qt.LeftToRight)
        try:
            hb.setDirection(QtWidgets.QBoxLayout.LeftToRight)
            hb.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
        except Exception:
            pass

        self.btn_ret_approve = QtWidgets.QPushButton("تایید برگشت"); self.btn_ret_approve.setProperty("class","primary")
        self.btn_ret_reject  = QtWidgets.QPushButton("رد")
        self.btn_ret_approve.setEnabled(False); self.btn_ret_reject.setEnabled(False)

        # اتصال مستقیم به هندلرهای موجود
        self.btn_ret_approve.clicked.connect(self._approve_selected_return)
        self.btn_ret_reject.clicked.connect(self._reject_selected_return)

        hb.addWidget(self.btn_ret_approve)
        hb.addWidget(self.btn_ret_reject)
        hb.addStretch(1)      # فضای خالی سمت راست
        v.addWidget(ret_bar)

        # فعال/غیرفعال شدن بر اساس انتخاب سطر
        def _toggle_ret_actions():
            sm = self.tbl_material_returns.selectionModel()
            has_sel = bool(sm and sm.hasSelection())
            self.btn_ret_approve.setEnabled(has_sel)
            self.btn_ret_reject.setEnabled(has_sel)
        try: self.tbl_material_returns.itemSelectionChanged.connect(_toggle_ret_actions)
        except Exception: pass

        self.trans_views['کالاهای برگشتی از تولید'] = {'stack': None, 'table': self.tbl_material_returns, 'tree': None}
        self.production_inner_tabs.addTab(w_ret, 'کالاهای برگشتی از تولید')

        # تب مادر
        prod_layout.addWidget(self.production_inner_tabs)
        self.tab_widget_trans.addTab(prod_tab, 'ارتباط با تولید')

        # تغییر تب → لود
        self.tab_widget_trans.currentChanged.connect(self._load_trans)
        self.production_inner_tabs.currentChanged.connect(lambda _: self._load_trans())
        self._load_trans()
    # END REWRITE


        
                                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _open_po_selection_dialog(self):
        """گردش کار انتخاب سفارش خرید و ثبت رسید را مدیریت می‌کند."""
        select_dlg = SelectPoDialog(self.db, self)
        if select_dlg.exec_() == QtWidgets.QDialog.Accepted:
            po_id = select_dlg.get_selected_po_id()
            if po_id:
                # حالا که PO ID را داریم، متد قبلی را برای باز کردن دیالوگ رسید فراخوانی می‌کنیم
                self._receive_po_action(preselected_po_id=po_id)
            else:
                self.toast.show_message("هیچ سفارش خریدی انتخاب نشد.", "warning")
                
                
        
        
    def _void_master_action(self):
        """
        این تابع فقط یک توزیع‌کننده (Dispatcher) است.
        تشخیص می‌دهد که کدام عملیات ابطال باید اجرا شود.
        """
        active_tab_name = self.tab_widget_trans.tabText(self.tab_widget_trans.currentIndex())
        
        if active_tab_name == 'تاریخچه دارایی':
            # اگر در تب دارایی‌ها بودیم، منطق ابطال دارایی را اجرا کن
            self._void_selected_asset_trans()
        else:
            # در غیر این صورت، تابع اصلی و دست‌نخورده برای ابطال کالا فراخوانی می‌شود
            self._void_selected_trans()

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _void_selected_asset_trans(self):
        """تراکنش انتخاب شده در جدول تاریخچه دارایی‌ها را باطل می‌کند."""
        # پیدا کردن جدول تاریخچه دارایی‌ها
        view_dict = self.trans_views.get('تاریخچه دارایی')
        if not view_dict: return
        
        asset_table = view_dict.get('table')
        if not asset_table: return

        selected_rows = asset_table.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک تراکنش را از جدول تاریخچه دارایی برای ابطال انتخاب کنید.", "warning")
            return

        # فقط اولین ردیف انتخاب شده را در نظر می‌گیریم
        row_index = selected_rows[0].row()
        try:
            trans_id = int(asset_table.item(row_index, 0).text())
        except (AttributeError, ValueError):
            self.toast.show_message("ردیف انتخاب شده معتبر نیست.", "error")
            return

        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی ابطال",
                                             f"آیا از ابطال تراکنش دارایی شماره {trans_id} و بازگرداندن وضعیت آن به حالت قبل مطمئنید؟",
                                             QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.void_asset_transaction(trans_id, self.user_id)
                self.toast.show_message("✔ تراکنش دارایی با موفقیت باطل شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ابطال با خطا مواجه شد:\n{e}")
                    
    # === BEGIN PATCH: MainWindow._get_selected_return_id (V2 — resilient to column order) ===
    def _get_selected_return_id(self):
        """ID ردیف انتخابی. اول از UserRole ستون اول، بعد آخرین ستون، بعد اولین ستون."""
        from PyQt5 import QtCore
        tbl = self.tbl_material_returns
        try:
            row = tbl.currentRow()
            if row is None or row < 0:
                return None
            # تلاش 1: UserRole روی ستون 0
            it0 = tbl.item(row, 0)
            if it0:
                rid = it0.data(QtCore.Qt.UserRole)
                if isinstance(rid, int) and rid > 0:
                    return rid
            # تلاش 2: آخرین ستون
            last = tbl.item(row, tbl.columnCount() - 1)
            if last and (last.text() or "").strip().isdigit():
                return int(last.text().strip())
            # تلاش 3: اولین ستون اگر عدد باشد
            first = tbl.item(row, 0)
            if first and (first.text() or "").strip().isdigit():
                return int(first.text().strip())
        except Exception:
            pass
        return None
    # === END PATCH ===
                  

    # === BEGIN PATCH: MainWindow._load_pending_returns (V2 — stable IDs + full stretch) ===
    def _load_pending_returns(self):
        """لیست برگشتی‌ها را لود می‌کند و ID را هم در UserRole ذخیره می‌کند که از جابجایی ستون‌ها مستقل باشد."""
        from PyQt5 import QtWidgets, QtCore
        def _safe_msg(kind, text):
            fn = getattr(self, f"_{kind}", None) or getattr(self, kind, None)
            if callable(fn):
                try: fn(text); return
                except Exception: pass
            try: print(f"[{kind.upper()}] {text}")
            except Exception: pass

        try:
            rows = self.db.get_pending_returns_from_production() or []
        except Exception as e:
            _safe_msg("error", f"خطا در خواندن لیست برگشتی‌ها: {e}")
            rows = []

        tbl = self.tbl_material_returns
        headers = ["نام کالا", "واحد", "مقدار برگشتی", "شماره بچ", "تاریخ", "درخواست دهنده", "دلیل", "شماره"]  # «شماره» آخر
        tbl.clear()
        tbl.setColumnCount(len(headers))
        tbl.setHorizontalHeaderLabels(headers)
        tbl.setRowCount(len(rows))

        for r, row in enumerate(rows):
            id_val = row.get("id") or row.get("return_id") or row.get("req_id") or None
            values = [
                row.get("item_name") or row.get("name") or "",
                row.get("unit_name") or row.get("unit") or "",
                str(row.get("qty") or 0),
                row.get("batch_no") or row.get("batch") or "",
                str(row.get("requested_at") or row.get("created_at") or row.get("date") or ""),
                row.get("requester") or row.get("requested_by") or "",
                row.get("reason") or row.get("note") or "",
                str(id_val or "")
            ]
            for c, val in enumerate(values):
                it = QtWidgets.QTableWidgetItem(val)
                if c == 2:
                    it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
                # ID را برای بازیافت مطمئن، روی ستون اول هم در UserRole ذخیره می‌کنیم
                if c == 0 and id_val is not None:
                    it.setData(QtCore.Qt.UserRole, int(id_val))
                tbl.setItem(r, c, it)

        try:
            hdr = tbl.horizontalHeader()
            for c in range(tbl.columnCount()):
                hdr.setSectionResizeMode(c, QtWidgets.QHeaderView.Stretch)
            hdr.setStretchLastSection(True)
            tbl.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            tbl.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
            if rows:
                tbl.selectRow(0)
        except Exception:
            pass

        # دکمه‌ها
        def _toggle_actions():
            has_sel = bool(tbl.selectedItems())
            if hasattr(self, "btn_ret_approve"): self.btn_ret_approve.setEnabled(has_sel)
            if hasattr(self, "btn_ret_reject"):  self.btn_ret_reject.setEnabled(has_sel)

        try: tbl.itemSelectionChanged.connect(_toggle_actions)
        except Exception: pass
        _toggle_actions()
    # === END PATCH ===
    
    
    # === REPLACE WHOLE METHOD: MainWindow._approve_selected_return ===
    def _approve_selected_return(self):
        """تایید برگشت: انتخاب مقصد با کشوییِ لوکیشن‌های غیرتولیدی، ثبت برگشت در انبار، و رفرش."""
        from PyQt5 import QtWidgets

        # پیام‌رسان ایمن
        def _safe_msg(kind, text):
            fn = getattr(self, f"_{kind}", None) or getattr(self, kind, None)
            if callable(fn):
                try:
                    fn(text); return
                except Exception:
                    pass
            try:
                print(f"[{kind.upper()}] {text}")
            except Exception:
                pass

        # شناسهٔ درخواست انتخاب‌شده
        ret_id = self._get_selected_return_id()
        if not ret_id:
            _safe_msg("warning", "هیچ ردیفی انتخاب نشده است.")
            return

        # 1) تلاش برای استفاده از انتخاب‌گر داخلی اگر داشته باشیم
        dest_id = None
        dest_label = ""
        try:
            # اگر پیاده‌سازی داخلی انتخاب لوکیشن داری، از همان استفاده کن
            # و در عین حال انبار تولید را از گزینه‌ها حذف کن (در هر دو زبان)
            chooser = getattr(self, "_choose_location", None)
            if callable(chooser):
                dest_id, dest_label = chooser(
                    title="انتخاب انبار مقصد بازگشت",
                    exclude_warehouses=['Production', 'تولید']
                )
        except Exception:
            dest_id = None

        # 2) اگر انتخاب‌گر داخلی نبود/خطا داد → کشویی با list_locationsِ غیرتولیدی
        if not dest_id:
            try:
                # این متد همین الان در DB داری (با include/exclude) – از خودش استفاده می‌کنیم
                rows = self.db.list_locations(exclude_warehouses=['Production', 'تولید']) or []
            except Exception as e:
                _safe_msg("error", f"خواندن لیست انبارها ناموفق بود: {e}")
                rows = []

            if not rows:
                _safe_msg("warning", "هیچ انبار غیرتولیدی در سیستم ثبت نشده است.")
                return

            # برچسب زیبا برای نمایش، با نقشهٔ امن text→id
            display_to_id = {}
            display_items = []
            for r in rows:
                lbl = (r.get("loc_label")
                    or f"{r.get('wh','')} / {r.get('rack','')}-{r.get('shelf','')}-{r.get('bin','')}"
                    ).strip()
                disp = f"{lbl}  (ID:{r.get('id')})"
                display_to_id[disp] = r.get("id")
                display_items.append(disp)

            choice, ok = QtWidgets.QInputDialog.getItem(
                self, "انبار مقصد", "انبار مقصد:", display_items, 0, False
            )
            if not ok:
                _safe_msg("warning", "انبار مقصد انتخاب نشد؛ عملیات متوقف شد.")
                return

            dest_id = display_to_id.get(choice)
            dest_label = choice.split("  (ID:")[0].strip()

            if not dest_id:
                _safe_msg("warning", "انتخاب مقصد نامعتبر است.")
                return

        # 3) انجام تایید در DB
        try:
            user_id = getattr(self, "current_user_id", None) or getattr(self, "user_id", None) or 0
            self.db.approve_material_return(return_id=ret_id, user_id=user_id, target_location_id=dest_id)
            try:
                self.db.mark_notification_resolved('APPROVE_RETURN', ret_id)
            except Exception:
                pass
            
            _safe_msg("info", f"برگشت به «{dest_label}» ثبت شد.")
            self._load_pending_returns()
        except Exception as e:
            _safe_msg("error", f"خطا در تایید برگشت: {e}")
    # === END REPLACE ===

    # === REPLACE WHOLE METHOD: MainWindow._reject_selected_return ===
    def _reject_selected_return(self):
        """رد درخواست برگشت: فقط وقتی کاربر OK بزند؛ بدون دست‌کاری موجودی."""
        from PyQt5 import QtWidgets

        def _safe_msg(kind, text):
            fn = getattr(self, f"_{kind}", None) or getattr(self, kind, None)
            if callable(fn):
                try:
                    fn(text); return
                except Exception:
                    pass
            try:
                print(f"[{kind.upper()}] {text}")
            except Exception:
                pass

        ret_id = self._get_selected_return_id()
        if not ret_id:
            _safe_msg("warning", "هیچ ردیفی انتخاب نشده است.")
            return

        reason = ""
        ok = False
        try:
            reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد", "علت رد:")
        except Exception:
            ok = False

        if not ok:
            # کاربر Cancel/X زده؛ هیچ تغییری نده
            return

        try:
            user_id = getattr(self, "current_user_id", None) or getattr(self, "user_id", None) or 0
            self.db.reject_material_return(return_id=ret_id, user_id=user_id, reason=reason or "")
            _safe_msg("info", "درخواست برگشت رد شد.")
            self._load_pending_returns()
        except Exception as e:
            _safe_msg("error", f"خطا در رد برگشت: {e}")
    # === END REPLACE ===

# BEGIN QA IMPROVEMENT — MainWindow::_approve_selected_delivery (linked QA forms + friendly flow)

    def _approve_selected_delivery(self):
        import json
        from PyQt5 import QtWidgets, QtCore
        Qt = QtCore.Qt

        try:
            # 0) انتخاب ردیف
            if not hasattr(self, 'tbl_pending_deliveries'):
                QtWidgets.QMessageBox.warning(self, "هشدار", "جدول تحویل‌های در انتظار پیدا نشد.")
                return

            row = self._get_selected_row(self.tbl_pending_deliveries, friendly_name="تحویل تولید")  # helper موجود
            if row is None:
                return

            # سعی می‌کنیم ID را از UserRole بخوانیم، اگر نبود از متن سلول
            id_item = self.tbl_pending_deliveries.item(row, 0)
            delivery_id = id_item.data(Qt.UserRole) if id_item is not None else None
            if delivery_id is None:
                try:
                    delivery_id = int(id_item.text())
                except Exception:
                    QtWidgets.QMessageBox.warning(self, "هشدار", "شناسه تحویل قابل تشخیص نیست.")
                    return

                # توابع کمکی کوچک (داخل همین متد نگه می‌داریم تا یکپارچه و قابل انتقال باشد)
                def _col_exists(table, col):
                    # متد DB._table_has_column قبلاً داخل کلاس DB پیاده شده است. 
                    # اگر نبود، false برمی‌گردد و ما مسیر سازگار را می‌رویم.
                    try:
                        return bool(self.db._table_has_column(table, col))
                    except Exception:
                        return False

                def _find_existing_entry(form_def_id: int) -> dict | None:
                    """آخرین رکوردی که همین فرم برای همین delivery لینک شده را برمی‌گرداند (اگر بود)."""
                    # اول: related_table/related_id
                    sql_related = """
                        SELECT id, status, score
                        FROM form_entries
                        WHERE {form_col}=%s AND related_table=%s AND related_id=%s
                        ORDER BY created_at DESC LIMIT 1
                    """
                    # دوم: target_table/target_id
                    sql_target = """
                        SELECT id, status, score
                        FROM form_entries
                        WHERE {form_col}=%s AND target_table=%s AND target_id=%s
                        ORDER BY created_at DESC LIMIT 1
                    """
                    form_col = 'form_def_id' if _col_exists('form_entries', 'form_def_id') else 'form_id'
                    try:
                        row = self.db.execute_query(
                            sql_related.format(form_col=form_col),
                            (form_def_id, 'production_deliveries', delivery_id),
                            fetch_one=True
                        )
                    except Exception:
                        row = None
                    if not row:
                        try:
                            row = self.db.execute_query(
                                sql_target.format(form_col=form_col),
                                (form_def_id, 'production_deliveries', delivery_id),
                                fetch_one=True
                            )
                        except Exception:
                            row = None
                    return row

                def _insert_linked_entry(form_def_id: int, user_id: int, form_data: dict) -> int:
                    """
                    درج رکورد form_entries به صورت مقاوم نسبت به تفاوت اسکیمای جدول:
                    - انتخاب خودکار بین form_def_id و form_id
                    - انتخاب خودکار بین related_* یا target_*
                    - نوشتن status/score اگر ستون‌ها باشند
                    """
                    form_col = 'form_def_id' if _col_exists('form_entries', 'form_def_id') else 'form_id'
                    link_cols = ('related_table', 'related_id') if _col_exists('form_entries', 'related_table') else \
                                (('target_table', 'target_id') if _col_exists('form_entries', 'target_table') else (None, None))
                    has_status = _col_exists('form_entries', 'status')
                    has_score  = _col_exists('form_entries', 'score')

                    # از دادهٔ فرم تلاش می‌کنیم وضعیت و امتیاز را برداشت کنیم تا Gate کار کند.
                    # قرارداد رایج: result یا status → PASSED/FAILED (حروف بزرگ)
                    status_val = None
                    for k in ('result', 'status', 'qc_result', 'qa_result'):
                        if k in form_data and isinstance(form_data[k], str):
                            status_val = form_data[k].strip().upper()
                            break
                    if status_val not in ('PASSED', 'FAILED', None):
                        status_val = None

                    score_val = None
                    for k in ('score', 'qc_score', 'qa_score'):
                        if k in form_data:
                            try:
                                score_val = int(float(form_data[k]))
                            except Exception:
                                score_val = None
                            break

                    # دادهٔ خام را هم ذخیره می‌کنیم
                    data_json = json.dumps(form_data, ensure_ascii=False)

                    cols = [form_col, 'user_id', 'data']
                    vals = [form_def_id, user_id, data_json]

                    if link_cols[0] and link_cols[1]:
                        cols += [link_cols[0], link_cols[1]]
                        vals += ['production_deliveries', delivery_id]

                    if has_status and status_val is not None:
                        cols.append('status'); vals.append(status_val)
                    if has_score and score_val is not None:
                        cols.append('score');  vals.append(score_val)

                    # ساخت placeholder ها
                    placeholders = ", ".join(["%s"] * len(vals))
                    sql = f"INSERT INTO form_entries ({', '.join(cols)}) VALUES ({placeholders}) RETURNING id"
                    rec = self.db.execute_query(sql, tuple(vals), fetch_one=True)
                    return rec['id'] if rec else None

                # 3) برای هر فرم لازم، اگر قبلاً ثبت نشده → باز کردن فرم پویا و ثبت لینک‌شده
                for g in gates:
                    form_def_id = int(g['form_def_id'])
                    form_name = g.get('form_name') or f"Form #{form_def_id}"

                    already = _find_existing_entry(form_def_id)
                    if already:
                        # همین کافی است؛ Gate جدید هم آخر کار دوباره چک می‌شود
                        continue

                    # فیلدهای فرم را بگیر (کلاس DynamicFormDialog همین را لازم دارد)  ← ref: get_form_fields استفادهٔ فعلی
                    fields = self.db.get_form_fields(form_def_id)
                    if not fields:
                        QtWidgets.QMessageBox.warning(self, "فرم‌های QA", f"فرم «{form_name}» هیچ فیلدی ندارد.")
                        return

                    # فرم پویا را باز کن
                    try:
                        dlg_title = f"فرم لازم برای تایید دریافت: {form_name}"
                        dlg = DynamicFormDialog(self.db, form_def_id, dlg_title, parent=self)
                    except Exception as e:
                        QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در باز کردن فرم «{form_name}»:\n{e}")
                        return

                    if dlg.exec_() != QtWidgets.QDialog.Accepted:
                        # کاربر انصراف داد
                        if getattr(self, 'toast', None):
                            self.toast.show_message("عملیات لغو شد؛ فرم لازم تکمیل نشد.", "warning")
                        return

                    form_data = dlg.get_data() or {}
                    new_entry_id = _insert_linked_entry(form_def_id, self.user_id, form_data)
                    if not new_entry_id:
                        QtWidgets.QMessageBox.critical(self, "خطا", f"ثبت فرم «{form_name}» ناموفق بود.")
                        return

            # 5) انتخاب مقصد دریافت (مثل قبل)
            locs = self.db.list_locations(exclude_warehouses=['Production'])
            if not locs:
                raise ValueError("هیچ مقصدی خارج از انبار تولید ثبت نشده است؛ لطفاً در تنظیمات انبار یک مقصد بسازید.")
            loc_map = {f"{r['wh']}/{r['loc']}": r['id'] for r in locs}
            loc_name, ok_sel = QtWidgets.QInputDialog.getItem(
                self, "انتخاب لوکیشن مقصد",
                "این تحویل در کدام لوکیشن دریافت شود؟",
                list(loc_map.keys()), 0, False
            )
            if not ok_sel or not loc_name:
                return

            # 6) تأیید سمت DB
            self.db.finalize_delivery(delivery_id=delivery_id, approver_user_id=self.user_id, dest_loc_id=loc_map[loc_name])

            if getattr(self, 'toast', None):
                self.toast.show_message("✔ محصول با موفقیت در انبار دریافت و ثبت شد.", "success")
            else:
                QtWidgets.QMessageBox.information(self, "موفق", "محصول با موفقیت در انبار دریافت و ثبت شد.")

            # Refresh های معمول
            if hasattr(self, 'refresh_all'):
                self.refresh_all()
            if hasattr(self, '_load_pending_deliveries'):
                self._load_pending_deliveries()
            if hasattr(self, '_refresh_stock_kpis'):
                self._refresh_stock_kpis()

        except Exception as e:
            self._handle_exception("خطا در تایید دریافت محصول از تولید", e)

# END QA IMPROVEMENT
        
    def _reject_selected_delivery(self):
        """گردش کار رد کردن یک ردیف انتخاب شده از جدول تحویل‌های در انتظار را آغاز می‌کند."""
        if not hasattr(self, 'tbl_pending_deliveries'): return

        selected_rows = self.tbl_pending_deliveries.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
            return
        
        row = selected_rows[0].row()
        delivery_id = int(self.tbl_pending_deliveries.item(row, 0).text())
        item_name = self.tbl_pending_deliveries.item(row, 1).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کردن تحویل", f"چرا تحویل محصول «{item_name}» را رد می‌کنید؟")
        if ok and reason.strip():
            try:
                self.db.reject_delivery(delivery_id, reason.strip(), self.user_id)
                self.toast.show_message("تحویل محصول رد و به تولید اطلاع داده شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")
                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _reject_material_request(self):
        """گردش کار رد کردن یک درخواست مواد اولیه را مدیریت می‌کند."""
        if not hasattr(self, 'tbl_material_requests'): return

        selected_rows = self.tbl_material_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را از لیست برای رد کردن انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        request_id = int(self.tbl_material_requests.item(row, 0).text())
        item_name = self.tbl_material_requests.item(row, 2).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد درخواست", f"چرا درخواست برای کالای «{item_name}» را رد می‌کنید؟")
        
        if ok and reason.strip():
            try:
                self.db.reject_material_request(request_id, self.user_id, reason.strip())
                self.toast.show_message("✔ درخواست با موفقیت رد و دلیل آن ثبت شد.", "success")
                self.refresh_all() # رفرش کردن همه چیز برای آپدیت شدن لیست‌ها
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند رد کردن درخواست با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")
        
# این سه متد را در MainWindow با نسخه‌های زیر جایگزین کنید

    def _temporary_asset_exit(self):
        """گردش کار خروج موقت یک دارایی با قابلیت انتخاب از لیست."""
        # ابتدا پنجره انتخاب دارایی‌های "در انبار" باز می‌شود
        select_dlg = SelectAssetDialog(self.db, "انتخاب دارایی برای خروج", ["در انبار"], self)
        if select_dlg.exec_() and select_dlg.get_selected_asset_id():
            asset_id = select_dlg.get_selected_asset_id()
            
            # سپس دیالوگ ورود اطلاعات باز می‌شود
            exit_dlg = TemporaryExitDialog(self)
            if exit_dlg.exec_():
                data = exit_dlg.get_data()
                self.db.log_asset_event(asset_id, data['t_type'], data['notes'], data['t_no'], self.user_id)
                self.refresh_all()
                self.toast.show_message("خروج موقت دارایی ثبت شد.", "success")

    def _return_asset(self):
        """گردش کار بازگرداندن یک دارایی به انبار با قابلیت انتخاب از لیست."""
        # ابتدا پنجره انتخاب دارایی‌های "خارج شده" باز می‌شود
        select_dlg = SelectAssetDialog(self.db, "انتخاب دارایی برای بازگشت", ["خروج (تعمیرات)", "خروج (پروژه)"], self)
        if select_dlg.exec_() and select_dlg.get_selected_asset_id():
            asset_id = select_dlg.get_selected_asset_id()
            
            t_no, ok = QtWidgets.QInputDialog.getText(self, "ثبت بازگشت", "شماره رسید یا سند بازگشت را وارد کنید:")
            if ok and t_no:
                self.db.log_asset_event(asset_id, "بازگشت به انبار", "دارایی به انبار بازگردانده شد", t_no, self.user_id)
                self.refresh_all()
                self.toast.show_message("بازگشت دارایی به انبار ثبت شد.", "success")

    def _scrap_asset(self):
        """گردش کار اسقاط کردن یک دارایی با قابلیت انتخاب از لیست."""
        # ابتدا پنجره انتخاب دارایی‌های "در انبار" باز می‌شود
        select_dlg = SelectAssetDialog(self.db, "انتخاب دارایی برای اسقاط", ["در انبار"], self)
        if select_dlg.exec_() and select_dlg.get_selected_asset_id():
            asset_id = select_dlg.get_selected_asset_id()
            
            reply = QtWidgets.QMessageBox.warning(self, "تایید عملیات", "آیا از اسقاط کردن این دارایی مطمئن هستید؟", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if reply == QtWidgets.QMessageBox.Yes:
                t_no, ok = QtWidgets.QInputDialog.getText(self, "ثبت اسقاط", "شماره سند یا مجوز اسقاط را وارد کنید:")
                if ok and t_no:
                    self.db.log_asset_event(asset_id, "اسقاط", "دارایی اسقاط شد", t_no, self.user_id)
                    self.refresh_all()
                    self.toast.show_message("دارایی اسقاط شد.", "info")
                
    def _asset_exit_action(self):
        """گردش کار کامل خروج دارایی با پیوست چندگانه."""
        dlg = AssetExitDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    new_trans_id = self.db.asset_exit(
                        asset_id=data['asset_id'],
                        t_no=data['doc_no'],
                        t_date=datetime.now(),
                        notes=data['notes'],
                        user_id=self.user_id
                    )
                    self.toast.show_message("تراکنش ثبت شد. اکنون فایل‌های پیوست را اضافه کنید.", "info")
                    # باز کردن دیالوگ جدید پیوست‌ها برای این تراکنش
                    AssetAttachDialog(self.db, new_trans_id, self).exec_()
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت خروج دارایی: {e}")
                    

                    
# این متد را به کلاس MainWindow اضافه کنید
    def _open_adjustment_dialog(self):
        """پنجره ثبت سند اصلاحی را باز کرده و عملیات را انجام می‌دهد."""
        dlg = InventoryAdjustmentDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if not data:
                self.toast.show_message("اطلاعات ورودی ناقص یا نامعتبر است.", "warning")
                return

            try:
                # فراخوانی تابع اصلی دیتابیس که قبلا اصلاح کردیم
                self.db.apply_inventory_adjustment(
                    item_id=data['item_id'],
                    counted_qty=data['counted_qty'],
                    location_id=data['location_id'],
                    batch_no=data['batch_no'], # این پارامتر را اضافه می‌کنیم
                    reason=data['reason'],
                    user_id=self.user_id
                )
                self.toast.show_message("✔ سند اصلاحی با موفقیت ثبت شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطای پایگاه داده", f"خطایی در هنگام ثبت رخ داد:\n{e}")
                print(traceback.format_exc())

# این دو متد جدید را به کلاس MainWindow اضافه کنید

    def _load_asset_trans(self):
        """جدول و درخت تاریخچه تراکنش‌های دارایی را بارگذاری می‌کند."""
        view_dict = self.trans_views.get('تاریخچه دارایی')
        if not view_dict: return

        table = view_dict['table']
        table.setRowCount(0)

        rows = self.db.asset_trans_recent()

        if not rows:
            set_empty_placeholder(table, "هیچ تراکنش دارایی تا کنون ثبت نشده است.")
            return
        
        table_headers = ["ID", "دارایی", "نوع تراکنش", "شماره سند", "تاریخ", "کاربر", "یادداشت‌ها", "پیوست‌ها"]
        table.setColumnCount(len(table_headers))
        table.setHorizontalHeaderLabels(table_headers)
        table.setColumnHidden(0, True)
        table.setRowCount(len(rows))

        for r, row in enumerate(rows):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(row['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(row['asset_lbl']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(row.get('t_type', '')))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(row.get('t_no', '')))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(row['t_date'])))
            table.setItem(r, 5, QtWidgets.QTableWidgetItem(row.get('user_name', '')))
            table.setItem(r, 6, QtWidgets.QTableWidgetItem(row.get('notes', '')))
            
            files_count = row.get('files_count', 0)
            btn_attach = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-attachment"), f" ({files_count})")
            btn_attach.setFlat(True)
            btn_attach.setCursor(Qt.PointingHandCursor)
            btn_attach.setToolTip(f"مدیریت پیوست‌ها ({files_count} فایل)")
            btn_attach.clicked.connect(lambda _, tid=row['id']: AssetAttachDialog(self.db, tid, self).exec_())
            table.setCellWidget(r, 7, btn_attach)
        
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        table.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.Stretch)

        
    def _open_asset_action_dialog(self, action_type: str):
        """یک دیالوگ برای انجام عملیات مختلف روی دارایی‌ها باز می‌کند."""
        handler_map = {
            'exit':   {'title': "خروج موقت دارایی",    'status': ["در انبار"],                      'handler': self._temporary_asset_exit},
            'return': {'title': "بازگشت دارایی به انبار",'status': ["خروج (تعمیرات)", "خروج (پروژه)"], 'handler': self._return_asset},
            'scrap':  {'title': "اسقاط دارایی",         'status': ["در انبار"],                      'handler': self._scrap_asset}
        }

        config = handler_map.get(action_type)
        if not config:
            return

        # 🔑 اصلاح کلیدی: مجوز درست برای عملیات دارایی
        if not self.has_permission('assets:transact'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return

        config['handler']()

                        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _add_new_asset_action(self):
        """دیالوگ افزودن دارایی جدید را باز کرده و در صورت تایید، آن را ثبت و جدول را رفرش می‌کند."""
        # --- اصلاح کلیدی: ارسال صحیح آرگومان‌ها ---
        # ما به دیالوگ می‌گوییم که هیچ داده اولیه‌ای (asset_data) وجود ندارد و این یک فرم جدید است.
        dlg = AddAssetDialog(self.db, parent=self)
        
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data and hasattr(self, 'user_id'):
                try:
                    self.db.add_asset(
                        code=data['code'], name=data['name'], 
                        brand=data['brand'], model=data['model'], 
                        cost=data['cost'], user_id=self.user_id
                    )
                    self._load_assets_table() # رفرش کردن لیست دارایی‌ها
                    self.toast.show_message("✔ دارایی جدید با موفقیت ثبت شد.", "success")
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"دارایی با این کد از قبل موجود است یا خطای دیگری رخ داد.\n{e}")
                    
                    

                
# در کلاس MainWindow، این دو متد را جایگزین کنید

    def _style_tree(self, tree: QtWidgets.QTreeWidget, headers: list = None):
        """
        یک استایل استاندارد را بر روی ویجت درختی اعمال کرده و سرستون‌های آن را تنظیم می‌کند.
        """
        tree.setAlternatingRowColors(True)
        tree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tree.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        tree.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        tree.header().setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
        
        if headers:
            tree.setHeaderLabels(headers)

        tree.setStyleSheet("""
            QTreeWidget {
                border: 1px solid #dfe4ea;
                font-size: 10pt;
            }
            QTreeWidget::item {
                padding: 7px;
                border-bottom: 1px solid #f0f0f0;
            }
            QTreeWidget::item:selected {
                background-color: #e7f1ff;
                color: #2c3e50;
            }
            QTreeWidget::item:hover {
                background-color: #f7f9fa;
            }
            QHeaderView::section {
                background-color: #ecf0f1;
                color: #34495e;
                padding: 10px 5px;
                border: none;
                border-bottom: 2px solid #3498db;
                font-weight: bold;
            }
        """)

    def _populate_item_tree(self, tree: QtWidgets.QTreeWidget, items: list):
        """یک ویجت درختی مشخص را با لیست کالاهای داده شده پر می‌کند."""
        tree.setSortingEnabled(False)
        tree.clear()

        # --- *** اصلاح کلیدی: فراخوانی متد متمرکز برای تنظیم هدرها *** ---
        headers = ['کالا (پک/محصول مادر)', 'دسته', 'مقدار موجودی', 'واحد', 'حد سفارش', 'ID']
        self._style_tree(tree, headers=headers)
        
        header = tree.header()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, len(headers)):
            header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        tree.setColumnHidden(headers.index('ID'), True)
        # --- ********************************************************** ---

        if not items:
            set_empty_placeholder(tree, "هیچ کالایی در این دسته یافت نشد.")
            return

        items_by_id = {item['id']: dict(item) for item in items}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id and parent_id in items_by_id:
                if parent_id not in child_map: child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)
        
        tree.setUpdatesEnabled(False)
        for item_data in top_level_items:
            parent_item = NumericTreeWidgetItem(tree)
            parent_item.setText(0, item_data.get('name', ''))
            parent_item.setText(1, item_data.get('category', ''))
            parent_item.setText(2, str(item_data.get('non_prod_qty', 0)))
            parent_item.setText(3, item_data.get('unit', ''))
            parent_item.setText(4, str(item_data.get('min_qty', 0)))
            parent_item.setText(5, str(item_data.get('id')))
            parent_item.setData(0, Qt.UserRole, item_data)
            
            if item_data.get('min_qty', 0) > 0 and item_data.get('non_prod_qty', 0) < item_data.get('min_qty', 0):
                parent_item.setBackground(0, QtGui.QColor("#fff2f2"))
            
            if item_data['id'] in child_map:
                for child_data in child_map[item_data['id']]:
                    child_item = NumericTreeWidgetItem(parent_item)
                    child_item.setText(0, child_data.get('name', ''))
                    child_item.setText(1, child_data.get('category', ''))
                    child_item.setText(2, str(child_data.get('non_prod_qty', 0)))
                    child_item.setText(3, child_data.get('unit', ''))
                    child_item.setText(4, str(child_data.get('min_qty', 0)))
                    child_item.setText(5, str(child_data.get('id')))
                    child_item.setData(0, Qt.UserRole, child_data)
                    if child_data.get('min_qty', 0) > 0 and child_data.get('non_prod_qty', 0) < child_data.get('min_qty', 0):
                        child_item.setBackground(0, QtGui.QColor("#fff2f2"))
        
        tree.setUpdatesEnabled(True)
        tree.expandAll()
        tree.setSortingEnabled(True)                                                
                
    # BEGIN REWRITE: MainWindow._toggle_trans_view
    def _toggle_trans_view(self, state=None):
        """
        جابه‌جایی بین «جدول» و «درخت» با تحمل‌پذیری بالا:
        - اگر تب فعلی stack/tree نداشت، بی‌سروصدا تیک را به حالت جدول برمی‌گرداند و کاری نمی‌کند.
        - اگر داشت، بین table/tree با setCurrentWidget سوییچ می‌کند (ایمن‌تر از setCurrentIndex).
        """
        from PyQt5 import QtWidgets

        # اگر تب‌ها تعریف نشده‌اند، خروج
        if not hasattr(self, 'tab_widget_trans') or not hasattr(self, 'trans_views'):
            return

        # تب فعلی و ویجت‌های وابسته
        idx = self.tab_widget_trans.currentIndex()
        if idx < 0:
            return
        tab_name = self.tab_widget_trans.tabText(idx)
        view_dict = self.trans_views.get(tab_name)
        if not view_dict:
            return

        stack = view_dict.get('stack')
        table = view_dict.get('table')
        tree  = view_dict.get('tree')

        # اگر این تب اصلاً stack یا tree ندارد، سوییچ دید بی‌معنی است → تیک را برگردان
        if stack is None or tree is None or table is None:
            if hasattr(self, 'view_mode_check') and isinstance(self.view_mode_check, QtWidgets.QCheckBox):
                try:
                    self.view_mode_check.blockSignals(True)
                    self.view_mode_check.setChecked(False)
                finally:
                    self.view_mode_check.blockSignals(False)
            return

        # سوییچ بر اساس وضعیت تیک
        show_tree = False
        if hasattr(self, 'view_mode_check') and isinstance(self.view_mode_check, QtWidgets.QCheckBox):
            show_tree = self.view_mode_check.isChecked()

        # اگر درخت خواستیم ولی tree وجود ندارد، امن برگردیم به جدول
        try:
            if show_tree and tree is not None:
                stack.setCurrentWidget(tree)
            else:
                stack.setCurrentWidget(table)
        except Exception:
            # در هر خطایی، به جدول برگرد و تیک را بردار تا UI پایدار بماند
            try:
                stack.setCurrentWidget(table)
            except Exception:
                pass
            if hasattr(self, 'view_mode_check') and isinstance(self.view_mode_check, QtWidgets.QCheckBox):
                try:
                    self.view_mode_check.blockSignals(True)
                    self.view_mode_check.setChecked(False)
                finally:
                    self.view_mode_check.blockSignals(False)
    # END REWRITE: MainWindow._toggle_trans_view
                                                                        
                                                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_settings_page(self):
        if self.pg_settings.layout() is not None:
            while self.pg_settings.layout().count():
                item = self.pg_settings.layout().takeAt(0)
                if item.widget(): item.widget().deleteLater()
        
        layout = self.create_page_layout(self.pg_settings, "تنظیمات و ابزارها")
        
        scroll_area = QScrollArea(); scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("QScrollArea { border: none; background-color: transparent; }")
        layout.addWidget(scroll_area)
        
        content_widget = QWidget(); scroll_area.setWidget(content_widget)
        content_layout = QVBoxLayout(content_widget); content_layout.setSpacing(20)

        action_groups = {
            "مدیریت کاربران و دسترسی": [
                {'title': "مدیریت کاربران", 'subtitle': "افزودن، ویرایش و حذف حساب‌ها", 'icon': "system-users", 'color': "#e7f1ff", 'handler': self._open_user_manager, 'permission': 'settings:manage_users'},
                {'title': "مدیریت نقش‌ها", 'subtitle': "ایجاد نقش و تعیین سطح دسترسی‌ها", 'icon': "preferences-system", 'color': "#e7f1ff", 'handler': lambda: RoleManagerDialog(self.db, self).exec_(), 'permission': 'settings:manage_users'},
                {'title': "مدیریت تفویض اختیار", 'subtitle': "تعیین جانشین برای تایید فرآیندها", 'icon': "system-run", 'color': "#e7f1ff", 'handler': self._open_delegation_manager, 'permission': 'settings:manage_users'},
            ],
            "پیکربندی انبار": [
                {'title': "مدیریت لوکیشن‌ها", 'subtitle': "تعریف راهرو، قفسه و طبقه‌های انبار", 'icon': "folder-blue", 'color': "#e8f8f5", 'handler': lambda: LocationDialog(self.db, self).exec_(), 'permission': 'settings:manage_locations'},
                {'title': "مدیریت واحدها", 'subtitle': "تعریف واحدهای شمارش (کیلوگرم، عدد...)", 'icon': "view-fullscreen", 'color': "#e8f8f5", 'handler': self._open_uom_manager, 'permission': 'settings:manage_units'},
                {'title': "تنظیمات برنامه", 'subtitle': "تغییر پارامترهای حد سفارش و انقضا", 'icon': "configure", 'color': "#e8f8f5", 'handler': self._open_app_settings_dialog, 'permission': 'settings:manage_app'},
            ],
            "ابزارهای داده و گزارش‌گیری": [
                {'title': "تهیه پشتیبان", 'subtitle': "ایجاد فایل پشتیبان از کل دیتابیس", 'icon': "document-save-as", 'color': "#fef9e7", 'handler': self._backup_now, 'permission': 'settings:backup_restore'},
                {'title': "بازیابی اطلاعات", 'subtitle': "بازگرداندن اطلاعات از یک فایل پشتیبان", 'icon': "document-revert", 'color': "#fef9e7", 'handler': self._restore_db, 'permission': 'settings:backup_restore'},
                # --- *** کارت جدید برای ابزار تشخیصی *** ---
                {'title': "بررسی وضعیت سیستم", 'subtitle': "نمایش اطلاعات کاربر و دسترسی‌های فعلی", 'icon': "utilities-terminal", 'color': "#fef9e7", 'handler': lambda: SystemStatusDialog(self.user_info, self).exec_(), 'permission': 'page:view:settings'},
            ],
            "منطقه خطر": [
                {'title': "ریست کامل برنامه", 'subtitle': "حذف تمام داده‌ها و بازگشت به تنظیمات اولیه", 'icon': "dialog-warning", 'color': "#fdedec", 'handler': self._factory_reset_confirmed, 'permission': 'settings:factory_reset'},
                {'title': "گزارش تشخیصی سیستم", 'subtitle': "بررسی وضعیت داخلی فرآیندها و تنظیمات", 'icon': "utilities-terminal", 'color': "#fef9e7", 'handler': self._run_diagnostic_report, 'permission': 'settings:manage_app'},

            ]
        }
        
        row, col = 0, 0
        grid_layout = QtWidgets.QGridLayout(); grid_layout.setSpacing(20)

        for group_title, actions in action_groups.items():
            if not any(self.has_permission(action['permission']) for action in actions): continue
            
            group_container = QWidget(); group_layout = QVBoxLayout(group_container)
            
            title_label = QLabel(group_title); title_label.setFont(QFont(FONT_FAMILY, 12, QFont.Bold)); title_label.setStyleSheet("color: #34495e; margin-bottom: 5px; border-bottom: 2px solid #e0e0e0; padding-bottom: 5px;")
            group_layout.addWidget(title_label)

            for action_data in actions:
                if self.has_permission(action_data['permission']):
                    card = SettingsActionCard(action_data['icon'], action_data['color'], action_data['title'], action_data['subtitle'])
                    card.clicked.connect(action_data['handler'])
                    group_layout.addWidget(card)
            
            group_layout.addStretch()
            grid_layout.addWidget(group_container, row, col)
            
            col += 1
            if col > 1:
                col = 0
                row += 1
        
        content_layout.addLayout(grid_layout)
        content_layout.addStretch()
                
            
    def _create_my_tasks_widget(self):
        """ویجت کارتابل وظایف من را می‌سازد."""
        group = QtWidgets.QGroupBox("کارتابل وظایف من (برای اقدام دابل کلیک کنید)")
        layout = QtWidgets.QVBoxLayout(group)
        table = QtWidgets.QTableWidget(); self._style_table(table)
        table.itemDoubleClicked.connect(self._process_task_action)
        layout.addWidget(table)
        # یک نام مشخص به جدول می‌دهیم تا در رفرش پیدا شود
        table.setObjectName("tasks_table")
        return group
        
    def _open_delegation_manager(self):
        """دیالوگ مدیریت تفویض اختیار را باز می‌کند."""
        # فرض می‌کنیم هر کاربری می‌تواند اختیارات خود را تفویض کند
        DelegationManagerDialog(self.db, self.user_id, self).exec_()

    
                
                    
# این متد باید در کلاس MainWindow وجود داشته باشد
    def setup_auto_backup_timer(self):
        """تایمر اصلی برنامه را برای چک کردن زمان بکاپ تنظیم و فعال می‌کند."""
        self.backup_check_timer = QtCore.QTimer(self)
        # هر ۳۰ ثانیه یک بار چک می‌کند
        self.backup_check_timer.timeout.connect(self._check_for_scheduled_backup)
        self.backup_check_timer.start(5000000)
        print("INFO: Auto-backup check timer started (Interval: 30 seconds).")
                
# در کلاس MainWindow، این دو متد را جایگزین کنید

# در کلاس MainWindow، این متد را با نسخه تشخیصی زیر جایگزین کنید
    def _check_for_scheduled_backup(self):
        """نسخه تشخیصی: تمام مراحل چک کردن بکاپ را در کنسول چاپ می‌کند."""
        print("\n--- Running Auto-Backup Check ---")

        if self.role != 'Admin':
            print(f"DEBUG: Check failed. User role is '{self.role}', not 'Admin'.")
            return
        print("DEBUG: Role check passed (User is Admin).")

        is_enabled = self.db.get_setting('autobackup_enabled', 'false') == 'true'
        if not is_enabled:
            print("DEBUG: Check failed. Auto-backup is disabled in settings.")
            return
        print("DEBUG: Auto-backup is enabled.")

        try:
            # ۱. خواندن تنظیمات
            frequency_days = int(self.db.get_setting('autobackup_frequency_days', '1'))
            scheduled_time_str = self.db.get_setting('autobackup_time', '02:00')
            last_backup_date_str = self.db.get_setting('last_autobackup_date', '1970-01-01')

            print(f"DEBUG: Frequency set to: {frequency_days} day(s)")
            print(f"DEBUG: Scheduled time set to: {scheduled_time_str}")
            print(f"DEBUG: Last backup date found: {last_backup_date_str}")

            # ۲. تبدیل تاریخ و زمان‌ها
            scheduled_time = QtCore.QTime.fromString(scheduled_time_str, "HH:mm")
            last_backup_dt = dt.date.fromisoformat(last_backup_date_str)
            today_dt = dt.date.today()
            now_time = QtCore.QTime.currentTime()

            # ۳. محاسبه شرایط
            days_since_last_backup = (today_dt - last_backup_dt).days
            is_period_passed = days_since_last_backup >= frequency_days
            is_time_passed = now_time >= scheduled_time

            print(f"DEBUG: Current time is: {now_time.toString('HH:mm:ss')}")
            print(f"DEBUG: Days since last backup: {days_since_last_backup}")
            print(f"DEBUG: Condition 'is_period_passed' (>= {frequency_days} days): {is_period_passed}")
            print(f"DEBUG: Condition 'is_time_passed' (>= {scheduled_time_str}): {is_time_passed}")

            # ۴. تصمیم‌گیری نهایی
            if is_period_passed and is_time_passed:
                print("SUCCESS: Both conditions met. Triggering backup.")
                self._trigger_background_backup(is_auto=True)
            else:
                print("INFO: Conditions not met. No backup triggered this time.")

        except Exception as e:
            print(f"CRITICAL ERROR in auto-backup check logic: {e}")
            
                        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _on_backup_finished(self, success, message, is_auto=False):
        """این متد زمانی اجرا می‌شود که عملیات پشتیبان‌گیری تمام شده باشد."""
        if success:
            # برای بکاپ خودکار، فقط یک پیغام کوچک در پس‌زمینه نشان می‌دهیم
            if is_auto:
                self.toast.show_message("پشتیبان‌گیری خودکار با موفقیت انجام شد.", "info")
            else:
                self.toast.show_message(message, "success")

            # اگر بکاپ از نوع خودکار بود، تاریخ آن را در تنظیمات ثبت می‌کنیم
            if is_auto:
                today_str = dt.date.today().isoformat()
                self.db.set_setting('last_autobackup_date', today_str)
                print(f"INFO: Auto-backup successful. Updated last_autobackup_date to {today_str}")
        else:
            # برای بکاپ خودکار، خطا را در کنسول نشان می‌دهیم تا مزاحم کاربر نشود
            if is_auto:
                print(f"ERROR: Automatic backup failed: {message}")
            else:
                QtWidgets.QMessageBox.critical(self, "خطای پشتیبان‌گیری", message)
                                                
                                
    def _open_app_settings_dialog(self):
            """پنجره مدیریت تنظیمات برنامه را باز می‌کند."""
            AppSettingsDialog(self.db, self).exec_()
                    
    def _open_uom_manager(self):
        """پنجره مدیریت واحدهای اندازه‌گیری را باز می‌کند."""
        UomManagerDialog(self.db, self).exec_()
        
    # BEGIN REWRITE: MainWindow._factory_reset_confirmed
    def _factory_reset_confirmed(self):
        """
        دیالوگ ریست کامل برنامه با انتخاب‌پذیری، بکاپ، حذف پیوست‌ها، رمز تأیید
        و اجرای setup_database پس از ریست؛ سپس ری‌استارت برنامه.
        """
        from PyQt5 import QtWidgets, QtCore
        from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QGridLayout, QGroupBox,
                                    QLabel, QCheckBox, QLineEdit, QPushButton, QFileDialog, QMessageBox)
        import os, traceback

        dlg = QDialog(self)
        dlg.setWindowTitle("ریست کامل برنامه (بسیار خطرناک)")
        dlg.setModal(True)
        layout = QVBoxLayout(dlg)

        warn = QLabel(
            "<b>هشدار:</b> حذف دائمی داده‌ها!<br>"
            "کالاها، تراکنش‌ها، فرمول‌ها، فرم‌ها، دارایی‌ها، درخواست‌های خرید و سوابق ممیزی پاک می‌شوند.<br>"
            "پیش‌فرض: کاربران/نقش‌ها حذف نمی‌شوند. اگر می‌خواهید آن‌ها را هم پاک کنید، تیک بزنید.<br>"
            "قبل از ادامه، گزینهٔ بکاپ را بررسی کنید."
        )
        warn.setWordWrap(True)
        layout.addWidget(warn)

        grp_box = QGroupBox("انتخاب بخش‌هایی که حذف می‌شوند")
        grid = QGridLayout(grp_box)

        cb_inventory   = QCheckBox("انبار (stock/trans/...)");            cb_inventory.setChecked(True)
        cb_catalog     = QCheckBox("کاتالوگ (items/units/warehouses)");   cb_catalog.setChecked(True)
        cb_production  = QCheckBox("تولید/نسخه‌سازی (recipes/BOM)");      cb_production.setChecked(True)
        cb_forms       = QCheckBox("فرم‌ها (form_defs/entries)");         cb_forms.setChecked(True)
        cb_assets      = QCheckBox("دارایی‌ها");                           cb_assets.setChecked(True)
        cb_procure     = QCheckBox("تدارکات/PR/استعلام‌ها");               cb_procure.setChecked(True)
        cb_audit       = QCheckBox("سوابق ممیزی");                         cb_audit.setChecked(True)
        cb_users       = QCheckBox("کاربران و نقش‌ها (خیلی خطرناک)");      cb_users.setChecked(False)

        grid.addWidget(cb_inventory,  0, 0); grid.addWidget(cb_catalog,   0, 1)
        grid.addWidget(cb_production, 1, 0); grid.addWidget(cb_forms,     1, 1)
        grid.addWidget(cb_assets,     2, 0); grid.addWidget(cb_procure,   2, 1)
        grid.addWidget(cb_audit,      3, 0); grid.addWidget(cb_users,     3, 1)
        layout.addWidget(grp_box)

        opt_box = QGroupBox("بکاپ و پیوست‌ها")
        opt_lyt = QGridLayout(opt_box)

        cb_backup = QCheckBox("قبل از حذف، بکاپ کامل بگیر"); cb_backup.setChecked(False)
        lbl_dir = QLabel("پوشهٔ بکاپ:")
        le_dir  = QLineEdit(); le_dir.setPlaceholderText("مثلاً C:\\Backups"); le_dir.setEnabled(False)
        btn_pick = QPushButton("انتخاب پوشه…"); btn_pick.setEnabled(False)

        cb_attachments = QCheckBox("فایل‌های پیوست ذخیره‌شده هم حذف شوند"); cb_attachments.setChecked(True)

        def on_toggle_backup(state):
            en = (state == QtCore.Qt.Checked)
            le_dir.setEnabled(en); btn_pick.setEnabled(en)
        cb_backup.stateChanged.connect(on_toggle_backup)

        def pick_dir():
            d = QFileDialog.getExistingDirectory(self, "انتخاب پوشهٔ بکاپ")
            if d: le_dir.setText(d)
        btn_pick.clicked.connect(pick_dir)

        opt_lyt.addWidget(cb_backup,       0, 0, 1, 3)
        opt_lyt.addWidget(lbl_dir,         1, 0)
        opt_lyt.addWidget(le_dir,          1, 1)
        opt_lyt.addWidget(btn_pick,        1, 2)
        opt_lyt.addWidget(cb_attachments,  2, 0, 1, 3)
        layout.addWidget(opt_box)

        pass_box = QGroupBox("تأیید نهایی")
        pass_lyt = QGridLayout(pass_box)
        lbl_pass = QLabel("رمز تأیید ریست:")
        le_pass  = QLineEdit(); le_pass.setEchoMode(QLineEdit.Password)
        le_pass.setPlaceholderText("رمز ریست را وارد کنید")
        pass_lyt.addWidget(lbl_pass, 0, 0); pass_lyt.addWidget(le_pass, 0, 1)
        layout.addWidget(pass_box)

        btns = QHBoxLayout()
        btn_reset  = QPushButton("شروع ریست"); btn_reset.setEnabled(False)
        btn_cancel = QPushButton("انصراف")
        btns.addStretch(1); btns.addWidget(btn_cancel); btns.addWidget(btn_reset)
        layout.addLayout(btns)

        def update_enable():
            ok = bool(le_pass.text().strip())
            if cb_backup.isChecked():
                ok = ok and bool(le_dir.text().strip()) and os.path.isdir(le_dir.text().strip())
            btn_reset.setEnabled(ok)

        le_pass.textChanged.connect(update_enable)
        le_dir.textChanged.connect(update_enable)
        cb_backup.stateChanged.connect(lambda _: update_enable())
        btn_cancel.clicked.connect(dlg.reject)

        def do_reset():
            reply = QMessageBox.question(
                dlg, "تأیید نهایی",
                "آیا از ریست کامل اطمینان دارید؟ این کار غیرقابل بازگشت است.",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )
            if reply != QMessageBox.Yes:
                return

            selections = {
                'inventory':  cb_inventory.isChecked(),
                'catalog':    cb_catalog.isChecked(),
                'production': cb_production.isChecked(),
                'forms':      cb_forms.isChecked(),
                'assets':     cb_assets.isChecked(),
                'procurement':cb_procure.isChecked(),
                'audit':      cb_audit.isChecked(),
                'users':      cb_users.isChecked(),
            }
            include_attachments = cb_attachments.isChecked()
            backup_confirmed    = cb_backup.isChecked()
            backup_dir          = le_dir.text().strip() if backup_confirmed else None
            reset_password      = le_pass.text().strip()

            try:
                if hasattr(self, 'toast'):
                    self.toast.show_message("در حال اجرای ریست… لطفاً صبر کنید.", "info", msec=4000)
                QtWidgets.QApplication.processEvents()

                # 1) ریست دیتابیس طبق انتخاب‌ها
                result = self.db.factory_reset(
                    selections=selections,
                    include_attachments=include_attachments,
                    backup_confirmed=backup_confirmed,
                    backup_dir=backup_dir,
                    reset_password=reset_password
                )

                # 2) بلافاصله پس از ریست: آماده‌سازی ساختار/داده‌های پایه برای اجرای بعدی
                try:
                    setup_database(self.db)  # <— اضافه شد: فراخوانی یک‌بارِ setup_database
                except Exception as se:
                    # اگر آماده‌سازی خطا داد، به کاربر خبر بدهیم ولی ری‌استارت را ادامه می‌دهیم
                    if hasattr(self, 'toast'):
                        self.toast.show_message(f"آماده‌سازی پس از ریست با خطا مواجه شد: {se}", "warning", msec=6000)

                if hasattr(self, 'toast'):
                    self.toast.show_message("✔ ریست کامل شد. برنامه مجدداً راه‌اندازی می‌شود…", "success", msec=4000)

                # 3) ری‌استارت برنامه
                self.restart_on_close = True
                dlg.accept()
                self.close()

            except Exception as e:
                if hasattr(self, 'toast'):
                    self.toast.show_message(f"خطا در ریست: {e}", "critical", msec=6000)
                print(traceback.format_exc())

        btn_reset.clicked.connect(do_reset)
        dlg.resize(650, dlg.sizeHint().height())
        dlg.exec_()
    # END REWRITE: MainWindow._factory_reset_confirmed
                            
                    
# این دو تابع کاملا جدید را به کلاس MainWindow اضافه کن
    def _refresh_roles_cache(self):
        """لیست نقش‌ها را از دیتابیس می‌خواند و در حافظه موقت برنامه آپدیت می‌کند."""
        print("SYSTEM: Refreshing roles cache from database...")
        self.ALL_ROLES_CACHE = self.db.get_all_roles()

    def _open_user_manager_with_fresh_data(self):
        """پنجره مدیریت کاربران را با پاس دادن لیست به‌روز نقش‌ها باز می‌کند."""
        # این تابع همیشه از لیست کش شده و آپدیت شده استفاده می‌کند
        UserManager(self.db, self.ALL_ROLES_CACHE, self).exec_()            
                    
    # این دو تابع کاملا جدید را به کلاس MainWindow اضافه کن
    def _load_app_data(self):
        """داده‌های پراستفاده برنامه مثل لیست نقش‌ها را یک بار می‌خواند و ذخیره می‌کند."""
        print("INFO: Loading fresh app data (roles)...")
        self.ALL_ROLES_CACHE = self.db.get_all_roles()

    def _open_user_manager(self):
        """
        پنجره مدیریت کاربران را باز می‌کند و قبل از آن، لیست نقش‌ها را رفرش می‌کند.
        """
        # --- *** اصلاح کلیدی در این بخش *** ---
        # قبل از باز کردن دیالوگ، کش نقش‌ها را از دیتابیس رفرش می‌کنیم
        self._load_app_data()
        
        UserManager(self.db, self.ALL_ROLES_CACHE, self.user, self).exec_()
                    
    # این تابع کمکی جدید را هم به کلاس MainWindow اضافه کن
    def _handle_settings_click(self, item):
        """تابع کلیک آیتم‌های صفحه تنظیمات را اجرا می‌کند"""
        title = item.text()
        handler = self.settings_action_handlers.get(title)
        if handler:
            handler()
            

                                            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _update_sidebar_style(self, active_button):
        # استایل دکمه فعال با متن وسط‌چین
        active_style = """
            QPushButton {
                color: white;
                background-color: #4a6582;
                border: none;
                text-align: center;
                padding: 13px 22px;
                font-weight: bold;
            }
        """
        # استایل دکمه‌های غیرفعال با متن وسط‌چین
        inactive_style = """
            QPushButton {
                color: #eceff1;
                background-color: transparent;
                border: none;
                text-align: center;
                padding: 13px 22px;
            }
            QPushButton:hover {
                background-color: #34495e;
            }
        """
        
        for btn in self.sidebar_buttons:
            if not isinstance(btn, NotificationButton):
                if btn == active_button:
                    btn.setStyleSheet(active_style)
                else:
                    btn.setStyleSheet(inactive_style)
                                                                                                                    
    # ─── ساخت ردیف فیلتر برای یک QTableWidget ───────────────────────────────
    def _make_filter_row(self, table: QtWidgets.QTableWidget):
        if getattr(table, '_filter_done', False):
            return
        table._filter_done = True
        hdr = table.horizontalHeader()
        roww = QtWidgets.QWidget(table)
        lay  = QtWidgets.QHBoxLayout(roww); lay.setContentsMargins(0,0,0,0)
        edits=[]
        for col in range(table.columnCount()):
            edit = QtWidgets.QLineEdit(placeholderText='🔍')
            edit.setFixedHeight(20); edits.append(edit); lay.addWidget(edit, 1)
            edit.textChanged.connect(
                lambda txt, c=col, t=table:
                    [t.setRowHidden(r,
                        txt.lower() not in (t.item(r,c).text() if t.item(r,c) else '').lower())
                    for r in range(t.rowCount())])
        roww.setGeometry(hdr.geometry().adjusted(0, hdr.height(), 0, 0))
        roww.show()
        table.setViewportMargins(0, 25, 0, 0)   # فضا برای ردیف فیلتر

        
    # <<< FIX
    def _handle_attach(self, *_):
        """
        اگر دکمۀ پیوست فایلی نداشته باشد → دیالوگ انتخاب فایل را باز می‌کند
        اگر فایلی ثبت شده باشد → آن فایل را با برنامهٔ پیش‌فرض سیستم باز می‌کند
        """
        btn = self.sender()
        if not isinstance(btn, QtWidgets.QPushButton):
            return

        tid    = btn.property('trans_id')
        attach = btn.property('attach_path') or ''

        if attach and Path(attach).exists():
            QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(attach))
            return

        new_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if not new_path:
            return

        # یک‌دست با Pool/Transaction
        with self.db.transaction() as cur:
            cur.execute("UPDATE trans SET attach_path=%s WHERE id=%s", (new_path, tid))

        btn.setText('📎')
        btn.setProperty('attach_path', new_path)
        
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _show_pending_voids_dialog(self):
        """پنجره مدیریت ابطال‌های در انتظار تایید را باز می‌کند."""
        ApproveVoidDialog(self.db, self.user, self).exec_()
        
    # این متد جدید را به انتهای کلاس MainWindow اضافه کنید
    def _open_approve_void_dialog(self):
        """پنجره مدیریت ابطال‌های در انتظار تایید را باز می‌کند."""
        if not self.has_permission('transactions:void'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return
        ApproveVoidDialog(self.db, self.user, self).exec_()
        
        
    def _style_table(self, tbl, headers=None):
        """استایل مشترک برای Table/Tree؛ با هندلِ ایمن QTableWidget و QTreeWidget."""
        # تنظیمات عمومی (اگر پشتیبانی شوند)
        if hasattr(tbl, 'setAlternatingRowColors'):
            tbl.setAlternatingRowColors(True)
        if hasattr(tbl, 'setSelectionBehavior'):
            tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        if hasattr(tbl, 'setEditTriggers'):
            tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)

        # شاخهٔ مخصوص جدول‌ها
        if isinstance(tbl, QtWidgets.QTableWidget):
            try:
                vh = tbl.verticalHeader()
                if vh is not None:
                    vh.setVisible(False)
                    vh.setDefaultSectionSize(42)
            except Exception:
                pass
            try:
                hh = tbl.horizontalHeader()
                if hh is not None:
                    hh.setStretchLastSection(True)
                    hh.setDefaultAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
            except Exception:
                pass
            return tbl

        # شاخهٔ مخصوص درخت‌ها
        if isinstance(tbl, QtWidgets.QTreeWidget):
            try:
                hh = tbl.header()
                if hh is not None:
                    hh.setStretchLastSection(True)
                    hh.setDefaultAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                tbl.setIndentation(14)
                tbl.setRootIsDecorated(False)
                tbl.setUniformRowHeights(True)
            except Exception:
                pass
            return tbl

        # پیش‌فرض: هیچ‌کاری نکن
        return tbl
                                                                        
    # ─── کمک: آیا کاربر فقط ناظر است؟ ───
    def _viewer(self) -> bool:
            return self.role == "Viewer"
        
            
    def has_permission(self, required_perm: str) -> bool:
        """
        بررسی دسترسی؛ ادمین همیشه True.
        نام‌های قدیمی BOM/فرمول به کُد نهایی نگاشت می‌شوند تا تکراری ساخته نشود.
        ضمن بررسی، اگر کُد در DB نبود ساخته می‌شود تا در «مدیریت نقش‌ها» دیده شود.
        """
        if not required_perm:
            return False

        alias = (required_perm or '').strip().lower()
        # نگاشت محلی هماهنگ با DB
        if alias in (
            'production:formulaview',
            'production:view_bom_full',
            'production:bom_full:view',
            'production:formula:full_view',
            'production:formula_full_view',
            'production:formula:view_full',
            'production:bomfull:view',
        ):
            alias = 'production:formula:view'
        else:
            alias = required_perm

        # ادمین: ثبتِ کُد + True
        if getattr(self, 'role', None) == 'Admin':
            try:
                if hasattr(self, 'db') and self.db:
                    self.db.ensure_permission_exists(alias)
            except Exception:
                pass
            return True

        # سایر نقش‌ها: اگر نبود، بساز
        try:
            if hasattr(self, 'db') and self.db:
                self.db.ensure_permission_exists(alias)
        except Exception:
            pass

        current_perms = set(getattr(self, 'permissions', set()) or [])
        return alias in current_perms
        
    def _open_attach_dialog(self, trans_id: int):
        AttachDialog(self.db, trans_id, self).exec_()

        
    def _transfer(self):
        dlg=TransferDialog(self.db, self.user)
        if dlg.exec_():
            self.refresh_all(); self.toast.show_message('⇄ انتقال انجام شد')

        
        
    def export_table_to_excel(self, table: QtWidgets.QTableWidget):
            """
            این متد داخلی، کار را به تابع اصلی و قدرتمند سراسری واگذار می‌کند
            تا تاریخ‌های شمسی به درستی در خروجی اکسل نمایش داده شوند.
            """
            # فراخوانی تابع عمومی و پاس دادن پارامترهای لازم (جدول و خود پنجره اصلی به عنوان والد)
            export_table_to_excel(table, self)
        
    def _add_filter_row(self, table: QtWidgets.QTableWidget):
        """زیر هدر یک ردیف فیلتر (QLineEdit) می‌سازد."""
        hdr = table.horizontalHeader()
        # اگر قبلاً ساخته‌ایم دوباره نساز
        if getattr(table, '_filter_row', None):
            return
        filt_row = QtWidgets.QWidget(table)
        lay = QtWidgets.QHBoxLayout(filt_row); lay.setContentsMargins(0,0,0,0)
        edits = []
        for c in range(table.columnCount()):
            e = QtWidgets.QLineEdit(placeholderText='🔍')
            e.setFixedHeight(20)
            idx = c
            e.textChanged.connect(lambda txt, col=idx: self._column_filter(table, col, txt))
            edits.append(e); lay.addWidget(e)
        table.setCellWidget(0, 0, QtWidgets.QWidget())   # dummy to reserve row-0
        table.setViewportMargins(0, 25, 0, 0)
        filt_row.setGeometry(hdr.geometry().adjusted(0, hdr.height(), 0, 0))
        table._filter_row = filt_row
        filt_row.show()

    def _column_filter(self, table, col, pattern):
        for r in range(1, table.rowCount()):         # ردیف ۰ رزرو فیلتر است
            txt = table.item(r, col).text() if table.item(r, col) else ''
            hidden = pattern.lower() not in txt.lower()
            table.setRowHidden(r, hidden)

    def _quick_filter_table(self, table, pattern):
        for r in range(table.rowCount()):
            matched = any(pattern.lower() in (table.item(r,c).text()
                        if table.item(r,c) else '').lower()
                        for c in range(table.columnCount()))
            table.setRowHidden(r, not matched)

            
    def _void_selected_trans(self):
            # ... (بخش انتخاب آیتم از جدول که صحیح بود، بدون تغییر باقی می‌ماند) ...
            tab_widget = self.pg_trans.findChild(QtWidgets.QTabWidget)
            if not tab_widget: return
            
            view_dict = self.trans_views.get(tab_widget.tabText(tab_widget.currentIndex()))
            if not view_dict: return
            
            active_view = view_dict['stack'].currentWidget()
            selected_items = active_view.selectedItems()

            if not selected_items:
                self.toast.show_message("لطفاً یک تراکنش را برای ابطال انتخاب کنید.", "warning")
                return

            trans_id = None
            try:
                item = selected_items[0]
                if isinstance(item, QtWidgets.QTableWidgetItem):
                    trans_id = int(item.tableWidget().item(item.row(), 0).text())
                elif isinstance(item, QtWidgets.QTreeWidgetItem):
                    data = item.data(0, Qt.UserRole)
                    if data and data.get('type') == 'item' and data.get('trans_id'):
                        trans_id = data['trans_id']
                if not trans_id: return
            except (ValueError, AttributeError, IndexError):
                return

            # ... (بخش دریافت تایید از کاربر بدون تغییر است) ...
            reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا از لغو یا ابطال تراکنش شماره {trans_id} اطمینان دارید؟", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)

            if reply == QtWidgets.QMessageBox.Yes:
                try:
                    # --- اصلاح کلیدی در این بخش ---
                    # نتیجه‌ی بازگشتی از تابع دیتابیس حالا یک عضو Enum است
                    result_status_enum = self.db.void_transaction(trans_id, self.user_id)
                    
                    # بر اساس نوع نتیجه، پیام مناسب را نمایش می‌دهیم
                    if result_status_enum == TransactionStatus.VOIDED:
                        self.toast.show_message("✔ ابطال با موفقیت انجام شد.", "success")
                    elif result_status_enum == TransactionStatus.PENDING_VOID_APPROVAL:
                        self.toast.show_message("✔ درخواست ابطال برای تایید ارسال شد.", "info")
                    elif result_status_enum == TransactionStatus.CANCELLED:
                        self.toast.show_message("✔ درخواست تایید نشده با موفقیت لغو شد.", "success")
                    
                    self.refresh_all()
                except Exception as e:
                    self.toast.show_message(f"خطا در عملیات ابطال: {str(e)}", "critical")
                    print(f"ERROR during voiding transaction {trans_id}: {traceback.format_exc()}")
                
                                                                
        
# این دو متد را به کلاس MainWindow اضافه کنید

    def _open_void_batch_dialog(self):
        """دیالوگ انتخاب بچ فعال برای ابطال را با لیستی خوانا باز می‌کند."""
        if not self.has_permission('production:void_production'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return

        available_batches = self.db.get_available_bulk_products()
        if not available_batches:
            self.toast.show_message("هیچ بچ تولید فعالی برای ابطال وجود ندارد.", "info")
            return
        
        # ساخت لیست خوانا برای نمایش به کاربر
        choices = [f"{item['product_name']} (بچ: {item['production_batch_no']})" for item in available_batches]
        
        choice, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب بچ برای ابطال",
                                                    "کدام بچ تولید را می‌خواهید به طور کامل باطل کنید؟",
                                                    choices, 0, False)
        
        if ok and choice:
            # پیدا کردن بچ نامبر واقعی از روی آیتم انتخاب شده
            selected_index = choices.index(choice)
            selected_batch_no = available_batches[selected_index]['production_batch_no']
            self._void_production_batch_action(selected_batch_no)

# در کلاس MainWindow، این دو متد را جایگزین کنید
    def _void_production_batch_action(self, product_batch_no: str):
        """یک بچ تولید را پس از دریافت دلیل از کاربر، به طور کامل باطل می‌کند."""
        if not product_batch_no: return
        
        # استفاده از دیالوگ سفارشی جدید
        dlg = ReasonDialog("ابطال بچ تولید", f"لطفاً دلیل ابطال کامل بچ <b>{product_batch_no}</b> را وارد کنید:", self)
        if dlg.exec_():
            reason = dlg.reason # دلیل معتبر را از دیالوگ می‌خوانیم
            try:
                self.db.void_production_batch(product_batch_no, self.user_id, reason)
                self.toast.show_message(f"✔ بچ تولید {product_batch_no} با موفقیت باطل شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ابطال بچ با خطا مواجه شد:\n{e}")
                print(traceback.format_exc())

    def _open_void_packing_dialog(self):
        """پنجره انتخاب بچ بسته‌بندی شده برای ابطال را باز کرده و دلیل دریافت می‌کند."""
        if not self.has_permission('production:void_production'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error"); return

        prod_loc_id = self.db.get_production_floor_location()
        if not prod_loc_id:
            self.toast.show_message("انبار تولید در سیستم تعریف نشده است.", "critical"); return

        packed_batches = self.db.get_packed_batches_in_location(prod_loc_id)
        if not packed_batches:
            self.toast.show_message("هیچ محصول بسته‌بندی شده‌ای برای ابطال در انبار تولید وجود ندارد.", "info"); return
        
        choices = [f"{b['name']} (بچ: {b['batch_no']}, موجودی: {b['qty']})" for b in packed_batches]
        choice, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب بچ برای ابطال", "کدام عملیات بسته‌بندی را می‌خواهید باطل کنید؟", choices, 0, False)
        
        if ok and choice:
            selected_index = choices.index(choice)
            selected_batch_no = packed_batches[selected_index]['batch_no']
            
            # استفاده از دیالوگ سفارشی جدید
            reason_dlg = ReasonDialog("دلیل ابطال بسته‌بندی", f"لطفاً دلیل ابطال بسته‌بندی بچ <b>{selected_batch_no}</b> را وارد کنید:", self)
            if reason_dlg.exec_():
                reason = reason_dlg.reason
                try:
                    self.db.void_packing_operation(selected_batch_no, self.user_id, reason)
                    self.toast.show_message(f"✔ بسته‌بندی بچ {selected_batch_no} با موفقیت باطل شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ابطال بسته‌بندی با خطا مواجه شد:\n{e}")
                    print(traceback.format_exc())
                    
                                    
    def _add_item(self):
        if self.has_permission('items:create'):
            dlg = ItemDialog(self.db, self.user_id, self.role, item_id=None)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                # ریست جستجو و صفحه‌بندی، سپس ریفرش تب فعلی
                if hasattr(self, 'search_items'):
                    self.search_items.blockSignals(True)
                    self.search_items.clear()
                    self.search_items.blockSignals(False)
                if hasattr(self, 'items_category_tabs'):
                    idx = self.items_category_tabs.currentIndex()
                    if idx >= 0:
                        cur_tab = self.items_category_tabs.tabText(idx)
                        self.item_page_state.pop(cur_tab, None)
                        self._load_items_for_page(cur_tab)
                self.refresh_all()
                self.toast.show_message('✔ کالا با موفقیت اضافه شد', 'success')

    def _edit_item_from_table(self, item_id):
        if not item_id or not self.has_permission('items:edit'):
            return
        dlg = ItemDialog(self.db, self.user_id, self.role, item_id=item_id)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            if hasattr(self, 'search_items'):
                self.search_items.blockSignals(True)
                self.search_items.clear()
                self.search_items.blockSignals(False)
            if hasattr(self, 'items_category_tabs'):
                idx = self.items_category_tabs.currentIndex()
                if idx >= 0:
                    cur_tab = self.items_category_tabs.tabText(idx)
                    self.item_page_state.pop(cur_tab, None)
                    self._load_items_for_page(cur_tab)
            self.refresh_all()
            self.toast.show_message('✔ کالا با موفقیت ویرایش شد', 'success')
                                                                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _recalc_minmax(self):
        """
        نسخه نهایی و پایدار:
        - منطق محاسبه را از UI جدا کرده و داده‌ها را مستقیماً از دیتابیس می‌خواند.
        """
        if not self.has_permission('items:recalc_minmax'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return

        days, ok = QtWidgets.QInputDialog.getInt(self, "Lead Time", "روزهای زمان تأمین (Lead Time):", 14, 1, 90)
        if not ok:
            return

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            # گام ۱: دریافت لیست کالاها مستقیماً از دیتابیس
            all_items = self.db.get_all_transactional_items()
            if not all_items:
                self.toast.show_message("هیچ کالایی برای محاسبه یافت نشد.", "warning")
                return

            n = 0
            # گام ۲: اجرای محاسبه برای هر کالا
            for item in all_items:
                if self.db.calc_min_max(item['id'], days):
                    n += 1
            
            # گام ۳: رفرش کردن صفحه برای نمایش نتایج جدید
            self.refresh_all()

            if n > 0:
                self.toast.show_message(f"✅ Min/Max برای {n} کالا با موفقیت به‌روزرسانی شد.", "success")
            else:
                self.toast.show_message("هیچ کالایی با سابقه مصرف کافی برای محاسبه یافت نشد.", "warning")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
                        
    # ----------------------------------------
    def _new_trans(self, t_type, item_id=None, qty=None, doc_no=None, request_id=None):
        """
        به‌جای ثبت تک‌قلمی، «فرم سند چندقلمه» باز می‌شود.
        - برای هر قلم همچنان TransactionDialog موجود باز می‌شود (حفظ تمام امکانات قبلی).
        - در پایان، برای هر ردیف همان db.add_trans_extended صدا زده می‌شود.
        - نقاط ورود، نام‌ها و رفتار کلی بدون تغییر ظاهری باقی می‌مانند.
        """
        try:
            dlg = DocTransFormDialog(self.db, self.user_id, t_type, self)
            if doc_no:
                dlg.set_doc_no(doc_no)
            # اگر از جایی مقدار/کالا پاس داده شده، همان ابتدا یک قلم پیش‌فرض اضافه کن (بدون اجبار)
            if item_id is not None or qty is not None:
                dlg.add_prefilled(item_id=item_id, qty=qty)

            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                # پس از ثبت موفق، کل صفحه‌ها را رفرش کن تا گروه‌بندی بر اساس سند هم به‌روزرسانی شود
                self.refresh_all()
        except Exception as e:
            try:
                QtWidgets.QMessageBox.critical(self, "خطا", f"باز کردن فرم سند با مشکل مواجه شد:\n{e}")
            except Exception:
                print("OPEN_DOC_TRANS_FORM ERROR:", e)
    
        # BEGIN ADD: MainWindow._add_trans_to_current_document
    def _add_trans_to_current_document(self, trans_data: dict):
        """
        افزودن امن ردیف تراکنش:
        - اگر سند جاری فعال نباشد: دقیقاً مثل قبل، همین الآن در دیتابیس ثبت می‌کند.
        - اگر سند جاری فعال باشد: فقط اگر t_type و doc_no با سند جاری یکی باشند، به بافر اضافه می‌کند.
        (همه‌ی ردیف‌های یک سند باید یک نوع تراکنش داشته باشند.)
        """
        from PyQt5 import QtWidgets

        # بافرها/فلگ‌ها اگر وجود نداشتند، بسازیم (سازگار با نسخه‌های قدیمی)
        if not hasattr(self, "_doc_mode_active"):
            self._doc_mode_active = False
        if not hasattr(self, "_doc_pending"):
            self._doc_pending = []
        if not hasattr(self, "_doc_no_current"):
            self._doc_no_current = None
        if not hasattr(self, "_doc_ttype_current"):
            self._doc_ttype_current = None

        # اعتبارسنجی اولیه‌ی ورودی
        if not isinstance(trans_data, dict):
            QtWidgets.QMessageBox.critical(self, "خطا", "دادهٔ تراکنش نامعتبر است.")
            return
        t_type = (trans_data.get('t_type') or '').strip()
        doc_no = (trans_data.get('doc_no') or '').strip()
        if not t_type or not doc_no:
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص",
                                        "نوع تراکنش یا شماره سند خالی است.")
            return

        # حالت 1) سند جاری خاموش → همان رفتار قبلی: ثبت فوری
        if not self._doc_mode_active:
            try:
                self.db.add_trans_extended(trans_data, self.user_id)
                # پیام موفقیت
                if hasattr(self, "toast") and hasattr(self.toast, "show_message"):
                    self.toast.show_message("✔ تراکنش ثبت شد.", "success")
                else:
                    QtWidgets.QMessageBox.information(self, "موفق", "تراکنش ثبت شد.")
                # رفرش UI با مسیرهای موجود
                if hasattr(self, "refresh_all"):
                    try: self.refresh_all()
                    except Exception: pass
                elif hasattr(self, "_load_trans"):
                    try: self._load_trans()
                    except Exception: pass
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در ثبت", f"{e}")
            return

        # حالت 2) سند جاری روشن → کنترل «نوع یکسان» و «شماره‌سند یکسان»
        # اگر اولین ردیف این سند است، هویت سند را تثبیت کن
        if not self._doc_pending:
            self._doc_no_current = doc_no
            self._doc_ttype_current = t_type

        # بررسی همسانی‌ها
        if doc_no != self._doc_no_current:
            QtWidgets.QMessageBox.warning(
                self, "ناسازگاری شماره سند",
                f"شماره سند فعلی «{self._doc_no_current}» است؛ اما ردیف جدید «{doc_no}» دارد.\n"
                "لطفاً شماره سند را یکسان وارد کنید."
            )
            return
        if t_type != self._doc_ttype_current:
            QtWidgets.QMessageBox.warning(
                self, "ناسازگاری نوع تراکنش",
                f"نوع سند جاری «{self._doc_ttype_current}» است؛ ردیف جدید «{t_type}» است.\n"
                "در هر سند فقط یک نوع تراکنش مجاز است."
            )
            return

        # افزودن به بافر سند
        self._doc_pending.append(dict(trans_data))  # کپی امن
        count = len(self._doc_pending)
        # بازخورد به کاربر
        msg = f"➕ ردیف به سند «{self._doc_no_current}» اضافه شد. ({count} ردیف)"
        if hasattr(self, "toast") and hasattr(self.toast, "show_message"):
            self.toast.show_message(msg, "info")
        else:
            QtWidgets.QMessageBox.information(self, "افزوده شد", msg)
    # END ADD: MainWindow._add_trans_to_current_document

        
        
                
                                    
            
                                                                                                
                                                            
    def _filter_items(self, txt):
        for r in range(self.tbl_items.rowCount()):
            match = any(txt.lower() in self.tbl_items.item(r, c).text().lower()
                        for c in range(self.tbl_items.columnCount()))
            self.tbl_items.setRowHidden(r, not match)
            
    def _reset_items_filter(self):
        for r in range(self.tbl_items.rowCount()):
            self.tbl_items.setRowHidden(r, False)
        self.search_items.clear()

# این دو متد را در MainWindow جایگزین کنید
    def _backup_now(self):
        """پشتیبان‌گیری دستی را آغاز می‌کند."""
        self._trigger_background_backup(is_auto=False)

    # در کلاس MainWindow، این متد را جایگزین کنید
    def _trigger_background_backup(self, is_auto=False):
        """عملیات پشتیبان‌گیری را در یک رشته مجزا و با استفاده از مسیر سفارشی اجرا می‌کند."""
        try:
            with open(BASE_DIR / 'config.json', 'r', encoding='utf-8') as f: config = json.load(f)
        except Exception as e:
            self.toast.show_message(f"خطا در خواندن فایل کانفیگ: {e}", "critical"); return

        if is_auto:
            default_path = str(BASE_DIR / 'Auto_Backups')
            backup_path_str = self.db.get_setting('autobackup_path', default_path)
            backup_dir = Path(backup_path_str); backup_dir.mkdir(exist_ok=True)
            timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
            fname = str(backup_dir / f"auto_backup_{config.get('dbname', 'db')}_{timestamp}.backup")
        else:
            fname, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره فایل پشتیبان', f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.backup", "Backup Files (*.backup)")

        if not fname: return

        self.toast.show_message("عملیات پشتیبان‌گیری در پس‌زمینه شروع شد...", "info")

        self.backup_thread = QtCore.QThread()
        self.backup_worker = BackupWorker(config, fname)
        self.backup_worker.moveToThread(self.backup_thread)
        self.backup_thread.started.connect(self.backup_worker.run)
        self.backup_worker.finished.connect(partial(self._on_backup_finished, is_auto=is_auto))
        self.backup_worker.finished.connect(self.backup_thread.quit)
        self.backup_worker.finished.connect(self.backup_worker.deleteLater)
        self.backup_thread.finished.connect(self.backup_thread.deleteLater)

        # --- *** اصلاح کلیدی: پاک کردن متغیر پس از اتمام کار نخ *** ---
        self.backup_thread.finished.connect(lambda: setattr(self, 'backup_thread', None))

        self.backup_thread.start()
                    
            
                            
    def _restore_db(self):
            try:
                with open(BASE_DIR / 'config.json', 'r', encoding='utf-8') as f:
                    config = json.load(f)
            except Exception as e:
                # **FIX**: استفاده صحیح از متد show_message
                self.toast.show_message(f"خطا در خواندن فایل کانفیگ: {e}", "critical")
                return

            reply = QtWidgets.QMessageBox.warning(self, 'تایید بازیابی اطلاعات',
                                                "<b>هشدار جدی!</b><br><br>"
                                                "این عملیات، تمام اطلاعات فعلی برنامه را پاک کرده و اطلاعات فایل پشتیبان را جایگزین آن می‌کند. این عمل غیرقابل بازگشت است.<br><br>"
                                                "آیا کاملاً مطمئن هستید که می‌خواهید ادامه دهید؟",
                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel,
                                                QtWidgets.QMessageBox.Cancel)

            if reply != QtWidgets.QMessageBox.Yes:
                return

            fname, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل پشتیبان برای بازیابی', '', "Backup Files (*.backup)")
            if not fname:
                return

            # **FIX**: استفاده صحیح از متد show_message
            self.toast.show_message("در حال بازیابی اطلاعات... این عملیات ممکن است کمی طول بکشد.", "info", msec=5000)
            QtWidgets.QApplication.processEvents()
            
            if self.db and hasattr(self.db, 'conn') and self.db.conn:
                self.db.close()

            success, message = restore_database(config, fname)
            
            if success:
                QtWidgets.QMessageBox.information(self, "عملیات موفق", message)
                self.restart_on_close = True
                self.close()
            else:
                QtWidgets.QMessageBox.critical(self, "خطای بازیابی", message)
                sys.exit()
            
                                    
                                        

# در کلاس MainWindow، این متد را با نسخه جدید جایگزین کنید

    def refresh_all(self):
        """عملیات رفرش کامل برنامه را در یک رشته پس‌زمینه آغاز می‌کند."""
        self._start_background_refresh()
        
        #
    def _load_actionable_purchase_requests(self):
        """بارگذاری PRهای قابل اقدام برای بازرگانی (لیست سبک و قابل سورت)."""
        if not hasattr(self, 'tbl_actionable_prs'): return
        t = self.tbl_actionable_prs
        t.setSortingEnabled(False)
        t.setRowCount(0)
        headers = ['ID', 'نام کالا', 'مقدار درخواستی', 'فوریت', 'وضعیت']
        t.setColumnCount(len(headers))
        t.setHorizontalHeaderLabels(headers)

        rows = self.db.get_actionable_purchase_requests() or []
        t.setRowCount(len(rows))
        for r, rec in enumerate(rows):
            t.setItem(r, 0, QtWidgets.QTableWidgetItem(str(rec.get('id', ''))))
            t.setItem(r, 1, QtWidgets.QTableWidgetItem(str(rec.get('item_name', ''))))
            t.setItem(r, 2, QtWidgets.QTableWidgetItem(str(rec.get('requested_qty', ''))))
            t.setItem(r, 3, QtWidgets.QTableWidgetItem(str(rec.get('urgency', ''))))
            t.setItem(r, 4, QtWidgets.QTableWidgetItem(str(rec.get('status', ''))))

        t.setColumnHidden(0, True)
        t.resizeColumnsToContents()
        t.horizontalHeader().setSectionResizeMode(headers.index('نام کالا'), QtWidgets.QHeaderView.Stretch)
        try:
            set_empty_placeholder(t, "هیچ درخواست فعالی برای اقدام بازرگانی وجود ندارد.")
        except Exception:
            pass
        t.setSortingEnabled(True)
    
    
    def _load_purchase_orders(self):
        """جدول تاریخچه سفارشات خرید را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_purchase_orders'): return
        table = self.tbl_purchase_orders
        table.setRowCount(0)
        
        try:
            orders = self.db.get_all_purchase_orders()
            headers = ["ID", "شماره PO", "تامین‌کننده", "تاریخ صدور", "مبلغ کل", "وضعیت"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(orders))

            for r, order in enumerate(orders):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['po_number']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(order['supplier_name']))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(order['issue_date'])))
                table.setItem(r, 4, NumericTableWidgetItem(f"{order.get('total_amount', 0):,.0f}"))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(order['status']))

            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ سفارش خریدی تا کنون ثبت نشده است.")
        except Exception as e:
            print(f"Error loading purchase orders: {e}")
                                    
        
                    
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _on_item_load_finished(self, all_items_data):
        """پس از اتمام کار Worker، داده‌های جدید را در تب‌های کالا توزیع می‌کند."""
        try:
            if not all_items_data:
                return

            items_by_category = {
                "Finished Goods": [i for i in all_items_data if i['category'] == 'محصول نهایی'],
                "Raw Materials": [i for i in all_items_data if i['category'] == 'مواد اولیه'],
                "Packaging Supplies": [i for i in all_items_data if i['category'] == 'لوازم بسته‌بندی'],
                "Bulk Products": [i for i in all_items_data if i['category'] == 'محصول فله']
            }

            for key, tree in self.item_trees.items():
                self._populate_item_tree(tree, items_by_category.get(key, []))
            
            # پس از بارگذاری موفق، پنل جزئیات را پاک می‌کنیم
            if hasattr(self, 'details_stack'):
                self.details_stack.setCurrentWidget(self.details_placeholder)

        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            print("INFO: Items page UI updated from background thread.")
                    

                        
    def _assign_asset_action(self):
        """گردش کار تخصیص دارایی به پرسنل را با استفاده از log_asset_event مدیریت می‌کند."""
        dlg = AssignAssetDialog(self.db, self)
        if dlg.exec_():
            data = dlg.get_data()
            if data:
                try:
                    # --- اصلاح کلیدی: فراخوانی متد عمومی و هوشمند شده ---
                    full_notes = f"تحویل به: {data['employee_name']}"
                    self.db.log_asset_event(
                        asset_id=data['asset_id'],
                        t_type="تحویل به پرسنل", # نوع تراکنش را مشخص می‌کنیم
                        notes=full_notes,
                        t_no=data['doc_no'],
                        user_id=self.user_id
                    )
                    self.toast.show_message("✔ دارایی با موفقیت به پرسنل تحویل داده شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))

                            

    # BEGIN REWRITE: MainWindow._load_material_requests
    def _load_material_requests(self):
        """لیست «درخواست‌های مواد اولیه» را فقط با وضعیت‌های معوق نمایش می‌دهد
        (هر موردی که ارسال/تحویل/رد شده باشد از نمایش حذف می‌شود) و جدول را پر می‌کند."""
        from PyQt5 import QtWidgets, QtGui

        if not hasattr(self, 'tbl_material_requests'):
            return

        table = self.tbl_material_requests

        # --- 1) اطمینان از وجود نوار اکشن‌ها (یک‌بار) ---
        try:
            if self.has_permission('warehouse:fulfill_request'):
                if not getattr(self, '_mr_actions_ready', False):
                    parent = table.parent()
                    lay = parent.layout() if parent is not None else None
                    if isinstance(lay, QtWidgets.QVBoxLayout):
                        bar = QtWidgets.QHBoxLayout()
                        bar.setContentsMargins(0, 6, 0, 0)
                        bar.addStretch()

                        self.btn_mr_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), "رد کردن درخواست")
                        self.btn_mr_ok = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "رسیدگی به درخواست")
                        self.btn_mr_ok.setProperty("class", "primary")
                        for b in (self.btn_mr_reject, self.btn_mr_ok):
                            b.setMinimumHeight(35)

                        if hasattr(self, '_reject_material_request'):
                            self.btn_mr_reject.clicked.connect(self._reject_material_request)
                        if hasattr(self, '_fulfill_material_request'):
                            self.btn_mr_ok.clicked.connect(self._fulfill_material_request)

                        bar.addWidget(self.btn_mr_reject)
                        bar.addWidget(self.btn_mr_ok)
                        lay.addLayout(bar)
                        self._mr_actions_ready = True
        except Exception:
            pass

        # --- 2) خواندن و «فیلتر قطعی» در UI ---
        table.setSortingEnabled(False)
        table.clear()

        headers = ['ID درخواست', 'ID کالا', 'نام کالا', 'مقدار درخواستی', 'درخواست دهنده', 'تاریخ درخواست', 'وضعیت', 'یادداشت/دلیل رد']
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setRowCount(0)

        try:
            rows = self.db.get_pending_material_requests() or []

            # فقط وضعیت‌های «در انتظار رسیدگی انبار/نیازمند تأمین…/ارجاع به انبار…»
            def _is_pending(st: str) -> bool:
                s = (st or '').strip()
                s_low = s.lower()

                # انگلیسی‌های رایج
                eng_pending = {'pending', 'submitted', 'awaiting_approval', 'awaiting_fulfillment', 'awaiting_warehouse'}

                # فارسی‌های رایج
                fa_ok = False
                try:
                    fa_ok |= (s == TransactionStatus.MR_PENDING.value)
                except Exception:
                    pass
                try:
                    # اگر چنین وضعیتی دارید (ارجاع برای بازبینی انبار)
                    fa_ok |= (s == getattr(TransactionStatus, 'MR_REWORK_WAREHOUSE').value)
                except Exception:
                    pass
                # الگوهای متنی رایج
                fa_ok |= s.startswith('نیازمند تامین') or s.startswith('ارجاع') or s.startswith('در انتظار')

                return (s_low in eng_pending) or fa_ok or (s == '')

            # «فیلتر قطعی» در UI؛ هرچه غیر از معوق است حذف می‌شود
            rows = [r for r in rows if _is_pending(r.get('status'))]

            table.setRowCount(len(rows))
            REWORK_COLOR = QtGui.QColor("#fff3cd")

            for r, req in enumerate(rows):
                rid   = str(req.get('id') or '')
                iid   = str(req.get('item_id') or '')
                iname = str(req.get('item_name') or '')
                qty   = '' if req.get('requested_qty') is None else str(req.get('requested_qty'))
                rname = str(req.get('requester_name') or '-')
                ts    = to_shamsi(req.get('created_at'), include_time=True)
                st    = str(req.get('status') or '')
                note  = str(req.get('notes') or '')

                vals = [rid, iid, iname, qty, rname, ts, st, note]
                for c, v in enumerate(vals):
                    it = QtWidgets.QTableWidgetItem(v)
                    it.setToolTip(v)
                    table.setItem(r, c, it)

                try:
                    if st == TransactionStatus.MR_REWORK_WAREHOUSE.value:
                        for c in range(len(headers)):
                            cell = table.item(r, c)
                            if cell:
                                cell.setBackground(REWORK_COLOR)
                except Exception:
                    pass

            # ستون‌های ID پنهان + عرض‌ها
            table.setColumnHidden(0, True)
            table.setColumnHidden(1, True)
            table.resizeColumnsToContents()
            try:
                table.horizontalHeader().setStretchLastSection(True)
                table.horizontalHeader().setSectionResizeMode(headers.index('نام کالا'), QtWidgets.QHeaderView.Stretch)
                table.horizontalHeader().setSectionResizeMode(headers.index('یادداشت/دلیل رد'), QtWidgets.QHeaderView.Stretch)
            except Exception:
                pass

            set_empty_placeholder(table, "هیچ درخواست فعالی برای رسیدگی وجود ندارد.")
        except Exception as e:
            set_empty_placeholder(table, f"خطا در بارگذاری: {e}")

        table.setSortingEnabled(True)
    # END REWRITE: MainWindow._load_material_requests
        
    # BEGIN REWRITE: MainWindow._load_pending_deliveries
    def _load_pending_deliveries(self, table_widget=None):
        """
        لیست «محصولات منتظر تایید» با نوار اکشن پایینی (رد/تایید) مشابه صفحه «درخواست‌های مواد اولیه».
        - هیچ دکمه‌ای داخل سطرها ساخته نمی‌شود.
        - فقط یک‌بار (lazy) نوار اکشن ساخته و به متدهای گروهی وصل می‌شود.
        """
        from PyQt5 import QtWidgets, QtGui, QtCore

        # جدول هدف
        table = table_widget if table_widget is not None else getattr(self, 'tbl_pending_deliveries', None)
        if not table:
            return

        # 1) اطمینان از وجود نوار اکشن‌ها (مثل _load_material_requests)
        try:
            if not getattr(self, '_pd_actions_ready', False):
                parent = table.parent()
                lay = parent.layout() if parent is not None else None
                if isinstance(lay, QtWidgets.QVBoxLayout):
                    bar = QtWidgets.QHBoxLayout()
                    bar.setContentsMargins(0, 6, 0, 0)
                    bar.addStretch()

                    self.btn_pd_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), "رد")
                    self.btn_pd_ok     = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "تایید دریافت")
                    self.btn_pd_ok.setProperty("class", "primary")
                    for b in (self.btn_pd_reject, self.btn_pd_ok):
                        b.setMinimumHeight(35)

                    # اتصال اکشن‌ها (ایمن: اگر متد نبود، دکمه غیرفعال می‌شود)
                    if hasattr(self, '_approve_selected_deliveries'):
                        self.btn_pd_ok.clicked.connect(self._approve_selected_deliveries)
                    else:
                        self.btn_pd_ok.setEnabled(False)

                    if hasattr(self, '_reject_selected_deliveries'):
                        self.btn_pd_reject.clicked.connect(self._reject_selected_deliveries)
                    else:
                        # تا وقتی متد رد گروهی را اضافه نکرده‌ایم، غیرفعال بماند
                        self.btn_pd_reject.setEnabled(False)

                    bar.addWidget(self.btn_pd_reject)
                    bar.addWidget(self.btn_pd_ok)
                    lay.addLayout(bar)
                    self._pd_actions_ready = True
        except Exception:
            pass

        # 2) تنظیمات انتخاب چندتایی ردیفی (برای تایید/رد گروهی)
        table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        table.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

        # 3) پرکردن جدول (بدون دکمه سطری)
        table.setSortingEnabled(False)
        table.clearContents()
        table.setRowCount(0)

        headers = ['ID', 'نام محصول کامل', 'شماره بچ', 'مقدار', 'درخواست‌دهنده (سرپرست)', 'تاریخ درخواست']
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)

        try:
            rows = self.db.get_pending_deliveries() or []
            table.setRowCount(len(rows))

            def _full_name(r):
                child = (r.get('product_name') or r.get('item_name') or '').strip()
                parent = (r.get('parent_name') or '').strip()
                return f"{parent} - {child}" if parent else child

            for r, row in enumerate(rows):
                values = [
                    str(row.get('id') or ''),
                    _full_name(row),
                    row.get('production_batch_no') or row.get('batch_no') or '',
                    str(row.get('quantity') or ''),
                    row.get('supervisor_name') or '',
                    to_shamsi(row.get('created_at')),
                ]
                for c, val in enumerate(values):
                    it = QtWidgets.QTableWidgetItem(val)
                    it.setToolTip(val)
                    if c == 0:
                        it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
                    table.setItem(r, c, it)

            table.setColumnHidden(0, True)
            hh = table.horizontalHeader()
            try:
                hh.setSectionResizeMode(headers.index('نام محصول کامل'), QtWidgets.QHeaderView.Stretch)
                for c in (headers.index('مقدار'), headers.index('تاریخ درخواست')):
                    hh.setSectionResizeMode(c, QtWidgets.QHeaderView.ResizeToContents)
            except Exception:
                pass

            # پیام جایگزین وقتی لیست خالی است
            set_empty_placeholder(table, "هیچ درخواست تحویلِ در صف تایید وجود ندارد.")

        except Exception as e:
            set_empty_placeholder(table, f"خطا در بارگذاری: {e}")

        table.setSortingEnabled(True)
    # END REWRITE: MainWindow._load_pending_deliveries
            

    # BEGIN REWRITE: MainWindow._load_trans
    def _load_trans(self, index=None):
        """
        لودر تب جاری در صفحه «تراکنش‌ها».
        - برای تب‌های «عملیات انبار» و «تاریخچه دارایی»، لودرهای اختصاصی صدا می‌خورند و سوییچ Table/Tree غیرفعال است.
        - اگر تب بیرونی «ارتباط با تولید» باشد، زیرتبِ فعال پیدا می‌شود و لودر همان زیرتب اجرا می‌گردد.
        - برای سایر تب‌ها، منطق عمومی (Table/Tree) اجرا می‌شود.
        - ستون «پیوست» برای هر ردیف یک دکمهٔ 📎 دارد (در صورت نبود زیرساخت، به‌صورت متن 📎 نمایش داده می‌شود).
        """
        from PyQt5 import QtWidgets, QtCore, QtGui

        # سوییچ لاگ اختیاری
        try:
            DEBUG_TRACE
        except NameError:
            DEBUG_TRACE = False

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        try:
            if not hasattr(self, 'tab_widget_trans'):
                return
            if index is None:
                index = self.tab_widget_trans.currentIndex()
            tab_name = self.tab_widget_trans.tabText(index)

            # نقشه‌ی نام زیرتب ↔ متد لودر
            warehouse_ops_tabs = {
                'درخواست‌های مواد اولیه':  '_load_material_requests',
                'محصولات منتظر تایید':     '_load_pending_deliveries',
                'کالاهای برگشتی از تولید': '_load_pending_returns',
            }

            # --- حالت ویژه: تب بیرونی «ارتباط با تولید» → لودر زیرتب فعال
            if tab_name == 'ارتباط با تولید':
                # در این تب‌ها نمای درخت نداریم → چک را غیرفعال کن
                if hasattr(self, 'view_mode_check'):
                    self.view_mode_check.setEnabled(False)
                    self.view_mode_check.setChecked(False)

                # یافتن QTabWidgetِ زیرتب‌ها به‌صورت پویا (بدون وابستگی به نام متغیر)
                inner_tab = None
                try:
                    want = set(warehouse_ops_tabs.keys())
                    candidates = []
                    for tw in self.findChildren(QtWidgets.QTabWidget):
                        try:
                            tabs = [tw.tabText(i) for i in range(tw.count())]
                        except Exception:
                            continue
                        matches = sum(1 for t in tabs if t in want)
                        if matches >= 2:
                            candidates.append((matches, tw))
                    if candidates:
                        inner_tab = sorted(candidates, key=lambda x: x[0], reverse=True)[0][1]
                except Exception:
                    inner_tab = None

                loader_name = None
                if inner_tab is not None and inner_tab.count() > 0:
                    inner_idx = inner_tab.currentIndex()
                    inner_name = inner_tab.tabText(inner_idx)
                    loader_name = warehouse_ops_tabs.get(inner_name)

                if loader_name == '_load_internal_requests' and not hasattr(self, '_load_internal_requests'):
                    if hasattr(self, '_load_pending_internal_requests_for_warehouse'):
                        loader_name = '_load_pending_internal_requests_for_warehouse'

                if loader_name and hasattr(self, loader_name):
                    getattr(self, loader_name)()
                else:
                    if hasattr(self, '_load_pending_deliveries'):
                        self._load_pending_deliveries()
                return  # از منطق عمومی خارج شو

            # --- تب‌های اختصاصی که ممکن است مستقیماً تب بیرونی باشند
            if tab_name in warehouse_ops_tabs or tab_name == 'تاریخچه دارایی':
                if hasattr(self, 'view_mode_check'):
                    self.view_mode_check.setEnabled(False)
                    self.view_mode_check.setChecked(False)
                if tab_name == 'تاریخچه دارایی':
                    if hasattr(self, '_load_asset_trans'):
                        self._load_asset_trans()
                else:
                    loader_name = warehouse_ops_tabs[tab_name]
                    if loader_name == '_load_internal_requests':
                        if hasattr(self, '_load_pending_internal_requests_for_warehouse'):
                            self._load_pending_internal_requests_for_warehouse()
                        elif hasattr(self, '_load_internal_requests'):
                            self._load_internal_requests()
                        else:
                            pass
                    else:
                        if hasattr(self, loader_name):
                            getattr(self, loader_name)()
                return

            # --- سایر تب‌ها: منطق عمومی موجود شما ---
            if hasattr(self, 'view_mode_check'):
                self.view_mode_check.setEnabled(True)

            view = self.trans_views.get(tab_name)
            if not view:
                return
            table = view.get('table')
            tree  = view.get('tree')
            stack = view.get('stack')

            # پاکسازی امن
            if table:
                table.setSortingEnabled(False)
                table.setRowCount(0)
            if tree is not None:
                tree.setSortingEnabled(False)
                tree.clear()

            # دریافت داده‌ها از DB با زیرساخت فعلی
            rows = []
            if hasattr(self.db, 'get_all_transactions_detailed'):
                rows = self.db.get_all_transactions_detailed(t_type_filter=tab_name) or []
                
            # --- فیلتر نمایشی: مخفی کردن «تبدیلات تولید» از تراکنش‌های اصلی ---
            def _is_production_conversion(rec):
                ttype = (rec.get('t_type') or '').strip()
                tno   = (rec.get('t_no') or '').strip()
                if tno.startswith('CNV-'):
                    return True
                conv_types = { 'ورود از تبدیل', 'ورود (تبدیل)', 'خروج به تبدیل', 'خروج (تبدیل)', 'خروج از تبدیل' }
                return ttype in conv_types

            _before = len(rows)
            rows = [r for r in rows if not _is_production_conversion(r)]
            _after = len(rows)
            if getattr(self, "DEBUG_TRACE", False):
                print(f"[TRACE:MAIN] removed_conversion={_before - _after} kept={_after}")
            # --- پایان فیلتر نمایشی ---

            # سرستون‌ها (حفظ نام‌ها)
            headers = ['ID', 'نوع', 'کالا', 'شماره سند', 'تاریخ', 'مقدار', 'شماره بچ',
                    'تاریخ انقضا', 'وضعیت', 'یادداشت', 'کاربر', 'لوکیشن', 'پیوست']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setColumnHidden(0, True)
            table.setRowCount(len(rows))
            attach_col = headers.index('پیوست')

            # رنگ وضعیت
            STATUS_VISUALS = {
                TransactionStatus.APPROVED: {'color': QtGui.QColor("#e7f5e7"), 'strike': False},
                TransactionStatus.VOIDED: {'color': QtGui.QColor("#e9ecef"), 'strike': True},
                TransactionStatus.CANCELLED: {'color': QtGui.QColor("#e9ecef"), 'strike': True},
                TransactionStatus.PENDING_APPROVAL: {'color': QtGui.QColor("#cfe2ff"), 'strike': False},
                TransactionStatus.PENDING_PRODUCTION_APPROVAL: {'color': QtGui.QColor("#cfe2ff"), 'strike': False},
                TransactionStatus.PENDING_VOID_APPROVAL: {'color': QtGui.QColor("#fff3cd"), 'strike': False},
                TransactionStatus.REJECTED: {'color': QtGui.QColor("#f8d7da"), 'strike': False},
            }
            DEFAULT_VISUAL = {'color': QtGui.QColor("white"), 'strike': False}

            # پرکردن جدول
            for r, rec in enumerate(rows):
                st = (rec.get('status') or rec.get('وضعیت') or '').strip()
                st_enum = next((s for s in TransactionStatus if s.value == st), None)
                visual = STATUS_VISUALS.get(st_enum, DEFAULT_VISUAL)

                full_name = rec.get('item_name', '') or rec.get('کالا', '') or ''
                if rec.get('parent_name'):
                    full_name = f"{rec['parent_name']} - {full_name}"

                vals = [
                    str(rec.get('id','')),
                    rec.get('t_type','') or rec.get('نوع',''),
                    full_name,
                    rec.get('t_no','') or rec.get('شماره سند',''),
                    to_shamsi(rec.get('t_date') or rec.get('تاریخ')),
                    str(rec.get('qty','') or rec.get('مقدار','')),
                    rec.get('batch_no','') or rec.get('شماره بچ','') or '',
                    to_shamsi(rec.get('expiry_date') or rec.get('تاریخ انقضا')),
                    rec.get('status','') or rec.get('وضعیت',''),
                    rec.get('notes','') or rec.get('یادداشت','') or '',
                    rec.get('username','') or rec.get('کاربر','') or '',
                    rec.get('location_name','') or rec.get('لوکیشن','') or '',
                    ''  # ستون پیوست با ویجت پر می‌شود
                ]
                for c, val in enumerate(vals):
                    if c == attach_col:
                        continue  # این ستون را با دکمه پر می‌کنیم
                    it = QtWidgets.QTableWidgetItem(val)
                    it.setBackground(visual['color'])
                    if visual['strike']:
                        f = it.font(); f.setStrikeOut(True); it.setFont(f)
                    if c == 0:
                        it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
                    table.setItem(r, c, it)

                # دکمهٔ پیوست برای هر ردیف
                try:
                    trans_id = int(rec.get('id') or 0)
                except Exception:
                    trans_id = 0
                files_count = rec.get('attachments_count')
                if files_count is None:
                    files_count = 1 if rec.get('has_attachment') else 0
                try:
                    self._add_attachment_button(table, r, attach_col, trans_id, int(files_count or 0))
                except Exception:
                    table.setItem(r, attach_col, QtWidgets.QTableWidgetItem('📎' if files_count else ''))

            # اندازه ستون‌های مهم
            hh = table.horizontalHeader()
            try:
                hh.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)  # نام کالا
                for c in (4, 5, 8, attach_col):
                    hh.setSectionResizeMode(c, QtWidgets.QHeaderView.ResizeToContents)
            except Exception:
                pass

            # پرکردن درخت (اگر داریم)
            if tree is not None:
                tree.setHeaderLabels(headers[1:])  # بدون ستون ID
                groups = {}
                for rec in rows:
                    key = rec.get('t_no') or rec.get('شماره سند') or 'بدون سند'
                    groups.setdefault(key, []).append(rec)

                def _full_item_name(rec):
                    name = rec.get('item_name', '') or rec.get('کالا','') or ''
                    if rec.get('parent_name'):
                        name = f"{rec['parent_name']} - {name}"
                    return name

                def _row_color(status_text: str):
                    st_enum = next((s for s in TransactionStatus if s.value == (status_text or '').strip()), None)
                    return STATUS_VISUALS.get(st_enum, DEFAULT_VISUAL)['color']

                tree.clear()
                for doc_no, recs in groups.items():
                    first = recs[0]
                    parent_vals = [
                        first.get('t_type','') or first.get('نوع',''),
                        f"سند {doc_no}",
                        str(doc_no),
                        to_shamsi(first.get('t_date') or first.get('تاریخ')),
                        f"{sum(float(r.get('qty') or r.get('مقدار') or 0) for r in recs):g}" if recs else '',
                        '', '', '', '', first.get('username','') or first.get('کاربر','') or '',
                        first.get('location_name','') or first.get('لوکیشن','') or '', ''
                    ]
                    parent = QtWidgets.QTreeWidgetItem(parent_vals)
                    tree.addTopLevelItem(parent)
                    for rec in recs:
                        vals = [
                            rec.get('t_type','') or rec.get('نوع',''),
                            _full_item_name(rec),
                            rec.get('t_no','') or rec.get('شماره سند',''),
                            to_shamsi(rec.get('t_date') or rec.get('تاریخ')),
                            str(rec.get('qty','') or rec.get('مقدار','')),
                            rec.get('batch_no','') or rec.get('شماره بچ','') or '',
                            to_shamsi(rec.get('expiry_date') or rec.get('تاریخ انقضا')),
                            rec.get('status','') or rec.get('وضعیت',''),
                            rec.get('notes','') or rec.get('یادداشت','') or '',
                            rec.get('username','') or rec.get('کاربر','') or '',
                            rec.get('location_name','') or rec.get('لوکیشن','') or '',
                            '📎' if rec.get('has_attachment') or rec.get('files_count') else ''
                        ]
                        child = QtWidgets.QTreeWidgetItem(vals)
                        col = _row_color(rec.get('status') or rec.get('وضعیت'))
                        for i in range(len(vals)):
                            child.setBackground(i, col)
                        parent.addChild(child)
                tree.expandAll()

            # سویچ دید بر اساس تیک
            if stack is not None:
                if getattr(self, 'view_mode_check', None) and self.view_mode_check.isChecked() and (tree is not None):
                    stack.setCurrentWidget(tree)
                else:
                    stack.setCurrentWidget(table)

            if table:
                table.setSortingEnabled(True)
            if tree is not None:
                tree.setSortingEnabled(True)

        except :
            QtWidgets.QApplication.restoreOverrideCursor()
    # END REWRITE: MainWindow._load_trans
                                                            
    # در کلاس MainWindow
    def _add_attachment_button(self, table, row_index, col_index, trans_id, files_count):
        """یک دکمه پیوست زیبا به سلول مشخص شده در جدول اضافه می‌کند."""
        # این نسخه، تعداد فایل را به عنوان ورودی می‌گیرد و دیگر به دیتابیس کوئری نمی‌زند.
        attach_icon = self.style().standardIcon(QtWidgets.QStyle.SP_FileLinkIcon)
        btn_attach = QtWidgets.QPushButton(attach_icon, "")
        btn_attach.setProperty("class", "cell-button") # <-- این خط جدید را اضافه کنید

        
        btn_attach.setFixedSize(32, 32)
        btn_attach.setCursor(Qt.PointingHandCursor)
        btn_attach.setToolTip(f"مدیریت پیوست‌ها ({files_count} فایل)")
        btn_attach.setStyleSheet("""
            QPushButton { border: none; background-color: transparent; }
            QPushButton:hover { background-color: #e8e8e8; border-radius: 4px; }
        """)
        
        if files_count == 0:
            opacity_effect = QtWidgets.QGraphicsOpacityEffect()
            opacity_effect.setOpacity(0.4)
            btn_attach.setGraphicsEffect(opacity_effect)
        
        btn_attach.clicked.connect(partial(self._open_attach_dialog, trans_id))
        
        cell_widget = QtWidgets.QWidget()
        cell_layout = QtWidgets.QHBoxLayout(cell_widget)
        cell_layout.addWidget(btn_attach)
        cell_layout.setAlignment(Qt.AlignCenter)
        cell_layout.setContentsMargins(0, 0, 0, 0)
        table.setCellWidget(row_index, col_index, cell_widget)        
                
                                                                        
    def _create_graphical_action(self, icon_path, title, subtitle, parent_menu):
        """یک اکشن گرافیکی سفارشی برای استفاده در منو ایجاد می‌کند."""
        
        # ویجت اصلی که داخل منو قرار می‌گیرد
        widget = QtWidgets.QWidget()
        layout = QtWidgets.QHBoxLayout(widget)
        layout.setContentsMargins(15, 10, 15, 10) # حاشیه داخلی برای زیبایی
        layout.setSpacing(15)

        # بخش آیکون
        icon_label = QtWidgets.QLabel()
        pixmap = QtGui.QPixmap(icon_path).scaled(32, 32, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        icon_label.setPixmap(pixmap)
        
        # بخش متن (عنوان و زیرنویس)
        text_layout = QtWidgets.QVBoxLayout()
        text_layout.setSpacing(2)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt;")
        
        subtitle_label = QtWidgets.QLabel(subtitle)
        subtitle_label.setStyleSheet("color: #636e72;")

        text_layout.addWidget(title_label)
        text_layout.addWidget(subtitle_label)
        
        layout.addWidget(icon_label)
        layout.addLayout(text_layout)
        layout.addStretch()

        # ساخت QWidgetAction
        action = QtWidgets.QWidgetAction(parent_menu)
        action.setDefaultWidget(widget)
        return action
            

# در کلاس MainWindow، این متد را جایگزین کنید
    def _show_item_details_panel(self, item, column):
        """نسخه نهایی با منطق هوشمند کارتکس برای دکمه پنل جزئیات."""
        if not item:
            self.details_stack.setCurrentWidget(self.details_placeholder)
            return
        
        item_data = item.data(0, Qt.UserRole)
        if not isinstance(item_data, dict):
            self.details_stack.setCurrentWidget(self.details_placeholder)
            return

        self.details_stack.setCurrentWidget(self.details_container)
        while self.details_form_layout.count():
            child = self.details_form_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        def add_detail_row(label, value, is_numeric=False):
            if is_numeric:
                try: value = f"{float(value):,}"
                except (ValueError, TypeError): pass
            lbl_widget = QtWidgets.QLabel(f"<b>{value or '---'}</b>")
            lbl_widget.setTextInteractionFlags(Qt.TextSelectableByMouse)
            self.details_form_layout.addRow(label, lbl_widget)

        # ... (بخش نمایش اطلاعات مثل قبل) ...
        add_detail_row("نام کامل:", item_data.get('name')); add_detail_row("شناسه کالا (SKU):", item_data.get('sku')); add_detail_row("دسته:", item_data.get('category'))
        parent_id = item_data.get('parent_item_id')
        if parent_id:
            parent_info = self.db.get_item_details(parent_id)
            parent_name = parent_info.get('name', f"ID: {parent_id}") if parent_info else f"ID: {parent_id}"
            add_detail_row("محصول مادر:", parent_name)
        add_detail_row("وزن خالص:", f"{item_data.get('net_weight', 0)} Kg")
        total_qty_str = f"{item_data.get('non_prod_qty', 0)} {item_data.get('unit')}"
        add_detail_row("موجودی در دسترس:", total_qty_str); add_detail_row("حد سفارش (Min):", item_data.get('min_qty', 0), is_numeric=True); add_detail_row("حداکثر موجودی (Max):", item_data.get('max_qty', 0), is_numeric=True); add_detail_row("تأمین‌کننده:", item_data.get('supplier'))
        entry_date = item_data.get('ent_date')
        add_detail_row("تاریخ تعریف:", to_shamsi(entry_date.date() if hasattr(entry_date, 'date') else entry_date))
        details_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-in"), "مشاهده جزئیات کامل موجودی..."); details_btn.clicked.connect(lambda: DetailedStockViewDialog(self.db, item_data, self).exec_()); self.details_form_layout.addRow(details_btn)
        
        action_bar = self.action_bar
        while action_bar.layout().count():
            child = action_bar.layout().takeAt(0)
            if child.widget(): child.widget().deleteLater()
        
        item_id = item_data['id']
        item_name = item_data['name']
        button_style = "QPushButton { background-color: #f0f2f5; border: 1px solid #dcdcdc; border-radius: 5px; padding: 8px 12px; font-weight: bold; } QPushButton:hover { background-color: #e4e6e8; border-color: #b0b0b0; }"
        
        btn_barcode = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("barcodescanner"), " لیبل"); btn_barcode.setStyleSheet(button_style)
        btn_barcode.clicked.connect(lambda: BarcodeLabelDialog(item_name, str(item_id), self).exec_())
        action_bar.layout().addWidget(btn_barcode)
        
        if self.has_permission('items:edit'):
            btn_edit = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), " ویرایش"); btn_edit.setStyleSheet(button_style)
            btn_edit.clicked.connect(lambda: self._edit_item_from_table(item_id))
            action_bar.layout().addWidget(btn_edit)

        if self.has_permission('page:view:transactions'):
            btn_stock_card = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("x-office-document"), " کارتکس"); btn_stock_card.setStyleSheet(button_style)
            
            def export_smart_stock_card():
                ids_to_export = []
                filename_base = "Report"
                
                if item_data.get('is_parent_product'):
                    child_items = self.db.get_child_items(item_id)
                    ids_to_export = [child['id'] for child in child_items]
                    filename_base = item_data.get('name', 'Report')
                    if not ids_to_export:
                        self.toast.show_message("این محصول مادر هیچ پک (فرزند) تعریف شده‌ای برای گزارش‌گیری ندارد.", "warning")
                        return
                else:
                    ids_to_export = [item_id]
                    filename_base = item_data.get('name', 'Report')

                safe_filename_base = filename_base.replace('/', '-').replace('\\', '-')
                default_filename = f"Stock_Card_{safe_filename_base}.xlsx"
                
                path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره کارتکس انبار', default_filename, 'Excel (*.xlsx)')
                
                if path:
                    export_transactions_of_items(self.db, ids_to_export, path, self)
            
            btn_stock_card.clicked.connect(export_smart_stock_card)
            action_bar.layout().addWidget(btn_stock_card)
        
        action_bar.layout().addStretch()
        
        if self.has_permission('items:delete'):
            btn_delete = QtWidgets.QPushButton("🗑️"); btn_delete.setToolTip("حذف این کالا"); btn_delete.setStyleSheet("QPushButton { background-color: #ffebee; border: 1px solid #e57373; border-radius: 5px; font-size: 16pt; padding: 0px; } QPushButton:hover { background-color: #ffcdd2; }"); btn_delete.setFixedSize(38, 38); btn_delete.clicked.connect(lambda: self._delete_items([item_id])); action_bar.layout().addWidget(btn_delete)
            
                                                
# این متد جدید را به کلاس MainWindow اضافه کنید
# در کلاس MainWindow
    def _generate_multiple_barcodes(self, selected_ids: list):
        """برای لیستی از ID های کالا، بارکد تولید کرده و در یک پوشه ذخیره می‌کند."""
        if not selected_ids: return

        folder_path = QtWidgets.QFileDialog.getExistingDirectory(self, "پوشه‌ای برای ذخیره لیبل‌ها انتخاب کنید")
        if not folder_path:
            self.toast.show_message("عملیات لغو شد.", "info")
            return
            
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        success_count = 0
        error_count = 0
        try:
            for item_id in selected_ids:
                item_data = self.db.get_item_details(item_id)
                if item_data:
                    item_name = item_data.get('name', str(item_id))
                    file_name = f"Label_{item_data.get('sku') or item_name.replace(' ', '_')}.png"
                    full_path = Path(folder_path) / file_name
                    
                    # --- اصلاح: ارسال item_name به دیالوگ ---
                    dialog = BarcodeLabelDialog(item_name, str(item_id), self)
                    barcode_bytes = dialog.barcode_image_bytes
                    dialog.close() 

                    if barcode_bytes:
                        with open(full_path, 'wb') as f:
                            f.write(barcode_bytes)
                        success_count += 1
                    else:
                        error_count += 1
                else:
                    error_count += 1
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
        if success_count > 0:
            self.toast.show_message(f"✔ تعداد {success_count} لیبل با موفقیت در پوشه انتخابی ذخیره شد.", "success")
        if error_count > 0:
            self.toast.show_message(f"هشدار: برای {error_count} کالا لیبل تولید نشد.", "warning")
            
        
                                                                                                                                    
    def _open_item_action_menu(self, button, item_id):
        """یک منوی عملیات برای ردیف انتخاب شده در جدول کالاها باز می‌کند."""
        if not item_id: return

        menu = QtWidgets.QMenu(self)
        edit_action = menu.addAction(QtGui.QIcon.fromTheme("document-edit"), "ویرایش این کالا")
        trans_action = menu.addAction(QtGui.QIcon.fromTheme("view-history"), "مشاهده تاریخچه تراکنش‌ها")
        
        action = menu.exec_(button.mapToGlobal(QtCore.QPoint(0, button.height())))
        
        if action == edit_action:
            self._edit_item_from_table(item_id)
        elif action == trans_action:
            self._show_item_transactions(item_id)
            
# این متد جدید را به کلاس MainWindow اضافه کن
    def _iterate_all_tree_items(self, tree_widget):
        """یک generator برای پیمایش تمام آیتم‌های یک QTreeWidget (والد و فرزند)."""
        root = tree_widget.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            yield parent_item
            for j in range(parent_item.childCount()):
                yield parent_item.child(j)
                            
    def _show_item_transactions(self, item_id):
        """به صفحه تراکنش‌ها رفته و آن را برای کالای انتخاب شده فیلتر می‌کند."""
        if not item_id: return
        
        # پیدا کردن نام کالا برای استفاده در فیلتر
        item_data = self.db.get_item_details(item_id)
        if not item_data: return
        item_name = item_data.get('name')

        # رفتن به صفحه تراکنش‌ها
        self.pages.setCurrentWidget(self.pg_trans)
        
        # فیلتر کردن تمام تب‌های تراکنش
        for tab_name, table in self.trans_tabs.items():
            if tab_name == 'خروج دارایی': continue # این تب مربوط به کالا نیست
            
            # پیدا کردن ایندکس ستون 'کالا'
            try:
                header_labels = [table.horizontalHeaderItem(i).text() for i in range(table.columnCount())]
                name_col_idx = header_labels.index('کالا')
            except (ValueError, AttributeError):
                continue # اگر ستون وجود نداشت، از این تب بگذر

            # اعمال فیلتر
            for r in range(table.rowCount()):
                cell_item = table.item(r, name_col_idx)
                if cell_item and cell_item.text() == item_name:
                    table.setRowHidden(r, False)
                else:
                    table.setRowHidden(r, True)
                
        # ──────────────────────────────────────────────────────────────
    #  Helper: هم‌تراز کردن فیلد فیلتر با عرض واقعی هر ستون
    # ──────────────────────────────────────────────────────────────
    def _sync_filter_row(self, tbl: QtWidgets.QTableWidget):
        fr = getattr(tbl, '_filter_row', None)
        if not fr:                              # اگر هنوز ساخته نشده
            return

        hdr = tbl.horizontalHeader()
        lay = fr.layout()

        # پهنای هر QLineEdit = پهنای ستون متناظر
        for col in range(tbl.columnCount()):
            w = hdr.sectionSize(col)
            lay.itemAt(col).widget().setFixedWidth(w)

        # ردیف فیلتر دقیقاً زیر هدر بنشیند
        g = hdr.geometry()
        fr.setGeometry(g.left(), g.bottom(),
                    g.width(), fr.sizeHint().height())
        
    # ──────────────────────────────────────────────────────────────
    #  وقتی کاربر بین تب‌های «ورود/خروج/…» جابه‌جا می‌شود
    # ──────────────────────────────────────────────────────────────
    def _on_trans_tab_changed(self, idx: int):
        # idx همان ترتیب TYPES است که در _build_trans_page تعریف شده
        types = ('ورود', 'خروج', 'برگشت', 'انتقال', 'خروج دارایی')
        tp = types[idx] if idx < len(types) else None
        if tp and tp in self.trans_tabs:
            self._sync_filter_row(self.trans_tabs[tp])
            

        
    def _show_details_for_trans_item(self, item): # <<-- توجه: آرگومان column به طور کامل حذف شد
        """
        با دابل کلیک روی آیتم، کارت کالا را نمایش می‌دهد.
        این نسخه برای حل قطعی مشکل، دیگر به آرگومان column وابسته نیست.
        """
        data = None
        
        # ابتدا بررسی می‌کنیم که آیا آیتم از نوع درخت است یا خیر
        # این روش مطمئن‌تر از isinstance است
        if hasattr(item, 'childCount'): # فقط QTreeWidgetItem این متد را دارد
            # چون آیتم درخت است، داده را از ستون اول (0) می‌خوانیم
            data = item.data(0, Qt.UserRole)
        else:
            # اگر آیتم درخت نبود، پس حتما آیتم جدول است و متد data آن یک آرگومان می‌گیرد
            try:
                data = item.data(Qt.UserRole)
            except Exception as e:
                print(f"Error getting data from QTableWidgetItem: {e}")
                return
        
        if not data:
            return

        # بقیه منطق برای پردازش داده استخراج شده
        item_id = None
        if isinstance(data, dict):
            if data.get('type') == 'item':
                item_id = data.get('id')
        elif isinstance(data, int):
            item_id = data
            
        if item_id:
            StockCardDialog(self.db, item_id, self).exec_()
                                                                                                                            
    # <<< FIX
    def _handle_asset_attach(self, btn, trans_id, current_path):
        if current_path and Path(current_path).exists():
            QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(current_path))
            return

        new_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل پیوست')
        if not new_path:
            return

        # یک‌دست با Pool/Transaction
        with self.db.transaction() as cur:
            cur.execute("UPDATE asset_trans SET attach=%s WHERE id=%s", (new_path, trans_id))

        btn.setText("📎")
            
            

    def _style_asset_tree(self, tree: QtWidgets.QTreeWidget):
        """یک استایل اختصاصی برای درخت تاریخچه دارایی‌ها اعمال می‌کند."""
        tree.setAlternatingRowColors(True)
        tree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tree.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        
        headers = ['سند / دارایی', 'نوع تراکنش', 'تاریخ', 'کاربر', 'یادداشت', 'پیوست‌ها']
        tree.setHeaderLabels(headers)
        tree.header().setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
        tree.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        tree.header().setSectionResizeMode(5, QtWidgets.QHeaderView.ResizeToContents) # ستون پیوست
        

                
    # -----------------------------------------------------------------
    #  رویداد فیلتر براى resize TableViewport
    # -----------------------------------------------------------------
    def eventFilter(self, obj, ev):
        if ev.type() == QtCore.QEvent.Resize and isinstance(obj.parent(), QtWidgets.QTableWidget):
            self._sync_filter_row(obj.parent())
        return super().eventFilter(obj, ev)

    # ------------------------------------------------------------------
    #   نمایش ریزِ موجودی یک کالا در تمام لوکیشن‌ها
    #   (روی سطر جدول «کالاها» دوبار کلیک شود)
    # ------------------------------------------------------------------
    def _show_stock_locations(self, itm: QtWidgets.QTableWidgetItem):
        """
        روی هر ردیفِ جدول کالاها دابل-کلیک کنید تا پنجره‌ای باز شود
        که مقدار موجودی همان کالا را در تمام موقعیت‌های انبار نشان می‌دهد.
        """
        try:
            row = itm.row()
            iid = int(self.tbl_items.item(row, 0).text())   # ستون 0 = ID
        except (AttributeError, ValueError):
            return                                         # دادهٔ غیر معتبر

        StockLocationsDialog(self.db, iid, self).exec_()
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _apply_bom_advanced_filter(self, filters):
        """فیلترهای سفارشی را روی درخت تاریخچه مصرف اعمال می‌کند."""
        tree = self.tbl_bom
        product_filter = filters.get("product")
        material_filter = filters.get("material")
        batch_filter = filters.get("batch")

        root = tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            
            # بررسی مطابقت در آیتم والد (محصول)
            parent_text = parent_item.text(0).lower()
            parent_matches = not product_filter or product_filter in parent_text

            # بررسی مطابقت در آیتم‌های فرزند (مواد اولیه)
            any_child_matches = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j)
                material_name = child_item.text(0).lower()
                batch_name = child_item.text(1).lower()

                material_matches = not material_filter or material_filter in material_name
                batch_matches = not batch_filter or batch_filter in batch_name
                
                child_matches_this_row = material_matches and batch_matches
                child_item.setHidden(not child_matches_this_row)
                if not child_item.isHidden():
                    any_child_matches = True
            
            # تصمیم‌گیری نهایی برای نمایش والد
            parent_item.setHidden(not (parent_matches and any_child_matches))

    # <<< FIX
    def _asset_attach_click(self):
        btn  = self.sender()
        path = btn.property('path') or ''
        tid  = btn.property('row_id')

        # اگر فایل موجود است → باز کن
        if path and Path(path).exists():
            QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(path))
            return

        # در غیر این صورت انتخاب/ذخیره فایل جدید
        new_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if not new_path:
            return

        # قبلاً اینجا اشتباه به‌صورت مستقیم روی Connection، execute صدا زده می‌شد.
        # الان استاندارد و ایمن:
        with self.db.transaction() as cur:
            cur.execute("UPDATE asset_trans SET attach=%s WHERE id=%s", (new_path, tid))

        btn.setText('📎')
        btn.setProperty('path', new_path)

            
    def _goto_cat(self, cat):
        self.pages.setCurrentWidget(self.pg_items)
        self.search_items.setText(cat)
        
    # Override resizeEvent برای Toast
    def resizeEvent(self, e):
        super().resizeEvent(e)
        if self.toast.isVisible():
            g = self.geometry()
            self.toast.move(g.right()-self.toast.width()-20,
                            g.bottom()-self.toast.height()-40)
    # ═════════════════════════════════════════════
    #                رخدادهای جدول‌ها
    # ═════════════════════════════════════════════

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _delete_items(self, item_ids: list):
        """منطق کامل و صحیح حذف یک یا چند کالا."""
        reply = QtWidgets.QMessageBox.question(self, 'تایید حذف', 
            f"آیا از حذف {len(item_ids)} کالا و تمام رکوردهای وابسته به آن‌ها مطمئن هستید؟\nاین عمل غیرقابل بازگشت است!",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # --- اصلاح کلیدی: ارسال self.user_id به عنوان آرگومان دوم ---
                self.db.delete_items_by_ids(item_ids, self.user_id)
                self.refresh_all()
                self.toast.show_message(f'🗑 {len(item_ids)} کالا با موفقیت حذف شد', 'success')
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در حذف", f"عملیات حذف با خطا مواجه شد:\n{e}")                

    def _show_items_table_context_menu(self, pos: QtCore.QPoint):
        """
        نسخه نهایی و اصلاح‌شده:
        - منو دقیقاً زیر اشاره‌گر باز می‌شود (viewport).
        - انتخاب ردیف موقت در صورت راست‌کلیک روی ردیف غیرمنتخب.
        - دسترسی‌ها granular شده‌اند.
        """
        if not hasattr(self, 'items_category_tabs'):
            return

        # درخت فعال در تب جاری
        active_tab_widget = self.items_category_tabs.currentWidget()
        if not active_tab_widget:
            return
        tree = active_tab_widget.findChild(QtWidgets.QTreeWidget)
        if not tree:
            return

        # آیتم‌های انتخاب‌شده یا آیتم زیرِ مکان‌نما
        selected_items = tree.selectedItems()
        if not selected_items:
            item = tree.itemAt(pos)  # pos در مختصات viewport است
            if not item:
                return
            selected_items = [item]

        item_data = selected_items[0].data(0, Qt.UserRole)
        if not isinstance(item_data, dict) or not item_data.get('id'):
            return

        is_transactional_item = not item_data.get('is_parent_product', False)
        item_id = item_data['id']

        menu = QtWidgets.QMenu(self)

        # اکشن‌های سریع (ورود/خروج) فقط در صورتی که کاربر حداقل یکی از دسترسی‌های ورود/خروج را داشته باشد
        can_quick_entry = self.has_permission('transactions:create_entry')
        can_quick_exit  = self.has_permission('transactions:create_exit')
        if is_transactional_item and (can_quick_entry or can_quick_exit):
            if can_quick_entry:
                quick_entry_action = menu.addAction(QtGui.QIcon.fromTheme("list-add"), "ثبت ورود سریع برای این کالا")
                quick_entry_action.triggered.connect(lambda: self._new_trans("ورود", item_id=item_id))
            if can_quick_exit:
                quick_exit_action = menu.addAction(QtGui.QIcon.fromTheme("list-remove"), "ثبت خروج سریع برای این کالا")
                quick_exit_action.triggered.connect(lambda: self._new_trans("خروج", item_id=item_id))
            menu.addSeparator()

        # محاسبه لیست IDها برای گزارش/لیبل و ...
        ids_for_export = []
        is_single_parent_selected = False
        report_name = "Report"

        if len(selected_items) == 1:
            report_name = item_data.get('name', 'Report')
            if item_data.get('is_parent_product'):
                is_single_parent_selected = True
                parent_id = item_data.get('id')
                child_items = self.db.get_child_items(parent_id)
                ids_for_export.extend([child['id'] for child in child_items])

        if not is_single_parent_selected:
            selected_ids_data = [it.data(0, Qt.UserRole) for it in selected_items]
            ids_for_export.extend([
                d.get('id') for d in selected_ids_data
                if isinstance(d, dict) and d.get('id') is not None
            ])
            if len(selected_items) > 1:
                report_name = "Multiple_Items"

        if not ids_for_export and not is_transactional_item:
            return

        def handler_for_export():
            safe_filename = report_name.replace('/', '-').replace('\\', '-')
            default_filename = f"Stock_Card_{safe_filename}.xlsx"
            path, _ = QtWidgets.QFileDialog.getSaveFileName(
                self, 'ذخیره کارتکس انبار', default_filename, 'Excel (*.xlsx)'
            )
            if path:
                export_transactions_of_items(self.db, ids_for_export, path, self)

        actions_data = [
            {'icon': 'icons/edit.png',   'color': '#3498db', 'title': "ویرایش کالا",        'subtitle': "تغییر مشخصات اصلی کالا", 'handler': lambda: self._edit_item_from_table(item_id), 'single_only': True,  'permission': 'items:edit'},
            {'icon': 'icons/info.png',   'color': '#9b59b6', 'title': "نمایش لوکیشن‌ها",     'subtitle': "نمایش تمام مکان‌های نگهداری کالا",         'handler': lambda: StockLocationsDialog(self.db, item_id, self).exec_(), 'single_only': True,  'permission': 'page:view:items'},
            {'icon': 'icons/excel.png',  'color': '#1abc9c', 'title': "دریافت کارتکس انبار",'subtitle': f"خروجی اکسل برای {len(ids_for_export)} کالای انتخابی", 'handler': handler_for_export, 'single_only': False, 'permission': 'page:view:transactions'},
            {'icon': 'icons/barcode.png','color': '#2c3e50', 'title': "چاپ لیبل بارکد",      'subtitle': f"تولید لیبل برای {len(ids_for_export)} کالای انتخابی", 'handler': lambda: self._generate_multiple_barcodes(ids_for_export), 'single_only': False, 'permission': 'page:view:items'},
            {'icon': 'icons/delete.png', 'color': '#e74c3c', 'title': "حذف کالا(ها)",        'subtitle': f"حذف کامل {len(ids_for_export)} کالای انتخابی",         'handler': lambda: self._delete_items(ids_for_export), 'single_only': False, 'permission': 'items:delete'},
            # 🔧 اصلاح کلیدی: این اکشن باید روی دسترسی بازرگانی باشد
        ]

        added_actions = 0
        for data in actions_data:
            if self.has_permission(data['permission']):
                if data['single_only'] and len(selected_items) > 1:
                    continue
                action_widget = MenuActionWidget(data['icon'], data['title'], data['subtitle'], data['color'])
                action_widget.triggered.connect(data['handler'])
                action_widget.triggered.connect(menu.close)
                q_action = QtWidgets.QWidgetAction(menu)
                q_action.setDefaultWidget(action_widget)
                menu.addAction(q_action)
                added_actions += 1
                if data['title'] in ["دریافت کارتکس انبار", "چاپ لیبل بارکد"]:
                    menu.addSeparator()

        # باز کردن منو دقیقاً زیر نشانگر
        if added_actions > 0 or (is_transactional_item and (can_quick_entry or can_quick_exit)):
            global_pos = tree.viewport().mapToGlobal(pos)
            menu.exec_(global_pos)
                                                
            
                                                                        
                                                
    def _transfer_generic(self):
        """دیالوگ انتقال عمومی بین تمام انبارها را باز می‌کند"""
        # <<<<<<< اصلاح کلیدی: ارسال self.user_id >>>>>>>
        dlg = TransferDialog(self.db, self.user_id)
        if dlg.exec_():
            self.refresh_all()
            self.toast.show_message("✔ انتقال با موفقیت ثبت شد.")
            
    # در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def closeEvent(self, e: QtGui.QCloseEvent):
        """قبل از بستن برنامه، به صورت امن منتظر اتمام کار نخ‌های پس‌زمینه می‌ماند."""
        reply = QtWidgets.QMessageBox.question(
            self, 'خروج', 'آیا مطمئن هستید؟',
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        if reply == QtWidgets.QMessageBox.Yes:
            print("INFO: Close event accepted. Safely shutting down background threads...")

            # --- بلوک ایمن برای مدیریت نخ رفرش ---
            try:
                if hasattr(self, 'refresh_thread') and self.refresh_thread and self.refresh_thread.isRunning():
                    print("INFO: Waiting for refresh thread to finish...")
                    self.refresh_thread.quit()
                    self.refresh_thread.wait(2000) # حداکثر ۲ ثانیه منتظر بمان
            except RuntimeError:
                # این خطا زمانی رخ می‌دهد که نخ از قبل حذف شده باشد که مشکلی نیست
                print("INFO: Refresh thread was already deleted. Continuing shutdown.")

            # --- بلوک ایمن برای مدیریت نخ پشتیبان‌گیری ---
            try:
                if hasattr(self, 'backup_thread') and self.backup_thread and self.backup_thread.isRunning():
                    print("INFO: Waiting for backup thread to finish...")
                    self.backup_thread.quit()
                    self.backup_thread.wait(5000) # حداکثر ۵ ثانیه منتظر بمان
            except RuntimeError:
                print("INFO: Backup thread was already deleted. Continuing shutdown.")

            print("INFO: All threads shut down. Closing application.")
            e.accept()
        else:
            e.ignore()
                
# در کلاس MainWindow، این دو متد را پیدا کرده و با کدهای زیر جایگزین کنید

    def _filter_bom_tree(self, column, text):
        """نمای درختی تاریخچه مصرف را بر اساس ستون و متن مشخص شده فیلتر می‌کند."""
        root = self.tbl_bom.invisibleRootItem()
        
        for i in range(root.childCount()):
            parent_item = root.child(i)
            
            # منطق فیلتر بر اساس ستون انتخابی
            parent_matches = False
            if column == 'کد/نام محصول نهایی':
                parent_matches = text in parent_item.text(0).lower()
            elif column == 'کاربر':
                parent_matches = text in parent_item.text(4).lower()

            child_matches_found = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j)
                
                child_matches = False
                if column == 'نام ماده اولیه':
                    child_matches = text in child_item.text(0).lower()
                elif column == 'بچ ماده اولیه':
                    child_matches = text in child_item.text(1).lower()
                
                if child_matches:
                    child_item.setHidden(False)
                    child_matches_found = True
                else:
                    # اگر فیلتر روی ستون‌های والد اعمال شده، فرزندان را نمایش بده
                    child_item.setHidden(parent_matches)

            if parent_matches or child_matches_found:
                parent_item.setHidden(False)
                # اگر والد به تنهایی مچ شده، تمام فرزندانش را نمایش بده
                if parent_matches and not child_matches_found:
                    for j in range(parent_item.childCount()):
                        parent_item.child(j).setHidden(False)
            else:
                parent_item.setHidden(True)
                

    # [inventory.py] در کلاس MainWindow
    def _request_material(self):
        """
        دیالوگ «درخواست مواد/لوازم» را باز می‌کند (چندقلمه‌ای).
        افزوده شد: امکان وارد کردن شماره سند سفارشی توسط کاربر.
        """
        from PyQt5 import QtWidgets
        import re

        dlg = RequestMaterialDialog(self.db, self)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        data = dlg.get_request_data()
        if not data:
            return

        try:
            # سازگاری با خروجی‌های قدیمی
            if isinstance(data, dict) and 'lines' not in data:
                lines = [{'item_id': data.get('item_id'), 'quantity': data.get('quantity')}]
                notes = ''
            else:
                lines = list(data.get('lines') or [])
                notes = data.get('notes') or ''

            if not lines:
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message("هیچ قلم معتبری انتخاب نشده است.", "warning")
                else:
                    QtWidgets.QMessageBox.warning(self, "ثبت درخواست", "هیچ قلم معتبری انتخاب نشده است.")
                return

            # قبل از submit_material_request_bulk این بلوک را بگذار/جایگزین کن
            doc_no, ok = QtWidgets.QInputDialog.getText(
                self, "شماره سند خروج",
                "شماره سند/حواله را وارد کن (اختیاری):"
            )

            # ⬅️ ضربدر/Cancel = لغو کامل عملیات
            if not ok:
                return

            doc_no = (doc_no or "").strip()

            # خالی با OK = ادامه با MR-… پیش‌فرض
            notes_aug = notes
            if doc_no:
                import re
                doc_no = re.sub(r"[^A-Za-z0-9_\-]+", "", doc_no).strip("_-")
                notes_aug = f"[DOCNO:{doc_no}] {notes}".strip()

            parent_id = self.db.submit_material_request_bulk(
                lines, requester_id=self.user_id, notes=notes_aug
            )

            shown_doc = doc_no if doc_no else f"MR-{parent_id}"
            if hasattr(self, 'toast') and self.toast:
                self.toast.show_message(f"✔ درخواست ثبت شد (شماره سند: {shown_doc}).", "success")
            else:
                QtWidgets.QMessageBox.information(self, "ثبت درخواست",
                                                f"درخواست با موفقیت ثبت شد (شماره سند: {shown_doc}).")

            # رفرش
            try:
                if hasattr(self, '_load_material_requests'):
                    self._load_material_requests()
                elif hasattr(self, 'refresh_all'):
                    self.refresh_all()
            except Exception:
                pass

        except Exception as e:
            if hasattr(self, 'toast') and self.toast:
                self.toast.show_message(f"خطا در ثبت درخواست: {e}", "critical")
            else:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست: {e}")
                                                                    
    def _open_deliver_to_lab_dialog(self):
        """دیالوگ ثبت خروج به آزمایشگاه را باز کرده و عملیات را انجام می‌دهد."""
        if not self.has_permission('production:report'): # فرض می‌کنیم دسترسی اینکار با گزارش تولید یکی است
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return
            
        dlg = DeliverToLabDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    self.db.add_lab_delivery_trans(
                        item_id=data['item_id'],
                        qty=data['qty'],
                        batch_no=data['batch_no'],
                        expiry_date=data['expiry_date'],
                        notes=data['notes'],
                        user_id=self.user_id
                    )
                    self.toast.show_message("✔ خروج به آزمایشگاه با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ثبت خروج به آزمایشگاه با خطا مواجه شد:\n{e}")
                    print(traceback.format_exc())
                    
    def _wire_production_other_ops_menu(self):
        """
        ساخت منوی «سایر عملیات تولید» + افزودن تبدیل A→B.
        دسترسی‌ها مثل قبل کنترل می‌شوند و اگر ساختار UI فرق داشت، بی‌صدا رد می‌شود.
        """
        try:
            if not hasattr(self, 'btn_production_other_ops'):
                return
            btn = self.btn_production_other_ops
            menu = QtWidgets.QMenu(btn)

            # 1) تحویل محصول بسته‌بندی‌شده به انبار
            if self.has_permission('production:ops:deliver') or self.has_permission('production:packing'):
                act = menu.addAction("تحویل محصول بسته‌بندی شده به انبار")
                act.triggered.connect(self._open_deliver_packaged_good_dialog)

            # 2) برگشت مواد اولیه به انبار
            if (self.has_permission('production:ops:return')
                or self.has_permission('production:request_materials')
                or self.has_permission('transactions:transfer')):
                act = menu.addAction("برگشت مواد اولیه به انبار")
                act.triggered.connect(self._open_return_material_dialog)

            menu.addSeparator()

            # 3) الگو و اجرای تبدیل A→B
            # اجازه پیش‌فرض: هر کس 'transactions:convert' یا 'transactions:transfer' دارد
            can_convert = self.has_permission('transactions:convert') or self.has_permission('transactions:transfer')
            if can_convert:

                act_run = menu.addAction("اجرای تبدیل A→B")
                act_run.triggered.connect(self._open_execute_conversion_dialog)

            # اتصال منو به دکمه
            btn.setMenu(menu)
            btn.setPopupMode(QtWidgets.QToolButton.InstantPopup)

            # تضمین ثبت مجوزها (اگر قبلاً ثبت شده باشند، مشکلی نیست)
            if hasattr(self, 'db'):
                self.db.ensure_permission_exists('production:ops:deliver')
                self.db.ensure_permission_exists('production:ops:return')
                self.db.ensure_permission_exists('transactions:convert')

        except Exception as e:
            print('WARN _wire_production_other_ops_menu:', e)
            
    def _is_widget_alive(self, w) -> bool:
        if w is None:
            return False
        try:
            # PyQt5
            from sip import isdeleted  # type: ignore
            return not isdeleted(w)
        except Exception:
            # راه‌حل عمومی‌تر: اگر metaObject صدا خورد، زنده است
            try:
                _ = w.metaObject()
                return True
            except Exception:
                return False

    # 2) آیا اجازهٔ دیدن کامل BOM/فرمول دارد؟
    def _can_view_production_formulas(self) -> bool:
        try:
            if getattr(self, 'role', None) == 'Admin':
                return True
            return bool(
                self.has_permission('production:formula:view') or
                self.has_permission('production:confidentiality:manage')
            )
        except Exception:
            return False

    def _apply_production_privacy(self):
        """
        اگر اجازهٔ 'production:formula:view' یا 'production:confidentiality:manage' نداشته باشی:
        - تب BOM فقط «غیرفعال» می‌شود (حذف نمی‌کنیم تا ارور شیء پاک‌شده نگیری).
        - روی جدول‌های تولید Delegateِ ماسک می‌گذاریم تا چیزی لو نرود.
        """
        try:
            from PyQt5 import QtCore, QtWidgets
        except Exception:
            from PySide2 import QtCore, QtWidgets

        if not hasattr(self, 'pg_prod') or self.pg_prod is None:
            return

        can_view = self._can_view_production_formulas()

        # تب‌های داخل صفحه تولید را پیدا کن و تب BOM را فقط غیرفعال/قفل کن
        for tabs in self.pg_prod.findChildren(QtWidgets.QTabWidget):
            for i in range(tabs.count()):
                try:
                    t = (tabs.tabText(i) or '').strip().lower()
                except Exception:
                    t = ''
                is_bom_tab = ('bom' in t) or ('تاریخچه' in t and 'مصرف' in t)
                if is_bom_tab:
                    tabs.setTabEnabled(i, bool(can_view))
                    if not can_view:
                        tabs.setTabText(i, 'محرمانه')
                    else:
                        # برگرداندن عنوان معمولی اگر قبلاً محرمانه شده بود
                        if tabs.tabText(i) == 'محرمانه':
                            tabs.setTabText(i, 'تاریخچه مصرف (BOM)')

        # ماسک کردن متون حساس داخل جدول‌ها وقتی مجوز نداری
        if not can_view:
            # Delegate ساده برای پوشاندن متن
            class _MaskDelegate(QtWidgets.QStyledItemDelegate):
                def __init__(self, parent=None):
                    super().__init__(parent)
                def displayText(self, value, locale):
                    return 'محرمانه' if value not in (None, '') else ''

            tables = list(self.pg_prod.findChildren(QtWidgets.QTableView)) + \
                     list(self.pg_prod.findChildren(QtWidgets.QTableWidget))
            for tv in tables:
                if self._is_widget_alive(tv):
                    tv.setItemDelegate(_MaskDelegate(tv))                    

        
        
    # BEGIN REWRITE: MainWindow._load_delivery_history (only "entry from production" + pack-first)
    def _load_delivery_history(self):
        """
        فقط «از تولید به انبار» را نشان بده؛
        ترجیح با «محصول بسته‌بندی». اگر نشانۀ بسته‌بندی پیدا نشد، جدول خالی نشود.
        """
        from PyQt5 import QtWidgets, QtCore

        if not hasattr(self, 'tbl_delivery_history'):
            return

        table = self.tbl_delivery_history
        try:
            QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)

            headers = ['تاریخ', 'شماره سند', 'نوع/شرح', 'بچ', 'انبار مبدا', 'انبار مقصد', 'مقدار', 'محصول بسته‌بندی']
            table.setSortingEnabled(False)
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(0)

            # بازهٔ دو سال اخیر
            import datetime as _dt
            today = _dt.date.today()
            d_from = (today - _dt.timedelta(days=730)).isoformat()
            d_to   = today.isoformat()

            rows = self.db.get_delivery_history(date_from=d_from, date_to=d_to,
                                                warehouse_name=None, limit=3000) or []

            # نام انبار تولید
            try:
                prod_name = PRODUCTION_WAREHOUSE_NAME
            except NameError:
                prod_name = 'انبار تولید'
            def _norm(x): return str(x or '').strip().lower()
            prod_names = {_norm(prod_name), 'production', 'انبار تولید'}

            # نوع‌ها
            to_prod_types      = {_norm('خروج به تولید'), 'exit_to_prod', 'exit to prod', 'exit_to_production'}
            from_prod_types    = {_norm('ورود از تولید'), _norm('برگشت از تولید'),
                                'entry_from_prod', 'return_from_prod', 'entry from production'}
            entry_from_types   = {_norm('ورود از تولید'), 'entry_from_prod', 'entry from production'}
            return_from_types  = {_norm('برگشت از تولید'), 'return_from_prod'}

            # دسته‌بندی اولیه
            from_prod = []
            for rec in rows:
                src = _norm(rec.get('src_wh'))
                dst = _norm(rec.get('dest_wh'))
                typ = _norm(rec.get('t_type'))

                if typ in from_prod_types:
                    from_prod.append(rec); continue
                # اگر نوع نبود، از جهت کمک بگیر
                if src in prod_names and (not dst or dst not in prod_names):
                    from_prod.append(rec); continue

            # فقط «ورود از تولید» (برگشتی‌ها حذف)
            def _is_entry_from_prod(rec):
                typ = _norm(rec.get('t_type'))
                if typ in entry_from_types:
                    return True
                if typ in return_from_types:
                    return False
                # اگر نوع مبهم بود: مبدا تولید و مقصد غیرتولید را «ورود» فرض می‌کنیم
                src = _norm(rec.get('src_wh')); dst = _norm(rec.get('dest_wh'))
                return (src in prod_names) and (dst not in prod_names)

            entry_from_prod = [r for r in from_prod if _is_entry_from_prod(r)]

            # فیلتر بسته‌بندی (ایمن)
            def _truthy(v):
                s = str(v).strip().lower()
                return s in ('1', 'true', 't', 'yes', 'y', 'بله')

            def _is_pack_row(rec: dict) -> bool:
                # فلگ‌های معمول
                for k in ('is_pack', 'is_packaged', 'is_fg', 'finished_good'):
                    if k in rec and _truthy(rec.get(k)):
                        return True
                # توضیح/نوع شامل بسته‌بندی
                typ = _norm(rec.get('t_type') or rec.get('desc') or rec.get('description'))
                if any(kw in typ for kw in ('pack', 'بسته', 'بسته‌بندی')):
                    return True
                # نام‌های رایج محصول بسته‌ای
                for k in ('pack_product','packaged_product','product_pack','pack_name','pack_sku','pack_code'):
                    if str(rec.get(k) or '').strip():
                        return True
                # اگر فقط item_name داریم و چیزی از raw/مواد اولیه نیست، رهاش می‌کنیم تا خالی نشود
                return False

            pack_only = [r for r in entry_from_prod if _is_pack_row(r)]
            rows_for_table = pack_only if pack_only else entry_from_prod  # اگر نشانه‌ای نبود، خالی نماند

            # اگر واقعاً هیچ چیز نبود
            if not rows_for_table:
                table.setRowCount(1)
                item = QtWidgets.QTableWidgetItem('— رکوردی یافت نشد —')
                try: f = item.font(); f.setBold(True); item.setFont(f)
                except Exception: pass
                table.setItem(0, 2, item)
                table.setSortingEnabled(True)
                return

            # نوشتن سطرها
            def _to_shamsi_safe(val):
                try:
                    if 'to_shamsi' in globals():
                        return to_shamsi(val)
                except Exception:
                    pass
                return (str(val)[:10] if val else "")

            def _write_row(rix: int, rec: dict):
                date_val = rec.get('t_date') or rec.get('d')
                table.setItem(rix, 0, QtWidgets.QTableWidgetItem(_to_shamsi_safe(date_val)))
                table.setItem(rix, 1, QtWidgets.QTableWidgetItem(str(rec.get('t_no') or '')))
                table.setItem(rix, 2, QtWidgets.QTableWidgetItem(str(rec.get('t_type') or '')))
                table.setItem(rix, 3, QtWidgets.QTableWidgetItem(str(rec.get('batch_no') or '')))
                table.setItem(rix, 4, QtWidgets.QTableWidgetItem(str(rec.get('src_wh') or '')))
                table.setItem(rix, 5, QtWidgets.QTableWidgetItem(str(rec.get('dest_wh') or '')))

                # مقدار با راست‌چین
                try: q = float(rec.get('qty') or 0.0)
                except Exception: q = 0.0
                try:
                    num_it = NumericTableWidgetItem(f"{q:.3f}")
                except Exception:
                    num_it = QtWidgets.QTableWidgetItem(f"{q:.3f}")
                    try: num_it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                    except Exception: pass
                table.setItem(rix, 6, num_it)

                # نام محصول بسته‌ای یا fallback به item_name
                name = (rec.get('pack_product') or rec.get('packaged_product') or
                        rec.get('product_pack') or rec.get('pack_name') or
                        rec.get('item_name') or '')
                table.setItem(rix, 7, QtWidgets.QTableWidgetItem(str(name)))

            table.setRowCount(len(rows_for_table))
            for i, rec in enumerate(rows_for_table):
                _write_row(i, rec)

            # ظاهر
            table.resizeColumnsToContents()
            try:
                hdr = table.horizontalHeader()
                for c in (2, 4, 5, 7):
                    hdr.setSectionResizeMode(c, QtWidgets.QHeaderView.Stretch)
            except Exception:
                pass
            table.setSortingEnabled(True)

        except Exception as e:
            try:
                table.setRowCount(1)
                table.setItem(0, 0, QtWidgets.QTableWidgetItem('خطا در بارگذاری'))
                table.setItem(0, 1, QtWidgets.QTableWidgetItem(str(e)))
            except Exception:
                pass
        finally:
            try:
                QtWidgets.QApplication.restoreOverrideCursor()
            except Exception:
                pass
    # END REWRITE

        
# این متد را به کلاس MainWindow اضافه کنید
    def _open_packing_dialog(self):
        """پنجره بسته‌بندی دستی و هوشمند را باز می‌کند."""
        if not self.has_permission('production:packing'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return
            
        dlg = PackingDialog(self.db, self)
        if dlg.exec_():
            self.refresh_all()
                            
                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _show_stock_card_from_prod_inventory(self, item: QtWidgets.QTableWidgetItem):
        """
        با دابل-کلیک، دیالوگ اختصاصی جزئیات موجودی تولید را باز می‌کند.
        """
        if not item: return
        
        table = item.tableWidget()
        row = item.row()
        item_name = table.item(row, 0).text() # نام کالا از سلول اول خوانده می‌شود
        
        try:
            item_with_data = table.item(row, 0)
            item_data = item_with_data.data(Qt.UserRole)
            
            if not isinstance(item_data, dict): return

            # ID کالا را بسته به نوع جدول (محصول فله یا عادی) استخراج می‌کنیم
            item_id = item_data.get('item_id') or self.db.get_item_by_name(item_data['product_name'])['id']

            if item_id:
                # فراخوانی دیالوگ جدید و اختصاصی
                ProductionStockDetailDialog(self.db, item_id, item_name, self).exec_()

        except (AttributeError, ValueError, TypeError, KeyError) as e:
            print(f"Could not retrieve item ID for production stock detail view: {e}")
                                    
                    
                                                                        
# این سه متد جدید را به کلاس MainWindow اضافه کنید

    # در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _refresh_production_dashboard_tab(self):
        """داده‌های داشبورد عملیاتی تولید شامل کارت‌ها و کارتابل جدید را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_prod_orders'): 
            return

        try:
            # --- ۱. به‌روزرسانی کارت‌های KPI ---
            pending_orders = self.db.get_pending_production_orders()
            bulk_products = self.db.get_available_bulk_products()
            prod_loc_id = self.db.get_production_floor_location()
            ready_items = self.db.get_finished_goods_at_location(prod_loc_id, packed_only=True) if prod_loc_id else []
            
            # آپدیت کردن متن ویجت‌های KPI با نام‌های جدید
            self.prod_card_new_orders.value_label.setText(f"{len(pending_orders)} سفارش")
            self.prod_card_bulk.value_label.setText(f"{len(bulk_products)} بچ")
            self.prod_card_ready.value_label.setText(f"{len(ready_items)} بچ")

            # --- ۲. بارگذاری کارتابل اصلی سفارشات تولید ---
            # این تابع از پیشنهاد قبلی وجود دارد و جدول اصلی داشبورد را پر می‌کند
            self._load_pending_production_orders()

        except Exception as e:
            print(f"Error refreshing production dashboard: {e}")
            if self.toast:
                self.toast.show_message(f"خطا در به‌روزرسانی داشبورد تولید: {e}", "critical")
                                                         
            
    def _create_production_chart(self):
        """نمودار آمار تولید ۷ روز گذشته را ایجاد یا به‌روزرسانی می‌کند."""
        # پاک کردن نمودار قبلی
        while self.chart_layout.count():
            child = self.chart_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        prod_data = self.db.get_production_summary_last_n_days(7)
        if not prod_data:
            self.chart_layout.addWidget(QtWidgets.QLabel("آماری برای نمایش در نمودار تولید یافت نشد."))
            return
            
        df = pd.DataFrame(prod_data)
        df['production_date'] = pd.to_datetime(df['production_date'])
        
        # تبدیل تاریخ میلادی به شمسی برای نمایش
        df['shamsi_date'] = df['production_date'].apply(lambda d: to_shamsi(d))
        
        fig, ax = plt.subplots(figsize=(8, 3), dpi=100)
        bars = ax.bar(df['shamsi_date'], df['total_quantity'], color='#27ae60')
        ax.set_ylabel(fa("مقدار تولید (واحد اصلی)"))
        ax.set_title(fa("خلاصه تولید ۷ روز گذشته"), fontsize=12, weight='bold')
        ax.tick_params(axis='x', rotation=25, labelsize=9)
        ax.grid(axis='y', linestyle='--', alpha=0.7)
        
        # اضافه کردن لیبل مقدار بالای هر میله
        ax.bar_label(bars, fmt='{:,.0f}', padding=3)

        fig.tight_layout()
        canvas = Canvas(fig)
        self.chart_layout.addWidget(canvas)

    def _handle_dashboard_list_double_click(self, item: QtWidgets.QTableWidgetItem, action_key: str):
        if not item: return

        table = item.tableWidget()
        row = item.row()
        record_id = int(table.item(row, 0).text())

        if action_key == 'approve_transfer':
            self._open_approve_material_dialog(preselect_id=record_id)
            self.prod_page_loaded = False # <-- این خط را اضافه کن
        elif action_key == 'deliver_good':
            self._create_delivery_request_action(preselect_id=record_id)
            self.prod_page_loaded = False # <-- این خط را اضافه کن
                
                

    def _go_to_prod_dashboard(self):
        """کاربر را از صفحه عملیات به داشبورد اصلی تولید برمی‌گرداند."""
        if hasattr(self, 'prod_stack'):
            self.prod_stack.setCurrentIndex(0)
            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _load_pending_production_orders(self):
        """جدول کارتابل سفارشات تولید را با داده‌های جدید و ستون وضعیت بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_prod_orders'): return
        table = self.tbl_prod_orders
        table.setRowCount(0)
        try:
            orders = self.db.get_pending_production_orders()
            prod_logger = get_production_logger()
            if prod_logger is not None:
                prod_logger.info("Loading production orders table", extra={"rows": len(orders)})
            # --- اصلاح: افزودن ستون وضعیت ---
            headers = ["ID", "محصول مورد نیاز", "مقدار", "برای سفارش فروش", "مشتری", "تاریخ ثبت", "وضعیت"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(orders))

            for r, order in enumerate(orders):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['item_name']))
                table.setItem(r, 2, NumericTableWidgetItem(str(order['quantity'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(order.get('so_number', '---')))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(order.get('customer_name', 'داخلی')))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(to_shamsi(order['created_at'])))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(order.get('status', 'نامشخص'))) # نمایش وضعیت

            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            if table.rowCount() > 0:
                try:
                    table.sortItems(5, QtCore.Qt.DescendingOrder)
                except Exception:
                    pass
            set_empty_placeholder(table, "هیچ سفارش تولید جدیدی در کارتابل وجود ندارد.")
        except Exception as e:
            print(f"Error loading pending production orders: {e}")
            
            
    def _start_production_from_order(self, item: QtWidgets.QTableWidgetItem):
        """با دابل-کلیک روی یک سفارش، 'میزکار برنامه‌ریزی تولید' را باز می‌کند."""
        if not item: return
        try:
            prod_order_id = int(self.tbl_prod_orders.item(item.row(), 0).text())
            
            # این دیالوگ در مراحل بعدی تکمیل خواهد شد. فعلا یک placeholder است.
            dlg = ProductionWorkbenchDialog(self.db, self.user_id, prod_order_id, self)
            dlg.exec_()
            
            # پس از بسته شدن میزکار، کل داده‌ها را رفرش می‌کنیم
            self.refresh_all()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند با خطا مواجه شد:\n{e}")
            print(traceback.format_exc())

    def _go_to_prod_operations(self):
        """کاربر را از داشبورد به صفحه عملیات (تب‌ها) می‌برد."""
        if hasattr(self, 'prod_stack'):
            self.prod_stack.setCurrentIndex(1)
            
    def _refresh_production_page_data(self):
        """داده‌های داشبورد و عملیات صفحه تولید را به صورت غیرهمزمان و تکه‌تکه رفرش می‌کند."""
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            QtCore.QTimer.singleShot(0, self._refresh_production_dashboard_tab)
            QtCore.QTimer.singleShot(50, self._load_production_inventory)
            QtCore.QTimer.singleShot(100, self._load_bom)
            QtCore.QTimer.singleShot(150, self._load_delivery_history)
            QtCore.QTimer.singleShot(200, self._load_my_request_history)
            QtCore.QTimer.singleShot(250, self._load_lab_delivery_history)
            # --- فراخوانی جدید برای بارگذاری کارتابل ---
            QtCore.QTimer.singleShot(300, self._load_pending_production_orders)
        finally:
            QtCore.QTimer.singleShot(350, lambda: QtWidgets.QApplication.restoreOverrideCursor())
                
    def _create_delivery_request_action(self, preselect_id=None):
        """دیالوگ انتخاب محصول از کف کارگاه برای ایجاد درخواست تحویل را باز می‌کند."""
        # در آینده می‌توان preselect_id را برای هایلایت کردن ردیف مربوطه استفاده کرد
        dlg = DeliverFinishedGoodDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    new_delivery_id = self.db.create_delivery_request(
                        product_item_id=data['item_id'],
                        batch_no=data['batch_no'],
                        quantity=data['qty'],
                        expiry_date=data.get('expiry_date'),
                        supervisor_user_id=self.user_id
                    )
                    if new_delivery_id:
                        self.db.submit_delivery_request(new_delivery_id)
                    self.toast.show_message("✔ درخواست تحویل محصول به انبار با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                    self.prod_page_loaded = False # <-- این خط را اضافه کن

                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست تحویل:\n{e}")
                                                        
                                    
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _load_lab_delivery_history(self):
        """جدول تاریخچه ارسال کالا به آزمایشگاه را در صفحه تولید بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_lab_deliveries'): return
        
        table = self.tbl_lab_deliveries
        table.setSortingEnabled(False)
        table.setRowCount(0)
        
        try:
            # فقط تراکنش‌های مربوط به آزمایشگاه را می‌خوانیم
            rows = self.db.execute_query("SELECT t.*, i.name as item_name, u.username FROM trans t LEFT JOIN items i ON t.item_id = i.id LEFT JOIN users u ON t.user_id = u.id WHERE t.t_type = 'خروج به آزمایشگاه' ORDER BY t.id DESC")
            
            headers = ['کالا', 'شماره بچ', 'مقدار', 'تاریخ ارسال', 'کاربر', 'یادداشت']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(rows))

            for r, row in enumerate(rows):
                values = [
                    row.get('item_name'),
                    row.get('batch_no'),
                    str(row.get('qty')),
                    to_shamsi(row.get('t_date')),
                    row.get('username'),
                    row.get('notes')
                ]
                for c, value in enumerate(values):
                    item = QtWidgets.QTableWidgetItem(value)
                    item.setToolTip(value)
                    table.setItem(r, c, item)
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch) # Stretch item name
            table.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.Stretch) # Stretch notes
        except Exception as e:
            print(f"Error loading lab delivery history: {e}")
        
        table.setSortingEnabled(True)
                        
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _open_return_material_dialog(self):
        """پنجره ثبت درخواست برگشت مواد را باز می‌کند."""
        dlg = ReturnMaterialDialog(self.db, self)
        if dlg.exec_():
            data = dlg.get_data()
            if data:
                try:
                    self.db.request_material_return(data['component'], data['qty'], data['reason'], self.user_id)
                    self.toast.show_message("✔ درخواست برگشت مواد با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست برگشت:\n{e}")
                    
    # این متد کاملاً جدید را به کلاس MainWindow اضافه کنید

    def _on_bom_tree_item_clicked(self, item, column):
        """
        وقتی روی یک آیتم در درخت BOM کلیک می‌شود، این متد فراخوانی می‌شود.
        """
        # ستون "پیوست" ایندکس 5 را دارد
        if column == 5 and item.parent() is None: # چک می‌کنیم که آیتم والد باشد
            bom_id = item.data(0, Qt.UserRole)
            if bom_id:
                self._open_bom_attach_dialog(bom_id)
                
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _filter_bom_tree_quick(self, text: str):
        """درخت تاریخچه مصرف (BOM) را بر اساس متن ورودی به صورت آنی فیلتر می‌کند."""
        if not hasattr(self, 'tbl_bom'): return

        tree = self.tbl_bom
        text = text.lower().strip()
        
        # پیمایش تمام آیتم‌های درخت
        iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            parent = item.parent()
            
            item_text = ""
            # برای آیتم‌های فرزند (مواد اولیه)، در نام و بچ جستجو کن
            if parent: 
                item_text = item.text(0).lower() + item.text(1).lower()
            # برای آیتم‌های والد (محصول)، در نام محصول جستجو کن
            else: 
                item_text = item.text(0).lower()
            
            item.setHidden(text not in item_text)
            iterator += 1

        # در یک پیمایش دوم، والدانی که فرزند قابل نمایش دارند را مجدداً نمایش بده
        iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            parent = item.parent()
            if parent and not item.isHidden():
                parent.setHidden(False)
            iterator += 1
            

    def _show_bom_context_menu(self, pos):
        """با راست‌کلیک روی تاریخچه مصرف، منوی عملیات را نمایش می‌دهد."""
        item = self.tbl_bom.itemAt(pos)
        if not item:
            return

        # فقط برای آیتم‌های والد (محصولات) منو را نمایش می‌دهیم
        if item.parent() is None:
            bom_id = item.data(0, Qt.UserRole) # ID که قبلا ذخیره کردیم را می‌خوانیم
            if not bom_id:
                return

            menu = QtWidgets.QMenu(self)
            
            attach_action = menu.addAction(QtGui.QIcon.fromTheme("mail-attachment"), "مدیریت پیوست‌ها")
            attach_action.setToolTip("پیوست‌های BOM را ببین یا اضافه کن.")
            attach_action.setStatusTip("پیوست‌های این فرمول را مدیریت کن.")
            attach_action.setToolTip("پیوست‌های BOM را ببین یا اضافه کن.")
            attach_action.setStatusTip("پیوست‌های این فرمول را مدیریت کن.")
            
            # اجرای منو و دریافت اکشن انتخاب شده
            action = menu.exec_(self.tbl_bom.mapToGlobal(pos))
            
            if action == attach_action:
                self._open_bom_attach_dialog(bom_id)
        

    # BEGIN REWRITE: MainWindow._open_report_production_dialog
    def _open_report_production_dialog(self, prefill_data=None):
        """دیالوگ گزارش تولید را باز و در صورت تایید، مواد را مصرف و خروجی تولید را ثبت می‌کند (بدون تکیه بر متد غیرموجود)."""
        dlg = ReportProductionDialog(self.db, self, prefill_data=prefill_data)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        data = dlg.get_data()
        if not data:
            return

        # انقضا: اگر سیاستی نداری، فعلاً ۲ سال بعد (مثل قبل)
        expiry_date = dt.date.today() + dt.timedelta(days=730)

        # نام محصول خروجی را به‌صورت امن استخراج کن
        def _resolve_output_product_name():
            rec = dlg.recipe_combo.currentData() or {}
            # 1) اگر recipe loader نام محصول خروجی را آورده
            for k in ("produced_item_name", "produced_name", "output_product_name"):
                v = (rec.get(k) if isinstance(rec, dict) else None)
                if v:
                    return str(v).strip()
            # 2) از DB بگیر: produces_item → parent → r.product_name
            rid = (rec.get("id") if isinstance(rec, dict) else None) or data.get("recipe_id")
            row = None
            try:
                row = self.db.execute_query(
                    """
                    SELECT COALESCE(pi.name, p.name, r.product_name) AS produced_name
                    FROM recipes r
                    LEFT JOIN items pi ON pi.id = r.produces_item_id
                    LEFT JOIN items p  ON p.id  = r.parent_product_id
                    WHERE r.id = %s
                    LIMIT 1
                    """,
                    (rid,),
                    fetch_one=True
                )
            except Exception:
                row = None
            name = (row or {}).get("produced_name")
            if name:
                return str(name).strip()
            # 3) آخرین تلاش
            if isinstance(rec, dict) and rec.get("product_name"):
                return str(rec["product_name"]).strip()
            return ""

        try:
            product_out_name = _resolve_output_product_name()
            if not product_out_name:
                QtWidgets.QMessageBox.warning(
                    self, "اطلاعات ناقص",
                    "نام محصول خروجی از روی فرمول پیدا نشد. لطفاً در تعریف فرمول «محصول خروجی» را مشخص کنید."
                )
                return

            # گام ۱: مصرف مواد و ثبت BOM در کف کارگاه
            self.db.consume_materials_for_production(
                recipe_id=data['recipe_id'],
                production_batch_no=data['batch_no'],
                consumption_plan=data['consumption_plan'],
                user_id=self.user_id,
            )

            # گام ۲: ثبت خروجی فلهٔ تولید شده (برای مصرف در بسته‌بندی یا ارسال به انبار)
            self.db.register_pending_delivery(
                product_name=product_out_name,
                batch_no=data['batch_no'],
                quantity=data['quantity'],
                supervisor_user_id=self.user_id,
                expiry_date=expiry_date,
            )

            # پیام موفقیت و به‌روزرسانی
            if getattr(self, "toast", None):
                self.toast.show_message(f"✔ تولید بچ {data['batch_no']} ثبت شد.", "success")
            self.refresh_all()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ثبت گزارش تولید با خطا مواجه شد:\n{e}")
            print(traceback.format_exc())
    # END REWRITE: MainWindow._open_report_production_dialog
    
    
    # BEGIN REWRITE: MainWindow._show_bom_asof_dialog
    def _show_bom_asof_dialog(self):
        """
        گزارش BOM تاریخی (As-Of) برای مالی
        - نمایش «نام مادر — نام بسته‌بندی» در انتخاب
        - تاریخ میلادی + برچسب تاریخ شمسی
        - سه تب: فله (A/B/P) ، لوازم بسته‌بندی ، مواد اولیهٔ پارت‌ها (A/B/P)
        - خروجی Excel از تبِ فعال
        """
        from PyQt5 import QtWidgets, QtCore
        import traceback

        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("گزارش BOM تاریخی (As-Of)")
        dlg.resize(1040, 720)

        # ===== لایه‌ها
        root = QtWidgets.QVBoxLayout(dlg)

        # --- فرم بالا
        form = QtWidgets.QFormLayout()
        pack_combo = QtWidgets.QComboBox(dlg)
        pack_combo.setEditable(True)
        pack_combo.setMinimumWidth(600)

        date_edit = QtWidgets.QDateEdit(dlg)
        date_edit.setCalendarPopup(True)
        date_edit.setDisplayFormat("yyyy-MM-dd")
        date_edit.setDate(QtCore.QDate.currentDate())
        date_edit.setMinimumWidth(180)

        shamsi_lbl = QtWidgets.QLabel("—", dlg)
        shamsi_lbl.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
        shamsi_lbl.setMinimumWidth(220)
        shamsi_lbl.setStyleSheet("color:#555;")

        date_row = QtWidgets.QHBoxLayout()
        date_row.addWidget(date_edit, 0)
        date_row.addSpacing(12)
        date_row.addWidget(QtWidgets.QLabel("تاریخ (شمسی):"), 0)
        date_row.addWidget(shamsi_lbl, 1)

        date_row_w = QtWidgets.QWidget(dlg); date_row_w.setLayout(date_row)

        form.addRow("محصول (مادر — بسته‌بندی):", pack_combo)
        form.addRow("تاریخ گزارش:", date_row_w)
        root.addLayout(form)

        # --- خلاصهٔ بالا
        info = QtWidgets.QGridLayout()
        lbl_parent_t = QtWidgets.QLabel("محصول مادر:"); lbl_parent = QtWidgets.QLabel("—")
        lbl_pack_t   = QtWidgets.QLabel("بسته‌بندی:");   lbl_pack   = QtWidgets.QLabel("—")
        lbl_w_t      = QtWidgets.QLabel("وزن خالص هر پک (kg):"); lbl_w = QtWidgets.QLabel("—")
        info.addWidget(lbl_parent_t, 0, 0); info.addWidget(lbl_parent, 0, 1)
        info.addWidget(lbl_pack_t,   0, 2); info.addWidget(lbl_pack,   0, 3)
        info.addWidget(lbl_w_t,      0, 4); info.addWidget(lbl_w,      0, 5)
        info_w = QtWidgets.QWidget(dlg); info_w.setLayout(info)
        root.addWidget(info_w)

        # --- تب‌ها
        tabs = QtWidgets.QTabWidget(dlg)
        tabs.setStyleSheet("QTabBar::tab { padding:10px 24px; min-width:160px; }")
        root.addWidget(tabs, 1)

        def _mk_table(headers):
            tbl = QtWidgets.QTableWidget(0, len(headers), dlg)
            tbl.setHorizontalHeaderLabels(headers)
            tbl.verticalHeader().setVisible(False)
            tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
            tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            tbl.setAlternatingRowColors(True)
            for c in range(len(headers)):
                mode = QtWidgets.QHeaderView.Stretch if c == 0 else QtWidgets.QHeaderView.ResizeToContents
                tbl.horizontalHeader().setSectionResizeMode(c, mode)
            return tbl

        tbl_bulk = _mk_table(["کالا", "مقدار به ازای ۱ پک", "واحد"])
        tbl_pack = _mk_table(["کالا", "مقدار به ازای ۱ پک", "واحد"])
        # تب جدید: مواد اولیهٔ پارت‌ها
        tbl_rm   = _mk_table(["کالا", "مقدار به ازای ۱ پک", "واحد", "پارت"])

        tabs.addTab(tbl_bulk, "فله (A/B یا P)")
        tabs.addTab(tbl_pack, "لوازم بسته‌بندی")
        tabs.addTab(tbl_rm,   "مواد اولیه (A/B/P)")

        # --- دکمه‌ها
        btn_row = QtWidgets.QHBoxLayout()
        btn_calc   = QtWidgets.QPushButton("محاسبه")
        btn_export = QtWidgets.QPushButton("خروجی Excel"); btn_export.setEnabled(False)
        btn_close  = QtWidgets.QPushButton("بستن")
        btn_row.addStretch(1)
        btn_row.addWidget(btn_calc)
        btn_row.addWidget(btn_export)
        btn_row.addWidget(btn_close)
        root.addLayout(btn_row)

        # --- وضعیت جاری برای Export
        current = {'bulk':[], 'pack':[], 'rm':[]}

        # ===== توابع کمکی
        def _load_packs():
            pack_combo.clear()
            rows = self.db.execute_query(
                """
                SELECT c.id, COALESCE(p.name,'—') AS parent_name, c.name AS pack_name, COALESCE(c.net_weight,0) AS net_w
                FROM items c
                JOIN items p ON p.id = c.parent_item_id
                ORDER BY p.name, c.name
                LIMIT 2000
                """
            ) or []
            for r in rows:
                pack_combo.addItem(f"{r['parent_name']} \u2014 {r['pack_name']}", r['id'])

        def _update_shamsi():
            try:
                d = date_edit.date().toString("yyyy-MM-dd")
                # تابع موجود در پروژه؛ اگر نبود، صرفاً خالی بماند
                val = to_shamsi(d, include_time=False) if 'to_shamsi' in globals() or hasattr(self, 'to_shamsi') else ""
                shamsi_lbl.setText(val or "—")
            except Exception:
                shamsi_lbl.setText("—")

        def _fill_table(tbl, rows, with_part=False):
            tbl.setRowCount(0)
            for r in rows:
                name = r.get('component_name') or r.get('name') or ""
                qty  = float(r.get('qty') or 0)
                unit = r.get('unit_name') or ""
                data = [name, f"{qty:.3f}", unit]
                if with_part:
                    kind = (r.get('kind') or '')
                    part = kind.split('_')[-1] if '_' in kind else ''
                    if part in ('A','B','P'):
                        data.append(part)
                    else:
                        data.append('')
                row = tbl.rowCount()
                tbl.insertRow(row)
                for c, val in enumerate(data):
                    item = QtWidgets.QTableWidgetItem(str(val))
                    if c > 0:
                        item.setTextAlignment(QtCore.Qt.AlignCenter)
                    tbl.setItem(row, c, item)

        # ===== محاسبه
        def _calculate():
            try:
                for t in (tbl_bulk, tbl_pack, tbl_rm):
                    t.setRowCount(0)
                current['bulk'].clear(); current['pack'].clear(); current['rm'].clear()

                idx = pack_combo.currentIndex()
                pack_id = pack_combo.itemData(idx)
                if not pack_id:
                    QtWidgets.QMessageBox.warning(dlg, "انتخاب ناقص", "لطفاً یک بسته‌بندی را انتخاب کنید.")
                    return

                as_of = date_edit.date().toString("yyyy-MM-dd")

                # اطلاعات نمایشی
                meta = self.db.execute_query(
                    "SELECT c.name AS pack_name, COALESCE(c.net_weight,0) AS net_w, p.name AS parent_name "
                    "FROM items c LEFT JOIN items p ON p.id = c.parent_item_id WHERE c.id = %s",
                    (pack_id,), fetch_one=True
                ) or {}
                lbl_parent.setText(meta.get('parent_name') or "—")
                lbl_pack.setText(meta.get('pack_name') or "—")
                try: lbl_w.setText(f"{float(meta.get('net_w') or 0):.3f}")
                except Exception: lbl_w.setText("—")

                # گرفتن BOM تخت از لایهٔ دیتابیس (که اکنون RM_* را هم می‌دهد)
                rows = self.db.get_flat_bom_for_pack_as_of(int(pack_id), as_of, 1.0) or []

                bulk_rows = [r for r in rows if (r.get('kind') or '').startswith('BULK')]
                pack_rows = [r for r in rows if (r.get('kind') or '') == 'PACK']
                rm_rows   = [r for r in rows if (r.get('kind') or '').startswith('RM_')]

                _fill_table(tbl_bulk, bulk_rows)
                _fill_table(tbl_pack, pack_rows)
                _fill_table(tbl_rm,   rm_rows, with_part=True)

                current['bulk'] = bulk_rows
                current['pack'] = pack_rows
                current['rm']   = rm_rows

                btn_export.setEnabled(bool(bulk_rows or pack_rows or rm_rows))
                _update_shamsi()

                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message("محاسبه انجام شد.", "success")
            except Exception as e:
                msg = f"خطا در محاسبه BOM تاریخی: {e}"
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message(msg, "critical")
                else:
                    QtWidgets.QMessageBox.critical(dlg, "خطا", msg)
                traceback.print_exc()

        # ===== خروجی Excel از تب فعال
        def _export_excel():
            try:
                current_tab = tabs.currentWidget()
                if current_tab is not None:
                    export_table_to_excel(current_tab, dlg)  # تابع موجود پروژه
            except Exception as e:
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message(f"خطا در خروجی اکسل: {e}", "critical")
                else:
                    QtWidgets.QMessageBox.critical(dlg, "خطا", f"خطا در خروجی اکسل: {e}")

        # ===== اتصال رویدادها و بارگذاری اولیه
        date_edit.dateChanged.connect(lambda *_: _update_shamsi())
        btn_calc.clicked.connect(_calculate)
        btn_export.clicked.connect(_export_excel)
        btn_close.clicked.connect(dlg.reject)

        _load_packs()
        _update_shamsi()

        dlg.exec_()
    # END REWRITE: MainWindow._show_bom_asof_dialog
    
    # BEGIN REWRITE: MainWindow._show_consumption_variance_dialog
    def _show_consumption_variance_dialog(self):
        """
        گزارش «مصرف واقعی در برابر استاندارد (تولید)» — کمیّتی و سازگار با DB.get_consumption_variance_for_pack
        - هیچ محاسبهٔ بهایی انجام نمی‌دهد.
        - نام اقلام از جدول items به صورت batch خوانده می‌شود تا سریع و دقیق باشد.
        """
        from PyQt5 import QtWidgets, QtCore, QtGui
        import csv, os, traceback

        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("گزارش مصرف واقعی در برابر استاندارد (تولید)")
        dlg.resize(980, 640)
        v = QtWidgets.QVBoxLayout(dlg)

        # --- فیلتر بالا ---
        grid = QtWidgets.QGridLayout(); v.addLayout(grid)

        grid.addWidget(QtWidgets.QLabel("پک:"), 0, 0)
        pack_combo = QtWidgets.QComboBox(dlg); pack_combo.setEditable(True)
        grid.addWidget(pack_combo, 0, 1, 1, 3)

        grid.addWidget(QtWidgets.QLabel("انبار تولید:"), 0, 4)
        wh_combo = QtWidgets.QComboBox(dlg)
        grid.addWidget(wh_combo, 0, 5)

        grid.addWidget(QtWidgets.QLabel("از تاریخ:"), 1, 0)
        d_from = QtWidgets.QDateEdit(dlg); d_from.setCalendarPopup(True); d_from.setDisplayFormat("yyyy-MM-dd")
        grid.addWidget(d_from, 1, 1)

        grid.addWidget(QtWidgets.QLabel("تا تاریخ:"), 1, 2)
        d_to = QtWidgets.QDateEdit(dlg); d_to.setCalendarPopup(True); d_to.setDisplayFormat("yyyy-MM-dd")
        grid.addWidget(d_to, 1, 3)

        # --- دکمه‌ها ---
        btns = QtWidgets.QHBoxLayout()
        btn_calc = QtWidgets.QPushButton("محاسبه")
        btn_export = QtWidgets.QPushButton("خروجی CSV"); btn_export.setEnabled(False)
        btn_close = QtWidgets.QPushButton("بستن")
        btns.addStretch(1); btns.addWidget(btn_calc); btns.addWidget(btn_export); btns.addWidget(btn_close)
        v.addLayout(btns)

        # --- خلاصه بالای تب‌ها ---
        hdr = QtWidgets.QHBoxLayout()
        lbl_info = QtWidgets.QLabel("—")
        hdr.addWidget(lbl_info)
        hdr.addStretch(1)
        v.addLayout(hdr)

        # --- تب‌ها: فله و لوازم بسته‌بندی ---
        tabs = QtWidgets.QTabWidget(dlg); v.addWidget(tabs)

        def _mk_table():
            tbl = QtWidgets.QTableWidget(0, 5, dlg)
            tbl.setHorizontalHeaderLabels(["کالا", "استاندارد", "واقعی", "واریانس", "٪"])
            tbl.verticalHeader().setVisible(False)
            tbl.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
            for c in (1,2,3,4):
                tbl.horizontalHeader().setSectionResizeMode(c, QtWidgets.QHeaderView.ResizeToContents)
            return tbl

        tbl_bulk = _mk_table()
        tbl_pack = _mk_table()
        tabs.addTab(tbl_bulk, "فله (A/B یا P)")
        tabs.addTab(tbl_pack, "لوازم بسته‌بندی")

        # --- بارگذاری اولیه لیست‌ها ---
        def _load_packs():
            pack_combo.clear()
            rows = self.db.execute_query(
                "SELECT id, name FROM items WHERE parent_item_id IS NOT NULL ORDER BY name LIMIT 2000"
            ) or []
            for r in rows:
                pack_combo.addItem(r['name'], r['id'])

        def _load_wh():
            wh_combo.clear()
            try:
                rows = self.db.execute_query("SELECT name FROM warehouses ORDER BY name") or []
            except Exception:
                rows = []
            for w in rows:
                wh_combo.addItem(w['name'], w['name'])
            # انتخاب پیش‌فرض: PRODUCTION_WAREHOUSE_NAME اگر وجود دارد
            try:
                idx = wh_combo.findData(PRODUCTION_WAREHOUSE_NAME)
                if idx >= 0:
                    wh_combo.setCurrentIndex(idx)
            except Exception:
                pass

        _load_packs()
        _load_wh()
        d_from.setDate(QtCore.QDate.currentDate().addMonths(-1))
        d_to.setDate(QtCore.QDate.currentDate())

        # --- ابزارهای داخلی ---
        def _num_item(val):
            try:
                return NumericTableWidgetItem(f"{float(val):.3f}")
            except Exception:
                it = QtWidgets.QTableWidgetItem(f"{float(val):.3f}")
                it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                return it

        def _fill_table(tbl, rows, name_map):
            tbl.setRowCount(0)
            total_std = total_act = 0.0
            for rec in rows:
                r = tbl.rowCount(); tbl.insertRow(r)
                iid = int(rec.get('item_id'))
                nm = name_map.get(iid, f"#{iid}")
                tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(nm))
                tbl.setItem(r, 1, _num_item(rec.get('std',0)))
                tbl.setItem(r, 2, _num_item(rec.get('act',0)))
                tbl.setItem(r, 3, _num_item(rec.get('var',0)))
                pct = rec.get('var_pct')
                pct_text = "" if pct is None else f"{(float(pct)*100.0):.1f}%"
                it = QtWidgets.QTableWidgetItem(pct_text)
                it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                try:
                    if pct is not None and abs(float(pct)*100.0) > 5.0:
                        it.setForeground(QtGui.QColor("red"))
                except Exception:
                    pass
                tbl.setItem(r, 4, it)
                total_std += float(rec.get('std',0) or 0)
                total_act += float(rec.get('act',0) or 0)

            # سطر جمع
            if rows:
                r = tbl.rowCount(); tbl.insertRow(r)
                it = QtWidgets.QTableWidgetItem("جمع")
                it.setForeground(QtGui.QColor("blue")); it.setFlags(QtCore.Qt.ItemIsEnabled)
                tbl.setItem(r, 0, it)
                tbl.setItem(r, 1, _num_item(total_std))
                tbl.setItem(r, 2, _num_item(total_act))
                var = total_act - total_std
                tbl.setItem(r, 3, _num_item(var))
                pct_text = "" if total_std == 0 else f"{(var/total_std*100):.1f}%"
                itp = QtWidgets.QTableWidgetItem(pct_text)
                itp.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                itp.setForeground(QtGui.QColor("blue")); itp.setFlags(QtCore.Qt.ItemIsEnabled)
                tbl.setItem(r, 4, itp)

        current_csv = {'bulk': [], 'pack': [], 'meta': {}}

        # --- محاسبه ---
        def _calculate():
            try:
                pid = pack_combo.currentData()
                if not pid:
                    QtWidgets.QMessageBox.warning(dlg, "انتخاب پک", "یک «پک» انتخاب کنید.")
                    return
                wh  = wh_combo.currentData() or wh_combo.currentText()
                as_from = d_from.date().toString("yyyy-MM-dd")
                as_to   = d_to.date().toString("yyyy-MM-dd")

                res = self.db.get_consumption_variance_for_pack(int(pid), as_from, as_to, production_wh_name=wh)

                # نام اقلام را یک‌جا بگیریم
                id_set = set()
                for arr in ('bulk','pack'):
                    for r in res.get(arr, []) or []:
                        if r.get('item_id') is not None:
                            id_set.add(int(r['item_id']))
                name_map = {}
                if id_set:
                    rows = self.db.execute_query("SELECT id, name FROM items WHERE id = ANY(%s)", (list(id_set),)) or []
                    name_map = {int(r['id']): r['name'] for r in rows}

                lbl_info.setText(f"پک: {pack_combo.currentText()} | بازه: {as_from} تا {as_to} | تولید ثبت‌شده: {res.get('produced_qty',0):.3f} عدد/پک")

                _fill_table(tbl_bulk, res.get('bulk') or [], name_map)
                _fill_table(tbl_pack, res.get('pack') or [], name_map)

                current_csv['bulk'] = [{'name': name_map.get(int(r['item_id']), f"#{int(r['item_id'])}"),
                                        'std': r.get('std',0), 'act': r.get('act',0),
                                        'var': r.get('var',0),
                                        'var_pct': (None if r.get('var_pct') is None else float(r['var_pct'])*100.0)}
                                        for r in (res.get('bulk') or [])]
                current_csv['pack'] = [{'name': name_map.get(int(r['item_id']), f"#{int(r['item_id'])}"),
                                        'std': r.get('std',0), 'act': r.get('act',0),
                                        'var': r.get('var',0),
                                        'var_pct': (None if r.get('var_pct') is None else float(r['var_pct'])*100.0)}
                                        for r in (res.get('pack') or [])]
                current_csv['meta'] = {'pack': pack_combo.currentText(), 'from': as_from, 'to': as_to}
                btn_export.setEnabled(bool(current_csv['bulk'] or current_csv['pack']))
            except Exception as e:
                traceback.print_exc()
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message(f"خطا در محاسبه واریانس مصرف: {e}", "critical")
                else:
                    QtWidgets.QMessageBox.critical(dlg, "خطا", f"خطا در محاسبه واریانس مصرف: {e}")

        # --- خروجی CSV ---
        def _export():
            if not (current_csv['bulk'] or current_csv['pack']):
                return
            dest = QtWidgets.QFileDialog.getExistingDirectory(dlg, "انتخاب مسیر ذخیره")
            if not dest:
                return
            base = f"CONS_VAR_{current_csv['meta'].get('pack','PACK').replace(' ','_')}_{current_csv['meta'].get('from','')}_{current_csv['meta'].get('to','')}"
            try:
                # bulk
                path_b = os.path.join(dest, base + "_bulk.csv")
                with open(path_b, "w", newline="", encoding="utf-8-sig") as f:
                    w = csv.writer(f); w.writerow(["کالا","استاندارد","واقعی","واریانس","٪"])
                    for r in current_csv['bulk']:
                        w.writerow([r.get('name',''), r.get('std',0), r.get('act',0), r.get('var',0),
                                    ("" if r.get('var_pct') is None else round(r.get('var_pct'),1))])
                # pack items
                path_p = os.path.join(dest, base + "_pack.csv")
                with open(path_p, "w", newline="", encoding="utf-8-sig") as f:
                    w = csv.writer(f); w.writerow(["کالا","استاندارد","واقعی","واریانس","٪"])
                    for r in current_csv['pack']:
                        w.writerow([r.get('name',''), r.get('std',0), r.get('act',0), r.get('var',0),
                                    ("" if r.get('var_pct') is None else round(r.get('var_pct'),1))])
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message("خروجی CSV ذخیره شد.", "success")
                else:
                    QtWidgets.QMessageBox.information(dlg, "خروجی", "خروجی CSV ذخیره شد.")
            except Exception as e:
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message(f"ذخیره CSV ناموفق: {e}", "critical")
                else:
                    QtWidgets.QMessageBox.critical(dlg, "خطا", f"ذخیره CSV ناموفق: {e}")

        btn_calc.clicked.connect(_calculate)
        btn_export.clicked.connect(_export)
        btn_close.clicked.connect(dlg.reject)

        dlg.exec_()
    # END REWRITE: MainWindow._show_consumption_variance_dialog

                                        
                                                        
    # در کلاس MainWindow
    def _open_deliver_to_warehouse_dialog(self):
        """
        نسخه نهایی:
        پس از ایجاد درخواست، وضعیت آن را برای تایید انباردار آماده می‌کند.
        """
        dlg = CreateDeliveryRequestDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_selected_data()
            if data:
                try:
                    # --- اصلاح کلیدی: فراخوانی تابع جدید برای تغییر وضعیت ---
                    delivery_id = self.db.request_delivery_from_production(
                        product_name=data['name'],
                        batch_no=data['batch_no'],
                        quantity=data['qty'],
                        supervisor_user_id=self.user_id,
                        expiry_date=data.get('expiry_date')
                    )
                    self.db.submit_delivery_request(delivery_id)
                    
                    self.toast.show_message("✔ درخواست تحویل محصول به انبار با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"خطا در ثبت درخواست تحویل:\n{e}")
                    print(traceback.format_exc())
                                                
                                        
    def _load_my_request_history(self):
        """بارگذاری تاریخچهٔ درخواست‌های من؛ حالت تخت یا گروهی بر اساس شماره سند (MR-xx/...)."""
        from PyQt5 import QtWidgets, QtCore
        import re

        if not hasattr(self, 'tbl_my_requests'):
            return

        table = self.tbl_my_requests
        table.setSortingEnabled(False)
        table.setRowCount(0)

        # دریافت داده خام
        rows = self.db.get_all_user_initiated_requests(self.user_id, limit=2000) or []

        headers = ['نوع درخواست', 'نام کالا', 'مقدار', 'وضعیت', 'تاریخ درخواست', 'تاریخ پردازش', 'یادداشت/دلیل']
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)

        def _fmt_dt(val):
            if not val:
                return ''
            try:
                # اگر to_shamsi دارید، با «ساعت» صدا بزن
                return to_shamsi(val, include_time=True) if 'to_shamsi' in globals() else str(val)[:16]
            except Exception:
                # اگر to_shamsi پارامتر include_time نپذیرفت یا خطا داد
                s = str(val).replace('T', ' ')
                return s[:16]  # YYYY-MM-DD HH:MM

        # فقط برای «نمایش»: DOCNO را نگه می‌داریم، MR-xx را حذف می‌کنیم
        def _pretty_notes(s: str) -> str:
            s = str(s or '')
            s = re.sub(r'\[DOCNO:[^\]]+\]', '', s)            # تگ DOCNO از متن حذف (جداگانه نشان می‌دهیم)
            s = re.sub(r'\b[A-Z]{1,4}-\d+\b', '', s)          # حذف زیرسندها مثل MR-23 / IR-7 / ...
            s = re.sub(r'\s*\|\s*', ' | ', s)                 # فاصله‌های اطراف | نرمال
            s = re.sub(r'\s{2,}', ' ', s).strip(' |')
            return s

        # فقط DOCNO را برای نمایش «شماره سند» استخراج می‌کنیم (MR-xx را به‌عنوان سندِ نمایش محسوب نکن)
        def _docno_display_only(s: str):
            m = re.search(r'\[DOCNO:([A-Za-z0-9_\-]+)\]', str(s or ''))
            return m.group(1) if m else None

        # نگاشت وضعیت برای نمایش فارسی
        status_map = {
            'PENDING': 'در انتظار',
            'FULFILLED': 'تایید شده',
            'در انتظار تایید انبار': 'در انتظار تایید'
        }

        # برای «گروه‌بندی» همچنان از notes خام استفاده می‌کنیم
        def _doc_no_from_notes(s: str):
            """
            اول سند سفارشی [DOCNO:...] را برمی‌گرداند؛
            اگر نبود، الگوی قدیمی MR-<id> را برمی‌گرداند؛ وگرنه None.
            """
            s = str(s or '')
            m = re.search(r'\[DOCNO:([A-Za-z0-9_\-]+)\]', s)
            if m:
                return m.group(1)
            m2 = re.search(r'\b([A-Z]{1,4}-\d+)\b', s)
            return m2.group(1) if m2 else None

        def _compose_notes_for_display(raw_notes: str) -> str:
            """DOCNO را به صورت «شماره سند: ...» جلو یادداشت تمیزشده می‌آورد؛
            شماره حواله که در متنِ یادداشت است دست‌نخورده می‌ماند."""
            doc = _docno_display_only(raw_notes)
            body = _pretty_notes(raw_notes)
            if doc and body:
                return f"شماره سند: {doc} | {body}"
            elif doc:
                return f"شماره سند: {doc}"
            else:
                return body

        grouped = bool(getattr(self, 'chk_group_myreqs_by_doc', None) and self.chk_group_myreqs_by_doc.isChecked())

        if not rows:
            table.setRowCount(1)
            x = QtWidgets.QTableWidgetItem('— رکوردی پیدا نشد —')
            f = x.font(); f.setBold(True); x.setFont(f)
            table.setItem(0, 1, x)
            return

        if not grouped:
            # حالت تخت: همان رفتار قبل
            table.setRowCount(len(rows))
            for r, rec in enumerate(rows):
                # نام کالا: اگر item_id نبود «نامشخص» می‌شود
                name = 'نامشخص'
                try:
                    if rec.get('item_id'):
                        info = self.db.get_item_details(rec['item_id']) or {}
                        name = info.get('name') or name
                except Exception:
                    pass

                display_notes = _compose_notes_for_display(rec.get('notes', '') or '')
                vals = [
                    rec.get('request_type', ''),
                    name,
                    str(rec.get('qty') or 0),
                    status_map.get(rec.get('status'), rec.get('status', '')),
                    _fmt_dt(rec.get('created_at')),
                    _fmt_dt(rec.get('processed_at')),
                    display_notes
                ]
                for c, v in enumerate(vals):
                    it = QtWidgets.QTableWidgetItem(v)
                    it.setToolTip(v)
                    # فقط خواندنی
                    it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
                    table.setItem(r, c, it)
        else:
            # حالت گروهی: بر اساس شماره سند، «سرگروه» بساز و ردیف‌های «نامشخص» را تبدیل به سرگروه کن
            groups = {}
            for rec in rows:
                key = _doc_no_from_notes(rec.get('notes')) or 'بدون سند'
                groups.setdefault(key, []).append(rec)

            r = 0
            for doc_no, items in groups.items():
                # محاسبهٔ خلاصهٔ گروه
                total_qty = sum((rec.get('qty') or 0) for rec in items if rec.get('item_id'))
                statuses = sorted({rec.get('status') for rec in items if rec.get('status')})
                created_min = None
                processed_max = None
                for rec in items:
                    ca = rec.get('created_at'); pa = rec.get('processed_at')
                    created_min = ca if created_min is None or (ca and ca < created_min) else created_min
                    processed_max = pa if processed_max is None or (pa and pa > processed_max) else processed_max

                # ردیف سرگروه
                table.insertRow(r)
                group_vals = [
                    'سند',
                    f'— {"سند "+doc_no if doc_no != "بدون سند" else "بدون سند"} —',
                    str(total_qty),
                    ' / '.join(statuses) if statuses else '',
                    _fmt_dt(created_min),
                    _fmt_dt(processed_max),
                    doc_no if doc_no != 'بدون سند' else ''
                ]
                for c, v in enumerate(group_vals):
                    it = QtWidgets.QTableWidgetItem(v)
                    # سرگروه بولد
                    f = it.font(); f.setBold(True); it.setFont(f)
                    it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
                    table.setItem(r, c, it)
                r += 1

                # ردیف‌های زیرگروه
                for rec in items:
                    # اگر ردیفِ «نامشخص» (فاقد item_id و معمولاً qty صفر) بود، در نمایش گروهی نیاور
                    if not rec.get('item_id') and not (rec.get('qty') or 0):
                        continue

                    name = 'نامشخص'
                    try:
                        if rec.get('item_id'):
                            info = self.db.get_item_details(rec['item_id']) or {}
                            name = info.get('name') or name
                    except Exception:
                        pass

                    display_notes = _compose_notes_for_display(rec.get('notes', '') or '')
                    child_vals = [
                        rec.get('request_type', ''),
                        f'   • {name}',
                        str(rec.get('qty') or 0),
                        status_map.get(rec.get('status'), rec.get('status', '')),
                        _fmt_dt(rec.get('created_at')),
                        _fmt_dt(rec.get('processed_at')),
                        display_notes
                    ]
                    table.insertRow(r)
                    for c, v in enumerate(child_vals):
                        it = QtWidgets.QTableWidgetItem(v)
                        it.setToolTip(v)
                        it.setFlags(it.flags() & ~QtCore.Qt.ItemIsEditable)
                        table.setItem(r, c, it)
                    r += 1

        # قالب‌بندی نهایی
        try:
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.Stretch)  # یادداشت/دلیل
        except Exception:
            pass
        set_empty_placeholder(table, "درخواستی وجود ندارد.")
        table.setSortingEnabled(True)
        
    def _open_manual_batch_selection_dialog(self, request_id, item_id, item_name, qty_needed):
            """
            یک دیالوگ برای انتخاب دستی بچ توسط کاربر باز می‌کند.
            این مسیر override برای زمانی است که پیشنهاد FEFO سیستم مناسب نیست.
            """
            self.toast.show_message("انتخاب دستی فعال شد. لطفاً بچ مورد نظر را انتخاب کنید.", "info")
            
            available_stock_records = self.db.stock_breakdown(item_id)
            if not available_stock_records:
                QtWidgets.QMessageBox.warning(self, "موجودی ناکافی", f"کالای «{item_name}» در انبار موجودی ندارد.")
                return

            # ساخت دیکشنری برای نمایش در دیالوگ
            batch_map = { 
                f"{rec['loc']} | بچ: {rec['batch_no']} | انقضا: {to_shamsi(rec.get('expiry_date'))} (موجودی: {rec['qty']})": rec 
                for rec in available_stock_records 
            }
            
            selected_batch_text, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب دستی بچ", f"کدام بچ از کالای «{item_name}» را می‌خواهید ارسال کنید؟", batch_map.keys(), 0, False)
            
            if not ok:
                self.toast.show_message("عملیات انتخاب دستی لغو شد.", "info")
                return
            
            selected_stock_info = batch_map[selected_batch_text]
            
            # بررسی اینکه بچ انتخابی موجودی کافی دارد یا خیر
            if selected_stock_info['qty'] < qty_needed:
                QtWidgets.QMessageBox.warning(self, "موجودی بچ ناکافی", f"موجودی بچ انتخابی ({selected_stock_info['qty']}) کمتر از مقدار درخواستی ({qty_needed}) است. لطفاً دوباره تلاش کنید.")
                return

            # دریافت شماره سند
            doc_no, ok = QtWidgets.QInputDialog.getText(self, "شماره سند", "شماره سند/حواله انبار را وارد کنید:")
            if not ok or not doc_no.strip():
                self.toast.show_message("عملیات به دلیل عدم ورود شماره سند لغو شد.", "info")
                return

            # ارسال درخواست به دیتابیس با بچ انتخاب شده دستی
            try:
                trans_data = {
                    'item_id': item_id,
                    'qty': qty_needed,
                    'src_loc_id': selected_stock_info['loc_id'],
                    'notes': f"خروج طبق حواله «{doc_no.strip()}» برای درخواست #{request_id} (انتخاب دستی کاربر)",
                    'batch_no': selected_stock_info['batch_no'],
                    'expiry_date': selected_stock_info.get('expiry_date'),
                    'doc_no': doc_no.strip()
                }
                self.db.fulfill_material_request(request_id, self.user_id, trans_data)
                
                self.toast.show_message(f"✔ مقدار {qty_needed} واحد از بچ انتخابی با موفقیت برای تولید ارسال شد.", "success")
                self.refresh_all()

            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ارسال کالا با خطا مواجه شد:\n{e}")
                print(traceback.format_exc())
            
                                                
    # BEGIN REWRITE: MainWindow._fulfill_material_request
    def _fulfill_material_request(self):
        """
        رسیدگی به «درخواست مواد اولیه»:
        - تک‌انتخاب: مثل قبل (دیالوگ FEFO + گرفتن شماره سند).
        - چندانتخاب: یک‌بار شماره سند می‌گیرد و برای هر ردیف، دیالوگ FEFO را نشان می‌دهد،
        سپس همه را با همان شماره سند ارسال می‌کند.
        """
        from PyQt5 import QtWidgets

        if not hasattr(self, 'tbl_material_requests'):
            return

        sel_indexes = self.tbl_material_requests.selectionModel().selectedRows()
        if not sel_indexes:
            if hasattr(self, 'toast') and self.toast:
                self.toast.show_message("لطفاً حداقل یک درخواست را انتخاب کنید.", "warning")
            else:
                QtWidgets.QMessageBox.warning(self, "توجه", "لطفاً حداقل یک درخواست را انتخاب کنید.")
            return

        def _get_row_values(r):
            try:
                request_id = int(self.tbl_material_requests.item(r, 0).text())     # ID درخواست
                item_id    = int(self.tbl_material_requests.item(r, 1).text())     # ID کالا
                item_name  = self.tbl_material_requests.item(r, 2).text()
                qty_needed = float(self.tbl_material_requests.item(r, 3).text())
                return request_id, item_id, item_name, qty_needed
            except Exception:
                return None

        # ---------------- حالت تک‌انتخاب ----------------
        if len(sel_indexes) == 1:
            r = sel_indexes[0].row()
            vals = _get_row_values(r)
            if not vals:
                QtWidgets.QMessageBox.critical(self, "خطا", "اطلاعات ردیف انتخاب‌شده معتبر نیست.")
                return
            request_id, item_id, item_name, qty_needed = vals

            # پیش‌نمایش FEFO (با امکان لغو)
            picks = self.db.fefo_pick(item_id, qty_needed)
            total = sum(p.get('pick_qty', 0) for p in (picks or []))
            if total < qty_needed - 1e-6:
                QtWidgets.QMessageBox.warning(
                    self, "کمبود موجودی",
                    f"موجودی کافی برای «{item_name}» وجود ندارد (نیاز: {qty_needed} | قابل تأمین: {total})."
                )
                return

            # دیالوگ FEFO (اگر در پروژه موجود باشد)
            try:
                dlg = FefoPickDialog(picks, item_name, qty_needed, self)
                if dlg.exec_() != QtWidgets.QDialog.Accepted:
                    return
            except Exception:
                # اگر دیالوگ در این بیلد موجود نیست، ادامه می‌دهیم (ارسال با FEFO خودکار)
                pass

            # شماره سند
            doc_no, ok = QtWidgets.QInputDialog.getText(self, "شماره سند خروج",
                                                        f"شماره سند/حواله برای «{item_name}» را وارد کنید:")
            if not (ok and doc_no.strip()):
                return

            try:
                self.db.fulfill_request_with_fefo(request_id, item_id, qty_needed, doc_no.strip(), self.user_id)
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message("✔ ارسال به تولید انجام شد.", "success")
                else:
                    QtWidgets.QMessageBox.information(self, "موفق", "ارسال به تولید انجام شد.")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
            return

        # ---------------- حالت چندانتخاب (سند مشترک + دیالوگ FEFO برای هر ردیف) ----------------
        doc_no, ok = QtWidgets.QInputDialog.getText(self, "شماره سند خروج مشترک",
                                                    "شماره سند/حواله برای همهٔ موارد انتخاب‌شده:")
        if not (ok and doc_no.strip()):
            return
        doc_no = doc_no.strip()

        success = 0
        failed  = []

        for idx in sorted({i.row() for i in sel_indexes}):
            vals = _get_row_values(idx)
            if not vals:
                failed.append(("?", "اطلاعات ردیف نامعتبر"))
                continue
            request_id, item_id, item_name, qty_needed = vals

            picks = self.db.fefo_pick(item_id, qty_needed)
            total = sum(p.get('pick_qty', 0) for p in (picks or []))
            if total < qty_needed - 1e-6:
                failed.append((request_id, f"کمبود موجودی (نیاز: {qty_needed} | قابل تأمین: {total})"))
                continue

            # دیالوگ FEFO برای هر ردیف
            try:
                dlg = FefoPickDialog(picks, item_name, qty_needed, self)
                if dlg.exec_() != QtWidgets.QDialog.Accepted:
                    # کاربر صرفاً این ردیف را لغو کرده است؛ می‌رویم سراغ بعدی
                    continue
            except Exception:
                pass  # در نبود دیالوگ، ادامه می‌دهیم

            try:
                self.db.fulfill_request_with_fefo(request_id, item_id, qty_needed, doc_no, self.user_id)
                success += 1
            except Exception as e:
                failed.append((request_id, str(e)))

        # پیام جمع‌بندی
        if hasattr(self, 'toast') and self.toast:
            if success and not failed:
                self.toast.show_message(f"✔ {success} درخواست با سند «{doc_no}» ارسال شد.", "success")
            elif success and failed:
                self.toast.show_message(f"✔ {success} موفق / {len(failed)} ناموفق.", "warning")
            else:
                self.toast.show_message("هیچ درخواستی ارسال نشد.", "error")
        else:
            QtWidgets.QMessageBox.information(self, "نتیجه‌ی ارسال",
                                            f"موفق: {success}\nناموفق: {len(failed)}")

        try:
            self.refresh_all()
        except Exception:
            pass
    # END REWRITE: MainWindow._fulfill_material_request
        
                                
            
    def _open_approve_material_dialog(self, preselect_id=None):
        """دیالوگ تایید دریافت مواد اولیه را برای کاربر فعلی باز می‌کند."""
        # در آینده می‌توان preselect_id را برای هایلایت کردن ردیف مربوطه استفاده کرد
        ApproveMaterialTransferDialog(self.db, self.user_id, self).exec_()                                            
                                                                                                                                                                        
                                                        
    def _open_confidentiality_manager(self):
            """پنجره مرکز کنترل محرمانگی را باز می‌کند."""
            AdvancedConfidentialityDialog(self.db, self).exec_()

    def _generate_financial_bom_report(self):
        """گزارش مالی را بر اساس قوانین ذخیره شده در دیتابیس تولید می‌کند."""
        product_codes = self.db.get_distinct_product_codes()
        if not product_codes:
            self.toast.show_message("هیچ تاریخچه مصرفی برای گزارش‌گیری وجود ندارد.", "warning"); return
        pcode, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب بچ محصول", "لطفاً بچ محصول را برای گزارش انتخاب کنید:", product_codes, 0, False)
        if ok and pcode:
            try:
                report_data = self.db.list_bom_financial(pcode)
                if not report_data:
                    self.toast.show_message(f"داده‌ای برای بچ '{pcode}' یافت نشد.", "warning"); return
                path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره گزارش مالی', f"Financial_BOM_{pcode}.xlsx", 'Excel (*.xlsx)')
                if not path: return
                import pandas as pd
                df = pd.DataFrame(report_data)
                df.to_excel(path, index=False)
                self.toast.show_message("✔ گزارش مالی با موفقیت ذخیره شد.", "success")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد گزارش مالی: {e}")
                
    # BEGIN REWRITE: MainWindow._show_kardex_dialog
    def _show_kardex_dialog(self):
        from PyQt5 import QtWidgets, QtCore, QtGui
        import traceback

        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("کارتکس مواد / لوازم")
        dlg.resize(1040, 680)
        v = QtWidgets.QVBoxLayout(dlg)

        # --- فرم فیلتر ---
        form = QtWidgets.QGridLayout()
        v.addLayout(form)

        form.addWidget(QtWidgets.QLabel("کالا:"), 0, 0)
        item_combo = QtWidgets.QComboBox(dlg); item_combo.setEditable(True); item_combo.setMinimumWidth(520)
        form.addWidget(item_combo, 0, 1, 1, 3)

        form.addWidget(QtWidgets.QLabel("انبار:"), 0, 4)
        wh_combo = QtWidgets.QComboBox(dlg); wh_combo.setMinimumWidth(220)
        form.addWidget(wh_combo, 0, 5)

        form.addWidget(QtWidgets.QLabel("از تاریخ:"), 1, 0)
        d_from = QtWidgets.QDateEdit(dlg); d_from.setCalendarPopup(True); d_from.setDisplayFormat("yyyy-MM-dd"); d_from.setMinimumWidth(160)
        form.addWidget(d_from, 1, 1)

        form.addWidget(QtWidgets.QLabel("تا تاریخ:"), 1, 2)
        d_to = QtWidgets.QDateEdit(dlg); d_to.setCalendarPopup(True); d_to.setDisplayFormat("yyyy-MM-dd"); d_to.setMinimumWidth(160)
        form.addWidget(d_to, 1, 3)

        form.addWidget(QtWidgets.QLabel("شماره بچ (اختیاری):"), 1, 4)
        batch_edit = QtWidgets.QLineEdit(dlg); batch_edit.setPlaceholderText("مثال: R-0406-027")
        form.addWidget(batch_edit, 1, 5)

        # --- دکمه‌ها ---
        btns = QtWidgets.QHBoxLayout()
        btn_calc = QtWidgets.QPushButton("محاسبه")
        btn_export = QtWidgets.QPushButton("خروجی Excel"); btn_export.setEnabled(False)
        btn_close = QtWidgets.QPushButton("بستن")
        btns.addStretch(1); btns.addWidget(btn_calc); btns.addWidget(btn_export); btns.addWidget(btn_close)
        v.addLayout(btns)

        # --- جدول کارتکس ---
        tbl = QtWidgets.QTableWidget(0, 9, dlg)
        tbl.setHorizontalHeaderLabels(["تاریخ", "شماره سند", "نوع", "بچ", "انبار مبدأ", "انبار مقصد", "ورود", "خروج", "مانده"])
        tbl.verticalHeader().setVisible(False)
        for col in (0,1,2,3,4,5):
            tbl.horizontalHeader().setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeToContents)
        tbl.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.ResizeToContents)
        tbl.horizontalHeader().setSectionResizeMode(7, QtWidgets.QHeaderView.ResizeToContents)
        tbl.horizontalHeader().setSectionResizeMode(8, QtWidgets.QHeaderView.Stretch)
        v.addWidget(tbl, 1)

        # --- بارگذاری اقلام و انبارها ---
        def _load_items():
            item_combo.clear()
            try:
                # مواد اولیه و لوازم بسته‌بندی
                rows = self.db.execute_query(
                    """
                    SELECT id, name FROM items
                    WHERE category IN ('مواد اولیه','مواد اولیه و افزودنی','لوازم بسته‌بندی')
                    ORDER BY name
                    LIMIT 2000
                    """
                ) or []
            except Exception:
                rows = self.db.execute_query("SELECT id, name FROM items ORDER BY name LIMIT 2000") or []
            for r in rows:
                item_combo.addItem(r['name'], r['id'])

        def _load_warehouses():
            wh_combo.clear()
            wh_combo.addItem("همهٔ انبارها (خالص)", None)
            try:
                wrows = self.db.execute_query("SELECT name FROM warehouses ORDER BY name") or []
                for w in wrows:
                    wh_combo.addItem(w['name'], w['name'])
            except Exception:
                pass

        _load_items()
        _load_warehouses()
        d_from.setDate(QtCore.QDate.currentDate().addMonths(-1))
        d_to.setDate(QtCore.QDate.currentDate())


    # ==== BEGIN PATCH: MainWindow._show_kardex_dialog helpers ====

        # ==== BEGIN PATCH: MainWindow._show_kardex_dialog._calculate (freeze sort + stable order) ====
        def _calculate():
            DEBUG_TRACE = False
            ALLOW_SORTING = False  # برای جلوگیری از به‌هم‌خوردن مانده، سورت را خاموش نگه داریم.

            try:
                idx = item_combo.currentIndex()
                item_id = item_combo.itemData(idx)
                if not item_id:
                    QtWidgets.QMessageBox.warning(dlg, "انتخاب ناقص", "لطفاً یک کالا را انتخاب کنید.")
                    return

                wh_name   = wh_combo.currentData()
                as_from   = d_from.date().toString("yyyy-MM-dd")
                as_to     = d_to.date().toString("yyyy-MM-dd")
                batch_no  = (batch_edit.text().strip() or None)

                # سورت جدول را پیش از پر کردن حتماً خاموش نگه داریم
                try:
                    tbl.setSortingEnabled(False)
                    hh = tbl.horizontalHeader()
                    if not ALLOW_SORTING:
                        hh.setSortIndicatorShown(False)
                        hh.setSectionsClickable(False)
                    else:
                        hh.setSortIndicatorShown(True)
                        hh.setSectionsClickable(True)
                except Exception:
                    pass

                # ترتیب پارامترها: item_id, date_from, warehouse_name, date_to, batch_no
                payload = self.db.get_kardex(int(item_id), as_from, wh_name, as_to, batch_no) or {}

                # مهم: ردیف‌ها باید «قدیمی → جدید» باشند تا مانده درست محاسبه شود
                rows = payload.get('rows', []) or []
                rows.sort(key=lambda r: ((r.get('date') or ''), str(r.get('doc_no') or '')))
                payload['rows'] = rows

                if DEBUG_TRACE:
                    print(f"[TRACE:KARDEX:UI] rows={len(rows)} opening={payload.get('opening_balance')} "
                        f"sum_in={payload.get('sum_in')} sum_out={payload.get('sum_out')} bal={payload.get('balance')}")

                _fill_table(payload)  # جدول را پر کن (خودِ تابع مانده را سطری محاسبه می‌کند)

                # توجه: برای جلوگیری از به‌هم‌ریختن مانده، سورت را دوباره فعال نمی‌کنیم.
                if ALLOW_SORTING:
                    try:
                        tbl.setSortingEnabled(True)
                        tbl.sortItems(0, QtCore.Qt.AscendingOrder)  # اگر اجازه دادیم، حداقل پیش‌فرض صعودی باشد
                    except Exception:
                        pass

                btn_export.setEnabled(True)
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message("کارتکس محاسبه شد.", "success")

            except Exception as e:
                btn_export.setEnabled(False)
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message(f"خطا در محاسبه کارتکس: {e}", "critical")
                else:
                    QtWidgets.QMessageBox.critical(dlg, "خطا", f"خطا در محاسبه کارتکس:\n{e}")
                traceback.print_exc()
        # ==== END PATCH ====

        # --- _fill_table: نمایش «شمسی + ساعت» و نشاندن in/out زیر هدرهای صحیح ---
        def _fill_table(payload: dict):
            DEBUG_TRACE = False  # True برای دیباگ

            # مبدّل کم‌حجم میلادی→شمسی (بدون وابستگی خارجی)
            def _g2j(y, m, d):
                gy = y - 1600; gm = m - 1; gd = d - 1
                g_day_no = 365*gy + (gy+3)//4 - (gy+99)//100 + (gy+399)//400
                mdays = [31,29 if ((y%4==0 and y%100!=0) or (y%400==0)) else 28,31,30,31,30,31,31,30,31,30,31]
                for i in range(gm): g_day_no += mdays[i]
                g_day_no += gd
                j_day_no = g_day_no - 79
                j_np = j_day_no // 12053
                j_day_no %= 12053
                jy = 979 + 33*j_np + 4*(j_day_no//1461)
                j_day_no %= 1461
                if j_day_no >= 366:
                    jy += (j_day_no-1)//365
                    j_day_no = (j_day_no-1)%365
                jm_list = [31,31,31,31,31,31,30,30,30,30,30,29]
                jm = 0
                while jm < 12 and j_day_no >= jm_list[jm]:
                    j_day_no -= jm_list[jm]; jm += 1
                jd = j_day_no + 1
                return jy, jm+1, jd

            def _to_jalali_dt(dt_iso: str) -> str:
                # dt_iso: 'YYYY-MM-DD HH:MM:SS' یا فقط 'YYYY-MM-DD'
                if not dt_iso:
                    return ''
                parts = dt_iso.split(' ')
                date_part = parts[0]
                time_part = parts[1] if len(parts) > 1 else "00:00:00"
                y, m, d = map(int, date_part.split('-'))
                jy, jm, jd = _g2j(y, m, d)
                return f"{jy:04d}-{jm:02d}-{jd:02d} {time_part}"

            rows = payload.get('rows', []) or []
            # اگر dt_iso هست، رویش سورت کن؛ بعد doc_no تا مانده به‌درستی پله‌ای شود
            rows = sorted(rows, key=lambda r: (r.get('dt_iso') or r.get('date') or '', str(r.get('doc_no') or '')))

            tbl.setSortingEnabled(False)
            tbl.setRowCount(0)

            # موجودی ابتدای دوره
            r = tbl.rowCount(); tbl.insertRow(r)
            it = QtWidgets.QTableWidgetItem("موجودی ابتدای دوره")
            it.setForeground(QtGui.QColor("blue")); it.setFlags(QtCore.Qt.ItemIsEnabled)
            tbl.setItem(r, 0, it)
            for c in range(1, 8):
                tbl.setItem(r, c, QtWidgets.QTableWidgetItem(""))

            try:
                num = NumericTableWidgetItem(f"{float(payload.get('opening_balance',0)):.3f}")
            except Exception:
                num = QtWidgets.QTableWidgetItem(f"{float(payload.get('opening_balance',0)):.3f}")
                num.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
            num.setForeground(QtGui.QColor("blue")); num.setFlags(QtCore.Qt.ItemIsEnabled)
            tbl.setItem(r, 8, num)

            # مشخص کردن اینکه کدام ستون جدول «خروج» و کدام «ورود» است (بر اساس عنوان هدر)
            # پیش‌فرض‌های قبلی UI: ستون 6 و 7؛ اما به‌صورت ایمن از متن هدر می‌خوانیم.
            try:
                hdr6 = (tbl.horizontalHeaderItem(6).text() or '').strip()
                hdr7 = (tbl.horizontalHeaderItem(7).text() or '').strip()
            except Exception:
                hdr6, hdr7 = '', ''

            # ایمن‌سازی: اگر هدرِ ستون شامل «خروج» بود ⇒ آن ستون برای out_qty است و دیگری برای in_qty
            if 'خروج' in hdr6 and 'ورود' in hdr7:
                col_out, col_in = 6, 7
            elif 'ورود' in hdr6 and 'خروج' in hdr7:
                col_out, col_in = 7, 6
            else:
                # اگر نتوانست تشخیص دهد، به‌طور صریح: 6=خروج ، 7=ورود (مطابق اسکرین‌شات)
                col_out, col_in = 6, 7

            if DEBUG_TRACE:
                print(f"[TRACE:KARDEX:UI] col_out={col_out} col_in={col_in} hdr6='{hdr6}' hdr7='{hdr7}'")

            # ردیف‌ها
            bal_last = float(payload.get('opening_balance',0) or 0)
            for rec in rows:
                r = tbl.rowCount(); tbl.insertRow(r)

                # تاریخ (شمسی + ساعت) در همان ستون
                disp_dt = _to_jalali_dt(rec.get('dt_iso') or rec.get('date') or '')
                tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(disp_dt))

                tbl.setItem(r, 1, QtWidgets.QTableWidgetItem(str(rec.get('doc_no','') or '')))
                tbl.setItem(r, 2, QtWidgets.QTableWidgetItem(rec.get('type','') or ''))
                tbl.setItem(r, 3, QtWidgets.QTableWidgetItem(rec.get('batch','') or ''))
                tbl.setItem(r, 4, QtWidgets.QTableWidgetItem(rec.get('src_wh','') or ''))
                tbl.setItem(r, 5, QtWidgets.QTableWidgetItem(rec.get('dest_wh','') or ''))

                # ***** نکتهٔ اصلی: مقدارها زیر ستون درست بنشیند *****
                in_val  = float(rec.get('in_qty',  0) or 0)
                out_val = float(rec.get('out_qty', 0) or 0)

                # خروج
                try:
                    out_it = NumericTableWidgetItem(f"{out_val:.3f}")
                except Exception:
                    out_it = QtWidgets.QTableWidgetItem(f"{out_val:.3f}")
                    out_it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                tbl.setItem(r, col_out, out_it)

                # ورود
                try:
                    in_it = NumericTableWidgetItem(f"{in_val:.3f}")
                except Exception:
                    in_it = QtWidgets.QTableWidgetItem(f"{in_val:.3f}")
                    in_it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                tbl.setItem(r, col_in, in_it)

                # مانده
                bal_last = bal_last + in_val - out_val
                try:
                    bal_it = NumericTableWidgetItem(f"{bal_last:.3f}")
                except Exception:
                    bal_it = QtWidgets.QTableWidgetItem(f"{bal_last:.3f}")
                    bal_it.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
                tbl.setItem(r, 8, bal_it)

            # موجودی پایان دوره
            r = tbl.rowCount(); tbl.insertRow(r)
            it2 = QtWidgets.QTableWidgetItem("موجودی پایان دوره")
            it2.setForeground(QtGui.QColor("green")); it2.setFlags(QtCore.Qt.ItemIsEnabled)
            tbl.setItem(r, 0, it2)
            for c in range(1, 8):
                tbl.setItem(r, c, QtWidgets.QTableWidgetItem(""))

            try:
                num2 = NumericTableWidgetItem(f"{bal_last:.3f}")
            except Exception:
                num2 = QtWidgets.QTableWidgetItem(f"{bal_last:.3f}")
                num2.setTextAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
            num2.setForeground(QtGui.QColor("green")); num2.setFlags(QtCore.Qt.ItemIsEnabled)
            tbl.setItem(r, 8, num2)

            tbl.resizeRowsToContents()
            tbl.setSortingEnabled(True)

        # --- خروجی Excel از جدول
        def _export_excel():
            try:
                export_table_to_excel(tbl, dlg)
            except Exception as e:
                if hasattr(self, 'toast') and self.toast:
                    self.toast.show_message(f"خطا در خروجی اکسل: {e}", "critical")
                else:
                    QtWidgets.QMessageBox.critical(dlg, "خطا", f"خطا در خروجی اکسل:\n{e}")

        # اتصال رویدادها
        btn_calc.clicked.connect(_calculate)
        btn_export.clicked.connect(_export_excel)
        btn_close.clicked.connect(dlg.reject)

        # نمایش دیالوگ (نکته کلیدی که قبلاً غایب بود)
        dlg.exec_()
    # END REWRITE: MainWindow._show_kardex_dialog
    
    # BEGIN ADD: MainWindow._unify_finance_reports_menu
    def _unify_finance_reports_menu(self):
        """
        یکپارچه‌سازی گزارش‌های مالی در صفحهٔ تولید:
        - حذف/پنهان‌کردن آیتم‌های قدیمی منوی گزارش مالی
        - تبدیل دکمهٔ «گزارش مالی (BOM)» به یک دکمهٔ تک‌عمله برای
            باز کردن دیالوگ «گزارش یکپارچهٔ مالی تولید».
        وابسته به: self._show_finance_production_overview
        """
        from PyQt5 import QtWidgets, QtCore

        # 1) اکشن‌های قدیمی که باید حذف/پنهان شوند (متن‌ها طبق تصویر شما)
        old_actions_texts = {
            "BOM تاریخی (As-Of)",
            "کارتکس مواد/لوازم",
            "مصرف واقعی در برابر استاندارد",
            "گزارش استاندارد BOM (قدیمی)",
        }

        # هرکدام از QActionهای قدیمی را اگر وجود دارند، مخفی و قطع اتصال کن
        for act in self.findChildren(QtWidgets.QAction):
            try:
                if act.text() in old_actions_texts:
                    act.setVisible(False)
                    try:
                        act.triggered.disconnect()
                    except Exception:
                        pass
                    act.deleteLater()
            except Exception:
                continue

        # 2) دکمه/ابزار «گزارش مالی (BOM)» را پیدا کن (QToolButton یا QPushButton)
        report_buttons = []
        # اول بر اساس objectName متداول (اگر پروژه شما نام‌گذاری کرده باشد)
        for name in ("btn_finance_reports", "btn_bom_reports", "btn_reports_finance"):
            w = self.findChild(QtWidgets.QToolButton, name) or self.findChild(QtWidgets.QPushButton, name)
            if w:
                report_buttons.append(w)
        # اگر نام‌گذاری نبود، بر اساس متن دکمه پیدا کن
        if not report_buttons:
            for w in self.findChildren(QtWidgets.QToolButton) + self.findChildren(QtWidgets.QPushButton):
                try:
                    txt = (w.text() or "").replace("&", "")
                except Exception:
                    txt = ""
                if "گزارش مالی" in txt or "BOM" in txt:
                    report_buttons.append(w)

        if not report_buttons:
            # اگر در این صفحه دکمه پیدا نشد، کار دیگری نمی‌کنیم تا خطایی ایجاد نشود
            return

        # فقط روی اولین دکمهٔ پیدا شده اعمال کن (در اغلب صفحات یکی است)
        btn = report_buttons[0]

        # 3) اگر QToolButton با منو بود، منو را حذف و به دکمهٔ ساده تبدیل کن
        try:
            if isinstance(btn, QtWidgets.QToolButton):
                # حذف منوی قبلی (اگر بود)
                if btn.menu() is not None:
                    try:
                        btn.menu().clear()
                    except Exception:
                        pass
                    btn.setMenu(None)
                # اتصال‌های قبلی کلیک را قطع کن
                try:
                    btn.clicked.disconnect()
                except Exception:
                    pass
                # عنوان دکمه را واضح کن
                btn.setText("گزارش مالی (یکپارچه)")
                btn.setToolButtonStyle(QtCore.Qt.ToolButtonTextOnly)
                btn.setPopupMode(QtWidgets.QToolButton.DelayedPopup)
                # اتصال به گزارش یکپارچه
                btn.clicked.connect(self._show_finance_production_overview)
                # برای سازگاری: اکشن پیش‌فرض را هم تنظیم کن
                act = QtWidgets.QAction("گزارش یکپارچهٔ مالی تولید", btn)
                act.triggered.connect(self._show_finance_production_overview)
                btn.setDefaultAction(act)
        except Exception:
            pass

        # اگر QPushButton بود
        try:
            if isinstance(btn, QtWidgets.QPushButton):
                try:
                    btn.clicked.disconnect()
                except Exception:
                    pass
                btn.setText("گزارش مالی (یکپارچه)")
                btn.clicked.connect(self._show_finance_production_overview)
        except Exception:
            pass

        # 4) برای اطمینان: همهٔ QMenuهایی که عنوان‌شان «گزارش مالی (BOM)» است را هم خالی کن
        for m in self.findChildren(QtWidgets.QMenu):
            try:
                title = (m.title() or "").replace("&", "")
            except Exception:
                title = ""
            if "گزارش مالی" in title or "BOM" in title:
                try:
                    m.clear()
                except Exception:
                    pass
                a = m.addAction("گزارش یکپارچهٔ مالی تولید")
                a.triggered.connect(self._show_finance_production_overview)
    # END ADD: MainWindow._unify_finance_reports_menu

    
        
    def _show_finance_production_overview(self):
        """
        گزارش مالی تولید (فقط مقداری)
        1) خلاصه BOM (درختی: کالا—بچ ← مواد اولیه)
        2) خروجی بسته‌بندی (کیلوگرم)
        3) عکس لحظه‌ای موجودی (کیلوگرم)
        """
        from PyQt5 import QtWidgets, QtCore
        import datetime as dt
        import csv

        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("گزارش مالی تولید — مقداری"); dlg.resize(1300, 720)
        root = QtWidgets.QVBoxLayout(dlg)
        tabs = QtWidgets.QTabWidget(); root.addWidget(tabs, 1)
        tab_bar = tabs.tabBar()
        try:
            tab_bar.setObjectName("productionFinanceTabBar")
            tab_bar.setElideMode(QtCore.Qt.ElideRight)
            tab_bar.setUsesScrollButtons(True)
            tab_bar.setExpanding(False)
        except Exception:
            pass
        # /* UI-SCOPED-FIX: prod-finance-tabs 2025-09-23 */

        tab_bar.setStyleSheet("""

        productionFinanceTabBar::tab {

            min-height: 40px;

            min-width: 150px;

            padding: 8px 12px;

            margin: 0 3px;

        }

        productionFinanceTabBar::tab:selected {

            margin-top: 0px;

        }

        productionFinanceTabBar::tab:hover {

            margin-top: 0px;

        }

        """)

        # --- کمکی تاریخ ---
        def _to_g(s):
            try:
                return shamsi_to_gregorian((s or '').strip()).isoformat()
            except Exception:
                return None

        def _preset(e_from, e_to, days):
            try:
                e_to.setText(to_shamsi(dt.date.today()).replace('-', '/'))
                e_from.setText(to_shamsi(dt.date.today() - dt.timedelta(days=days-1)).replace('-', '/'))
            except Exception:
                pass

        # ================= TAB 1: خلاصه BOM (درختی) =================
        w1 = QtWidgets.QWidget(); l1 = QtWidgets.QVBoxLayout(w1)
        f1 = QtWidgets.QHBoxLayout(); l1.addLayout(f1)
        f1.addWidget(QtWidgets.QLabel("از (شمسی):")); d1_from = QtWidgets.QLineEdit(); d1_from.setInputMask("0000/00/00;_"); f1.addWidget(d1_from)
        f1.addWidget(QtWidgets.QLabel("تا (شمسی):")); d1_to   = QtWidgets.QLineEdit(); d1_to.setInputMask("0000/00/00;_");   f1.addWidget(d1_to)
        b1_today = QtWidgets.QPushButton("امروز"); b1_7 = QtWidgets.QPushButton("۷ روز"); b1_30 = QtWidgets.QPushButton("۳۰ روز"); b1_go = QtWidgets.QPushButton("محاسبه")
        for b in (b1_today,b1_7,b1_30,b1_go): f1.addWidget(b)

        # فیلتر + خروجی (خودکار)
        f1.addWidget(QtWidgets.QLabel("فیلتر:"))
        e_filter = QtWidgets.QLineEdit(); e_filter.setPlaceholderText("نام کالا / بچ / ماده...")
        f1.addWidget(e_filter, 1)
        b_clear = QtWidgets.QPushButton("پاک‌سازی فیلتر"); f1.addWidget(b_clear)
        b_export = QtWidgets.QPushButton("خروجی Excel"); f1.addWidget(b_export)

        tree1 = QtWidgets.QTreeWidget()
        tree1.setColumnCount(2)
        tree1.setHeaderLabels(["کالا — بچ / ماده اولیه (طبق محرمانگی)","مقدار (کیلوگرم)"])
        tree1.header().setStretchLastSection(False)
        tree1.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        tree1.header().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        l1.addWidget(tree1, 1)
        tabs.addTab(w1, "خلاصه BOM")

        try:
            d1_to.setText(to_shamsi(dt.date.today()).replace('-', '/'))
            d1_from.setText(to_shamsi(dt.date.today()-dt.timedelta(days=6)).replace('-', '/'))
        except Exception:
            pass

        def _t1_calc():
            df, dt_ = _to_g(d1_from.text()), _to_g(d1_to.text())
            if not (df and dt_):
                QtWidgets.QMessageBox.warning(dlg, "تاریخ نامعتبر", "تاریخ را درست وارد کنید.")
                return
            rows = self.db.get_bom_summary_over_time(df, dt_) or []
            tree1.clear()
            for rec in rows:
                top = QtWidgets.QTreeWidgetItem([rec.get('product_name') or '', ""])
                tree1.addTopLevelItem(top)
                for it in (rec.get('items') or []):
                    name = str(it.get('rm_display') or '')
                    qty  = it.get('qty_kg') or 0.0
                    child = QtWidgets.QTreeWidgetItem([name, f"{float(qty):.3f}"])
                    top.addChild(child)
            tree1.expandAll()
            _apply_filter()

        def _apply_filter():
            q = (e_filter.text() or "").strip().lower()
            for i in range(tree1.topLevelItemCount()):
                top = tree1.topLevelItem(i)
                if not q:
                    top.setHidden(False)
                    for j in range(top.childCount()):
                        top.child(j).setHidden(False)
                    continue
                top_match = (q in (top.text(0) or "").lower()) or (q in (top.text(1) or "").lower())
                any_child = False
                for j in range(top.childCount()):
                    ch = top.child(j)
                    m = (q in (ch.text(0) or "").lower()) or (q in (ch.text(1) or "").lower())
                    ch.setHidden(not m); any_child = any_child or m
                top.setHidden(not (top_match or any_child))

        def _export_tree_to_csv(hierarchical: bool):
            if tree1.topLevelItemCount() == 0:
                QtWidgets.QMessageBox.information(dlg, "خروجی", "چیزی برای خروجی وجود ندارد.")
                return
            path, _ = QtWidgets.QFileDialog.getSaveFileName(dlg, "ذخیرهٔ Excel/CSV", "bom_summary.csv", "CSV (*.csv)")
            if not path:
                return
            with open(path, "w", newline="", encoding="utf-8-sig") as f:
                w = csv.writer(f)
                if hierarchical:
                    w.writerow(["ردیف", "عنوان", "مقدار (کیلوگرم)"])
                    r = 1
                    for i in range(tree1.topLevelItemCount()):
                        top = tree1.topLevelItem(i)
                        if top.isHidden():  continue
                        w.writerow([r, top.text(0), ""]); r += 1
                        for j in range(top.childCount()):
                            ch = top.child(j)
                            if ch.isHidden():  continue
                            w.writerow([r, f"—  {ch.text(0)}", ch.text(1)]); r += 1
                else:
                    w.writerow(["کالا — بچ", "ماده اولیه (طبق محرمانگی)", "مقدار (کیلوگرم)"])
                    for i in range(tree1.topLevelItemCount()):
                        top = tree1.topLevelItem(i)
                        if top.isHidden():  continue
                        title = top.text(0)
                        for j in range(top.childCount()):
                            ch = top.child(j)
                            if ch.isHidden():  continue
                            w.writerow([title, ch.text(0), ch.text(1)])
            QtWidgets.QMessageBox.information(dlg, "خروجی", "فایل CSV با موفقیت ذخیره شد.")

        # نوع خروجیِ خودکار برای تب ۱
        def _export_bom_csv_auto():
            # اگر والدها فرزند دارند => درختی؛ در غیر این صورت تخت
            hierarchical = False
            for i in range(tree1.topLevelItemCount()):
                if tree1.topLevelItem(i).childCount() > 0:
                    hierarchical = True; break
            _export_tree_to_csv(hierarchical)

        b1_today.clicked.connect(lambda: _preset(d1_from,d1_to,1))
        b1_7.clicked.connect(lambda: _preset(d1_from,d1_to,7))
        b1_30.clicked.connect(lambda: _preset(d1_from,d1_to,30))
        b1_go.clicked.connect(_t1_calc)
        e_filter.textChanged.connect(_apply_filter)
        b_clear.clicked.connect(lambda: (e_filter.setText(""), _apply_filter()))
        b_export.clicked.connect(_export_bom_csv_auto)

        # =============== TAB 2: خروجی بسته‌بندی (کیلوگرم) ===============
        w2 = QtWidgets.QWidget(); l2 = QtWidgets.QVBoxLayout(w2)
        f2 = QtWidgets.QHBoxLayout(); l2.addLayout(f2)
        f2.addWidget(QtWidgets.QLabel("محصول مادر:")); c_parent = QtWidgets.QComboBox(); f2.addWidget(c_parent,1)
        f2.addWidget(QtWidgets.QLabel("از (شمسی):")); d2_from = QtWidgets.QLineEdit(); d2_from.setInputMask("0000/00/00;_"); f2.addWidget(d2_from)
        f2.addWidget(QtWidgets.QLabel("تا (شمسی):")); d2_to   = QtWidgets.QLineEdit(); d2_to.setInputMask("0000/00/00;_"); f2.addWidget(d2_to)
        b2_today = QtWidgets.QPushButton("امروز"); b2_7 = QtWidgets.QPushButton("۷ روز"); b2_30 = QtWidgets.QPushButton("۳۰ روز"); b2_go = QtWidgets.QPushButton("محاسبه")
        for b in (b2_today,b2_7,b2_30,b2_go): f2.addWidget(b)
        b2_export = QtWidgets.QPushButton("خروجی Excel"); f2.addWidget(b2_export)

        t2 = QtWidgets.QTableWidget(0,4)
        t2.setHorizontalHeaderLabels(["پک","تعداد (واحد)","وزن خالص هر پک","جمع (کیلوگرم)"])
        t2.verticalHeader().setVisible(False); t2.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        t2.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        t2.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for col in (1,2,3): t2.horizontalHeader().setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeToContents)
        l2.addWidget(t2,1)
        tabs.addTab(w2, "خروجی بسته‌بندی (کیلوگرم)")

        parents = self.db.execute_query("SELECT id,name FROM items WHERE is_parent_product = TRUE ORDER BY name") or []
        for r in parents: c_parent.addItem(r['name'], int(r['id']))
        if parents: c_parent.setCurrentIndex(0)
        try:
            d2_to.setText(to_shamsi(dt.date.today()).replace('-', '/'))
            d2_from.setText(to_shamsi(dt.date.today()-dt.timedelta(days=6)).replace('-', '/'))
        except Exception:
            pass

        def _t2_calc():
            pid = c_parent.currentData()
            df, dt_ = _to_g(d2_from.text()), _to_g(d2_to.text())
            if not (pid and df and dt_):
                QtWidgets.QMessageBox.warning(dlg,"ورودی ناقص","محصول مادر و تاریخ را کامل کنید."); return
            data = self.db.get_packaged_output_kg_over_time(int(pid), df, dt_) or {'rows':[],'total_kg':0}
            t2.setRowCount(0)
            for r,row in enumerate(data['rows']):
                t2.insertRow(r)
                t2.setItem(r,0,QtWidgets.QTableWidgetItem(row['pack_name']))
                it = QtWidgets.QTableWidgetItem(f"{float(row['qty_units']):.3f}"); it.setTextAlignment(QtCore.Qt.AlignCenter); t2.setItem(r,1,it)
                it = QtWidgets.QTableWidgetItem(f"{float(row['net_weight']):.3f}"); it.setTextAlignment(QtCore.Qt.AlignCenter); t2.setItem(r,2,it)
                it = QtWidgets.QTableWidgetItem(f"{float(row['qty_kg']):.3f}"); it.setTextAlignment(QtCore.Qt.AlignCenter); t2.setItem(r,3,it)
            r = t2.rowCount(); t2.insertRow(r)
            it = QtWidgets.QTableWidgetItem("جمع کل (کیلوگرم)"); it.setFlags(it.flags() & ~QtCore.Qt.ItemIsSelectable); t2.setItem(r,0,it)
            t2.setItem(r,1,QtWidgets.QTableWidgetItem("")); t2.setItem(r,2,QtWidgets.QTableWidgetItem(""))
            it = QtWidgets.QTableWidgetItem(f"{float(data.get('total_kg') or 0.0):.3f}"); it.setTextAlignment(QtCore.Qt.AlignCenter); t2.setItem(r,3,it)

        def _export_tablewidget_to_csv(tbl: QtWidgets.QTableWidget, suggested: str):
            if tbl.rowCount() == 0:
                QtWidgets.QMessageBox.information(dlg, "خروجی", "چیزی برای خروجی وجود ندارد.")
                return
            path, _ = QtWidgets.QFileDialog.getSaveFileName(dlg, "ذخیرهٔ Excel/CSV", suggested, "CSV (*.csv)")
            if not path:
                return
            with open(path, "w", newline="", encoding="utf-8-sig") as f:
                w = csv.writer(f)
                headers = [tbl.horizontalHeaderItem(c).text() for c in range(tbl.columnCount())]
                w.writerow(headers)
                for r in range(tbl.rowCount()):
                    row = []
                    for c in range(tbl.columnCount()):
                        it = tbl.item(r, c)
                        row.append("" if it is None else it.text())
                    w.writerow(row)
            QtWidgets.QMessageBox.information(dlg, "خروجی", "فایل CSV با موفقیت ذخیره شد.")

        b2_today.clicked.connect(lambda: _preset(d2_from,d2_to,1))
        b2_7.clicked.connect(lambda: _preset(d2_from,d2_to,7))
        b2_30.clicked.connect(lambda: _preset(d2_from,d2_to,30))
        b2_go.clicked.connect(_t2_calc)
        b2_export.clicked.connect(lambda: _export_tablewidget_to_csv(t2, "pack_output.csv"))

        # =========== TAB 3: عکس لحظه‌ای موجودی (کیلوگرم) ===========
        w3 = QtWidgets.QWidget(); l3 = QtWidgets.QVBoxLayout(w3)
        f3 = QtWidgets.QHBoxLayout(); l3.addLayout(f3)
        f3.addWidget(QtWidgets.QLabel("تاریخ (شمسی):")); d3 = QtWidgets.QLineEdit(); d3.setInputMask("0000/00/00;_"); f3.addWidget(d3)
        f3.addWidget(QtWidgets.QLabel("انبار تولید:")); cmb_wh = QtWidgets.QComboBox(); f3.addWidget(cmb_wh, 1)
        f3.addWidget(QtWidgets.QLabel("دستهٔ موجودی:")); cmb_kind = QtWidgets.QComboBox(); f3.addWidget(cmb_kind)
        cmb_kind.addItems(["مواد اولیه","محصولات فله","لوازم بسته‌بندی","محصولات بسته‌بندی‌شده"])
        b3_today = QtWidgets.QPushButton("امروز"); b3_go = QtWidgets.QPushButton("نمایش")
        for b in (b3_today,b3_go): f3.addWidget(b)
        b3_export = QtWidgets.QPushButton("خروجی Excel"); f3.addWidget(b3_export)

        # پرکردن کمبو با انبارهای «تولید»
        keys = ["مواد اولیه", "محصولات فله", "لوازم بسته‌بندی", "محصولات بسته‌بندی", "Production", "کارگاه", "تولید", "Workshop"]
        like = " OR ".join(["name ILIKE %s"]*len(keys))
        rows = self.db.execute_query(f"SELECT id,name FROM warehouses WHERE {like} ORDER BY id",
                                    tuple([f"%{k}%" for k in keys])) or []
        for r in rows: cmb_wh.addItem(r["name"], int(r["id"]))

        t3 = QtWidgets.QTableWidget(0,3)
        t3.setHorizontalHeaderLabels(["نام","مقدار (واحد)","مقدار (کیلوگرم)"])
        t3.verticalHeader().setVisible(False); t3.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        t3.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        t3.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        t3.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        t3.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)
        l3.addWidget(t3,1)
        tabs.addTab(w3, "عکس لحظه‌ای موجودی (کیلوگرم)")

        for idx in range(tabs.count()):
            tabs.setTabToolTip(idx, tabs.tabText(idx))

        try: d3.setText(to_shamsi(dt.date.today()).replace('-', '/'))
        except Exception: pass

        def _map_kind(text):
            t = (text or "").strip()
            return "RM"   if t=="مواد اولیه" else \
                "BULK" if t=="محصولات فله" else \
                "PKG"  if t=="لوازم بسته‌بندی" else "FG"

        def _t3_calc():
            g = _to_g(d3.text())
            if not g:
                QtWidgets.QMessageBox.warning(dlg,"تاریخ نامعتبر","تاریخ را درست وارد کنید."); return
            if cmb_wh.count()==0:
                QtWidgets.QMessageBox.information(dlg,"انبار پیدا نشد","هیچ انبار تولیدی یافت نشد."); return
            wh_name = cmb_wh.currentText()
            kind = _map_kind(cmb_kind.currentText())

            if not self.db.has_inventory_snapshot(g):
                QtWidgets.QMessageBox.information(dlg, "اسنپ‌شات موجود نیست",
                    "برای این تاریخ اسنپ‌شات ثبت نشده است.\n"
                    "برنامه را در ابتدای روز باز کنید تا اسنپ‌شات روزانه ساخته شود.")
                t3.setRowCount(0); return

            data = self.db.get_inventory_snapshot_kg(g, kind, warehouse_name=wh_name) or {'rows':[],'total_kg':0,'snapshot_found':True}
            t3.setRowCount(0)
            for r,row in enumerate(data['rows']):
                t3.insertRow(r)
                t3.setItem(r,0,QtWidgets.QTableWidgetItem(row['name']))
                it = QtWidgets.QTableWidgetItem(f"{float(row.get('qty_units',0.0)):.3f}"); it.setTextAlignment(QtCore.Qt.AlignCenter); t3.setItem(r,1,it)
                it = QtWidgets.QTableWidgetItem(f"{float(row.get('qty_kg',0.0)):.3f}");   it.setTextAlignment(QtCore.Qt.AlignCenter); t3.setItem(r,2,it)
            r = t3.rowCount(); t3.insertRow(r)
            it = QtWidgets.QTableWidgetItem("جمع کل (کیلوگرم)"); it.setFlags(it.flags() & ~QtCore.Qt.ItemIsSelectable); t3.setItem(r,0,it)
            t3.setItem(r,1,QtWidgets.QTableWidgetItem(""))
            it = QtWidgets.QTableWidgetItem(f"{float(data.get('total_kg') or 0.0):.3f}"); it.setTextAlignment(QtCore.Qt.AlignCenter); t3.setItem(r,2,it)

        b3_today.clicked.connect(lambda: d3.setText(to_shamsi(dt.date.today()).replace('-', '/')))
        b3_go.clicked.connect(_t3_calc)
        b3_export.clicked.connect(lambda: _export_tablewidget_to_csv(t3, "inventory_snapshot.csv"))

        dlg.exec_()
            
                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_production_inventory(self):
        """
        نسخه نهایی: تمام موجودی‌ها را مستقیماً از انبار تولید (جدول stock) می‌خواند.
        """
        if not all(hasattr(self, name) for name in ['tbl_prod_raw', 'tbl_prod_bulk', 'tbl_prod_supplies', 'tbl_prod_packaged']):
            return

        def populate_stock_table(table, data, headers):
            # ... (این تابع داخلی بدون تغییر باقی می‌ماند)
            tooltip_text = "برای مشاهده جزئیات بچ در انبار تولید، دابل کلیک کنید"
            table.setSortingEnabled(False); table.setRowCount(0)
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(data))
            for r, item_row_data in enumerate(data):
                name_item = QtWidgets.QTableWidgetItem(item_row_data.get('name'))
                name_item.setData(Qt.UserRole, dict(item_row_data))
                name_item.setToolTip(tooltip_text)
                table.setItem(r, 0, name_item)
                values = [item_row_data.get('batch_no'), str(item_row_data.get('total_qty', 0)), item_row_data.get('unit'), to_shamsi(item_row_data.get('expiry_date'))]
                for c_offset, value in enumerate(values):
                    cell_item = QtWidgets.QTableWidgetItem(value); cell_item.setToolTip(tooltip_text); table.setItem(r, 1 + c_offset, cell_item)
            set_empty_placeholder(table, "هیچ موردی یافت نشد."); table.resizeColumnsToContents(); table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch); table.setSortingEnabled(True)

        try:
            # --- *** اصلاح کلیدی و نهایی اینجاست: منبع داده به stock تغییر کرد *** ---
            stock_in_prod = self.db.get_stock_for_warehouse('Production')
            headers = ['نام کالا', 'شماره بچ', 'مقدار موجود', 'واحد', 'تاریخ انقضا']

            populate_stock_table(self.tbl_prod_raw, [i for i in stock_in_prod if i.get('category') == CATEGORY_RAW_MATERIAL], headers)
            populate_stock_table(self.tbl_prod_supplies, [i for i in stock_in_prod if i.get('category') == CATEGORY_PACKAGING], headers)
            # برای محصولات فله نیز از همین منبع استفاده می‌کنیم
            # AFTER: hide zero/near-zero rows in BULK tab
            populate_stock_table(
                self.tbl_prod_bulk,
                [
                    i for i in stock_in_prod
                    if i.get('category') == CATEGORY_BULK_PRODUCT
                    and float(i.get('total_qty') or 0) > 0.001  # filter zeros; tolerate float noise
                ],
                headers
            )

            packaged_stock = [i for i in stock_in_prod if i.get('category') == CATEGORY_FINAL_PRODUCT]
            table = self.tbl_prod_packaged
            table.setSortingEnabled(False); table.setRowCount(0)
            pkg_headers = ['محصول مادر', 'مشخصات پک', 'شماره بچ', 'موجودی', 'تاریخ انقضا']
            table.setColumnCount(len(pkg_headers)); table.setHorizontalHeaderLabels(pkg_headers)
            table.setRowCount(len(packaged_stock))
            tooltip_text = "برای مشاهده جزئیات بچ در انبار تولید، دابل کلیک کنید"
            for r, item in enumerate(packaged_stock):
                item_data = dict(item); parent_name = "نامشخص"
                if item_data.get('parent_item_id'):
                    parent_info = self.db.get_item_details(item_data['parent_item_id']); parent_name = parent_info.get('name', 'نامشخص') if parent_info else 'نامشخص'
                parent_name_item = QtWidgets.QTableWidgetItem(parent_name); parent_name_item.setData(Qt.UserRole, item_data); parent_name_item.setToolTip(tooltip_text); table.setItem(r, 0, parent_name_item)
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(item_data['name'])); table.item(r, 1).setToolTip(tooltip_text)
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(item_data['batch_no'])); table.item(r, 2).setToolTip(tooltip_text)
                table.setItem(r, 3, NumericTableWidgetItem(str(item_data['total_qty']))); table.item(r, 3).setToolTip(tooltip_text)
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(item_data.get('expiry_date')))); table.item(r, 4).setToolTip(tooltip_text)
            table.resizeColumnsToContents(); table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch); table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch); table.setSortingEnabled(True)
            self._update_packaged_selection_summary()

        except Exception as e:
            print(f"Error loading production inventory: {e}"); self.toast.show_message("خطا در بارگذاری موجودی تولید.", "critical")                        

    def _update_packaged_selection_summary(self):
        """جمع انتخاب‌ها در جدول محصولات بسته‌بندی شده را به‌روزرسانی می‌کند."""
        table = getattr(self, "tbl_prod_packaged", None)
        label = getattr(self, "lbl_packaged_selection", None)
        if table is None or label is None:
            return
        sel_model = table.selectionModel()
        if sel_model is None or not sel_model.hasSelection():
            label.setText("هنوز هیچ ردیفی انتخاب نشده است.")
            return
        rows = {index.row() for index in sel_model.selectedRows()}
        total_qty = 0.0
        for row in rows:
            item = table.item(row, 3)
            if item is None:
                continue
            try:
                value = float(item.text().replace(',', ''))
            except Exception:
                value = 0.0
            total_qty += value
        summary = f"{len(rows)} ردیف انتخاب شد"
        if total_qty > 0:
            summary += f" | جمع مقدار: {total_qty:,.3f}"
        label.setText(summary)

        # BEGIN REWRITE: MainWindow._build_production_page
    def _build_production_page(self):
        """
        نسخه نهایی و کامل:
        - شامل داشبورد KPI و کارتابل سفارشات تولید.
        - دارای دکمه برای بسته‌بندی دستی (Ad-hoc) و همچنین میزکار هوشمند مبتنی بر سفارش.
        - ⚠️ دکمه‌های «مدیریت محرمانگی فرمول‌ها» و «گزارش مالی (BOM)» در همان ردیف عملیات اضافه شده‌اند.
        """
        layout = self.create_page_layout(self.pg_prod, "داشبورد و عملیات تولید")
        self.prod_stack = QtWidgets.QStackedWidget()
        layout.addWidget(self.prod_stack)

        # === پنل اصلی: داشبورد ===
        dashboard_panel_frame = QtWidgets.QWidget()
        dashboard_layout = QtWidgets.QVBoxLayout(dashboard_panel_frame)
        dashboard_layout.setContentsMargins(0, 10, 0, 0)
        dashboard_layout.setSpacing(15)

        top_layout = QtWidgets.QHBoxLayout()
        top_layout.setSpacing(20)

        self.prod_card_new_orders = self._create_kpi_card("سفارشات تولید جدید", "0", "#3498db", "view-process-tasks")
        self.prod_card_bulk       = self._create_kpi_card("محصولات فله فعال", "0", "#1abc9c", "view-list-tree")
        self.prod_card_ready      = self._create_kpi_card("محصولات آماده تحویل", "0", "#9b59b6", "go-up")
        self.prod_card_new_orders.setToolTip("تعداد سفارش‌هایی که هنوز شروع نشده‌اند.")
        self.prod_card_bulk.setToolTip("محصولات فله‌ای که در حال آماده‌سازی هستند.")
        self.prod_card_ready.setToolTip("محصولات بسته‌بندی شده و آماده تحویل.")

        top_layout.addWidget(self.prod_card_new_orders)
        top_layout.addWidget(self.prod_card_bulk)
        top_layout.addWidget(self.prod_card_ready)
        top_layout.addStretch()

        btn_go_to_ops = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), " ورود به عملیات تولید")
        btn_go_to_ops.setMinimumHeight(55)
        btn_go_to_ops.setMinimumWidth(280)
        btn_go_to_ops.setProperty("class", "primary")
        btn_go_to_ops.setStyleSheet("font-size: 12pt; font-weight: bold;")
        btn_go_to_ops.clicked.connect(self._go_to_prod_operations)
        top_layout.addWidget(btn_go_to_ops)

        dashboard_layout.addLayout(top_layout)

        workbench_group = QtWidgets.QGroupBox("کارتابل سفارشات تولید (برای برنامه‌ریزی، روی ردیف دابل کلیک کنید)")
        workbench_layout = QtWidgets.QVBoxLayout(workbench_group)
        self.tbl_prod_orders = QtWidgets.QTableWidget()
        self._style_table(self.tbl_prod_orders)
        self.tbl_prod_orders.itemDoubleClicked.connect(self._start_production_from_order)
        workbench_layout.addWidget(self.tbl_prod_orders)
        dashboard_layout.addWidget(workbench_group, 1)

        self.prod_stack.addWidget(dashboard_panel_frame)

        # === پنل دوم: عملیات و گزارش‌ها ===
        operations_panel_frame = QtWidgets.QWidget()
        operations_layout = QtWidgets.QVBoxLayout(operations_panel_frame)
        operations_layout.setContentsMargins(0, 10, 0, 0)

        action_bar = QtWidgets.QHBoxLayout()
        action_bar.setContentsMargins(0, 0, 0, 10)
        action_bar.setSpacing(10)

        btn_back_to_dash = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " بازگشت به داشبورد")
        btn_back_to_dash.setMinimumHeight(35)
        btn_back_to_dash.clicked.connect(self._go_to_prod_dashboard)
        action_bar.addWidget(btn_back_to_dash)
        action_bar.addSpacing(20)

        if self.has_permission('production:report'):
            btn_report_prod = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " ثبت گزارش تولید")
            btn_report_prod.setProperty("class", "primary")
            btn_report_prod.setMinimumHeight(35)
            btn_report_prod.clicked.connect(self._open_report_production_dialog)
            action_bar.addWidget(btn_report_prod)

        # --- دکمه بسته‌بندی دستی ---
        if self.has_permission('production:packing'):
            btn_packing = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("utilities-x-archive"), " بسته‌بندی محصول")
            btn_packing.setMinimumHeight(35)
            btn_packing.clicked.connect(self._open_packing_dialog)
            action_bar.addWidget(btn_packing)

        if self.has_permission('production:request_materials'):
            btn_req_mat = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-down"), " درخواست مواد/لوازم")
            btn_req_mat.setMinimumHeight(35)
            btn_req_mat.clicked.connect(self._request_material)
            action_bar.addWidget(btn_req_mat)

        # --- گزارش مالی (BOM): کلیک = گزارش یکپارچه، راست‌کلیک = منوی گزارش‌های قبلی ---
        btn_fin = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("x-office-spreadsheet"), " گزارش مالی (BOM)")
        btn_fin.setObjectName("btn_financial_reports")
        btn_fin.setMinimumHeight(35)
        btn_fin.setProperty('perm_code', 'production:financial_report')

        # قبلاً اینجا 'production:report' بود
        can_fin = self.has_permission('production:financial_report')

        fin_menu = QtWidgets.QMenu(self)
        added = 0
        if hasattr(self, "_show_bom_asof_dialog"):
            fin_menu.addAction("BOM تاریخی (As-Of)").triggered.connect(self._show_bom_asof_dialog); added += 1
        if hasattr(self, "_show_kardex_dialog"):
            fin_menu.addAction("کارتکس مواد/لوازم").triggered.connect(self._show_kardex_dialog); added += 1
        if hasattr(self, "_show_consumption_variance_dialog"):
            fin_menu.addAction("مصرف واقعی در برابر استاندارد").triggered.connect(self._show_consumption_variance_dialog); added += 1
        if hasattr(self, "_generate_financial_bom_report"):
            if added > 0:
                fin_menu.addSeparator()
            fin_menu.addAction("گزارش استاندارد BOM (قدیمی)").triggered.connect(self._generate_financial_bom_report); added += 1

        self._fin_menu = fin_menu

        if can_fin:
            if hasattr(self, "_show_finance_production_overview"):
                btn_fin.clicked.connect(self._show_finance_production_overview)
                btn_fin.setEnabled(True)
                btn_fin.setToolTip("کلیک = گزارش یکپارچهٔ مالی تولید • راست‌کلیک = سایر گزارش‌ها")
                btn_fin.setContextMenuPolicy(Qt.CustomContextMenu)
                btn_fin.customContextMenuRequested.connect(
                    lambda pos: self._fin_menu.exec_(btn_fin.mapToGlobal(pos)) if added > 0 else None
                )
            else:
                if added > 0:
                    btn_fin.clicked.connect(lambda: self._fin_menu.exec_(btn_fin.mapToGlobal(btn_fin.rect().bottomLeft())))
                    btn_fin.setEnabled(True)
                    btn_fin.setToolTip("گزارش‌های مالی تولید")
                else:
                    btn_fin.setEnabled(False)
                    btn_fin.setToolTip("هیچ گزارش فعالی برای نمایش موجود نیست.")
        else:
            btn_fin.setEnabled(False)
            btn_fin.setToolTip("⛔ دسترسی لازم: production:financial_report")

        action_bar.addWidget(btn_fin)

        btn_other_ops = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-more"), " سایر عملیات")
        btn_other_ops.setMinimumHeight(35)
        self._rebuild_other_ops_menu(btn_other_ops)  # ← منوی دسترسی‌محور را بساز
        action_bar.addWidget(btn_other_ops)
        
        action_bar.addWidget(btn_other_ops)

        action_bar.addStretch()
        operations_layout.addLayout(action_bar)
        hint_label = QtWidgets.QLabel("راهنما: ابتدا محصول و مقدار را مشخص کنید، سپس بچ‌ها را انتخاب کنید.")
        hint_label.setStyleSheet("color:#616161; font-size:10pt;")
        hint_label.setWordWrap(True)
        operations_layout.addWidget(hint_label)

        # --- تب‌ها: موجودی و گزارش‌ها ---
        main_tabs = QtWidgets.QTabWidget()
        main_tabs.setObjectName("mainProdTabs")
        operations_layout.addWidget(main_tabs, 1)
        main_tabs.setStyleSheet("QTabBar::tab { min-width: 200px; padding: 10px; }")

        # موجودی کف کارگاه
        inventory_panel_frame = QtWidgets.QWidget()
        inventory_layout = QtWidgets.QVBoxLayout(inventory_panel_frame)
        inventory_layout.setContentsMargins(0, 10, 0, 0)

        inventory_tabs = QtWidgets.QTabWidget()
        inventory_tabs.setObjectName("interfaceTabWidget")
        inventory_layout.addWidget(inventory_tabs)
        inventory_tabs.tabBar().setExpanding(True)

        self.tbl_prod_raw = QtWidgets.QTableWidget()
        self._style_table(self.tbl_prod_raw)
        inventory_tabs.addTab(self.tbl_prod_raw, "مواد اولیه")

        self.tbl_prod_bulk = QtWidgets.QTableWidget()
        self._style_table(self.tbl_prod_bulk)
        inventory_tabs.addTab(self.tbl_prod_bulk, "محصولات فله")

        self.tbl_prod_supplies = QtWidgets.QTableWidget()
        self._style_table(self.tbl_prod_supplies)
        inventory_tabs.addTab(self.tbl_prod_supplies, "لوازم بسته‌بندی")

        self.tbl_prod_packaged = QtWidgets.QTableWidget()
        self._style_table(self.tbl_prod_packaged)
        inventory_tabs.addTab(self.tbl_prod_packaged, "محصولات بسته‌بندی شده")
        self.lbl_packaged_selection = QtWidgets.QLabel("هنوز هیچ ردیفی انتخاب نشده است.")
        self.lbl_packaged_selection.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.lbl_packaged_selection.setStyleSheet("color:#424242; margin-top:4px;")
        inventory_layout.addWidget(self.lbl_packaged_selection)
        self.tbl_prod_packaged.itemSelectionChanged.connect(self._update_packaged_selection_summary)
        self._update_packaged_selection_summary()

        # گزارش‌ها و تاریخچه
        history_panel_frame = QtWidgets.QWidget()
        history_layout = QtWidgets.QVBoxLayout(history_panel_frame)
        history_layout.setContentsMargins(0, 10, 0, 0)

        history_tabs = QtWidgets.QTabWidget()
        history_tabs.setObjectName("interfaceTabWidget")
        history_layout.addWidget(history_tabs)
        history_tabs.tabBar().setExpanding(True)

        # تاریخچه مصرف (BOM)
        bom_page   = QtWidgets.QWidget()
        bom_layout = QtWidgets.QVBoxLayout(bom_page)
        bom_toolbar = QtWidgets.QHBoxLayout()
        bom_search_edit = QtWidgets.QLineEdit(placeholderText="جستجوی سریع در محصول، ماده اولیه یا بچ...")
        bom_search_edit.textChanged.connect(self._filter_bom_tree_quick)
        bom_toolbar.addWidget(bom_search_edit)
        bom_layout.addLayout(bom_toolbar)

        self.tbl_bom = QtWidgets.QTreeWidget()
        self.tbl_bom.setObjectName("bom_tree")
        self.tbl_bom.setItemDelegate(CustomTreeDelegate(self.tbl_bom))
        self.tbl_bom.setAlternatingRowColors(True)
        self.tbl_bom.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        headers_bom = ['شرح (محصول / ماده اولیه)', 'بچ', 'مقدار مصرف', 'تاریخ', 'کاربر', 'پیوست', 'وضعیت']
        self.tbl_bom.setHeaderLabels(headers_bom)
        self.tbl_bom.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.tbl_bom.setColumnWidth(5, 40)
        self.tbl_bom.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tbl_bom.customContextMenuRequested.connect(self._show_bom_context_menu)
        self.tbl_bom.itemClicked.connect(self._on_bom_tree_item_clicked)
        bom_layout.addWidget(self.tbl_bom)
        history_tabs.addTab(bom_page, "تاریخچه مصرف (BOM)")

        # تاریخچه تحویل‌ها
        delivery_status_page = QtWidgets.QWidget()
        delivery_layout = QtWidgets.QVBoxLayout(delivery_status_page)
        self.tbl_delivery_history = QtWidgets.QTableWidget()
        self._style_table(self.tbl_delivery_history)
        add_filter_export_tools(self.tbl_delivery_history, delivery_layout)
        delivery_layout.addWidget(self.tbl_delivery_history)
        history_tabs.addTab(delivery_status_page, "تاریخچه تحویل‌ها")

        # ارسال به آزمایشگاه
        lab_page = QtWidgets.QWidget()
        lab_layout = QtWidgets.QVBoxLayout(lab_page)
        self.tbl_lab_deliveries = QtWidgets.QTableWidget()
        self._style_table(self.tbl_lab_deliveries)
        add_filter_export_tools(self.tbl_lab_deliveries, lab_layout)
        lab_layout.addWidget(self.tbl_lab_deliveries)
        history_tabs.addTab(lab_page, "ارسال به آزمایشگاه")

        # تاریخچه درخواست‌های من
        my_requests_page = QtWidgets.QWidget()
        my_requests_layout = QtWidgets.QVBoxLayout(my_requests_page)
        self.tbl_my_requests = QtWidgets.QTableWidget()
        self._style_table(self.tbl_my_requests)
        
        self.chk_group_myreqs_by_doc = QtWidgets.QCheckBox("نمایش گروهی بر اساس شماره سند")
        self.chk_group_myreqs_by_doc.stateChanged.connect(self._load_my_request_history)  # تغییر حالت → رفرش جدول
        my_requests_layout.addWidget(self.chk_group_myreqs_by_doc)
        
        add_filter_export_tools(self.tbl_my_requests, my_requests_layout)
        my_requests_layout.addWidget(self.tbl_my_requests)
        history_tabs.addTab(my_requests_page, "تاریخچه درخواست‌های من")

        main_tabs.addTab(inventory_panel_frame, "موجودی کف کارگاه")
        main_tabs.addTab(history_panel_frame, "گزارش‌ها و تاریخچه")

        self.prod_stack.addWidget(operations_panel_frame)
        self._wire_production_other_ops_menu()
        self._apply_production_privacy()
        
        # === زیرتب: تبدیلات تولید ===
        conv_page = QtWidgets.QWidget()
        conv_layout = QtWidgets.QVBoxLayout(conv_page)

        self.tbl_conv_history = QtWidgets.QTableWidget()
        self._style_table(self.tbl_conv_history)
        # اگر تابع ابزار Export/Filter داری از همان استفاده کن
        try:
            add_filter_export_tools(self.tbl_conv_history, conv_layout)
        except Exception:
            pass
        conv_layout.addWidget(self.tbl_conv_history)

        # تب را اضافه کن و ایندکسش را نگه دار
        self._tabidx_conv = history_tabs.addTab(conv_page, "تبدیلات تولید")

        # وقتی کاربر این تب را باز می‌کند، داده را بارگذاری کن
        def _on_history_tab_changed(idx):
            try:
                if idx == self._tabidx_conv:
                    self._load_production_conversions()
            except Exception:
                pass

        history_tabs.currentChanged.connect(_on_history_tab_changed)
        
    # Production Conversions: replace _load_production_conversions()
    def _load_production_conversions(self):
        """
        لودر تب «تبدیلات تولید».
        جدول را با کلیدها/ترتیب زیر پر می‌کند:
        d, a, b, qty, b_batch, username, t_no, note
        """
        from PyQt5 import QtWidgets, QtCore
        DEBUG_TRACE = globals().get("DEBUG_TRACE", False)

        # پیدا کردن TableWidget همین زیرتب به‌صورت مطمئن
        table = getattr(self, 'tbl_production_conversions', None)
        if table is None:
            # اگر اسم مشخص نداریم: دنبال TabPage با عنوان «تبدیلات تولید» می‌گردیم
            table = None
            try:
                # فعال‌ترین QTabWidget را پیدا کن
                for tw in self.findChildren(QtWidgets.QTabWidget):
                    for i in range(tw.count()):
                        if tw.tabText(i).strip() == 'تبدیلات تولید':
                            page = tw.widget(i)
                            tbls = page.findChildren(QtWidgets.QTableWidget)
                            if tbls:
                                table = tbls[0]
                                break
                    if table:
                        break
            except Exception:
                table = None

        if table is None:
            # آخرین راه‌حل: اولین جدول روی صفحه را استفاده کن (برای اینکه UI کرش نکند)
            tbs = self.findChildren(QtWidgets.QTableWidget)
            table = tbs[0] if tbs else None

        if table is None:
            if DEBUG_TRACE:
                print("[TRACE:CONV:ui] table not found")
            return

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        try:
            rows = self.db.get_production_conversions(limit=500, offset=0) or []
            if DEBUG_TRACE:
                import sys
                print(f"[TRACE:CONV:ui] fetched={len(rows)}")
                sys.stdout.flush()

            headers = ['تاریخ', 'A', 'B', 'مقدار', 'بچ B', 'کاربر', 'شماره سند', 'یادداشت']
            table.setSortingEnabled(False)
            table.clear()
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(rows))

            # پرکردن جدول
            for r, rec in enumerate(rows):
                vals = [
                    to_shamsi(rec.get('d')),
                    rec.get('a') or '',
                    rec.get('b') or '',
                    f"{float(rec.get('qty') or 0):g}",
                    rec.get('b_batch') or '',
                    rec.get('username') or '',
                    rec.get('t_no') or '',
                    rec.get('note') or '',
                ]
                for c, v in enumerate(vals):
                    table.setItem(r, c, QtWidgets.QTableWidgetItem(str(v)))

            table.setSortingEnabled(True)

        except Exception as e:
            try:
                QtWidgets.QMessageBox.critical(self, "خطا در خواندن تبدیلات تولید", str(e))
            except Exception:
                import sys, traceback
                traceback.print_exc(file=sys.stdout)
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()


    # END REWRITE: MainWindow._build_production_page
        
    def __resolve_production_loc_ids(self):
        """
        لوکیشن(های) معتبرِ «انبار تولید» را برمی‌گرداند.
        چند مسیر مطمئن:
        1) اگر DB متدی به‌نام get_production_floor_location دارد → همان id
        2) جستجو بر اساس نام/برچسب‌های رایج در لوکیشن/انبار (فارسی/انگلیسی)
        3) تنظیمات داخلی برنامه اگر کلیدی ذخیره شده باشد
        خروجی: set از آی‌دی‌های لوکیشن تولید (ممکن است چندتا باشد).
        """
        loc_ids = set()

        # مسیر 1: متد آماده در DB
        try:
            if hasattr(self.db, 'get_production_floor_location'):
                pid = self.db.get_production_floor_location()
                if pid:
                    loc_ids.add(int(pid))
        except Exception:
            pass

        # مسیر 2: جستجو با نام/برچسب
        try:
            rows = self.db.execute_query("""
                SELECT l.id AS loc_id, LOWER(COALESCE(l.name,'')) AS lname,
                    LOWER(COALESCE(w.name,'')) AS wname
                FROM locations l
                LEFT JOIN warehouses w ON w.id=l.warehouse_id
            """)
            for r in rows or []:
                lname = r.get('lname',''); wname = r.get('wname','')
                hay = lname + " " + wname
                # کلیدواژه‌های تولید
                if any(k in hay for k in ['تولید','کارگاه','production','workshop','floor']):
                    loc_ids.add(int(r['loc_id']))
        except Exception:
            pass

        # مسیر 3: تنظیمات
        try:
            if hasattr(self.db, 'get_setting'):
                v = self.db.get_setting('production_loc_id', '')
                if v:
                    loc_ids.add(int(v))
        except Exception:
            pass

        return loc_ids

    def __is_prod_row(self, row_dict, prod_loc_ids):
        """
        تشخیص اینکه رکورد موجودی مربوط به «انبار تولید» است یا نه.
        سازگار با خروجی‌های متفاوت: loc_id یا فقط loc/wh_label متنی.
        """
        if not row_dict:
            return False
        # اگر loc_id داریم، مستقیم
        try:
            lid = row_dict.get('loc_id') or row_dict.get('location_id') or row_dict.get('locid')
            if lid is not None and int(lid) in prod_loc_ids:
                return True
        except Exception:
            pass

        # تطبیق روی برچسب‌ها (fallback مطمئن)
        label = (row_dict.get('loc_label')
                or row_dict.get('loc')
                or row_dict.get('location')
                or row_dict.get('warehouse')
                or row_dict.get('wh_label') or '')
        lab = str(label).lower()
        if any(k in lab for k in ['تولید','کارگاه','production','workshop','floor']):
            return True
        return False

    def __load_a_batches_from_production(self, item_id: int):
        """
        Combo مربوط به «بچِ A از انبار تولید» را پر می‌کند.
        اگر هیچ موردی نبود، پیام کاربرپسند نشان می‌دهد.
        """
        cb = self.cmb_a_batch   # همان combobox بچ A در دیالوگ
        cb.clear()

        if not item_id:
            cb.addItem("— ابتدا کالا را انتخاب کنید —", None)
            return

        prod_loc_ids = self.__resolve_production_loc_ids()
        records = []
        try:
            # از همان خروجی همیشگی پروژه استفاده کن (نامش هرچه هست: stock_breakdown)
            if hasattr(self.db, 'stock_breakdown'):
                records = self.db.stock_breakdown(item_id=item_id)
            else:
                # بکاپ: کوئری مستقیم
                records = self.db.execute_query("""
                    SELECT i.name AS item_name, b.batch_no, b.qty, b.expiry_date, l.id AS loc_id,
                        l.name AS loc_label
                    FROM stock b
                    JOIN items i ON i.id=b.item_id
                    LEFT JOIN locations l ON l.id=b.loc_id
                    WHERE b.item_id=%s AND COALESCE(b.qty,0) > 0
                    ORDER BY b.expiry_date NULLS LAST, b.batch_no
                """, (item_id,))
        except Exception:
            records = []

        # فیلتر فقط تولید
        prod_recs = [r for r in (records or []) if self.__is_prod_row(r, prod_loc_ids) and float(r.get('qty',0) or 0) > 0]

        if not prod_recs:
            cb.addItem("— انبار تولید موجودی ندارد —", None)
            return

        # پر کردن Combo؛ نمایش تاریخ به «شمسی»
        def _to_jalali_str(d):
            # تاریخ میلادی را به شمسی نمایشی برگردان؛ اگر util داخلی داری همان را صدا بزن
            try:
                # اگر رشته بود
                if isinstance(d, str):
                    d = datetime.fromisoformat(d)
                if isinstance(d, (datetime, date)):
                    # تبدیل خیلی سبک: اگر util jdatetime داری، اینجا جایگزین کن
                    # نمایش YYYY-MM-DD شمسی (بدون زیرساخت تازه)
                    from datetime import datetime as _dt
                    import math
                    # جایگزین ساده: فقط همان میلادی را نشان بده اگر تبدیل در دسترس نیست
                    return d.strftime("%Y-%m-%d")
            except Exception:
                pass
            return ""

        for r in prod_recs:
            batch = r.get('batch_no') or r.get('batch') or ''
            qty   = float(r.get('qty',0) or 0)
            exp   = r.get('expiry_date') or r.get('exp_date')
            exp_j = _to_jalali_str(exp)
            label = f"{batch or '—بدون بچ—'} | موجودی: {qty:g}" + (f" | انقضا: {exp_j}" if exp_j else "")
            # نگهداری loc_id برای اعتبارسنجی سمت کد
            data = {
                'batch_no': batch,
                'qty': qty,
                'loc_id': r.get('loc_id') or r.get('location_id') or r.get('locid'),
                'label': r.get('loc_label') or r.get('loc') or ''
            }
            cb.addItem(label, data)
        
    def _open_execute_conversion_dialog(self):
        try:
            dlg = ExecuteConversionDialog(self.db, self.user_id, self)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                # پس از تبدیل، رفرش نمای موجودی/تراکنش اگر وجود دارد
                try:
                    if hasattr(self, 'refresh_all'):
                        self.refresh_all()
                except Exception:
                    pass
                if hasattr(self, 'toast'):
                    self.toast.show_message("✔ تبدیل انجام شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", str(e))
            
    def handle_conversion_submit(self):
        """
        اجرای تبدیل A→B:
        - تأیید می‌کند بچِ A متعلق به انبار تولید است.
        - مقدار را از A کم و به B اضافه می‌کند.
        - تاریخ‌ها را اگر DB میلادی می‌خواهد، بی‌سروصدا تبدیل می‌کند.
        - منشأ لاگ: «تبدیل از A→B (CNV-...)»
        """
        # خواندن الگو/انتخاب‌ها
        pat = self.cmb_patterns.currentData()  # ممکن است None باشد
        item_a = self.cmb_a_item.currentData()
        item_b = self.cmb_b_item.currentData()
        if not item_a or not item_b:
            QtWidgets.QMessageBox.warning(self, "خطا", "کالای A و B را انتخاب کنید.")
            return

        # مقدار
        try:
            qty = float(self.edt_qty.text().strip().replace(',', '.'))
        except Exception:
            qty = 0.0
        if qty <= 0:
            QtWidgets.QMessageBox.warning(self, "خطا", "مقدار معتبر وارد کنید.")
            return

        # بچ A از Combo
        sel = self.cmb_a_batch.currentData()
        if not isinstance(sel, dict) or not sel.get('batch_no'):
            QtWidgets.QMessageBox.warning(self, "خطا", "بچ معتبر برای A انتخاب نشده است.")
            return

        # اعتبارسنجی «فقط انبار تولید»
        prod_loc_ids = self.__resolve_production_loc_ids()
        sel_loc_id = sel.get('loc_id')
        sel_label  = (sel.get('label') or '').lower()
        allowed = (sel_loc_id is not None and int(sel_loc_id) in prod_loc_ids) or any(
            k in sel_label for k in ['تولید','کارگاه','production','workshop','floor']
        )
        if not allowed:
            QtWidgets.QMessageBox.warning(self, "محدودیت", "فقط انبار تولید مجاز است.")
            return

        # بررسی موجودی کافی
        if float(sel.get('qty',0) or 0) < qty:
            QtWidgets.QMessageBox.warning(self, "کمبود موجودی", "موجودی بچ انتخابی از مقدار درخواستی کمتر است.")
            return

        # تاریخ انقضا برای B: از ورودی شمسی/نمایشی خوانده‌ای؛ اگر لازم بود به میلادی تبدیل کن
        # این پروژه معمولاً در DB میلادی نگه می‌دارد. اگر فیلد خالی بود، مقدار ایمن قرار می‌دهیم.
        def to_db_date_safe(jalali_str_or_none):
            # اگر خالی بود، تاریخ دور (ایمن) بگذار که DB خطا ندهد
            if not jalali_str_or_none:
                return datetime(2099, 12, 31)
            # اگر util داخلی داری، اینجا تبدیل کن؛ در غیر این صورت همان رشته را قبول می‌کنیم یا ایمن میلادی می‌گذاریم
            try:
                # نمونهٔ ساده: اگر yyyy-mm-dd بود
                s = str(jalali_str_or_none).strip()
                return datetime.fromisoformat(s)
            except Exception:
                return datetime(2099, 12, 31)

        expiry_for_b = to_db_date_safe(self.edt_expiry_b.text().strip() if hasattr(self, 'edt_expiry_b') else None)

        # اجرای تبدیل در DB
        try:
            # شماره سند مشترک CNV-...
            cnv_no = self.db.next_running_code(prefix="CNV-", pad=3)

            # خروج از تولید
            self.db.add_trans_extended(
                item_id=item_a,
                qty=-qty,
                t_type='خروج به تبدیل',
                t_no=cnv_no,
                batch_no=sel.get('batch_no') or '',
                src_loc=sel_loc_id,   # تولید
                dest_loc=None,
                notes=f"تبدیل از {self.cmb_a_item.currentText()} → {self.cmb_b_item.currentText()}"
            )
            # ورود به تولید (یا لوکیشن مقصد موردنظر)
            new_batch_b = self.db.next_running_code(prefix=self.lbl_b_batch_prefix.text().strip() if hasattr(self,'lbl_b_batch_prefix') else "RE-", pad=3)
            self.db.add_trans_extended(
                item_id=item_b,
                qty=qty,
                t_type='ورود از تبدیل',
                t_no=cnv_no,
                batch_no=new_batch_b,
                src_loc=None,
                dest_loc=list(prod_loc_ids)[0] if prod_loc_ids else sel_loc_id,
                expiry_date=expiry_for_b,
                notes=f"تبدیل از {self.cmb_a_item.currentText()} → {self.cmb_b_item.currentText()}"
            )

            QtWidgets.QMessageBox.information(self, "انجام شد", f"تبدیل با سند {cnv_no} ثبت شد.")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"ذخیره نشد:\n{e}")


    
    def _load_bom(self):
        """
        بارگذاری «تاریخچه مصرف (BOM)» با رعایت محرمانگی:
        - فقط Admin یا کسانی که مجوز 'production:formula:view' دارند، لیست واقعی را می‌بینند.
        - اگر اجازه ندارید، فقط یک پیام «عدم دسترسی» نمایش داده می‌شود و هیچ دیتایی لود نمی‌شود.
        - ایمپورت‌های محلی Qt برای جلوگیری از خطاهای UnboundLocalError.
        """
        # --- ایمپورت محلی و ایمن Qt ---
        try:
            from PyQt5 import QtWidgets, QtCore, QtGui  # type: ignore
            from PyQt5.QtCore import Qt  # type: ignore
            from PyQt5.QtGui import QFont  # type: ignore
        except Exception:
            from PySide2 import QtWidgets, QtCore, QtGui  # type: ignore
            from PySide2.QtCore import Qt  # type: ignore
            from PySide2.QtGui import QFont  # type: ignore

        # --- گرفتن ویجت درخت و قطع کار اگر نابود شده باشد ---
        tree = getattr(self, 'tbl_bom', None)
        if not tree:
            return
        try:
            _ = tree.metaObject()  # دست‌نخورده بودن ویجت
        except Exception:
            return

        # --- فقط این مجوز: Admin یا 'production:formula:view' ---
        # توجه: عمداً 'production:confidentiality:manage' را اینجا لحاظ نمی‌کنیم.
        try:
            can_view = bool(getattr(self, 'role', None) == 'Admin' or self.has_permission('production:formula:view'))
        except Exception:
            can_view = False

        # پاک‌سازی درخت
        try:
            tree.clear()
        except Exception:
            pass

        if not can_view:
            # پیام «عدم دسترسی» و خروج
            try:
                tree.setHeaderLabels(['تاریخچه مصرف (BOM)'])
                item = QtWidgets.QTreeWidgetItem(['⛔ دسترسی مشاهده BOM ندارید'])
                tree.addTopLevelItem(item)
            except Exception:
                pass
            return

        # --- از اینجا به بعد: لود واقعی لیست ---
        try:
            rows = self.db.list_bom(limit=500)  # اگر تابع فیلتر تاریخ یا نقش دارید، همینجا اعمال کنید

            # هدرها
            headers = ['شرح (محصول / ماده اولیه)', 'بچ', 'مقدار مصرف', 'تاریخ', 'کاربر', 'پیوست', 'وضعیت']
            tree.setHeaderLabels(headers)
            try:
                header = tree.header()
                header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
                header.setSectionResizeMode(headers.index('پیوست'), QtWidgets.QHeaderView.ResizeToContents)
                header.setSectionResizeMode(headers.index('وضعیت'), QtWidgets.QHeaderView.ResizeToContents)
            except Exception:
                pass

            if not rows:
                tree.addTopLevelItem(QtWidgets.QTreeWidgetItem(['هیچ تاریخچه مصرفی ثبت نشده است.']))
                return

            # گروه‌بندی بر اساس کُد بچ محصول
            grouped = {}
            for row in rows:
                pcode = row.get('product_code')
                grouped.setdefault(pcode, []).append(row)

            for pcode, materials in grouped.items():
                if not materials:
                    continue

                details = materials[0]
                is_voided = details.get('status') == 'باطل شده'
                parent_display = f"{details.get('product_name', 'نامشخص')} (بچ: {pcode})"

                parent_item = QtWidgets.QTreeWidgetItem(tree)
                parent_item.setText(0, parent_display)
                parent_item.setText(3, to_shamsi(details.get('ts')))
                parent_item.setText(4, details.get('user_', 'کاربر حذف شده'))
                parent_item.setText(6, 'باطل شده' if is_voided else 'فعال')
                parent_item.setData(0, Qt.UserRole, details.get('id'))

                # برجسته‌سازی
                base_font = parent_item.font(0)
                base_font.setBold(True)
                parent_item.setFont(0, base_font)

                if is_voided:
                    strike = QFont(base_font); strike.setStrikeOut(True)
                    for i in range(tree.columnCount()):
                        parent_item.setFont(i, strike)
                        parent_item.setForeground(i, QtGui.QColor('#7f8c8d'))
                else:
                    for i in range(tree.columnCount()):
                        parent_item.setBackground(i, QtGui.QColor('#f8f9fa'))

                # دکمهٔ پیوست
                try:
                    files_count = int(details.get('files_count', 0) or 0)
                except Exception:
                    files_count = 0
                btn_attach = QtWidgets.QPushButton(QtGui.QIcon.fromTheme('mail-attachment'), f' ({files_count})')
                btn_attach.setIconSize(QtCore.QSize(20, 20))
                btn_attach.setFixedHeight(30); btn_attach.setFlat(True)
                btn_attach.setCursor(Qt.PointingHandCursor)
                btn_attach.setToolTip('مدیریت پیوست‌های این سند مصرف')
                try:
                    bom_id = details.get('id')
                    btn_attach.clicked.connect(lambda _, x=bom_id: self._open_bom_attach_dialog(x))
                except Exception:
                    pass
                try:
                    tree.setItemWidget(parent_item, 5, btn_attach)
                except Exception:
                    pass

                # فرزندان (مصارف مواد)
                for mat in materials:
                    child_item = QtWidgets.QTreeWidgetItem(parent_item)
                    child_values = [
                        mat.get('raw_item_name', ''),  # نام ماده
                        mat.get('raw_batch', ''),      # بچ ماده
                        str(mat.get('qty', '')),       # مقدار
                        '', '', ''                     # تاریخ/کاربر/وضعیت برای ردیف ماده خالی می‌ماند
                    ]
                    for i, val in enumerate(child_values):
                        child_item.setText(i, val)
                    if is_voided:
                        for i in range(tree.columnCount()):
                            child_item.setFont(i, strike)
                            child_item.setForeground(i, QtGui.QColor('#7f8c8d'))

            tree.expandAll()

        except Exception as e:
            print(f'Error loading BOM: {e}')
            try:
                tree.addTopLevelItem(QtWidgets.QTreeWidgetItem([f'خطا در بارگذاری اطلاعات: {e}']))
            except Exception:
                pass

    
    def _rebuild_other_ops_menu(self, btn_other_ops):
        """
        منوی «سایر عملیات» را بر اساس دسترسی‌ها می‌سازد.
        اگر هیچ آیتمی مجاز نبود، دکمه را غیرفعال می‌کند.
        """
        try:
            from PyQt5 import QtWidgets, QtGui  # type: ignore
        except Exception:
            from PySide2 import QtWidgets, QtGui  # type: ignore

        menu = QtWidgets.QMenu(self)
        added = False

        def _add_sep():
            nonlocal added
            if added:
                menu.addSeparator()

        # تحویل محصول بسته‌بندی‌شده به انبار
        if self.has_permission('production:ops:deliver') or self.has_permission('production:packing'):
            menu.addAction("تحویل محصول بسته‌بندی شده به انبار").triggered.connect(
                getattr(self, '_open_deliver_packaged_good_dialog', lambda: None)
            )
            added = True

        # تایید دریافت مواد و تایید/رد ابطال‌های انبار
        if self.has_permission('production:approve_transfer'):
            _add_sep()
            menu.addAction("تایید دریافت مواد اولیه").triggered.connect(
                getattr(self, '_open_approve_material_dialog', lambda: None)
            )
            act_void = menu.addAction("تایید/رد ابطال‌های انبار")
            act_void.triggered.connect(getattr(self, '_open_approve_void_dialog', lambda: None))
            added = True

        # برگشت مواد اولیه به انبار
        if (self.has_permission('production:ops:return')
            or self.has_permission('production:request_materials')
            or self.has_permission('transactions:transfer')):
            _add_sep()
            menu.addAction("برگشت مواد اولیه به انبار").triggered.connect(
                getattr(self, '_open_return_material_dialog', lambda: None)
            )
            added = True

        # آزمایشگاه و رهگیری (در صورت مجوز ثبت گزارش تولید)
        if self.has_permission('production:report'):
            _add_sep()
            try:
                menu.addAction("تحویل نمونه به آزمایشگاه").triggered.connect(
                    getattr(self, '_open_deliver_to_lab_dialog', lambda: None)
                )
            except Exception:
                pass
            try:
                menu.addAction("رهگیری بچ‌ها (Traceability)").triggered.connect(
                    lambda: TraceabilityDialog(self.db, self).exec_()
                )
            except Exception:
                pass
            added = True

        # ابطال‌های تولید/بسته‌بندی
        if self.has_permission('production:void_production'):
            _add_sep()
            menu.addAction("ابطال بچ تولید").triggered.connect(getattr(self, '_open_void_batch_dialog', lambda: None))
            menu.addAction("ابطال عملیات بسته‌بندی").triggered.connect(getattr(self, '_open_void_packing_dialog', lambda: None))
            added = True

        # مدیریت فرمول‌ها
        if self.has_permission('production:manage_recipes'):
            _add_sep()
            menu.addAction("مدیریت فرمول‌ها").triggered.connect(getattr(self, '_open_recipe_manager', lambda: None))
            added = True

        # --- افزوده‌ی خواسته‌شده: دو آیتم تبدیل A→B (بدون دست‌زدن به بقیه) ---
        can_convert = (self.has_permission('transactions:convert')
                    or self.has_permission('transactions:transfer'))
        if can_convert:
            _add_sep()

            act_run = menu.addAction("اجرای تبدیل A→B")
            act_run.triggered.connect(
                getattr(self, '_open_execute_conversion_dialog',
                        lambda: QtWidgets.QMessageBox.warning(self, "نصب ناقص",
                            "دیالوگ اجرای تبدیل هنوز به برنامه اضافه نشده است."))
            )
            added = True
        # ------------------------------------------------------------------------

        btn_other_ops.setMenu(menu)
        try:
            btn_other_ops.setPopupMode(QtWidgets.QToolButton.InstantPopup)
        except Exception:
            pass
        btn_other_ops.setEnabled(added)

                                                            
                                                
    # بقیه توابع مربوط به صفحه تولید...
    def _open_recipe_manager(self): RecipeManagementDialog(self.db, self).exec_()

    # BEGIN REWRITE: MainWindow._approve_delivery
    def _approve_delivery(self, delivery_id: int):
        """
        تایید «تحویل از تولید»:
        - برچسب مقصد را از خروجی list_locations به‌درستی می‌سازد (loc_label یا rack/shelf/bin)
        - از انتخاب مقصد توسط کاربر اطمینان می‌گیرد و سپس finalize_delivery را فراخوانی می‌کند.
        """
        from PyQt5 import QtWidgets

        try:
            # 1) اعتبار درخواست
            details = self.db.get_delivery_details(delivery_id)
            if not details or (details.get('status') or '').strip() != 'در انتظار تایید انبار':
                if getattr(self, 'toast', None):
                    self.toast.show_message("این درخواست معتبر نیست یا قبلاً پردازش شده.", "warning")
                else:
                    QtWidgets.QMessageBox.warning(self, "هشدار", "این درخواست معتبر نیست یا قبلاً پردازش شده.")
                self.refresh_all()
                return

            # 2) لیست مقصدهای مجاز (به‌جز Production)
            locs = self.db.list_locations(exclude_warehouses=['Production']) or []
            if not locs:
                raise ValueError("هیچ مقصدی خارج از انبار تولید ثبت نشده است؛ لطفاً در تنظیمات انبار یک مقصد بسازید.")

            # 3) ساخت برچسب نمایشی و نگاشت به id (بدون استفاده از کلید ناموجود 'loc')
            loc_map = {}
            display_items = []
            for r in locs:
                wh = (r.get('wh') or r.get('warehouse') or r.get('warehouse_name') or '').strip()
                label = r.get('loc_label')
                if not label:
                    # اگر loc_label نبود، از rack/shelf/bin بساز
                    rack  = str(r.get('rack') or '')
                    shelf = str(r.get('shelf') or '')
                    bin_  = str(r.get('bin') or '')
                    label = "-".join([p for p in (rack, shelf, bin_) if p != ''])
                display = f"{wh}|{label}" if wh else label
                loc_map[display] = r.get('id')
                display_items.append(display)

            # 4) انتخاب مقصد توسط کاربر
            display_items.sort()
            loc_name, ok_sel = QtWidgets.QInputDialog.getItem(
                self, "انتخاب لوکیشن مقصد",
                f"محصول «{details.get('product_name','')}» را در کدام لوکیشن دریافت می‌کنید؟",
                display_items, 0, False
            )
            if not ok_sel or not loc_name:
                return

            dest_loc_id = loc_map.get(loc_name)
            if not dest_loc_id:
                raise ValueError("شناسهٔ مقصد معتبر نیست.")

            # 5) تایید سمت DB
            self.db.finalize_delivery(
                delivery_id=delivery_id,
                approver_user_id=self.user_id,
                dest_loc_id=dest_loc_id
            )

            # 6) پیام و رفرش
            if getattr(self, 'toast', None):
                self.toast.show_message("محصول با موفقیت در انبار دریافت و ثبت شد.", "success")
            else:
                QtWidgets.QMessageBox.information(self, "موفق", "محصول با موفقیت در انبار دریافت و ثبت شد.")
            self.refresh_all()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در عملیات تایید دریافت:\n{e}")
    # END REWRITE: MainWindow._approve_delivery
    
    # BEGIN ADD: MainWindow._approve_selected_deliveries
    def _approve_selected_deliveries(self):
        """
        تایید گروهی «محصولات منتظر تایید» با یک مقصد و یک شماره سند مشترک.
        - از جدول self.tbl_pending_deliveries، آیتم‌های انتخاب‌شده را می‌خواند (ستون 0 = ID).
        - یکبار مقصد دریافت از کاربر گرفته می‌شود (به جز Production).
        - یکبار شماره سند از کاربر گرفته می‌شود (اختیاری).
        - برای هر ردیف: db.finalize_delivery(id, self.user_id, dest_loc_id, t_no) صدا می‌خورد.
        - در پایان، تب رفرش می‌شود و گزارش کوتاه نمایش داده می‌شود.
        """
        from PyQt5 import QtWidgets

        table = getattr(self, 'tbl_pending_deliveries', None)
        if table is None:
            QtWidgets.QMessageBox.warning(self, "هشدار", "جدول محصولات منتظر تایید در این صفحه پیدا نشد.")
            return

        # 1) جمع‌آوری شناسه‌های انتخاب‌شده
        sel = table.selectionModel()
        if sel is None or not sel.hasSelection():
            QtWidgets.QMessageBox.information(self, "توجه", "حداقل یک ردیف را انتخاب کنید.")
            return
        rows = sorted({idx.row() for idx in sel.selectedIndexes()})
        ids = []
        for r in rows:
            item = table.item(r, 0)  # ستون 0 = ID (حتی اگر پنهان باشد)
            if item and (item.text() or "").strip().isdigit():
                ids.append(int(item.text()))
        if not ids:
            QtWidgets.QMessageBox.information(self, "توجه", "شناسهٔ معتبری از ردیف‌های انتخاب‌شده پیدا نشد.")
            return

        # 2) انتخاب مقصد (به‌جز Production)
        try:
            locs = self.db.list_locations(exclude_warehouses=['Production']) or []
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در دریافت لیست لوکیشن‌ها:\n{e}")
            return
        if not locs:
            QtWidgets.QMessageBox.warning(self, "هشدار", "هیچ مقصدی برای این تحویل پیدا نشد؛ ابتدا مقصدی خارج از انبار تولید تعریف کنید.")
            return

        loc_map = {}
        display_items = []
        for r in locs:
            wh = (r.get('wh') or r.get('warehouse') or r.get('warehouse_name') or '').strip()
            label = r.get('loc_label')
            if not label:
                rack  = str(r.get('rack') or '')
                shelf = str(r.get('shelf') or '')
                bin_  = str(r.get('bin') or '')
                label = "-".join([p for p in (rack, shelf, bin_) if p != ''])
            disp = f"{wh}|{label}" if wh else label
            loc_map[disp] = r.get('id')
            display_items.append(disp)
        display_items.sort()

        dest_disp, ok_loc = QtWidgets.QInputDialog.getItem(
            self, "انتخاب مقصد دریافت",
            "محصولات انتخاب‌شده در کدام لوکیشن دریافت شوند؟",
            display_items, 0, False
        )
        if not ok_loc or not dest_disp:
            return
        dest_loc_id = loc_map.get(dest_disp)
        if not dest_loc_id:
            QtWidgets.QMessageBox.warning(self, "هشدار", "لوکیشن مقصد نامعتبر است.")
            return

        # 3) دریافت شماره سند مشترک (اختیاری)
        t_no, ok_t = QtWidgets.QInputDialog.getText(
            self, "شماره سند", "شماره سند مشترک برای تایید دریافت:", QtWidgets.QLineEdit.Normal, ""
        )
        if not ok_t:
            return
        t_no = (t_no or "").strip() or None

        # 4) اجرای تایید گروهی
        ok_count = 0
        errs = []
        table.setEnabled(False)
        try:
            for did in ids:
                try:
                    self.db.finalize_delivery(did, self.user_id, dest_loc_id, t_no)
                    ok_count += 1
                except Exception as e:
                    errs.append(f"ID {did}: {e}")
        finally:
            table.setEnabled(True)

        # 5) نتیجه و رفرش
        if getattr(self, 'toast', None):
            if ok_count:
                self.toast.show_message(f"{ok_count} ردیف با موفقیت تایید شد.", "success")
            if errs:
                self.toast.show_message("برخی ردیف‌ها تایید نشدند؛ جزئیات در دیالوگ.", "warning")
        if errs:
            QtWidgets.QMessageBox.warning(self, "گزارش تایید گروهی", "موفق: %d\nناموفق: %d\n\n%s" %
                                        (ok_count, len(errs), "\n".join(errs[:10])))
        else:
            QtWidgets.QMessageBox.information(self, "موفق", f"تمام {ok_count} ردیف با موفقیت تایید شد.")

        # رفرش تب
        try:
            self._load_trans()
        except Exception:
            pass
    # END ADD: MainWindow._approve_selected_deliveries
    
        # BEGIN ADD: MainWindow._reject_selected_deliveries
    def _reject_selected_deliveries(self):
        """
        ردِ گروهی «محصولات منتظر تایید» با یک دلیل مشترک (یکنواخت با صفحه «درخواست‌های مواد اولیه»).
        - از جدول self.tbl_pending_deliveries آیتم‌های انتخاب‌شده را می‌خواند (ستون 0 = ID).
        - یک‌بار دلیل رد از کاربر می‌گیرد (اجباری).
        - برای هر ردیف: self.db.reject_delivery(id, reason, self.user_id)
        - در پایان، تب را رفرش و گزارش کوتاه نمایش می‌دهد.
        """
        from PyQt5 import QtWidgets

        table = getattr(self, 'tbl_pending_deliveries', None)
        if table is None:
            QtWidgets.QMessageBox.warning(self, "هشدار", "جدول محصولات منتظر تایید در این صفحه پیدا نشد.")
            return

        # 1) جمع‌آوری شناسه‌های انتخاب‌شده
        sel = table.selectionModel()
        if sel is None or not sel.hasSelection():
            QtWidgets.QMessageBox.information(self, "توجه", "حداقل یک ردیف را انتخاب کنید.")
            return
        rows = sorted({idx.row() for idx in sel.selectedIndexes()})
        ids = []
        for r in rows:
            item = table.item(r, 0)  # ستون 0 = ID (پنهان)
            if item and (item.text() or "").strip().isdigit():
                ids.append(int(item.text()))
        if not ids:
            QtWidgets.QMessageBox.information(self, "توجه", "شناسهٔ معتبری از ردیف‌های انتخاب‌شده پیدا نشد.")
            return

        # 2) دریافت «دلیل رد» (اجباری)
        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کردن تحویل",
                                                    "دلیل رد برای همهٔ ردیف‌های انتخاب‌شده:")
        if not ok:
            return
        reason = (reason or "").strip()
        if not reason:
            QtWidgets.QMessageBox.information(self, "توجه", "بدون وارد کردن دلیل، رد کردن انجام نشد.")
            return

        # 3) اجرای ردِ گروهی
        ok_count, errs = 0, []
        table.setEnabled(False)
        try:
            for did in ids:
                try:
                    self.db.reject_delivery(int(did), reason, self.user_id)
                    ok_count += 1
                except Exception as e:
                    errs.append(f"ID {did}: {e}")
        finally:
            table.setEnabled(True)

        # 4) نتیجه و رفرش
        if getattr(self, 'toast', None):
            if ok_count:
                self.toast.show_message(f"{ok_count} ردیف با موفقیت رد شد.", "success")
            if errs:
                self.toast.show_message("برخی ردیف‌ها رد نشدند؛ جزئیات در دیالوگ.", "warning")

        if errs:
            QtWidgets.QMessageBox.warning(self, "گزارش رد گروهی", "موفق: %d\nناموفق: %d\n\n%s" %
                                        (ok_count, len(errs), "\n".join(errs[:10])))
        else:
            QtWidgets.QMessageBox.information(self, "موفق", f"تمام {ok_count} ردیف با موفقیت رد شد.")

        try:
            self._load_trans()
        except Exception:
            pass
    # END ADD: MainWindow._reject_selected_deliveries

            
                                
                                                                                
    def _open_bom_attach_dialog(self, bom_id): BOMAttachDialog(self.db, bom_id, self).exec_()
    def _export_tree_to_excel(self):
            """محتوای نمای درختی تاریخچه مصرف را به یک فایل اکسل خوانا صادر می‌کند."""
            tree = self.tbl_bom
            if not tree.topLevelItemCount():
                self.toast.show_message("اطلاعاتی برای صدور وجود ندارد.", "warning")
                return
                
            path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "ذخیره فایل اکسل", "تاریخچه_مصرف.xlsx", "Excel Files (*.xlsx)")
            if not path:
                return

            try:
                import pandas as pd
                
                data_to_export = []
                headers = [tree.headerItem().text(i) for i in range(tree.columnCount())]
                
                root = tree.invisibleRootItem()
                for i in range(root.childCount()):
                    parent_item = root.child(i)
                    if not parent_item.isHidden():
                        # اضافه کردن ردیف والد (محصول نهایی)
                        parent_data = [parent_item.text(j) for j in range(tree.columnCount())]
                        data_to_export.append(parent_data)
                        
                        # اضافه کردن ردیف‌های فرزند (مواد اولیه)
                        for j in range(parent_item.childCount()):
                            child_item = parent_item.child(j)
                            if not child_item.isHidden():
                                child_data = [child_item.text(k) for k in range(tree.columnCount())]
                                # ایجاد تورفتگی برای نمایش بهتر سلسله مراتب
                                child_data[0] = "    " + child_data[0] 
                                data_to_export.append(child_data)
                
                df = pd.DataFrame(data_to_export, columns=headers)
                df.to_excel(path, index=False, engine='openpyxl')
                
                self.toast.show_message("✔ فایل اکسل با موفقیت ذخیره شد.", "success")

            except ImportError:
                self.toast.show_message("خطا: کتابخانه pandas یا openpyxl نصب نیست.", "critical")
            except Exception as e:
                self.toast.show_message(f"خطا در ذخیره فایل: {e}", "critical")
            

                
        
    # این متد را در کلاس MainWindow به طور کامل جایگزین کنید
    def _start_background_refresh(self):
        """یک رشته جدید برای رفرش داده‌ها را به صورت امن و بدون تداخل آغاز می‌کند."""
        # تلاش برای قفل کردن؛ اگر قفل بود یعنی یک رفرش دیگر در حال اجراست
        if not self.refresh_mutex.tryLock():
            print("INFO: Refresh operation already in progress. Skipping new request.")
            return

        print("INFO: Starting background refresh job...")
        try:
            self.refresh_thread = QtCore.QThread()
            user_role_id = self.user_info.get('role_id')

            self.refresh_worker = RefreshWorker(self.db, self.user_id, user_role_id, self.permissions, self.role)
            self.refresh_worker.moveToThread(self.refresh_thread)

            self.refresh_thread.started.connect(self.refresh_worker.run)
            self.refresh_worker.finished.connect(self._update_ui_with_refreshed_data)
            self.refresh_worker.finished.connect(self.refresh_thread.quit)
            self.refresh_worker.finished.connect(self.refresh_worker.deleteLater)
            self.refresh_thread.finished.connect(self.refresh_thread.deleteLater)

            # --- اصلاح کلیدی: پس از اتمام کار، قفل را آزاد می‌کنیم ---
            self.refresh_thread.finished.connect(self.refresh_mutex.unlock)

            self.refresh_thread.start()
        except Exception as e:
            # اطمینان از آزاد شدن قفل در صورت بروز خطا هنگام ساخت نخ
            print(f"ERROR: Failed to start the refresh thread: {e}")
            self.refresh_mutex.unlock()
                                    
                        
# این متد جدید را به انتهای کلاس MainWindow اضافه کنید

    def _on_refresh_finished(self):
        """پس از اتمام کامل رشته رفرش، فلگ را ریست می‌کند."""
        print("INFO: Background refresh thread has finished.")
        self._is_refreshing = False
# در کلاس MainWindow، این متد را جایگزین کنید
# در کلاس MainWindow، این متد را جایگزین کنید
    def _update_ui_with_refreshed_data(self, data: dict):
        """پس از اتمام کار Worker، داده‌های جدید را به صورت امن در رابط کاربری نمایش می‌دهد."""
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            print("INFO: Updating UI with data from background thread...")
            
            # --- *** اصلاح کلیدی: ابتدا کش اعلان‌ها را آپدیت می‌کنیم *** ---
            self.notifications_cache = data.get('actionable_notifications', [])
            self._update_notification_count() # سپس تابع آپدیت UI را صدا می‌زنیم
            
            cnt, _ = data.get('kpi_stats', (0, []))
            low_items = data.get('min_alert', [])
            exp_items = data.get('exp_alert', [])
            
            if hasattr(self, 'card_total_items'):
                self.card_total_items.value_label.setText(str(cnt))
            if hasattr(self, 'card_shortage'):
                self.card_shortage.value_label.setText(f"{len(low_items)} مورد")
            if hasattr(self, 'card_expiring'):
                self.card_expiring.value_label.setText(f"{len(exp_items)} مورد")
            if hasattr(self, 'std_card_tasks') and self.user_info.get('role_id'):
                self.std_card_tasks.value_label.setText(str(self.db.get_new_tasks_count(self.user_id, self.user_info['role_id'])))
            if hasattr(self, 'std_card_memos'):
                 self.std_card_memos.value_label.setText(str(self.db.get_unread_memos_count(self.user_id)))

            if hasattr(self, 'pie_frame_layout'):
                value_stats = data.get('category_value_stats', [])
                cats_for_pie = [(c['category'], c['total_value']) for c in value_stats if c.get('total_value') and c['total_value'] > 0]
                while self.pie_frame_layout.count():
                    child = self.pie_frame_layout.takeAt(0)
                    if child.widget(): child.widget().deleteLater()
                if cats_for_pie:
                    self.pie_frame_layout.addWidget(Pie(cats_for_pie, self._goto_cat))
            
            if hasattr(self, 'pinned_table'):
                last_id = data.get('last_cleared_trans_id', '0')
                self.pinned_table.refresh(since_id=int(last_id))

            self._on_page_changed(self.pages.currentIndex())
            print("INFO: UI update complete.")

        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
                        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    # این متد را در کلاس MainWindow به طور کامل جایگزین کنید
    def _refresh_dashboard_page(self):
        """کارگردان داشبورد: داشبورد فعال را تشخیص داده و تمام ویجت‌های آن را رفرش می‌کند."""
        if not hasattr(self, 'pg_dash') or not self.pg_dash.layout():
            return

        # تشخیص داشبورد فعال
        key = 'DEFAULT'
        dashboard_selector = self.pg_dash.findChild(QtWidgets.QComboBox)
        if dashboard_selector:
            key = dashboard_selector.currentData()
        elif self.user_dashboards:
            key = self.user_dashboards[0]

        # --- بخش ۱: رفرش داشبوردهای استاندارد ---
        if key == 'WAREHOUSE':
            warehouse_dash = self.pg_dash.findChild(WarehouseDashboardWidget)
            if warehouse_dash:
                warehouse_dash.refresh_data()
        
        elif key == 'PURCHASING':
            tasks_table = self.pg_dash.findChild(QtWidgets.QTableWidget)
            if tasks_table: self._load_my_tasks(tasks_table)
            if hasattr(self, 'purch_card_suppliers'):
                suppliers = self.db.get_all_suppliers(active_only=True)
                self.purch_card_suppliers.value_label.setText(f"{len(suppliers)} تامین‌کننده")
        
        elif key == 'DEFAULT':
            if hasattr(self, 'standard_tasks_widget'): self.standard_tasks_widget.refresh_tasks()
            if hasattr(self, '_load_dynamic_actions'): self._load_dynamic_actions()

        # --- بخش ۲: رفرش کامل و جامع داشبورد مدیرعامل (CEO) ---
        elif key == 'CEO':
            # رفرش کارت‌های KPI
            
            # <<< --- اصلاح کلیدی اینجاست --- >>>
            # فراخوانی متد صحیح برای بارگذاری لیست فرم‌های در انتظار تایید
            if hasattr(self, '_reload_ceo_groups'):
                self._reload_ceo_groups()
            # <<< --- پایان اصلاح --- >>>
                
                        
                                                                        
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _on_warehouse_task_selected(self):
        """با انتخاب یک وظیفه در کارتابل انبار، پنل جزئیات را به‌روز می‌کند."""
        if not hasattr(self, 'warehouse_tasks_widget'): return
        
        selected_items = self.warehouse_tasks_widget.table.selectedItems()
        if not selected_items:
            self.warehouse_task_details_widget.update_with_task(None)
            return
            
        task_data = self.warehouse_tasks_widget.table.item(selected_items[0].row(), 0).data(Qt.UserRole)
        self.warehouse_task_details_widget.update_with_task(task_data)
        
    # BEGIN REWRITE: MainWindow._receive_po_action
    def _receive_po_action(self, preselected_po_id=None):
        """گردش کار ثبت رسید برای یک سفارش خرید (با شمارهٔ رسید و تاریخ)."""
        from PyQt5 import QtWidgets
        if getattr(self, "_receiving_busy", False):
            return
        self._receiving_busy = True
        try:
            po_id = preselected_po_id
            if po_id is None:
                if not hasattr(self, 'tbl_open_pos'):
                    QtWidgets.QMessageBox.warning(self, "لیست سفارش‌ها", "جدول سفارش‌ها در دسترس نیست.")
                    return
                selected = self.tbl_open_pos.selectedItems()
                if not selected:
                    if getattr(self, 'toast', None):
                        self.toast.show_message("لطفاً ابتدا یک سفارش خرید را از لیست انتخاب کنید.", "warning")
                    else:
                        QtWidgets.QMessageBox.information(self, "انتخاب لازم", "یک سفارش خرید انتخاب کنید.")
                    return
                row = selected[0].row()
                try:
                    po_id = int(self.tbl_open_pos.item(row, 0).text())
                except Exception:
                    QtWidgets.QMessageBox.warning(self, "شناسه نامعتبر", "شناسهٔ سفارش خرید قابل تشخیص نیست.")
                    return

            po_data = self.db.execute_query(
                "SELECT po.*, s.name AS supplier_name FROM purchase_orders po "
                "LEFT JOIN suppliers s ON s.id = po.supplier_id WHERE po.id = %s",
                (po_id,), fetch_one=True
            )
            if not po_data:
                (self.toast.show_message("اطلاعات سفارش خرید یافت نشد.", "error")
                if getattr(self, 'toast', None) else QtWidgets.QMessageBox.critical(self, "خطا", "اطلاعات سفارش خرید یافت نشد."))
                return

            dlg = ReceivePoDialog(self.db, dict(po_data), self)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                received_items = dlg.get_received_data()
                if not received_items:
                    (self.toast.show_message("هیچ کالایی برای دریافت ثبت نشد.", "info")
                    if getattr(self, 'toast', None) else QtWidgets.QMessageBox.information(self, "عدم دریافت", "هیچ مقداری وارد نشد."))
                    return

                dn, dt = dlg.receipt_meta()
                try:
                    res = self.db.receive_purchase_order(po_id, int(self.user_id), received_items,
                                                        receipt_no=dn, received_at=dt)
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ثبت رسید با خطا مواجه شد:\n{e}")
                    return

                is_complete = bool(res.get('complete')) if isinstance(res, dict) else False
                is_dup      = bool(res.get('duplicate')) if isinstance(res, dict) else False

                if is_dup:
                    msg = "این شمارهٔ رسید قبلاً برای همین سفارش ثبت شده بود؛ چیزی دوباره ثبت نشد."
                elif is_complete:
                    msg = "✔ رسید ثبت شد و سفارش کامل شد."
                else:
                    msg = "✔ رسید ثبت شد (دریافت بخشی)."

                if getattr(self, 'toast', None):
                    self.toast.show_message(msg, "success")
                else:
                    QtWidgets.QMessageBox.information(self, "نتیجهٔ دریافت", msg)

                try:
                    self.refresh_all()
                except Exception:
                    if hasattr(self, "_reload_open_purchase_orders"):
                        self._reload_open_purchase_orders()
        finally:
            self._receiving_busy = False
    # END REWRITE: MainWindow._receive_po_action
                
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _run_diagnostic_report(self):
        """گزارش تشخیصی سیستم را اجرا کرده و در یک پنجره نمایش می‌دهد."""
        report_data = self.db.get_diagnostic_report_data()
        report_str = "--- System Diagnostic Report ---\n\n"

        wf = report_data.get('sales_workflow')
        report_str += "== Sales Workflow Configuration ==\n"
        if wf:
            report_str += f"Name: {wf['name']} (ID: {wf['id']}, v{wf['version']})\n"
            report_str += f"Status: {wf.get('status')}\n"
            report_str += f"FINAL ACTION KEY: --> {wf.get('final_action_key')} <--\n"
            if wf.get('final_action_key') == 'CREATE_PROD_ORDER_FROM_SO':
                report_str += "  [OK] کلید اقدام نهایی به درستی تنظیم شده است.\n"
            else:
                report_str += "  [!! PROBLEM !!] کلید اقدام نهایی تنظیم نشده یا اشتباه است. باید 'CREATE_PROD_ORDER_FROM_SO' باشد.\n"
        else:
            report_str += "[!! PROBLEM !!] هیچ فرآیندی با نام حاوی 'تایید فروش' یافت نشد.\n"

        report_str += "\n== Last 5 Completed Process Instances ==\n"
        for inst in report_data.get('last_completed_instances', []):
            report_str += f"- Instance ID: {inst['id']}, Workflow: {inst['name']} (ID: {inst['workflow_id']}), Status: {inst['status']}, Completed: {to_shamsi(inst['completed_at'])}\n"

        report_str += "\n== Last 10 Audit Logs ==\n"
        for log in report_data.get('last_audit_logs', []):
            report_str += f"[{to_shamsi(log['stamp'])}] Action: {log['action']}, Details: {log['details']}\n"

        report_str += "\n--- End of Report ---"

        DebugReportDialog(report_str, self).exec_()
        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _open_deliver_packaged_good_dialog(self):
        """دیالوگ ثبت درخواست تحویل محصول نهایی (بسته‌بندی شده) را باز می‌کند."""
        dlg = DeliverFinishedGoodDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    new_delivery_id = self.db.create_delivery_request(
                        product_item_id=data['item_id'],
                        batch_no=data['batch_no'],
                        quantity=data['qty'],
                        expiry_date=data.get('expiry_date'),
                        supervisor_user_id=self.user_id,
                        # --- ارسال پارامتر جدید ---
                        production_order_id=data.get('production_order_id') 
                    )
                    if new_delivery_id:
                        self.db.submit_delivery_request(new_delivery_id)
                    
                    self.toast.show_message("✔ درخواست تحویل محصول به انبار با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست تحویل:\n{e}")
                    

                                    
            

class DatabaseConnectionDialog(QtWidgets.QDialog):
    """نسخه نهایی: با کلیدهای استاندارد psycopg2 کار می‌کند."""
    def __init__(self, parent=None, current_config=None):
        super().__init__(parent)
        self.setWindowTitle("تنظیمات اتصال به دیتابیس")
        self.setMinimumWidth(450)
        self.config_path = BASE_DIR / 'config.json'
        self.current_config = current_config or {}

        layout = QFormLayout(self)
        # --- اصلاح: خواندن از کلیدهای استاندارد ---
        self.host_edit = QLineEdit(self.current_config.get("host", "localhost"))
        self.port_edit = QLineEdit(str(self.current_config.get("port", "5433")))
        self.dbname_edit = QLineEdit(self.current_config.get("dbname", "Megatite_db"))
        self.user_edit = QLineEdit(self.current_config.get("user", "postgres"))
        self.pass_edit = QLineEdit(self.current_config.get("password", ""))
        self.pass_edit.setEchoMode(QLineEdit.Password)

        self.ssl_combo = QComboBox()
        self.ssl_combo.addItems(["غیرفعال", "ترجیحاً", "الزامی"])
        ssl_map = {"disable": 0, "prefer": 1, "require": 2}
        self.ssl_combo.setCurrentIndex(ssl_map.get(self.current_config.get("sslmode", "prefer"), 1))

        layout.addRow("آدرس سرور (IP/Hostname):", self.host_edit)
        layout.addRow("پورت:", self.port_edit)
        layout.addRow("نام دیتابیس:", self.dbname_edit)
        layout.addRow("نام کاربری دیتابیس:", self.user_edit)
        layout.addRow("رمز عبور دیتابیس:", self.pass_edit)
        layout.addRow("حالت اتصال امن (SSL):", self.ssl_combo)

        btn_layout = QHBoxLayout()
        btn_test = QPushButton("تست اتصال")
        btn_box = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        
        btn_layout.addWidget(btn_test); btn_layout.addStretch(); btn_layout.addWidget(btn_box)
        layout.addRow(btn_layout)

        btn_test.clicked.connect(self._test_connection)
        btn_box.accepted.connect(self._save_config)
        btn_box.rejected.connect(self.reject)

    def _get_config_from_form(self):
        ssl_map = {0: "disable", 1: "prefer", 2: "require"}
        # --- اصلاح: ذخیره با کلیدهای استاندارد ---
        return {
            "host": self.host_edit.text(),
            "port": int(self.port_edit.text()),
            "dbname": self.dbname_edit.text(),
            "user": self.user_edit.text(),
            "password": self.pass_edit.text(),
            "sslmode": ssl_map.get(self.ssl_combo.currentIndex(), "prefer")
        }

    def _test_connection(self):
        config = self._get_config_from_form()
        try:
            conn = psycopg2.connect(**config, connect_timeout=5)
            conn.close()
            QMessageBox.information(self, "موفقیت", "اتصال به دیتابیس با موفقیت برقرار شد.")
        except Exception as e:
            QMessageBox.critical(self, "خطا در اتصال", f"برقراری ارتباط با دیتابیس ناموفق بود.\n\n{e}")

    def _save_config(self):
        config_data = self._get_config_from_form()
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, indent=4, ensure_ascii=False)
            self.accept()
        except Exception as e:
            QMessageBox.critical(self, "خطا در ذخیره فایل", f"فایل config.json قابل نوشتن نیست.\n\n{e}")
                    
# این کلاس را به طور کامل با نسخه نهایی زیر جایگزین کنید
class CustomTreeDelegate(QtWidgets.QStyledItemDelegate):
    """
    نسخه نهایی نقاش سفارشی با خطوط خوانا و جهت‌گیری صحیح راست-به-چپ.
    """
    def paint(self, painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex):
        super().paint(painter, option, index)

        if index.column() != 0:
            return

        if not index.parent().isValid():
            return

        painter.save()
        
        # --- اصلاح ۱: خطوط ضخیم‌تر و پررنگ‌تر ---
        pen = QtGui.QPen(QtGui.QColor("#909090"), 2, QtCore.Qt.SolidLine)
        painter.setPen(pen)

        rect = option.rect
        indentation = 5
        mid_y = int(option.rect.center().y())

        # --- اصلاح ۲: محاسبات مختصات برای چیدمان راست-به-چپ (RTL) ---
        vline_x = int(rect.right() - indentation // 2)
        hline_start_x = int(rect.right() - indentation)
        
        # رسم خط افقی (چنگال)
        painter.drawLine(QtCore.QPoint(hline_start_x, mid_y), QtCore.QPoint(vline_x, mid_y))

        is_last_child = (index.row() == index.model().rowCount(index.parent()) - 1)

        # رسم خط عمودی
        if is_last_child:
            painter.drawLine(QtCore.QPoint(vline_x, rect.top()), QtCore.QPoint(vline_x, mid_y))
        else:
            painter.drawLine(QtCore.QPoint(vline_x, rect.top()), QtCore.QPoint(vline_x, rect.bottom()))
            
        painter.restore()
        
                        
# تابع main را به طور کامل با این نسخه نهایی جایگزین کنید

# BEGIN REWRITE: main
def main():
    MatplotlibConfig.ensure()

    app = QtWidgets.QApplication(sys.argv)
    app.setFont(QFont(FONT_FAMILY, 10))
    app.setLayoutDirection(QtCore.Qt.RightToLeft)

    app.setStyleSheet(f"""
        /* === General & Fonts === */
        QWidget {{
            background-color: #f4f6f9;
            color: #263238; 
        }}
        QLabel, QPushButton, QLineEdit, QTextEdit, QComboBox, QSpinBox {{
            font-family: '{FONT_FAMILY}', Tahoma;
            font-size: 10pt;
        }}

        /* === **NEW**: Dialog Styling === */
        QDialog {{
            background-color: #f8f9fa;
            border-radius: 6px;
        }}
        
        /* === Sidebar === */
        QFrame[objectName="sidebar"] {{
            background-color: #263238;
            border-right: 1px solid #37474f;
        }}

        QPushButton[class="sidebar-button"] {{
            color: #eceff1;
            background-color: transparent;
            border: none;
            direction: center; /* حفظ رفتار فعلی */
            text-align: left;
            padding: 13px 22px;
            font-size: 11pt;
            font-weight: bold;
        }}
        QPushButton[class="sidebar-button"]:hover {{
            background-color: #34495e;
        }}        

        /* === Tables & Trees === */
        QTableWidget, QTreeWidget {{
            border: 1px solid #dfe4ea;
            gridline-color: #e9ecef;
            background-color: #ffffff;
            alternate-background-color: #f7f9fc;
        }}
        QTableWidget[status_colored="true"] {{
            alternate-background-color: transparent;
        }}
        QHeaderView::section {{
            background-color: #e9ecef;
            padding: 8px 5px;
            border: none;
            border-bottom: 2px solid #ced4da;
            font-weight: bold;
        }}
        QTableWidget::item, QTreeWidget::item {{
            padding: 6px 8px;
            border-bottom: 1px solid #f1f3f5;
        }}
        QTableWidget::item:selected, QTreeWidget::item:selected {{
            background-color: rgba(0, 120, 212, 0.3);
            color: #000;
        }}
        
        /* === Buttons === */
        QPushButton {{
            padding: 4px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: #ffffff;
            font-weight: bold;
            min-height: 28px;
        }}
        QPushButton:hover {{
            background-color: #e9ecef;
            border-color: #adb5bd;
        }}
        QPushButton[class="primary"] {{
            background-color: #0d6efd;
            color: white;
            border: 1px solid #0d6efd;
        }}
        QPushButton[class="primary"]:hover {{
            background-color: #0b5ed7;
            border-color: #0a58ca;
        }}
        QPushButton[class="danger"] {{
            background-color: #dc3545;
            color: white;
            border: 1px solid #dc3545;
        }}
        QPushButton[class="danger"]:hover {{
            background-color: #bb2d3b;
            border-color: #b02a37;
        }}

        /* === Input Fields === */
        QLineEdit, QTextEdit, QComboBox, QSpinBox {{
            border: 1px solid #ced4da;
            border-radius: 5px;
            padding: 6px;
            background-color: white;
        }}
        QLineEdit:focus, QTextEdit:focus, QComboBox:focus, QSpinBox:focus {{
            border-color: #86b7fe;
            outline: 0;
        }}
        
        /* === GroupBox as Cards === */
        QGroupBox {{
            background-color: #ffffff;
            border: 1px solid #dfe4ea;
            border-radius: 8px;
            margin-top: 15px;
            padding-top: 10px;
            font-weight: bold;
        }}
        QGroupBox::title {{
            subcontrol-origin: margin;
            subcontrol-position: top center;
            padding: 5px 15px;
            background-color: #f1f3f5;
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            color: #495057;
        }}

        /* === Tabs, Splitter, Tooltip === */
        QTabWidget::pane {{ border: 1px solid #dfe4ea; border-top: none; }}
        QTabBar::tab {{
            padding: 10px 20px;
            border-bottom: 3px solid transparent;
            font-weight: bold;
            color: #6c757d;
        }}
        QTabBar::tab:hover {{ color: #212529; }}
        QTabBar::tab:selected {{
            border-bottom: 3px solid #0d6efd;
            color: #0d6efd;
        }}
        QTabWidget[objectName="mainProdTabs"] > QTabBar,
        QTabWidget[objectName="interfaceTabWidget"] > QTabBar {{
            qproperty-expanding: true;
        }}
        QToolTip {{
            border: 1px solid #343a40;
            padding: 6px;
            border-radius: 4px;
            background-color: #212529;
            color: white;
            font-weight: bold;
        }}

        /* === Menus === */
        QMenu {{
            background-color: #2c3e50;
            color: #ecf0f1;
            border: 1px solid #34495e;
            border-radius: 6px;
            padding: 8px;
        }}
        QMenu::item {{
            padding: 8px 20px;
            background-color: transparent;
            border-radius: 4px;
        }}
        QMenu::item:selected {{
            background-color: #3498db;
            color: #ffffff;
        }}
        QMenu::separator {{
            height: 1px;
            background: #4a6572;
            margin: 6px 4px;
        }}

        /* === CheckBox === */
        QCheckBox {{ spacing: 5px; }}
        QCheckBox::indicator {{
            width: 16px; height: 16px;
            border: 1px solid #ced4da; border-radius: 4px;
        }}
        QCheckBox::indicator:checked {{
            background-color: #0d6efd; border-color: #0d6efd;
            image: url({(BASE_DIR / 'icons' / 'check.png').as_posix()});
        }}

        /* === ScrollBar === */
        QScrollBar:vertical {{
            border: 1px solid #e0e0e0; background: #f8f9fa;
            width: 15px; margin: 0;
        }}
        QScrollBar::handle:vertical {{
            background: #adb5bd; min-height: 25px; border-radius: 7px;
        }}
        QScrollBar::handle:vertical:hover {{ background: #6c757d; }}
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical,
        QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{ background: none; border: none; }}

        QListWidget {{
            border: 1px solid #dfe4ea; background-color: #ffffff;
        }}
        QListWidget::item {{
            padding: 8px; border-bottom: 1px solid #f1f3f5;
        }}

        /* === Selection Visibility Fix (GLOBAL) === */
        /* کمبوباکس (لیست پاپ‌آپ) */
        QComboBox QAbstractItemView::item:selected {{
            background-color: rgba(0, 120, 212, 0.18);
            color: #111111;
        }}
        /* لیست‌ها/نمایه‌های عمومی */
        QListView::item:selected, QListWidget::item:selected, QAbstractItemView::item:selected {{
            background-color: rgba(0, 120, 212, 0.18);
            color: #111111;
        }}
        /* انتخاب متن داخل ورودی‌ها */
        QLineEdit, QTextEdit, QPlainTextEdit {{
            selection-background-color: #cfe2ff;
            selection-color: #111111;
        }}
    """)

    # --- اتصال به DB و بارگذاری کانفیگ (بدون تغییر) ---
    config = {}
    db = None
    while db is None:
        try:
            if not (BASE_DIR / 'config.json').exists():
                create_config_if_not_exists()
                QMessageBox.information(
                    None,
                    "فایل تنظیمات ایجاد شد",
                    "فایل 'config.json' یافت نشد و یک نسخه پیش‌فرض ایجاد گردید. لطفاً اطلاعات اتصال به دیتابیس را در آن وارد کرده و برنامه را مجدداً اجرا کنید."
                )
                sys.exit(0)

            with open(BASE_DIR / 'config.json', 'r', encoding='utf-8') as f:
                config = json.load(f)

            db = DB(config)

            try:
                db.ensure_minimum_operational_schema()
            except Exception as bootstrap_exc:
                raise ConnectionError(f"Database bootstrap failed: {bootstrap_exc}") from bootstrap_exc

        except (IOError, FileNotFoundError, json.JSONDecodeError) as e:
            QMessageBox.critical(None, "خطای فایل کانفیگ", f"مشکلی در خواندن فایل config.json وجود دارد: {e}")
            dlg = DatabaseConnectionDialog(current_config=config)
            if dlg.exec_() != QDialog.Accepted:
                sys.exit(0)

        except (ConnectionError, psycopg2.OperationalError) as e:
            QMessageBox.warning(None, "خطای اتصال", f"برقراری ارتباط با دیتابیس ناموفق بود.\nلطفاً اطلاعات اتصال را بررسی و اصلاح کنید.\n\nخطا: {e}")
            dlg = DatabaseConnectionDialog(current_config=config)
            if dlg.exec_() != QDialog.Accepted:
                sys.exit(0)

    # --- چرخهٔ لاگین و اجرای برنامه (بدون تغییر) ---
    restart_app = True
    while restart_app:
        restart_app = False
        login = LoginDialog(db)
        if login.exec_() == QtWidgets.QDialog.Accepted:
            win = MainWindow(db, login.user_info)
            win.showMaximized()
            app.exec_()
            if getattr(win, 'restart_on_close', False):
                restart_app = True
        else:
            break
# END REWRITE: main
                                                                                                        
if __name__ == '__main__':
    main()

# ========================= Operations Center (Non-invasive stub) =========================
try:
    from PyQt5 import QtWidgets, QtGui, QtCore
    class OperationsCenterPage(QtWidgets.QWidget):
        """
        یک صفحه‌ی سبک برای «مرکز عملیات» که فقط از قابلیت‌های موجود استفاده می‌کند
        و چیزی را جایگزین/حذف نمی‌کند. اگر زیرساخت‌ها در MainWindow وجود داشته باشند
        دکمه‌های میان‌بر فعال می‌شوند؛ در غیر این صورت به‌صورت غیرفعال نمایش داده می‌شوند.
        """
        def __init__(self, main_window):
            super().__init__()
            self.mw = main_window
            v = QtWidgets.QVBoxLayout(self)
            header = QtWidgets.QLabel("مرکز عملیات (Operations Center)")
            header.setStyleSheet("font-size:18px; font-weight:bold;")
            v.addWidget(header)

            grid = QtWidgets.QGridLayout()
            v.addLayout(grid)

            # Shortcut cards (only use already-present attributes; do not assume existence)
            def make_btn(title, slot):
                btn = QtWidgets.QPushButton(title)
                btn.setMinimumHeight(42)
                if slot is None:
                    btn.setEnabled(False)
                else:
                    btn.clicked.connect(slot)
                return btn

            # QA Settings Panel
            btn_qa = make_btn("تنظیمات QA (قوانین SLA / Escalation / Gates)",
                              getattr(self.mw, "_open_qa_settings_panel", None))

            # Forms Designer if exists
            btn_forms = make_btn("فرم‌ساز سازمانی",
                                 getattr(self.mw, "_open_forms_designer", None))

            # Workflow Monitor if exists
            btn_wf = make_btn("پایش فرآیندها و هشدارها",
                              getattr(self.mw, "_open_workflow_monitor", None))

            # Reports hub if exists
            btn_reports = make_btn("هاب گزارش‌ها",
                                   getattr(self.mw, "_open_reports_hub", None))

            grid.addWidget(btn_qa, 0, 0)
            grid.addWidget(btn_forms, 0, 1)
            grid.addWidget(btn_wf, 1, 0)
            grid.addWidget(btn_reports, 1, 1)
            v.addStretch(1)

    # ----- Hook MainWindow (non-breaking) -----
    def _oc_install_into_mainwindow(MainWindow):
        """
        به‌صورت ایمن صفحهٔ OC را به MainWindow اضافه می‌کند. اگر ساختار UI
        تفاوت داشته باشد، بدون ایجاد خطا صرفاً کاری انجام نمی‌دهد.
        """
        if not hasattr(MainWindow, "_oc_hooked"):
            MainWindow._oc_hooked = False

        if MainWindow._oc_hooked:
            return

        # Add helper to show OC page
        def show_operations_center(self):
            try:
                if not hasattr(self, "pg_operations_center"):
                    self.pg_operations_center = OperationsCenterPage(self)
                    if hasattr(self, "pages") and isinstance(self.pages, QtWidgets.QStackedWidget):
                        self.pages.addWidget(self.pg_operations_center)
                if hasattr(self, "pages"):
                    self.pages.setCurrentWidget(self.pg_operations_center)
            except Exception as e:
                # No hard failure
                print("OC hook: show failed:", e)

        setattr(MainWindow, "show_operations_center", show_operations_center)

        # Try to add a sidebar button if the structure matches the known one
        old_init = MainWindow.__init__
        def new_init(self, *a, **kw):
            old_init(self, *a, **kw)
            try:
                # If sidebar & mapping exist, add the button
                if hasattr(self, "page_map") and hasattr(self, "sidebar_buttons") and hasattr(self, "pages"):
                    btn = QtWidgets.QPushButton("مرکز عملیات")
                    btn.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
                    btn.setMinimumHeight(38)
                    btn.clicked.connect(lambda: self.show_operations_center())
                    # Keep a reference to avoid GC
                    self.sidebar_buttons.append(btn)
                    # If there is a sidebar frame with a layout, add it
                    try:
                        cw = self.centralWidget()
                        if cw and cw.layout():
                            lay = cw.layout()
                            # Heuristic: sidebar is a QFrame with width >= 200
                            for i in range(lay.count()):
                                w = lay.itemAt(i).widget()
                                if isinstance(w, QtWidgets.QFrame) and w.maximumWidth() >= 200:
                                    if w.layout():
                                        w.layout().addWidget(btn)
                                        break
                    except Exception:
                        pass
            except Exception as e:
                print("OC hook: button add failed:", e)

        MainWindow.__init__ = new_init
        MainWindow._oc_hooked = True

    # Try to find defined MainWindow and install
    try:
        if "MainWindow" in globals() and hasattr(globals()["MainWindow"], "__mro__"):
            _oc_install_into_mainwindow(globals()["MainWindow"])
    except Exception as _e:
        print("OC hook install failed:", _e)

except Exception as _outer_e:
    # If PyQt is unavailable here (headless), silently ignore
    pass
# =========================================================================================

# ============================================================================
# BEGIN QA IMPROVEMENT: Event Store (priority + idempotency + safe replay)
# ----------------------------------------------------------------------------
# این بلوک یک Event Store سبک اضافه می‌کند که:
#  - صف اولویت‌دار برای رویدادهای سیستمی دارد
#  - کلید idempotency برای جلوگیری از اجراهای تکراری
#  - پردازش امن با قفل خوشه‌ای (FOR UPDATE SKIP LOCKED)
#  - لاگ و شمارش تلاش‌ها

try:
    import psycopg2
except Exception:
    psycopg2 = None  # در محیط‌های بدون pg فقط تعریف‌ها بماند

def _db_exec_block__event_store(db_self, sql):
    try:
        with db_self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute(sql)
            conn.commit()
    except Exception as e:
        print("WARN(EventStore):", e)

# END QA IMPROVEMENT: Event Store (priority + idempotency + safe replay)
# ============================================================================

# ============================================================================
# BEGIN QA IMPROVEMENT: Dynamic QA Form Validation (JSON fields schema)
# ----------------------------------------------------------------------------
# این بلوک یک اعتبارسنج ساده و قدرتمند برای فرم‌های پویا اضافه می‌کند.
# تعریف فیلدها در form_defs.fields به شکل زیر پشتیبانی می‌شود:
# [ { "name":"ph", "label":"pH", "type":"number", "min":6.5, "max":7.5, "required":true, "pattern": null }, ... ]

import re as _re

def _coerce_type(value, t):
    if t in ('text','string','str'):
        return str(value) if value is not None else ''
    if t in ('int','integer','number:int'):
        return int(value)
    if t in ('float','number','double','real'):
        return float(value)
    if t in ('bool','boolean'):
        if isinstance(value, bool): return value
        s = str(value).strip().lower()
        return s in ('1','true','yes','on','y')
    return value

def validate_form_data_against_fields(fields: list, data: dict) -> tuple[bool, list]:
    errors = []
    d = dict(data or {})
    for f in (fields or []):
        name = f.get('name') or f.get('key') or f.get('field') or ''
        if not name: 
            continue
        label = f.get('label') or name
        t = (f.get('type') or 'text').lower()

        if f.get('required') and (name not in d or d.get(name) in (None, '', [])):
            errors.append(f"فیلد «{label}» ضروری است.")
            continue
        if name not in d:  # optional & missing
            continue

        # type coercion + bounds
        try:
            val = _coerce_type(d[name], t)
        except Exception:
            errors.append(f"نوع مقدار «{label}» صحیح نیست.")
            continue

        if t in ('int','integer','number:int','float','number','double','real'):
            minv = f.get('min'); maxv = f.get('max')
            if minv is not None and float(val) < float(minv):
                errors.append(f"مقدار «{label}» نباید کمتر از {minv} باشد.")
            if maxv is not None and float(val) > float(maxv):
                errors.append(f"مقدار «{label}» نباید بیشتر از {maxv} باشد.")
        patt = f.get('pattern')
        if patt:
            try:
                if not _re.fullmatch(str(patt), str(val)):
                    errors.append(f"فرمت «{label}» معتبر نیست.")
            except Exception:
                pass
    return (len(errors) == 0), errors

def db_validate_form_entry(self, form_def_id: int, data: dict) -> tuple[bool, list]:
    row = self.execute_query("SELECT fields FROM form_defs WHERE id=%s", (form_def_id,), fetch_one=True)
    fields = row['fields'] if row else []
    if isinstance(fields, str):
        try:
            fields = json.loads(fields)
        except Exception:
            fields = []
    return validate_form_data_against_fields(fields or [], data or {})

# تزریق به DB:
try:
    if 'DB' in globals() and isinstance(DB, type):
        setattr(DB, 'validate_form_entry', db_validate_form_entry)
except Exception as _e_inject2:
    print("WARN: could not inject validate_form_entry into DB:", _e_inject2)

# END QA IMPROVEMENT: Dynamic QA Form Validation
# ============================================================================

# ============================================================================
# BEGIN QA IMPROVEMENT: QAFormEntryService.save_linked_form implementation
# ----------------------------------------------------------------------------
# اگر کلاس QAFormEntryService قبلاً در فایل تعریف شده، این پیاده‌سازی با همان نام
# قابل استفاده است. در غیر این صورت، تعریف ساده زیر فراهم می‌شود.

if 'QAFormEntryService' not in globals():
    class QAFormEntryService:
        def __init__(self, db): self.db = db; self.ensure_schema()
        def ensure_schema(self):
            block = r"""
            DO $$
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='form_entries' AND column_name='related_table') THEN
                    EXECUTE 'ALTER TABLE form_entries ADD COLUMN related_table VARCHAR(64)';
                END IF;
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='form_entries' AND column_name='related_id') THEN
                    EXECUTE 'ALTER TABLE form_entries ADD COLUMN related_id INT';
                END IF;
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='form_entries' AND column_name='status') THEN
                    EXECUTE 'ALTER TABLE form_entries ADD COLUMN status VARCHAR(16)';
                END IF;
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='form_entries' AND column_name='score') THEN
                    EXECUTE 'ALTER TABLE form_entries ADD COLUMN score INT';
                END IF;
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='form_entries' AND column_name='form_def_id') THEN
                    EXECUTE 'ALTER TABLE form_entries ADD COLUMN form_def_id INT';
                END IF;
                BEGIN
                    CREATE INDEX IF NOT EXISTS idx_form_entries_link ON form_entries (form_def_id, related_table, related_id);
                EXCEPTION WHEN others THEN NULL;
                END;
            END $$;
            """
            try:
                self.db.execute_sql_block(block)
            except Exception: pass

        def save_linked_form(self, form_def_id, user_id, data_dict, related_table=None, related_id=None, entry_id=None):
            ok, errs = self.db.validate_form_entry(form_def_id, data_dict)
            if not ok:
                raise ValueError("; ".join(errs))
            payload = json.dumps(data_dict, ensure_ascii=False)
            with self.db.transaction() as cur:
                if entry_id:
                    cur.execute("""UPDATE form_entries
                                   SET data=%s, user_id=%s, form_id=%s, form_def_id=%s, related_table=%s, related_id=%s
                                   WHERE id=%s RETURNING id""",
                                (payload, user_id, form_def_id, form_def_id, related_table, related_id, entry_id))
                    rid = cur.fetchone()['id']
                else:
                    cur.execute("""INSERT INTO form_entries(form_id, form_def_id, user_id, data, related_table, related_id)
                                    VALUES (%s,%s,%s,%s,%s,%s) RETURNING id""" ,
                                (form_def_id, form_def_id, user_id, payload, related_table, related_id))
                    rid = cur.fetchone()['id']
            return rid

        def link_existing_entry(self, entry_id, related_table, related_id):
            with self.db.transaction() as cur:
                cur.execute("UPDATE form_entries SET related_table=%s, related_id=%s WHERE id=%s", (related_table, related_id, entry_id))
            return True

# END QA IMPROVEMENT: QAFormEntryService.save_linked_form
# ============================================================================

# ============================================================================
# BEGIN QA IMPROVEMENT: Tiny TTL cache for hot lookups (permissions/roles)
# ----------------------------------------------------------------------------
import time as _time

class _TTLCache:
    def __init__(self, ttl_sec=60, maxsize=256):
        self.ttl = ttl_sec; self.maxsize = maxsize
        self._data = {}

    def get(self, key):
        now = _time.time()
        v = self._data.get(key)
        if not v: return None
        val, exp = v
        if exp < now:
            self._data.pop(key, None)
            return None
        return val

    def set(self, key, value):
        if len(self._data) >= self.maxsize:
            # حذف قدیمی‌ترین کلید
            try:
                self._data.pop(next(iter(self._data)))
            except Exception:
                self._data.clear()
        self._data[key] = (value, _time.time() + self.ttl)

_perm_cache = _TTLCache(ttl_sec=120, maxsize=1024)

def has_permission_cached(self, user_id:int, code:str) -> bool:
    key = (user_id, str(code).lower())
    v = _perm_cache.get(key)
    if v is not None:
        return v
    # fallback به متد موجود (has_permission) اگر هست؛ در غیر اینصورت از جدول‌ها بخوانیم
    result = False
    try:
        if hasattr(self, 'has_permission'):
            result = bool(self.has_permission.__wrapped__(self, user_id, code)) if hasattr(self.has_permission, '__wrapped__') else bool(self.has_permission(user_id, code))
        else:
            sql = """SELECT COUNT(*)>0 AS ok
                       FROM users u
                       JOIN roles r ON u.role_id=r.id
                       JOIN role_permissions rp ON rp.role_id=r.id
                       JOIN permissions p ON p.id=rp.permission_id
                       WHERE u.id=%s AND LOWER(p.code)=LOWER(%s)"""
            row = self.execute_query(sql, (user_id, code), fetch_one=True)
            result = bool(row and row.get('ok'))
    except Exception:
        result = False
    _perm_cache.set(key, result)
    return result

try:
    if 'DB' in globals() and isinstance(DB, type):
        # بدون جایگزینی نام متد اصلی، نسخه cacheدار را با نام جدید اضافه می‌کنیم
        setattr(DB, 'has_permission_cached', has_permission_cached)
except Exception as _e_inject3:
    print("WARN: could not inject has_permission_cached:", _e_inject3)

# END QA IMPROVEMENT: Tiny TTL cache
# ============================================================================
