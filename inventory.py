# ------------------ بخش ۱: کتابخانه‌های استاندارد پایتون ------------------
import os
import sys
from passlib.context import CryptContext
import hashlib

import json
import tempfile
import time
import traceback
import subprocess
import datetime as dt
from datetime import datetime
from pathlib import Path
from threading import Timer
from functools import partial
from typing import List
from contextlib import contextmanager

# ------------------ بخش ۲: کتابخانه‌های جانبی (Third-Party) ------------------
# --- PyQt5 ---
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QIcon, QFont, QPalette, QColor, QDoubleValidator, QPixmap, QDesktopServices
from PyQt5.QtCore import Qt, QSize, QPoint, QRect, QPropertyAnimation, QAbstractAnimation, QEasingCurve, pyqtSignal
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QFrame, QLabel, QLineEdit, QTextEdit,
    QPushButton, QComboBox, QTableWidget, QTableWidgetItem, QListWidget, QListWidgetItem,
    QHBoxLayout, QVBoxLayout, QFormLayout, QDialogButtonBox, QAction, QMenu,
    QMessageBox, QInputDialog, QFileDialog, QSplashScreen, QToolBar, QSplitter,
    QStackedWidget, QCheckBox, QGroupBox, QScrollArea, QTreeWidget, QTreeWidgetItem,
    QHeaderView, QAbstractItemView, QStyle, QStyledItemDelegate, QGraphicsDropShadowEffect,
    QGraphicsOpacityEffect, QWidgetAction
)
from PyQt5.QtCore import Qt, QSize, QPoint, QRect, QPropertyAnimation, QAbstractAnimation, QEasingCurve, pyqtSignal, QLocale

# --- پایگاه داده ---
import psycopg2
from psycopg2 import pool # <-- این خط جدید را اضافه کنید

from psycopg2.extras import DictCursor
import psycopg2.errors

# --- تحلیل داده و گزارش‌گیری ---
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.font_manager as fm
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas

# --- فارسی‌سازی و تاریخ ---
import jdatetime as jd
from arabic_reshaper import reshape
from bidi.algorithm import get_display

# --- اسکنر (فقط ویندوز) ---
try:
    import win32com.client
    import pythoncom
except ImportError:
    win32com = None # برای جلوگیری از خطا در سیستم‌های غیر ویندوزی
    pythoncom = None

# ------------------ بخش ۳: کدهای داخلی برنامه (در آینده می‌توان منظم‌تر کرد) ------------------
# (فعلا توابع و کلاس‌های اصلی در ادامه همین فایل قرار دارند)

BASE_DIR    = Path(__file__).resolve().parent
BACKUP_INT  = 86400                     # 24h
VIEWS_FILE = BASE_DIR / 'views.json'

_hash_legacy = lambda s: hashlib.sha256(s.encode('utf-8')).hexdigest()


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """رمز عبور را به صورت امن هش می‌کند."""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """رمز وارد شده را با هش ذخیره شده مقایسه می‌کند."""
    return pwd_context.verify(plain_password, hashed_password)



def create_config_if_not_exists(default_config: dict = None) -> bool:
    """
    نسخه نهایی: از کلیدهای استاندارد psycopg2 برای ساخت فایل کانفیگ استفاده می‌کند.
    """
    config_path = BASE_DIR / 'config.json'
    if not config_path.exists():
        print("INFO: 'config.json' not found. Creating a default file.")

        if default_config is None:
            # --- اصلاح کلیدی: استفاده از نام‌های استاندارد ---
            default_config = {
                "host": "localhost",
                "port": 5433,
                "dbname": "megatite_db",
                "user": "postgres",
                "password": "YOUR_POSTGRES_PASSWORD",
                "sslmode": "prefer"
            }

        try:
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(default_config, f, indent=4, ensure_ascii=False)
            print(f"SUCCESS: Default 'config.json' created at {config_path}")
            return True
        except Exception as e:
            print(f"ERROR: Could not create default 'config.json'. Reason: {e}")
            raise IOError(f"قادر به ساخت فایل تنظیمات در مسیر {config_path} نیست. لطفاً دسترسی‌ها را بررسی کنید.") from e

    return False
            
from dateutil.parser import parse, ParserError
import jdatetime as jd
import datetime as dt

# این تابع باید در کد شما به این شکل باشد
def to_shamsi(date_input) -> str:
    """
    ورودی: یک رشته تاریخ یا یک شیء datetime.
    خروجی: تاریخ معادل شمسی. در صورت بروز خطا یا ورودی نامعتبر، رشته خالی برمی‌گرداند.
    """
    if not date_input:
        return ''

    try:
        # اگر ورودی از قبل یک شیء datetime معتبر پایتون بود
        if isinstance(date_input, (dt.datetime, dt.date)):
            dt_g = date_input
        # در غیر این صورت، آن را به عنوان رشته در نظر گرفته و با parse به صورت هوشمند تبدیلش کن
        else:
            # برای جلوگیری از خطاهای احتمالی، ورودی را حتما به رشته تبدیل می‌کنیم
            dt_g = parse(str(date_input))

        # حالا که شیء datetime را داریم، آن را به شمسی تبدیل می‌کنیم
        if isinstance(dt_g, dt.datetime):
            # اگر زمان داشت، با زمان تبدیل کن
            dt_j = jd.datetime.fromgregorian(datetime=dt_g)
            return dt_j.strftime('%Y/%m/%d %H:%M')
        elif isinstance(dt_g, dt.date):
            # اگر فقط تاریخ بود
            dt_j = jd.date.fromgregorian(date=dt_g)
            return dt_j.strftime('%Y/%m/%d')
        else:
            # اگر parse یک نوع داده غیرمنتظره برگرداند
            print(f"WARNING: 'dateutil.parser.parse' returned an unexpected type for input: {date_input}")
            return ''

    except (ValueError, TypeError, ParserError) as e:
        # اگر parse نتوانست رشته را به تاریخ تبدیل کند یا خطای دیگری رخ داد
        print(f"WARNING: Could not convert '{date_input}' to Shamsi date. Error: {e}")
        return ''
    
# این تابع جدید را بالای فایل، کنار تابع to_shamsi اضافه کن
def shamsi_to_gregorian(shamsi_date_str: str) -> dt.date | None:
    """
    یک رشته تاریخ شمسی را به شیء تاریخ میلادی تبدیل می‌کند.
    در صورت نامعتبر بودن ورودی، None برمی‌گرداند.
    """
    if not shamsi_date_str or '_' in shamsi_date_str:
        return None
    try:
        parts = shamsi_date_str.split('/')
        if len(parts) == 3:
            y, m, d = map(int, parts)
            return jd.date(y, m, d).togregorian()
    except (ValueError, TypeError):
        return None
    return None
    
                        
def export_table_to_excel(widget: QtWidgets.QWidget, parent):
    """
    نسخه نهایی و یکپارچه:
    محتوای یک ویجت (جدول یا درخت) را به صورت هوشمند استخراج کرده و به یک فایل اکسل زیبا صادر می‌کند.
    این تابع تمام مراحل از جمله استایل‌دهی را مدیریت می‌کند.
    """
    path, _ = QtWidgets.QFileDialog.getSaveFileName(
        parent, 'ذخیره خروجی اکسل', 'Report.xlsx', 'Excel (*.xlsx)')
    if not path:
        return

    headers = []
    data = []

    try:
        if isinstance(widget, QtWidgets.QTableWidget):
            table = widget
            headers = [table.horizontalHeaderItem(c).text() for c in range(table.columnCount()) if not table.isColumnHidden(c)]
            for r in range(table.rowCount()):
                if table.isRowHidden(r): continue
                row = []
                for c in range(table.columnCount()):
                    if not table.isColumnHidden(c):
                        if table.cellWidget(r, c):
                            row.append('')
                        else:
                            cell = table.item(r, c)
                            row.append(cell.text() if cell else '')
                data.append(row)

        elif isinstance(widget, QtWidgets.QTreeWidget):
            tree = widget
            headers = [tree.headerItem().text(i) for i in range(tree.columnCount())]
            iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()
                if not item.isHidden():
                    row_data = [item.text(i) for i in range(tree.columnCount())]
                    if item.parent():
                        row_data[0] = "    " + row_data[0]
                    elif data:
                        data.append([''] * len(headers))
                    data.append(row_data)
                iterator += 1
        else:
            parent.toast.show_message("این ویجت برای خروجی اکسل پشتیبانی نمی‌شود.", "error")
            return

        if not data:
            parent.toast.show_message("داده‌ای برای خروجی گرفتن وجود ندارد.", "warning")
            return

        df = pd.DataFrame(data, columns=headers)
        
        # --- بخش استایل‌دهی (ادغام شده از تابع حذف شده) ---
        from openpyxl.styles import Font, Alignment, PatternFill
        from openpyxl.utils import get_column_letter

        with pd.ExcelWriter(path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name="Report", index=False, startrow=1)
            
            workbook = writer.book
            worksheet = writer.sheets["Report"]

            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            center_align = Alignment(horizontal='center', vertical='center')

            for col_num, value in enumerate(df.columns.values, 1):
                cell = worksheet.cell(row=2, column=col_num)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = center_align

            for col_num, column_cells in enumerate(worksheet.columns, 1):
                max_length = max(len(str(cell.value or '')) for cell in column_cells)
                adjusted_width = (max_length + 2)
                worksheet.column_dimensions[get_column_letter(col_num)].width = adjusted_width

            worksheet.sheet_view.rightToLeft = True
            worksheet.freeze_panes = 'A3'

        if hasattr(parent, 'toast'):
            parent.toast.show_message(f'✔ گزارش با موفقیت در فایل اکسل ذخیره شد.', 'success')

    except ImportError:
        QtWidgets.QMessageBox.critical(parent, "خطای کتابخانه", "برای ایجاد گزارش حرفه‌ای، لطفاً کتابخانه‌های `pandas` و `openpyxl` را نصب کنید.")
    except Exception as e:
        QtWidgets.QMessageBox.critical(parent, "خطای پیش‌بینی نشده", f"یک خطای ناشناخته در هنگام ایجاد گزارش اکسل رخ داد: {e}")
        print(traceback.format_exc())


# این تابع را با نسخه نهایی و خلاصه‌ شده زیر جایگزین کنید

def add_filter_export_tools(target_widget, layout: QtWidgets.QVBoxLayout, custom_filter_dialog_class=None, quick_filter_widget: QtWidgets.QLineEdit = None):
    """
    نسخه نهایی و یکپارچه:
    - نوار وضعیت فیلتر را هم برای فیلتر پیشرفته و هم برای جستجوی سریع (در صورت ارائه) نمایش می‌دهد.
    """
    tool_widget = QtWidgets.QWidget()
    tool_layout = QtWidgets.QHBoxLayout(tool_widget)
    tool_layout.setContentsMargins(0, 5, 0, 8)

    btn_filter = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), " فیلتر پیشرفته")
    btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل")

    tool_layout.addStretch()
    tool_layout.addWidget(btn_filter)
    tool_layout.addWidget(btn_export)
    layout.insertWidget(0, tool_widget)

    filter_status_widget = QtWidgets.QFrame(); filter_status_widget.setObjectName("filterStatus"); filter_status_widget.hide()
    filter_status_layout = QtWidgets.QHBoxLayout(filter_status_widget); filter_status_layout.setContentsMargins(10, 5, 10, 5)
    filter_status_icon = QtWidgets.QLabel("ℹ️"); filter_status_label = QtWidgets.QLabel("")
    filter_status_layout.addWidget(filter_status_icon); filter_status_layout.addWidget(filter_status_label, 1)
    btn_clear_quick = QtWidgets.QPushButton("حذف فیلترها"); btn_clear_quick.setProperty("class", "danger")
    filter_status_layout.addWidget(btn_clear_quick)
    filter_status_widget.setStyleSheet("#filterStatus { background-color: #e7f1ff; border: 1px solid #b3d1ff; border-radius: 4px; }")
    layout.insertWidget(1, filter_status_widget)

    def get_active_widget():
        if hasattr(target_widget, 'currentWidget'): return target_widget.currentWidget()
        return target_widget

    def update_filter_status():
        table = get_active_widget()
        total_items = 0; visible_items = 0
        
        # --- *** بخش اصلاح شده برای تشخیص نوع فیلتر *** ---
        is_advanced_filtered = hasattr(table, '_active_filters') and table._active_filters
        is_quick_filtered = quick_filter_widget and quick_filter_widget.text().strip()
        is_filtered = is_advanced_filtered or is_quick_filtered
        # --- ****************************************** ---

        if isinstance(table, QtWidgets.QTableWidget):
            total_items = table.rowCount()
            if total_items > 0:
                visible_items = total_items - sum(1 for r in range(total_items) if table.isRowHidden(r))
        elif isinstance(table, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value():
                if iterator.value().parent():
                    total_items += 1
                    if not iterator.value().isHidden(): visible_items += 1
                iterator += 1
        
        if is_filtered:
            filter_type_text = "فیلتر پیشرفته" if is_advanced_filtered else "جستجوی سریع"
            filter_status_label.setText(f"<b>{filter_type_text} فعال است:</b> نمایش {visible_items} از {total_items} رکورد.")
            filter_status_widget.show()
        else:
            filter_status_widget.hide()

    def open_filter_dialog():
        active_widget = get_active_widget()
        dlg_class = custom_filter_dialog_class or FilterDialog
        dlg = dlg_class(active_widget, active_widget.parent(), on_finish=update_filter_status)
        dlg.exec_()

    def reset_all_filters():
        table = get_active_widget()
        if hasattr(table, '_active_filters'): table._active_filters = []
        if quick_filter_widget: quick_filter_widget.clear() # این خط فیلتر سریع را هم پاک می‌کند
        
        if isinstance(table, QtWidgets.QTableWidget):
            for r in range(table.rowCount()): table.setRowHidden(r, False)
        elif isinstance(table, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value(): iterator.value().setHidden(False); iterator += 1
        update_filter_status()

    btn_filter.clicked.connect(open_filter_dialog)
    btn_export.clicked.connect(lambda: export_table_to_excel(get_active_widget(), get_active_widget().parent()))
    btn_clear_quick.clicked.connect(reset_all_filters)
    
    # --- *** اتصال سیگنال ویجت جستجوی سریع (در صورت وجود) *** ---
    if quick_filter_widget:
        quick_filter_widget.textChanged.connect(update_filter_status)                
    

# این نسخه نهایی و صحیح تابع اسکن است که باید در برنامه شما قرار گیرد
def scan_document(parent_widget=None):
    try:
        import win32com.client
        import pythoncom
        import tempfile
        import time
    except ImportError:
        QtWidgets.QMessageBox.critical(parent_widget, "خطا", "کتابخانه pywin32 نصب نیست. لطفا با دستور 'pip install pywin32' آن را نصب کنید.")
        return None

    pythoncom.CoInitialize()
    try:
        device_manager = win32com.client.Dispatch("WIA.DeviceManager")
        
        if device_manager.Devices.Count == 0:
            QtWidgets.QMessageBox.warning(parent_widget, "عدم وجود دستگاه", "هیچ دستگاه تصویربرداری (اسکنر یا دوربین) روی سیستم شما یافت نشد.")
            return None
            
        scanner_device = None
        devices = [d for d in device_manager.Devices if d.Type == 1]
        
        if not devices:
            QtWidgets.QMessageBox.warning(parent_widget, "عدم وجود اسکنر", "هیچ دستگاه اسکنری یافت نشد (ممکن است فقط دوربین متصل باشد).")
            return None
        
        if len(devices) == 1:
            scanner_device = devices[0]
        else:
            scanner_names = [d.Properties("Name").Value for d in devices]
            name, ok = QtWidgets.QInputDialog.getItem(parent_widget, "انتخاب اسکنر", "چندین اسکنر یافت شد، لطفا یکی را انتخاب کنید:", scanner_names, 0, False)
            if ok and name:
                for d in devices:
                    if d.Properties("Name").Value == name: scanner_device = d; break
            else: return None
        
        if not scanner_device: return None

        item = scanner_device.Items[0]
        image = item.Transfer()
        temp_filename = tempfile.gettempdir() + f"\\scan_{int(time.time())}.jpg"
        image.SaveFile(temp_filename)
        return temp_filename

    except Exception as e:
        if hasattr(e, 'excepinfo') and e.excepinfo and e.excepinfo[5] == -2145320829:
            print("User cancelled the scan operation.")
            return None
        else:
            print(f"An unexpected WIA error occurred: {e}")
            QtWidgets.QMessageBox.critical(parent_widget, "خطای اسکن", f"یک خطای پیش‌بینی نشده در هنگام اسکن رخ داد.\nمطمئن شوید اسکنر روشن و آماده به کار است.\n\n{e}")
            return None
    finally:
        pythoncom.CoUninitialize()
        
        
# این بلوک کد را جایگزین سه تابع مرتبط با پشتیبان‌گیری و بازیابی کنید

def _get_pg_common_args(config: dict) -> tuple:
    """
    (تابع کمکی جدید)
    پارامترهای اتصال و متغیرهای محیطی مشترک برای pg_dump و pg_restore را برمی‌گرداند.
    """
    db_name = config.get("dbname")
    user = config.get("user")
    password = config.get("password")
    host = config.get("host", "localhost")
    port = str(config.get("port", "5432"))

    if not all([db_name, user, password]):
        raise ValueError("اطلاعات اتصال به دیتابیس در فایل config.json ناقص است.")

    env = os.environ.copy()
    env['PGPASSWORD'] = password
    
    base_args = ["-U", user, "-h", host, "-p", port]
    
    return db_name, base_args, env

def backup_database(config: dict, backup_file_path: str):
    """
    نسخه بازنویسی شده: از تابع کمکی برای حذف کد تکراری استفاده می‌کند.
    """
    try:
        db_name, base_args, env = _get_pg_common_args(config)
        
        command = ["pg_dump", *base_args, "-F", "c", "--clean", "-f", backup_file_path, db_name]
        
        process = subprocess.Popen(command, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8')
        stdout, stderr = process.communicate()
        
        if process.returncode == 0:
            return True, f"✔ پشتیبان‌گیری کامل با موفقیت انجام شد."
        else:
            return False, f"خطا در پشتیبان‌گیری:\n{stderr}"
            
    except FileNotFoundError:
        return False, "خطا: دستور pg_dump یافت نشد.\nآیا PostgreSQL به درستی نصب شده و در PATH سیستم قرار دارد؟"
    except (ValueError, Exception) as e:
        return False, f"یک خطای پیش‌بینی نشده رخ داد: {e}"
        
def restore_database(config: dict, backup_file_path: str):
    """
    نسخه بازنویسی شده: از تابع کمکی برای حذف کد تکراری استفاده می‌کند.
    """
    try:
        db_name, base_args, env = _get_pg_common_args(config)

        command = ["pg_restore", *base_args, "-d", db_name, "--clean", "--if-exists", backup_file_path]

        process = subprocess.Popen(command, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8')
        stdout, stderr = process.communicate()

        if process.returncode == 0:
            return True, "✔ بازیابی اطلاعات با موفقیت کامل انجام شد."
        else:
            return False, f"فرآیند بازیابی با خطا مواجه شد:\n{stderr}"

    except FileNotFoundError:
        return False, "خطا: دستور pg_restore یافت نشد.\nآیا PostgreSQL به درستی نصب شده و در PATH سیستم قرار دارد؟"
    except (ValueError, Exception) as e:
        return False, f"یک خطای پیش‌بینی نشده در زمان بازیابی رخ داد: {e}"
        
# این تابع کاملا جدید را برای مدیریت متون ترکیبی اضافه کنید
def create_mixed_font_paragraph(text, base_style):
    """
    یک پاراگراف reportlab ایجاد می‌کند که قادر است متن‌های ترکیبی فارسی و انگلیسی را
    با فونت‌های مجزا به درستی نمایش دهد.
    """
    # --- *** اصلاح کلیدی: استفاده از کتابخانه استاندارد html *** ---
    import html
    import re
    from reportlab.platypus import Table, TableStyle, Paragraph


    font_fa = 'B-Nazanin'
    font_en = 'Helvetica'
    
    parts = re.split(r'([\u0600-\u06FF][\u0600-\u06FF\s\d]*)', text)
    
    processed_text = ""
    for part in parts:
        if not part: continue
        if re.search(r'[\u0600-\u06FF]', part):
            processed_text += f'<font name="{font_fa}">{get_display(reshape(part))}</font>'
        else:
            # --- استفاده از html.escape به جای escape از reportlab ---
            processed_text += f'<font name="{font_en}">{html.escape(part)}</font>'
            
    return Paragraph(processed_text, base_style)

    
# این تابع را به طور کامل با نسخه نهایی زیر جایگزین کنید
def create_invoice_pdf(invoice_data: dict, file_path: str):
    """
    با استفاده از reportlab، یک فایل PDF پیش فاکتور حرفه‌ای و فارسی تولید می‌کند.
    نسخه نهایی با چیدمان دینامیک و بدون تداخل.
    """
    import re
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import mm
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    from reportlab.platypus import Table, TableStyle, Paragraph
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_RIGHT, TA_LEFT

    font_name_fa = 'B-Nazanin'
    font_name_en = 'Helvetica'
    try:
        font_path = BASE_DIR / "BNazanin.ttf"
        if font_path.exists():
            pdfmetrics.registerFont(TTFont(font_name_fa, font_path))
        else:
            print(f"WARNING: '{font_path.name}' not found.")
    except Exception as e:
        print(f"ERROR: Could not load or register font '{font_name_fa}'. Reason: {e}")

    styles = getSampleStyleSheet()
    style_fa_right = ParagraphStyle(name='PersianRight', parent=styles['Normal'], fontName=font_name_fa, alignment=TA_RIGHT, fontSize=10, leading=14)
    style_fa_left = ParagraphStyle(name='PersianLeft', parent=styles['Normal'], fontName=font_name_fa, alignment=TA_LEFT, fontSize=10)
    style_en_center = ParagraphStyle(name='EnglishCenter', parent=styles['Normal'], fontName=font_name_en, alignment=TA_CENTER, fontSize=10)
    style_fa_header = ParagraphStyle(name='PersianHeader', parent=style_fa_right, textColor=colors.whitesmoke, alignment=TA_CENTER, fontSize=11)

    c = canvas.Canvas(file_path, pagesize=A4)
    width, height = A4

    def fa_text(text):
        return get_display(reshape(str(text)))

    c.setFont(font_name_fa, 20)
    c.drawCentredString(width / 2, height - 25 * mm, fa_text("پیش فاکتور"))

    cust_info = invoice_data['header']
    
    p_so_number = create_mixed_font_paragraph(f"شماره سفارش: {cust_info['so_number']}", style_fa_left)
    p_so_date = create_mixed_font_paragraph(f"تاریخ صدور: {to_shamsi(cust_info['issue_date'])}", style_fa_left)
    
    p_so_number.wrapOn(c, 100 * mm, 10 * mm); p_so_date.wrapOn(c, 100 * mm, 10 * mm)
    p_so_number.drawOn(c, 30 * mm, height - 40 * mm); p_so_date.drawOn(c, 30 * mm, height - 46 * mm)

    c.setFont(font_name_fa, 12); c.drawRightString(width - 30 * mm, height - 40 * mm, fa_text("مشخصات خریدار:"))
    c.setFont(font_name_fa, 10)
    c.drawRightString(width - 30 * mm, height - 48 * mm, fa_text(f"نام شرکت: {cust_info['customer_name']}"))
    c.drawRightString(width - 30 * mm, height - 54 * mm, fa_text(f"آدرس: {cust_info['address']}"))
    c.drawRightString(width - 30 * mm, height - 60 * mm, fa_text(f"تلفن: {cust_info['phone']}"))
    c.drawRightString(width - 30 * mm, height - 66 * mm, fa_text(f"کد اقتصادی: {cust_info['tax_id']}"))

    table_headers = [Paragraph(fa_text(h), style_fa_header) for h in ["قیمت کل", "قیمت واحد", "مقدار", "شرح کالا", "ردیف"]]
    table_data = [table_headers]
    
    total_amount = 0
    for i, item in enumerate(invoice_data['items']):
        total_price = item['quantity'] * item['unit_price']
        total_amount += total_price
        
        sku = item.get('sku', '')
        description_text = item['full_item_name']
        if sku:
            description_text += f"\n(SKU: {sku})"

        table_data.append([
            Paragraph(f"{total_price:,.0f}", style_en_center),
            Paragraph(f"{item['unit_price']:,.0f}", style_en_center),
            Paragraph(f"{item['quantity']:,}", style_en_center),
            create_mixed_font_paragraph(description_text, style_fa_right),
            Paragraph(str(i + 1), style_en_center)
        ])

    col_widths = [30*mm, 30*mm, 20*mm, 85*mm, 15*mm]
    table = Table(table_data, colWidths=col_widths)
    
    style = TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor("#4a6572")),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor("#f1f2f6")),
    ])
    table.setStyle(style)
    
    table_width = sum(col_widths)
    table_x_position = (width - table_width) / 2
    
    # --- *** اصلاح کلیدی اینجاست: محاسبه دینامیک موقعیت *** ---
    table_height = table.wrapOn(c, width - 40 * mm, height)[1]
    table_y_position = height - 80 * mm - table_height
    table.drawOn(c, table_x_position, table_y_position)

    total_box_width = 80 * mm
    total_box_height = 12 * mm
    total_box_x = table_x_position # هم‌راستا با شروع جدول
    # موقعیت باکس جمع کل، ۵ میلی‌متر پایین‌تر از انتهای جدول محاسبه می‌شود
    total_box_y = table_y_position - 5 * mm - total_box_height 
    # --- ****************************************************** ---

    c.setFillColor(colors.HexColor("#4a6572"))
    c.roundRect(total_box_x, total_box_y, total_box_width, total_box_height, 4, fill=1, stroke=0)
    
    c.setFont(font_name_fa, 12)
    c.setFillColor(colors.white)
    text_y_position = total_box_y + (total_box_height - (c._fontsize * 1.2)) / 2
    c.drawString(total_box_x + 5*mm, text_y_position, fa_text(f"جمع کل: {total_amount:,.0f} ریال"))

    c.save()
            
                    
SYSTEM_DATA_CATALOG = {
    "SALES": {
        "SO_NUMBER": "شماره سفارش فروش",
        "CUSTOMER_NAME": "نام مشتری",
        "CUSTOMER_ADDRESS": "آدرس مشتری",
        "CUSTOMER_TAX_ID": "کد اقتصادی مشتری",
        "SO_ITEMS_SUMMARY": "خلاصه کل اقلام سفارش"
    },
    # --- *** دسته جدید برای اطلاعات دقیق هر قلم کالا در سفارش فروش *** ---
    "SALES_ITEMS": {
        "SO_ITEM_NAME": "نام کالای فروخته شده",
        "SO_ITEM_QTY": "تعداد کالای فروخته شده",
        "SO_ITEM_PRICE": "قیمت واحد فروش"
    },
    "PURCHASING": {
        "PO_NUMBER": "شماره سفارش خرید",
        "SUPPLIER_NAME": "نام تامین‌کننده",
        "PR_ITEM_NAME": "نام کالای درخواستی",
        "PR_REQUESTED_QTY": "مقدار کالای درخواستی"
    },
    "PRODUCTION": {
        "PROD_BATCH_NO": "شماره بچ تولید",
        "PROD_PRODUCT_NAME": "نام محصول تولیدی",
        "PROD_QUANTITY": "مقدار تولید شده"
    }
}
        
from enum import Enum

# این کلاس را به طور کامل جایگزین نسخه قبلی کنید

class TransactionStatus(Enum):
    """یک واژه‌نامه استاندارد و متمرکز برای تمام وضعیت‌های سیستم."""
    # وضعیت‌های عمومی تراکنش
    APPROVED = 'تایید شده'
    VOIDED = 'باطل شده'
    CANCELLED = 'لغو شده'
    
    # وضعیت‌های در حال انتظار
    PENDING_APPROVAL = 'در انتظار تایید'
    PENDING_PRODUCTION_APPROVAL = 'در انتظار تایید تولید'
    PENDING_VOID_APPROVAL = 'در انتظار تایید ابطال'
    PENDING_WAREHOUSE_APPROVAL = 'در انتظار تایید انبار'
    MR_REWORK_WAREHOUSE = 'نیازمند بازبینی انبار' # <-- عضو جدید
        # --- *** بخش جدید و کامل شده برای درخواست مواد اولیه *** ---
    MR_PENDING = 'در انتظار رسیدگی انبار'       # <-- عضو جدید
    MR_FULFILLED = 'ارسال شده به تولید'          # <-- عضو جدید
    MR_REJECTED_BY_WAREHOUSE = 'رد شده توسط انبار' # <-- عضو جدید
    IR_PENDING_FULFILLMENT = 'در انتظار رسیدگی انبار'       # <-- عضو جدید
    IR_PENDING_PURCHASE = 'نیازمند تامین کالا'           # <-- عضو جدید
    IR_FULFILLED = 'تحویل شده به واحد'                   # <-- عضو جدید
    IR_REJECTED = 'رد شده توسط انبار'                   # <-- عضو جدید

    
    # وضعیت‌های رد شده
    REJECTED = 'رد شده'
    
    # وضعیت‌های تولید
    PRODUCED = 'تولید شده'
    CONSUMED = 'مصرف شده'

    # وضعیت‌های درخواست خرید
    PR_CREATED = 'ایجاد شده'
    PR_AWAITING_COMMERCE = 'در انتظار تایید بازرگانی'
    PR_AWAITING_MANAGER = 'در انتظار تایید مدیر واحد'
    PR_REJECTED_BY_COMMERCE = 'رد شده توسط بازرگانی'
    
    # وضعیت‌های فرآیند
    WF_DRAFT = 'DRAFT'
    PI_IN_PROGRESS = 'IN_PROGRESS'

    def __str__(self):
        return self.value
                    
# <<< IMPROVEMENT
class MatplotlibConfig:
    """
    پیکربندی امن و یک‌بارهٔ matplotlib برای فونت فارسی و rcParams.
    این کلاس امکان چندبار صدا زدن را بدون اثر جانبی می‌دهد (idempotent).
    """
    _configured = False
    _chosen_font = None  # 'B Nazanin' یا 'Tahoma'

    @classmethod
    def ensure(cls):
        if cls._configured:
            return

        from pathlib import Path
        import matplotlib as mpl
        import matplotlib.font_manager as fm

        this_dir = Path(__file__).resolve().parent

        # 1) تلاش برای بارگذاری فونت محلی (سازگار با ساختار فعلی پروژه)
        local_candidates = ('BNazanin.ttf', 'B Nazanin.ttf', 'BTitr.ttf', 'B Titr.ttf')
        found_any = False
        for fn in local_candidates:
            fp = this_dir / fn
            if fp.exists():
                try:
                    fm.fontManager.addfont(str(fp))
                    found_any = True
                except Exception:
                    pass

        # 2) انتخاب خانواده‌ی پیش‌فرض (ترجیح BNazanin اگر موجود بود)
        cls._chosen_font = "B Nazanin" if any(
            n for n in ["B Nazanin", "BNazanin"] if n in [f.name for f in fm.fontManager.ttflist]
        ) else "Tahoma"

        # 3) rcParams یک‌دست
        try:
            mpl.rcParams['font.family'] = 'sans-serif'
            mpl.rcParams['font.sans-serif'] = [cls._chosen_font, 'Tahoma']
            # سایز کلیِ نمودارها (با UI تداخل نداره)
            mpl.rcParams['font.size'] = 12
            mpl.rcParams['axes.unicode_minus'] = False
        except Exception:
            # اگر به هر دلیل نشد، لااقل منفی درست نمایش داده بشه
            mpl.rcParams['axes.unicode_minus'] = False

        # پرچم نهایی
        cls._configured = True

# کل کلاس FilterDialog را با این نسخه نهایی جایگزین کنید
class FilterDialog(QtWidgets.QDialog):
    """
    نسخه نهایی:
    - پس از اعمال یا ریست فیلتر، یک تابع callback را برای به‌روزرسانی نوار وضعیت فراخوانی می‌کند.
    """
    # ... (بخش OPS و متدهای استاتیک بدون تغییر باقی می‌مانند) ...
    @staticmethod
    def _to_num(s: str):
        try: return float(str(s).replace(',', ''))
        except: return float('nan')

    # در کلاس FilterDialog

    # --- REPLACE this static method in FilterDialog ---
    @staticmethod
    def _to_date(s: str):
        try:
            import re  # ensure available even if module-level import changes
            s_cleaned = str(s).strip().split(' ')[0]
            if not s_cleaned or '_' in s_cleaned:
                return None
            parts = re.split(r'[/.\-]', s_cleaned)
            if len(parts) == 3:
                return jd.date(int(parts[0]), int(parts[1]), int(parts[2]))
        except (ValueError, TypeError, AttributeError):
            return None
        return None
    # --- اصلاح: تابع on_finish را به عنوان ورودی می‌پذیرد ---
    def __init__(self, table, parent=None, on_finish=None):
        super().__init__(parent)
        self.tbl = table
        self.on_finish = on_finish # ذخیره تابع callback
        self.setWindowTitle('فیلتر پیشرفته')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(450, 350)

        v_layout = QtWidgets.QVBoxLayout(self); self.lst_filters = QtWidgets.QListWidget(); v_layout.addWidget(self.lst_filters, 1); grid = QtWidgets.QGridLayout(); grid.setSpacing(10); self.c_col = QtWidgets.QComboBox(); self.c_op = QtWidgets.QComboBox(); self.e_val = QtWidgets.QLineEdit(); btn_add = QtWidgets.QPushButton("افزودن شرط ➕"); grid.addWidget(QtWidgets.QLabel("ستون:"), 0, 0); grid.addWidget(self.c_col, 0, 1); grid.addWidget(QtWidgets.QLabel("شرط:"), 1, 0); grid.addWidget(self.c_op, 1, 1); grid.addWidget(QtWidgets.QLabel("مقدار:"), 2, 0); grid.addWidget(self.e_val, 2, 1); grid.addWidget(btn_add, 3, 0, 1, 2); v_layout.addLayout(grid); btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Reset | QtWidgets.QDialogButtonBox.Close); btns.button(QtWidgets.QDialogButtonBox.Ok).setText("اعمال فیلتر"); btns.button(QtWidgets.QDialogButtonBox.Reset).setText("حذف همه شرط‌ها"); v_layout.addWidget(btns)

        self.header_map = {}
        headers = []
        if isinstance(self.tbl, QtWidgets.QTableWidget):
            for i in range(self.tbl.columnCount()):
                if not self.tbl.isColumnHidden(i) and self.tbl.horizontalHeaderItem(i):
                    header_text = self.tbl.horizontalHeaderItem(i).text()
                    headers.append(header_text)
                    self.header_map[header_text] = i
        elif isinstance(self.tbl, QtWidgets.QTreeWidget):
            headers = [self.tbl.headerItem().text(i) for i in range(self.tbl.columnCount())]
            for i, header_text in enumerate(headers): self.header_map[header_text] = i

        self.c_col.addItems(headers)
        if hasattr(self.tbl, '_active_filters'):
            for f in self.tbl._active_filters: self._re_add_cond(f['name'], f['op_key'], f['val'])

        self.c_col.currentIndexChanged.connect(self._update_operators); btn_add.clicked.connect(self._add_cond); btns.accepted.connect(self.apply_filter); btns.button(QtWidgets.QDialogButtonBox.Reset).clicked.connect(self.reset_filter); btns.rejected.connect(self.close); self._update_operators()
    # ... (متدهای _re_add_cond, _update_operators, _add_cond بدون تغییر) ...
    def _re_add_cond(self, col_name, op_key, val): # ... (بدون تغییر)
        item = QtWidgets.QListWidgetItem(f"«{col_name}» {op_key} «{val}»"); real_col_index = self.header_map.get(col_name)
        if real_col_index is not None: item.setData(Qt.UserRole, (real_col_index, op_key, val)); self.lst_filters.addItem(item)
    def _update_operators(self): # ... (بدون تغییر)
        self.c_op.clear(); selected_column = self.c_col.currentText().lower()
        if 'تاریخ' in selected_column: self.c_op.addItems(['از تاریخ', 'تا تاریخ', 'برابر با']); self.e_val.setInputMask("0000/00/00;_")
        else: self.c_op.addItems(['شامل', 'برابر با', 'بزرگتر از', 'کوچکتر از', 'بزرگتر مساوی', 'کوچکتر مساوی']); self.e_val.setInputMask("")
    def _add_cond(self): # ... (بدون تغییر)
        col_name = self.c_col.currentText(); op_key = self.c_op.currentText(); val = self.e_val.text().strip()
        if not val: return
        self._re_add_cond(col_name, op_key, val); self.e_val.clear()

    def apply_filter(self):
        # ... (منطق اصلی فیلتر کردن بدون تغییر است) ...
        conditions = []; active_filters_to_save = []
        for i in range(self.lst_filters.count()):
            real_col_idx, op_key, val = self.lst_filters.item(i).data(Qt.UserRole)
            conditions.append({'col': int(real_col_idx), 'op': self.OPS[op_key], 'val': val})
            col_name = next((name for name, index in self.header_map.items() if index == real_col_idx), None)
            if col_name: active_filters_to_save.append({'name': col_name, 'op_key': op_key, 'val': val})
        self.tbl._active_filters = active_filters_to_save
        if not conditions: self._reset_widget_filter()
        elif isinstance(self.tbl, QtWidgets.QTableWidget):
            for r in range(self.tbl.rowCount()):
                match = all(self._check_match_table(self.tbl.item(r, c['col']), c['op'], c['val']) for c in conditions)
                self.tbl.setRowHidden(r, not match)
        elif isinstance(self.tbl, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(self.tbl, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()
                if item.parent(): # Only filter child items
                    match = all(self._check_match_tree(item, c['col'], c['op'], c['val']) for c in conditions)
                    item.setHidden(not match)
                iterator += 1
            self._update_tree_parents_visibility(self.tbl)

        # --- اصلاح: فراخوانی callback پس از اعمال فیلتر ---
        if self.on_finish: self.on_finish()
        self.close()

    def reset_filter(self):
        self.lst_filters.clear()
        if hasattr(self.tbl, '_active_filters'): self.tbl._active_filters = []
        self._reset_widget_filter()
        # --- اصلاح: فراخوانی callback پس از ریست فیلتر ---
        if self.on_finish: self.on_finish()

    def _reset_widget_filter(self): # ... (این متد و متدهای check_match بدون تغییر)
        if isinstance(self.tbl, QtWidgets.QTableWidget):
            for r in range(self.tbl.rowCount()): self.tbl.setRowHidden(r, False)
        elif isinstance(self.tbl, QtWidgets.QTreeWidget):
            iterator = QtWidgets.QTreeWidgetItemIterator(self.tbl, QtWidgets.QTreeWidgetItemIterator.All)
            while iterator.value(): iterator.value().setHidden(False); iterator += 1
    def _check_match_table(self, item, func, value): # ...
        cell_text = item.text() if item else "";
        try: return func(cell_text, value)
        except: return False
    def _check_match_tree(self, item, col_idx, func, value): # ...
        cell_text = item.text(col_idx) if item else "";
        try: return func(cell_text, value)
        except: return False
    def _update_tree_parents_visibility(self, tree): # ...
        root = tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent = root.child(i); has_visible_child = False
            for j in range(parent.childCount()):
                if not parent.child(j).isHidden(): has_visible_child = True; break
            parent.setHidden(not has_visible_child)
            
                    
                                                        
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas
import matplotlib.pyplot as plt
from arabic_reshaper import reshape          # ← افزوده
from bidi.algorithm import get_display       # ← افزوده

# ─── ثبت فونت فارسی + تابع fa() (نسخه نهایی و پایدار) ──────────────────
from arabic_reshaper import reshape
from bidi.algorithm    import get_display
import matplotlib as mpl
import matplotlib.font_manager as fm
from pathlib import Path

_THIS_DIR = Path(__file__).resolve().parent

def fa(txt: str) -> str:
    """متن فارسی را برای نمایش صحیح در نمودارهای matplotlib آماده می‌کند."""
    return get_display(reshape(str(txt)))

# تلاش برای پیدا کردن و ثبت فونت فارسی از فایل محلی
font_path = _THIS_DIR / "BNazanin.ttf"
if font_path.exists():
    fm.fontManager.addfont(str(font_path))
    FONT_FAMILY_MATPLOTLIB = "B Nazanin"
    print("INFO: Local 'B Nazanin' font loaded for matplotlib.")
else:
    # اگر فونت محلی نبود، به فونت‌های سیستمی اکتفا می‌کنیم
    FONT_FAMILY_MATPLOTLIB = "Tahoma"
    print("WARNING: 'BNazanin.ttf' not found. Falling back to system's 'Tahoma' font for charts.")

mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = [FONT_FAMILY_MATPLOTLIB]
mpl.rcParams['axes.unicode_minus'] = False


# فایل‌های فونت قابل قبول
for fn in ('BNazanin.ttf', 'B Nazanin.ttf', 'BTitr.ttf', 'B Titr.ttf'):
    fp = _THIS_DIR / fn
    if fp.exists():
        fm.fontManager.addfont(str(fp))

mpl.rcParams['font.family']      = 'sans-serif'
mpl.rcParams['font.sans-serif']  = ['B Nazanin', 'Tahoma']   # fallback اگر نازنین نبود
mpl.rcParams['font.size']        = 12
mpl.rcParams['axes.unicode_minus'] = False                   # علامت منفی درست

BASE_DIR    = Path(__file__).resolve().parent
BACKUP_INT  = 86400                     # 24h
VIEWS_FILE = BASE_DIR / 'views.json'


FONT_FAMILY = 'B Nazanin'
FONT_SIZE   = 11
# ───── پالت رنگ سراسری
PRIMARY  = '#3949ab'
ERROR    = '#c62828'
WARNING  = '#f9a825'
SURFACE  = '#f5f5f5'

# فونت تیتر (اگر نصب نیست BYekan یا هر فونت تیتری فارسی انتخاب کن)
FONT_TITLE = 'B Titr'        # یا 'BTitr' بسته به سیستم


_hash = lambda s: hashlib.sha256(s.encode('utf-8')).hexdigest()

from typing import List
import pandas as pd       # فرض بر این‌که pandas نصب است

CATEGORY_FINAL_PRODUCT = 'محصول نهایی'
CATEGORY_RAW_MATERIAL  = 'مواد اولیه'
CATEGORY_PACKAGING     = 'لوازم بسته‌بندی' # <-- این خط جدید را اضافه کنید
CATEGORY_CONSUMABLES   = 'لوازم مصرفی و ابزارآلات' # <-- ثابت جدید
CATEGORY_BULK_PRODUCT = 'محصول فله'


# --- *** بخش جدید برای افزودن *** ---
PRODUCTION_WAREHOUSE_NAME = 'Production'
MAIN_WAREHOUSE_NAME = 'Main'



def export_transactions_of_items(db: 'DB', item_ids: List[int], path: str, parent):
    """
    نسخه نهایی (V10.2):
    - 'موجودی اولیه' به‌عنوان ورودی شناسایی می‌شود.
    - تراکنش‌هایی که در notes عبارت 'موجودی اولیه' دارند، در گزارش با همین عنوان نمایش داده می‌شوند.
    - باقی رفتارها و استایل اکسل بدون تغییر.
    """
    if not item_ids:
        QtWidgets.QMessageBox.information(parent, '', 'هیچ کالایی انتخاب نشده است')
        return
    
    if not path:
        return

    try:
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from openpyxl.utils import get_column_letter
        import pandas as pd
        import datetime

        sheets_to_write = []
        for item_id in item_ids:
            item_details = db.get_item_details(item_id)
            if not item_details:
                continue
            item_name = item_details.get('name', f"کالای {item_id}")

            q_trans = """
                SELECT 
                    t.*, 
                    u.username,
                    orig_trans.t_type as voided_t_type,
                    (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin) AS src_loc_full,
                    (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin) AS dst_loc_full
                FROM trans t
                LEFT JOIN users u ON u.id = t.user_id
                LEFT JOIN trans orig_trans ON t.voids_trans_id = orig_trans.id
                LEFT JOIN locations src_l ON t.src_loc = src_l.id
                LEFT JOIN warehouses src_w ON src_l.warehouse_id = src_w.id
                LEFT JOIN locations dst_l ON t.dest_loc = dst_l.id
                LEFT JOIN warehouses dst_w ON dst_l.warehouse_id = dst_w.id
                WHERE t.item_id = %s AND t.status IN ('تایید شده', 'باطل شده')
                ORDER BY t.t_date, t.id
            """
            all_transactions = db.execute_query(q_trans, (item_id,))
            transactions = [t for t in all_transactions if t.get('t_date')]
            if not transactions:
                continue

            report_data_list = []
            running_balance = 0

            for t in transactions:
                qty = t.get('qty', 0)
                t_type_raw = str(t.get('t_type', '') or '')
                notes_str = str(t.get('notes', '') or '')

                # نرمال‌سازی برچسب نمایش
                # - اگر t_type انگلیسیِ قدیمی بود یا در توضیحات «موجودی اولیه» داشت → برچسب نهایی = «موجودی اولیه»
                if t_type_raw in ('INITIAL_ENTRY', 'INITIAL ENTRY') or ('موجودی اولیه' in notes_str) or (t_type_raw == 'موجودی اولیه'):
                    t_type_disp = 'موجودی اولیه'
                else:
                    t_type_disp = t_type_raw

                in_qty, out_qty = 0, 0

                # تشخیص ورودی/خروجی
                if t_type_disp.startswith('ورود') \
                   or t_type_disp == 'موجودی اولیه' \
                   or t_type_disp == 'برگشت' \
                   or t_type_disp == 'اضافه شدنی انبارگردانی':
                    in_qty = abs(qty)

                elif t_type_disp.startswith('خروج') \
                     or t_type_disp == 'کسری انبارگردانی' \
                     or t_type_disp == 'ضایعات':
                    out_qty = abs(qty)

                elif t_type_disp.startswith('ابطال'):
                    original_type = str(t.get('voided_t_type', '') or '')
                    if original_type.startswith('خروج'):
                        in_qty = abs(qty)
                    else:
                        out_qty = abs(qty)

                elif t_type_disp == 'انتقال':
                    running_balance -= abs(qty)
                    report_data_list.append({
                        'تاریخ': to_shamsi(t.get('t_date')),
                        'نوع عملیات': 'خروج (انتقال)',
                        'ورودی': '',
                        'خروجی': abs(qty),
                        'موجودی لحظه‌ای': running_balance,
                        'توضیحات': f"به: {t.get('dst_loc_full', '')} (سند: {t.get('t_no', '')})"
                    })
                    running_balance += abs(qty)
                    report_data_list.append({
                        'تاریخ': to_shamsi(t.get('t_date')),
                        'نوع عملیات': 'ورود (انتقال)',
                        'ورودی': abs(qty),
                        'خروجی': '',
                        'موجودی لحظه‌ای': running_balance,
                        'توضیحات': f"از: {t.get('src_loc_full', '')} (سند: {t.get('t_no', '')})"
                    })
                    continue

                running_balance += (in_qty - out_qty)
                report_data_list.append({
                    'تاریخ': to_shamsi(t.get('t_date')),
                    'نوع عملیات': t_type_disp,  # برچسب نهایی
                    'ورودی': in_qty if in_qty else '',
                    'خروجی': out_qty if out_qty else '',
                    'موجودی لحظه‌ای': running_balance,
                    'توضیحات': f"{notes_str} (کاربر: {t.get('username', '')})"
                })

            if not report_data_list:
                continue

            final_df = pd.DataFrame(report_data_list, columns=['تاریخ', 'نوع عملیات', 'ورودی', 'خروجی', 'موجودی لحظه‌ای', 'توضیحات'])
            safe_sheet_name = item_name.replace('/', '-').replace('\\', '-').replace(':', '')[:30]
            sheets_to_write.append({'name': safe_sheet_name, 'data': final_df})

        if sheets_to_write:
            try:
                with pd.ExcelWriter(path, engine='openpyxl') as writer:
                    # استایل‌دهی اکسل (بدون تغییر نسبت به نسخه‌ی شما)
                    REPORT_FONT_NAME = 'Tahoma'; REPORT_FONT_SIZE = 11
                    default_font = Font(name=REPORT_FONT_NAME, size=REPORT_FONT_SIZE)
                    bold_font = Font(name=REPORT_FONT_NAME, size=REPORT_FONT_SIZE, bold=True)
                    title_font = Font(name=REPORT_FONT_NAME, size=16, bold=True, color="FFFFFF")
                    header_font = Font(name=REPORT_FONT_NAME, size=REPORT_FONT_SIZE, bold=True, color="FFFFFF")
                    timestamp_font = Font(name=REPORT_FONT_NAME, size=9, italic=True, color="7F7F7F")
                    center_align = Alignment(horizontal='center', vertical='center')
                    right_align = Alignment(horizontal='right', vertical='center')
                    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
                    title_fill = PatternFill(start_color="2F5597", fill_type="solid")
                    header_fill = PatternFill(start_color="4F81BD", fill_type="solid")
                    alternating_fill = PatternFill(start_color="F2F2F2", fill_type="solid")
                    positive_fill = PatternFill(start_color="E7F5E8", fill_type="solid")
                    negative_fill = PatternFill(start_color="FDEDED", fill_type="solid")

                    for sheet_info in sheets_to_write:
                        sheet_name = sheet_info['name']
                        df_for_excel = sheet_info['data']
                        worksheet = writer.book.create_sheet(title=sheet_name)
                        writer.sheets[sheet_name] = worksheet

                        headers = list(df_for_excel.columns)
                        worksheet.merge_cells(start_row=1, start_column=1, end_row=1, end_column=len(headers))
                        title_cell = worksheet.cell(row=1, column=1, value=f"کارتکس انبار: {sheet_name}")
                        title_cell.font = title_font; title_cell.fill = title_fill; title_cell.alignment = center_align

                        worksheet.append(headers)
                        for col_num, header_title in enumerate(headers, 1):
                            cell = worksheet.cell(row=2, column=col_num)
                            cell.font = header_font; cell.fill = header_fill; cell.alignment = center_align; cell.border = thin_border

                        for r_idx, record in enumerate(df_for_excel.itertuples(index=True), 3):
                            worksheet.append(list(record[1:]))
                            for c_idx, col_name in enumerate(headers, 1):
                                cell = worksheet.cell(row=r_idx, column=c_idx)
                                cell.font = default_font; cell.border = thin_border; cell.alignment = right_align
                                if (r_idx % 2) != 0: cell.fill = alternating_fill
                                if col_name == 'ورودی' and isinstance(cell.value, (int, float)) and cell.value > 0: cell.fill = positive_fill
                                if col_name == 'خروجی' and isinstance(cell.value, (int, float)) and cell.value > 0: cell.fill = negative_fill
                                if col_name == 'موجودی لحظه‌ای': cell.font = bold_font

                        from openpyxl.utils import get_column_letter
                        for qty_col_name in ['ورودی', 'خروجی', 'موجودی لحظه‌ای']:
                            try:
                                qty_col_index = headers.index(qty_col_name) + 1
                                qty_col_letter = get_column_letter(qty_col_index)
                                for cell in worksheet[qty_col_letter]:
                                    if isinstance(cell.value, (int, float)):
                                        cell.number_format = '#,##0.###;[Red]-#,##0.###;0'
                                        cell.alignment = center_align
                            except ValueError:
                                pass

                        for col_num, column_cells in enumerate(worksheet.columns, 1):
                            max_length = max(len(str(cell.value or '')) for cell in column_cells)
                            adjusted_width = (max_length + 2) * 1.2 if max_length < 40 else 50
                            worksheet.column_dimensions[get_column_letter(col_num)].width = adjusted_width

                        worksheet.sheet_view.rightToLeft = True
                        worksheet.freeze_panes = 'A3'
                        last_row = worksheet.max_row
                        from openpyxl.utils import get_column_letter as _gcl
                        timestamp_cell_range = f'A{last_row + 2}:{_gcl(len(headers))}{last_row + 2}'
                        worksheet.merge_cells(timestamp_cell_range)
                        now_shamsi = to_shamsi(datetime.datetime.now())
                        timestamp_cell = worksheet.cell(row=last_row + 2, column=1, value=f"گزارش تهیه شده در تاریخ {now_shamsi}")
                        timestamp_cell.font = timestamp_font; timestamp_cell.alignment = Alignment(horizontal='left', vertical='center')

                    if 'Sheet' in writer.book.sheetnames and len(writer.book.sheetnames) > 1:
                        del writer.book['Sheet']

                QtWidgets.QMessageBox.information(parent, 'عملیات موفق', f'✔ کارتکس هوشمند برای {len(sheets_to_write)} کالا در فایل اکسل ذخیره شد.')
            except PermissionError:
                from pathlib import Path
                QtWidgets.QMessageBox.critical(parent, "خطای دسترسی به فایل",
                    f"<b>امکان ذخیره فایل اکسل وجود ندارد.</b><br><br>"
                    f"احتمالاً فایل <code>{Path(path).name}</code> در حال حاضر در برنامه اکسل باز است. لطفاً آن را ببندید و دوباره امتحان کنید.")
        else:
            QtWidgets.QMessageBox.information(parent, 'اطلاعات ناکافی', 'هیچ تراکنشی برای کالاهای انتخاب شده یافت نشد تا گزارشی ایجاد شود.')

    except Exception as e:
        print(traceback.format_exc())
        QtWidgets.QMessageBox.critical(parent, "خطای پیش‌بینی نشده", f"یک خطای ناشناخته در هنگام ایجاد گزارش رخ داد: {e}")
    finally:
        QtWidgets.QApplication.restoreOverrideCursor()

# در بخش CONSTANTS، این کلاس را جایگزین کنید

class TransactionType(Enum):
    """یک واژه‌نامه استاندارد و متمرکز برای تمام انواع تراکنش."""
    ENTRY = 'ورود'
    INITIAL_ENTRY = 'ورود اولیه'
    ENTRY_FROM_PROD = 'ورود از تولید'
    EXIT = 'خروج'
    EXIT_TO_PROD = 'خروج به تولید'
    EXIT_TO_LAB = 'خروج به آزمایشگاه' # <-- عضو جدید اضافه شد
    RETURN = 'برگشت'
    RETURN_FROM_PROD = 'برگشت از تولید'
    TRANSFER = 'انتقال'
    WASTE = 'ضایعات'
    INV_COUNT_ADD = 'اضافه شدنی انبارگردانی'
    INV_COUNT_SUB = 'کسری انبارگردانی'
    VOID_PREFIX = 'ابطال'

    def __str__(self):
        return self.value

class ItemLoaderWorker(QtCore.QObject):
    """
    یک Worker برای اجرای عملیات سنگین خواندن لیست کالاها در یک رشته مجزا.
    """
    finished = QtCore.pyqtSignal(dict) # دیکشنری برای ارسال داده‌های تفکیک شده

    def __init__(self, db_instance: 'DB', categories_to_fetch: list):
        super().__init__()
        self.db = db_instance
        self.categories = categories_to_fetch

    def run(self):
        """این متد در رشته جدید اجرا شده و لیست کالاها را برای هر دسته برمی‌گرداند."""
        results = {}
        try:
            for cat_name in self.categories:
                # برای هر دسته، داده‌ها را جداگانه می‌خوانیم
                total_items = self.db.get_items_count_by_category(cat_name)
                results[cat_name] = {
                    'total_items': total_items,
                    'data': [] # در ابتدا فقط تعداد کل را می‌گیریم
                }
        except Exception as e:
            print(f"Error in ItemLoaderWorker: {e}")
            traceback.print_exc()
        
        self.finished.emit(results)    
        
# این کلاس جدید را برای اجرای عملیات در پس‌زمینه اضافه کنید
class RefreshWorker(QtCore.QObject):
    """
    یک Worker برای اجرای عملیات خواندن داده‌های اصلی برنامه در یک رشته مجزا.
    """
    finished = QtCore.pyqtSignal(dict)

# در کلاس RefreshWorker این دو متد را جایگزین کنید
    def __init__(self, db_instance: 'DB', user_id: int, user_role_id: int, permissions: set, role_name: str):
        super().__init__()
        self.db = db_instance
        self.user_id = user_id
        self.user_role_id = user_role_id
        self.permissions = permissions
        self.role_name = role_name # دریافت نقش کاربر

    def run(self):
        """این متد در رشته جدید اجرا خواهد شد و تمام داده‌ها را واکشی می‌کند."""
        results = {}
        try:
            # ارسال نقش کاربر به تابع اعلان‌ها
            results['actionable_notifications'] = self.db.get_actionable_notifications(self.permissions, self.user_id, self.role_name)
            
            results['kpi_stats'] = self.db.stats()
            results['min_alert'] = self.db.min_alert()
            results['exp_alert'] = self.db.exp_alert()
            results['category_value_stats'] = self.db.get_category_value_stats()
            results['last_cleared_trans_id'] = self.db.get_setting('last_cleared_trans_id', '0')
        except Exception as e:
            print(f"Error in RefreshWorker: {e}")
            traceback.print_exc()
        
        self.finished.emit(results)
                        
                                                                                                                                        
# این کلاس جدید را برای اجرای عملیات در پس‌زمینه اضافه کنید
class BackupWorker(QtCore.QObject):
    """
    یک Worker برای اجرای عملیات پشتیبان‌گیری در یک رشته مجزا.
    """
    # سیگنالی که نتیجه عملیات (بولین موفقیت و پیام متنی) را برمی‌گرداند
    finished = QtCore.pyqtSignal(bool, str)

    def __init__(self, config, backup_path):
        super().__init__()
        self.config = config
        self.backup_path = backup_path

    def run(self):
        """این متد در رشته جدید اجرا خواهد شد."""
        success, message = backup_database(self.config, self.backup_path)
        self.finished.emit(success, message)
        
# در بخش CONSTANTS، این کلاس جدید را اضافه کنید
class AssetStatus(Enum):
    IN_STOCK = 'در انبار'
    ASSIGNED = 'در اختیار پرسنل'
    OUT_FOR_REPAIR = 'خروج (تعمیرات)'
    OUT_FOR_PROJECT = 'خروج (پروژه)'
    SCRAPPED = 'اسقاط شده'
    DELIVERED = 'تحویل شده'
    
def apply_schema_hotfixes_2025_08(db_instance: 'DB'):
    """
    هات‌فیکس‌های لازم برای هم‌خوانی کد و دیتابیس:
      - افزودن ستون mr.requester_user_id (و همگام‌سازی با requester_id)
      - افزودن ستون po.source_sales_order_id روی production_orders
      - ساخت جدول assets (حداقل اسکیمای لازم)
      - ساخت جداول هشدار/قواعد SLA مربوط به QA (برای حذف WARN)
    همهٔ دستورات idempotent هستند (چندبار اجرا بی‌خطر است).
    """
    ddl = r"""
    -- ===== material_requests: ستون سازگار با کدهای قدیمی =====
    DO $$
    BEGIN
        -- اگر ستون requester_id نبود، اضافه شود (محض اطمینان)
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema='public' AND table_name='material_requests' AND column_name='requester_id'
        ) THEN
            EXECUTE 'ALTER TABLE material_requests ADD COLUMN requester_id INTEGER REFERENCES users(id) ON DELETE SET NULL';
        END IF;

        -- اگر ستون requester_user_id نبود، اضافه شود
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema='public' AND table_name='material_requests' AND column_name='requester_user_id'
        ) THEN
            EXECUTE 'ALTER TABLE material_requests ADD COLUMN requester_user_id INTEGER';
            -- هم‌ارزش‌سازی مقادیر موجود
            EXECUTE 'UPDATE material_requests SET requester_user_id = requester_id WHERE requester_user_id IS NULL';
        END IF;

        -- تابع/ترایگر برای همگام‌سازی دو ستون (ساده و کافی)
        IF NOT EXISTS (
            SELECT 1 FROM pg_proc WHERE proname='trg_sync_mr_requester'
        ) THEN
            EXECUTE $f$
                CREATE OR REPLACE FUNCTION trg_sync_mr_requester() RETURNS trigger AS $$
                BEGIN
                    IF NEW.requester_user_id IS NULL AND NEW.requester_id IS NOT NULL THEN
                        NEW.requester_user_id := NEW.requester_id;
                    ELSIF NEW.requester_id IS NULL AND NEW.requester_user_id IS NOT NULL THEN
                        NEW.requester_id := NEW.requester_user_id;
                    END IF;
                    RETURN NEW;
                END;
                $$ LANGUAGE plpgsql;
            $f$;
        END IF;

        -- نصب/بازنصب ترایگر
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='material_requests') THEN
            EXECUTE 'DROP TRIGGER IF EXISTS material_requests_sync ON material_requests';
            EXECUTE 'CREATE TRIGGER material_requests_sync
                     BEFORE INSERT OR UPDATE ON material_requests
                     FOR EACH ROW EXECUTE FUNCTION trg_sync_mr_requester()';
        END IF;
    END $$;

    -- ===== production_orders: ستون ارجاع به sales_orders برای JOINهای داشبورد =====
    DO $$
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema='public' AND table_name='production_orders' AND column_name='source_sales_order_id'
        ) THEN
            EXECUTE 'ALTER TABLE production_orders
                     ADD COLUMN source_sales_order_id INTEGER REFERENCES sales_orders(id) ON DELETE SET NULL';
        END IF;
    END $$;

    -- ===== assets: حداقل اسکیمای لازم برای لود جدول دارایی‌ها =====
    CREATE TABLE IF NOT EXISTS assets (
        id SERIAL PRIMARY KEY,
        code TEXT UNIQUE,
        name TEXT NOT NULL,
        category TEXT,
        location TEXT,
        status TEXT DEFAULT ''  -- برای فیلترهای احتمالی UI
    );

    -- ===== جداول QA SLA/Alerts: حذف WARNهای هنگام Mount =====
    CREATE TABLE IF NOT EXISTS qa_sla_rules (
        id SERIAL PRIMARY KEY,
        workflow_id INTEGER NOT NULL,
        step_id INTEGER NULL,
        threshold_minutes INTEGER NOT NULL,
        severity VARCHAR(16) DEFAULT 'HIGH',
        active BOOLEAN DEFAULT TRUE
    );
    CREATE INDEX IF NOT EXISTS idx_sla_wf ON qa_sla_rules (workflow_id, active);
    CREATE INDEX IF NOT EXISTS idx_sla_step ON qa_sla_rules (step_id NULLS LAST);

    CREATE TABLE IF NOT EXISTS qa_escalation_alerts (
        id SERIAL PRIMARY KEY,
        process_instance_id INTEGER NOT NULL,
        workflow_id INTEGER NOT NULL,
        step_id INTEGER NULL,
        message TEXT NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    );
    CREATE INDEX IF NOT EXISTS idx_esc_alerts_time ON qa_escalation_alerts (created_at DESC);
    """

    try:
        with db_instance._conn() as conn:
            with conn.cursor() as cur:
                cur.execute(ddl)
            conn.commit()
        print("SUCCESS: 2025-08 hotfixes applied (MR requester*, PO source_sales_order_id, assets, QA tables).")
    except Exception as e:
        print(f"CRITICAL: apply_schema_hotfixes_2025_08 failed: {e}")
        raise

    
def setup_database(db_instance: 'DB'):
    """ساخت دیتابیس + مایگریشن‌ها (ایمن و idempotent)."""

    MAIN_WAREHOUSE_NAME = 'Main'
    PRODUCTION_WAREHOUSE_NAME = 'Production'

    # ---------- TX 1: ساخت جداول پایه ----------
    table_creation_commands = [
        """CREATE TABLE IF NOT EXISTS warehouses(id SERIAL PRIMARY KEY, name TEXT UNIQUE);""",
        """CREATE TABLE IF NOT EXISTS locations(
               id SERIAL PRIMARY KEY,
               warehouse_id INTEGER REFERENCES warehouses(id) ON DELETE CASCADE,
               rack TEXT, shelf TEXT, bin TEXT,
               UNIQUE(warehouse_id, rack, shelf, bin));""",

        """CREATE TABLE IF NOT EXISTS roles(
               id SERIAL PRIMARY KEY,
               name TEXT UNIQUE NOT NULL,
               dashboard_type TEXT DEFAULT 'DEFAULT');""",
        """CREATE TABLE IF NOT EXISTS role_dashboards(
               role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
               dashboard_key TEXT NOT NULL,
               PRIMARY KEY(role_id, dashboard_key));""",

        """CREATE TABLE IF NOT EXISTS process_categories(
               id SERIAL PRIMARY KEY,
               category_key TEXT UNIQUE NOT NULL,
               display_name TEXT NOT NULL,
               handler_key TEXT NOT NULL DEFAULT 'GENERIC');""",

        """CREATE TABLE IF NOT EXISTS permissions(
               id SERIAL PRIMARY KEY, code TEXT UNIQUE NOT NULL, description TEXT);""",
        """CREATE TABLE IF NOT EXISTS role_permissions(
               role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
               permission_id INTEGER NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
               PRIMARY KEY(role_id, permission_id));""",

        """CREATE TABLE IF NOT EXISTS departments(
               id SERIAL PRIMARY KEY,
               name TEXT UNIQUE NOT NULL,
               parent_id INTEGER REFERENCES departments(id) ON DELETE SET NULL,
               manager_user_id INTEGER,
               pos_x REAL, pos_y REAL);""",

        """CREATE TABLE IF NOT EXISTS users(
               id SERIAL PRIMARY KEY,
               username TEXT UNIQUE NOT NULL,
               passhash TEXT NOT NULL,
               role_id INTEGER REFERENCES roles(id) ON DELETE SET NULL,
               department_id INTEGER REFERENCES departments(id) ON DELETE SET NULL);""",

        """CREATE TABLE IF NOT EXISTS units (id SERIAL PRIMARY KEY, name TEXT UNIQUE NOT NULL, abbreviation TEXT);""",

        """CREATE TABLE IF NOT EXISTS items(
               id SERIAL PRIMARY KEY,
               name TEXT UNIQUE NOT NULL,
               category TEXT,
               unit_id INTEGER REFERENCES units(id) ON DELETE SET NULL,
               cost REAL DEFAULT 0.0, min_qty REAL DEFAULT 0.0, max_qty REAL DEFAULT 0.0,
               supplier TEXT, reporting_group TEXT, ent_date DATE, expiry_lead_days INTEGER DEFAULT 30,
               notes TEXT, default_loc INTEGER REFERENCES locations(id) ON DELETE SET NULL,
               is_packed BOOLEAN DEFAULT FALSE, sku TEXT UNIQUE,
               is_parent_product BOOLEAN DEFAULT FALSE, parent_item_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               net_weight REAL DEFAULT 0.0,
               requires_qc BOOLEAN DEFAULT TRUE,
               is_two_component BOOLEAN DEFAULT FALSE
        );""",

        # recipes
        """CREATE TABLE IF NOT EXISTS recipes(
               id SERIAL PRIMARY KEY,
               product_name TEXT NOT NULL,
               version INTEGER DEFAULT 1,
               status TEXT DEFAULT 'ACTIVE',
               properties JSONB,
               parent_product_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               produces_item_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               notes TEXT,
               created_by_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               created_at TIMESTAMPTZ DEFAULT NOW()
        );""",

        # مواد/اجزای recipe
        """CREATE TABLE IF NOT EXISTS recipe_ingredients(
               id SERIAL PRIMARY KEY,
               recipe_id INTEGER NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
               raw_material_item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
               percentage REAL NOT NULL DEFAULT 0,
               notes TEXT
        );""",

        """CREATE TABLE IF NOT EXISTS stock(
               id SERIAL PRIMARY KEY,
               item_id INTEGER REFERENCES items(id) ON DELETE CASCADE,
               location_id INTEGER REFERENCES locations(id) ON DELETE CASCADE,
               qty REAL, batch_no TEXT, expiry_date DATE,
               status TEXT DEFAULT 'AVAILABLE',
               UNIQUE(item_id, location_id, batch_no, expiry_date));""",

        """CREATE TABLE IF NOT EXISTS trans(
               id SERIAL PRIMARY KEY, item_id INTEGER REFERENCES items(id),
               t_type TEXT, t_no TEXT, t_date TIMESTAMPTZ,
               qty REAL, notes TEXT, user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               src_loc INTEGER, dest_loc INTEGER, voids_trans_id INTEGER DEFAULT NULL,
               status TEXT, attach_path TEXT, batch_no TEXT,
               approved_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
               approved_at TIMESTAMPTZ,
               expiry_date DATE);""",

        # 🔹 جدول پیوست‌های تراکنش‌ها (برای رفع خطای فعلی)
        """CREATE TABLE IF NOT EXISTS trans_files(
               id SERIAL PRIMARY KEY,
               trans_id INTEGER NOT NULL REFERENCES trans(id) ON DELETE CASCADE,
               file_path TEXT NOT NULL,
               uploaded_at TIMESTAMPTZ DEFAULT NOW()
        );""",

        """CREATE TABLE IF NOT EXISTS audit(
               id SERIAL PRIMARY KEY, stamp TIMESTAMPTZ,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               action TEXT, details TEXT);""",

        """CREATE TABLE IF NOT EXISTS app_settings(key TEXT PRIMARY KEY, value TEXT);""",

        """CREATE TABLE IF NOT EXISTS form_defs(
               id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL,
               created_at TIMESTAMPTZ DEFAULT NOW(), fields JSONB,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               form_type TEXT DEFAULT 'GENERAL', UNIQUE(name, user_id));""",

        """CREATE TABLE IF NOT EXISTS form_entries(
               id SERIAL PRIMARY KEY, form_id INTEGER NOT NULL REFERENCES form_defs(id) ON DELETE CASCADE,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               ts TIMESTAMPTZ DEFAULT NOW(), data JSONB);""",

        """CREATE TABLE IF NOT EXISTS suppliers(
               id SERIAL PRIMARY KEY, name TEXT UNIQUE NOT NULL,
               contact_person TEXT, phone TEXT, email TEXT, address TEXT,
               economic_code TEXT, notes TEXT, is_active BOOLEAN DEFAULT TRUE,
               created_at TIMESTAMPTZ DEFAULT NOW());""",

        # Workflows
        """CREATE TABLE IF NOT EXISTS workflows(
               id SERIAL PRIMARY KEY, name TEXT NOT NULL, description TEXT,
               version INTEGER DEFAULT 1, is_active BOOLEAN DEFAULT FALSE,
               created_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
               created_at TIMESTAMPTZ DEFAULT NOW(),
               status TEXT DEFAULT 'DRAFT', approved_by_id INTEGER REFERENCES users(id),
               approved_at TIMESTAMPTZ,
               form_def_id INTEGER REFERENCES form_defs(id),
               process_type_key TEXT REFERENCES process_categories(category_key),
               is_manual_start BOOLEAN DEFAULT TRUE,
               initial_action_key TEXT, final_action_key TEXT,
               start_conditions JSONB,
               UNIQUE(name, version));""",

        """CREATE TABLE IF NOT EXISTS workflow_steps(
               id SERIAL PRIMARY KEY, workflow_id INTEGER NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
               step_name TEXT NOT NULL, step_order INTEGER NOT NULL,
               approver_type TEXT NOT NULL, approver_role_id INTEGER REFERENCES roles(id),
               success_status_text TEXT, failure_status_text TEXT, rules JSONB,
               UNIQUE(workflow_id, step_order));""",

        """CREATE TABLE IF NOT EXISTS process_instances(
               id SERIAL PRIMARY KEY, workflow_id INTEGER NOT NULL REFERENCES workflows(id),
               related_record_id INTEGER NOT NULL, related_table_name TEXT NOT NULL,
               current_step_id INTEGER REFERENCES workflow_steps(id),
               status TEXT NOT NULL, started_at TIMESTAMPTZ DEFAULT NOW(),
               completed_at TIMESTAMPTZ,
               initiator_user_id INTEGER REFERENCES users(id),
               context JSONB, kanban_state TEXT DEFAULT 'new');""",

        """CREATE TABLE IF NOT EXISTS system_event_mappings(
               event_name TEXT PRIMARY KEY, workflow_id INTEGER NOT NULL REFERENCES workflows(id) ON DELETE CASCADE);""",

        """CREATE TABLE IF NOT EXISTS manual_workflow_access(
               workflow_id INTEGER NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
               department_id INTEGER NOT NULL REFERENCES departments(id) ON DELETE CASCADE,
               PRIMARY KEY(workflow_id, department_id));""",

        """CREATE TABLE IF NOT EXISTS system_operation_mappings(
               operation_key TEXT PRIMARY KEY,
               workflow_id INTEGER NOT NULL REFERENCES workflows(id) ON DELETE CASCADE);""",

        """CREATE TABLE IF NOT EXISTS delegations(
               id SERIAL PRIMARY KEY, delegator_id INTEGER NOT NULL REFERENCES users(id),
               delegate_id INTEGER NOT NULL REFERENCES users(id),
               workflow_id INTEGER REFERENCES workflows(id),
               start_date DATE NOT NULL, end_date DATE NOT NULL,
               notes TEXT, created_at TIMESTAMPTZ DEFAULT NOW());""",

        # UI: SLA/Alerts + دارایی‌ها
        """CREATE TABLE IF NOT EXISTS assets(
               id SERIAL PRIMARY KEY, code TEXT UNIQUE, name TEXT NOT NULL,
               category TEXT, location TEXT, status TEXT DEFAULT '');""",

        """CREATE TABLE IF NOT EXISTS asset_trans(
               id SERIAL PRIMARY KEY,
               asset_id INTEGER NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
               t_type TEXT NOT NULL,
               t_date TIMESTAMPTZ DEFAULT NOW(),
               t_no TEXT,
               notes TEXT,
               user_id INTEGER REFERENCES users(id) ON DELETE SET NULL
        );""",
        """CREATE TABLE IF NOT EXISTS asset_trans_files(
               id SERIAL PRIMARY KEY,
               asset_trans_id INTEGER NOT NULL REFERENCES asset_trans(id) ON DELETE CASCADE,
               file_path TEXT NOT NULL,
               uploaded_at TIMESTAMPTZ DEFAULT NOW()
        );""",

        """CREATE TABLE IF NOT EXISTS qa_sla_rules(
               id SERIAL PRIMARY KEY, workflow_id INTEGER NOT NULL,
               step_id INTEGER NULL, threshold_minutes INTEGER NOT NULL,
               severity VARCHAR(16) DEFAULT 'HIGH', active BOOLEAN DEFAULT TRUE);""",
        """CREATE INDEX IF NOT EXISTS idx_sla_wf ON qa_sla_rules (workflow_id, active);""",
        """CREATE INDEX IF NOT EXISTS idx_sla_step ON qa_sla_rules (step_id);""",
        """CREATE TABLE IF NOT EXISTS qa_escalation_alerts(
               id SERIAL PRIMARY KEY, process_instance_id INTEGER NOT NULL,
               workflow_id INTEGER NOT NULL, step_id INTEGER NULL,
               message TEXT NOT NULL,
               created_at TIMESTAMPTZ NOT NULL DEFAULT NOW());""",
        """CREATE INDEX IF NOT EXISTS idx_esc_alerts_time ON qa_escalation_alerts (created_at DESC);""",

        # درخواست مواد داخلی
        """CREATE TABLE IF NOT EXISTS material_requests(
               id SERIAL PRIMARY KEY,
               requester_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
               requester_user_id INTEGER,
               item_id INTEGER REFERENCES items(id) ON DELETE SET NULL,
               requested_qty REAL NOT NULL DEFAULT 0,
               fulfilled_qty REAL NOT NULL DEFAULT 0,
               status TEXT NOT NULL,
               notes TEXT,
               parent_request_id INTEGER REFERENCES material_requests(id) ON DELETE SET NULL,
               created_at TIMESTAMPTZ DEFAULT NOW()
        );""",
        """CREATE TABLE IF NOT EXISTS material_request_items(
               id SERIAL PRIMARY KEY,
               request_id INTEGER NOT NULL REFERENCES material_requests(id) ON DELETE CASCADE,
               item_id INTEGER NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
               requested_qty REAL NOT NULL,
               approved_qty REAL DEFAULT 0,
               issued_qty REAL DEFAULT 0,
               notes TEXT
        );""",
    ]

    try:
        with db_instance._conn() as conn:
            with conn.cursor() as cur:
                print("INFO: (TX 1/3) Initializing base tables...")
                for command in table_creation_commands:
                    cur.execute(command)
            conn.commit()
        print("SUCCESS: Base tables created/verified.")
    except Exception as e:
        print(f"CRITICAL ERROR during table creation: {e}")
        raise

    # ---------- TX 2: مایگریشن‌ها ----------
    migrations = [
        ("ALTER TABLE stock ADD CONSTRAINT qty_must_be_non_negative CHECK (qty >= 0);", "non-negative stock qty"),
        ("ALTER TABLE users DROP COLUMN IF EXISTS department;", "drop obsolete users.department"),
        ("ALTER TABLE process_instances ADD COLUMN IF NOT EXISTS kanban_state TEXT DEFAULT 'new';", "kanban state"),
        ("ALTER TABLE workflows ADD COLUMN IF NOT EXISTS is_manual_start BOOLEAN DEFAULT TRUE;", "manual start flag"),
        ("ALTER TABLE workflows ADD COLUMN IF NOT EXISTS description TEXT;", "wf description"),
        ("ALTER TABLE workflows ADD COLUMN IF NOT EXISTS start_conditions JSONB;", "wf start_conditions"),
        ("ALTER TABLE purchase_requests ADD COLUMN IF NOT EXISTS selected_quote_id INTEGER;", "pr.selected_quote_id"),
        ("ALTER TABLE process_instances ADD COLUMN IF NOT EXISTS context JSONB;", "pi.context"),
        ("ALTER TABLE process_instances ADD COLUMN IF NOT EXISTS initiator_user_id INTEGER REFERENCES users(id);", "pi.initiator"),
        ("ALTER TABLE workflows DROP CONSTRAINT IF EXISTS workflows_name_key;", "drop old wf unique"),
        ("ALTER TABLE workflows ADD CONSTRAINT workflows_name_version_key UNIQUE (name, version);", "wf unique(name,version)"),
        ("ALTER TABLE workflows DROP COLUMN IF EXISTS process_type;", "drop process_type"),
        ("ALTER TABLE workflows ADD COLUMN IF NOT EXISTS process_type_key TEXT REFERENCES process_categories(category_key);", "wf.process_type_key"),
        ("ALTER TABLE process_categories ADD COLUMN IF NOT EXISTS handler_key TEXT NOT NULL DEFAULT 'GENERIC';", "pc.handler_key"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'موجود';", "stock.status default fa"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS entry_value REAL;", "stock.entry_value"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS source_po_item_id INTEGER REFERENCES purchase_order_items(id) ON DELETE SET NULL;", "stock.source_po_item_id"),

        # recipes + part_type + yield
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;", "recipes.version"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'ACTIVE';", "recipes.status"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS properties JSONB;", "recipes.properties"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS parent_product_id INTEGER REFERENCES items(id) ON DELETE SET NULL;", "recipes.parent_product_id"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS produces_item_id INTEGER REFERENCES items(id) ON DELETE SET NULL;", "recipes.produces_item_id"),
        ("ALTER TABLE recipes DROP CONSTRAINT IF EXISTS recipes_product_name_key;", "drop old recipe unique"),
        ("DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='recipes_product_name_version_key') THEN ALTER TABLE recipes ADD CONSTRAINT recipes_product_name_version_key UNIQUE (product_name, version); END IF; END $$;", "recipes unique(name,version)"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS part_type TEXT;", "recipes.part_type"),
        ("""
            UPDATE recipes r
               SET part_type = 'PACKAGING'
             WHERE part_type IS NULL
               AND EXISTS (
                    SELECT 1
                      FROM recipe_ingredients ri
                      JOIN items i ON i.id = ri.raw_material_item_id
                     WHERE ri.recipe_id = r.id
                       AND i.category = %s
               );
         """, "backfill recipes.part_type=PACKAGING"),
        ("UPDATE recipes SET part_type = 'MIX' WHERE part_type IS NULL;", "backfill recipes.part_type=MIX"),
        ("ALTER TABLE recipes ADD COLUMN IF NOT EXISTS yield_percentage REAL;", "recipes.yield_percentage"),
        ("""
            UPDATE recipes
               SET yield_percentage = NULLIF((properties->>'yield_percentage'),'')::REAL
             WHERE yield_percentage IS NULL
               AND properties ? 'yield_percentage'
               AND COALESCE(part_type,'MIX') <> 'PACKAGING';
         """, "backfill recipes.yield from properties"),
        ("""UPDATE recipes SET properties = properties - 'yield_percentage' WHERE properties ? 'yield_percentage';""", "cleanup properties.yield_percentage"),

        ("ALTER TABLE sales_orders ADD COLUMN IF NOT EXISTS order_type TEXT DEFAULT 'STOCK' NOT NULL;", "so.order_type"),
        ("ALTER TABLE workflows ADD COLUMN IF NOT EXISTS final_action_key TEXT;", "wf.final_action_key"),
        ("ALTER TABLE items ADD CONSTRAINT items_name_key UNIQUE (name);", "items unique(name)"),
        ("ALTER TABLE production_deliveries ADD COLUMN IF NOT EXISTS production_order_id INTEGER REFERENCES production_orders(id) ON DELETE SET NULL;", "pd.production_order_id"),
        ("ALTER TABLE material_requests ADD COLUMN IF NOT EXISTS parent_request_id INTEGER REFERENCES material_requests(id) ON DELETE SET NULL;", "mr.parent_request_id"),
        ("ALTER TABLE material_requests ADD COLUMN IF NOT EXISTS fulfilled_qty REAL DEFAULT 0;", "mr.fulfilled_qty"),
        ("UPDATE stock SET status = 'تایید شده' WHERE status IS NULL OR status = 'موجود';", "migrate stock status"),

        # یکتایی نام (root/child)
        ("ALTER TABLE items DROP CONSTRAINT IF EXISTS items_name_key;", "drop items unique(name)"),
        ("""
        CREATE UNIQUE INDEX IF NOT EXISTS ux_items_name_global_when_no_parent
        ON items ( (LOWER(REPLACE(REPLACE(name, E'\u200c',''), ' ', ''))) )
        WHERE parent_item_id IS NULL;
        """, "ux items name no_parent"),
        ("""
        CREATE UNIQUE INDEX IF NOT EXISTS ux_items_name_per_parent
        ON items ( parent_item_id, (LOWER(REPLACE(REPLACE(name, E'\u200c',''), ' ', ''))) )
        WHERE parent_item_id IS NOT NULL;
        """, "ux items name per_parent"),

        # timestamps در stock
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS received_at TIMESTAMPTZ;", "stock.received_at"),
        ("UPDATE stock SET received_at = NOW() WHERE received_at IS NULL;", "backfill stock.received_at"),
        ("ALTER TABLE stock ADD COLUMN IF NOT EXISTS last_moved_at TIMESTAMPTZ;", "stock.last_moved_at"),
        ("UPDATE stock SET last_moved_at = COALESCE(received_at, NOW()) WHERE last_moved_at IS NULL;", "backfill stock.last_moved_at"),
        ("""
        DO $$
        BEGIN
          IF EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = current_schema()
              AND table_name = 'stock'
              AND column_name = 'last_moved_at'
          ) THEN
            ALTER TABLE stock ALTER COLUMN last_moved_at SET DEFAULT NOW();
          END IF;
        END $$;
        """, "default stock.last_moved_at"),

        # ✅ قاعده: مادر/فرزند فقط برای «محصول نهایی»
        ("""
        DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'items_parent_rules_chk') THEN
            ALTER TABLE items
              ADD CONSTRAINT items_parent_rules_chk
              CHECK ( (category = 'محصول نهایی') OR (is_parent_product = FALSE AND parent_item_id IS NULL) )
              NOT VALID;
          END IF;
        END $$;
        """, "rule: parent only for final products"),

        # ایندکس‌های کاربردی
        ("CREATE INDEX IF NOT EXISTS ix_items_category ON items(category);", "ix items.category"),
        ("CREATE INDEX IF NOT EXISTS ix_items_parent ON items(parent_item_id);", "ix items.parent"),
        ("CREATE INDEX IF NOT EXISTS ix_stock_item ON stock(item_id);", "ix stock.item"),
        ("CREATE INDEX IF NOT EXISTS ix_stock_item_loc ON stock(item_id, location_id);", "ix stock.item_loc"),

        # ستون‌های دارایی‌ها + cost
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS brand TEXT;", "assets.brand"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS model TEXT;", "assets.model"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS serial_no TEXT;", "assets.serial_no"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS purchase_date DATE;", "assets.purchase_date"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS warranty_expiry DATE;", "assets.warranty_expiry"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS acquisition_cost REAL;", "assets.acquisition_cost"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS vendor TEXT;", "assets.vendor"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS depreciates BOOLEAN DEFAULT FALSE;", "assets.depreciates"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS depreciation_method TEXT DEFAULT 'STRAIGHT_LINE';", "assets.depreciation_method"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS useful_life_months INTEGER;", "assets.useful_life_months"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS residual_value REAL DEFAULT 0;", "assets.residual_value"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS notes TEXT;", "assets.notes"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS photo_path TEXT;", "assets.photo_path"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS assigned_to_user_id INTEGER REFERENCES users(id) ON DELETE SET NULL;", "assets.assigned_to_user_id"),
        ("ALTER TABLE assets ADD COLUMN IF NOT EXISTS cost REAL;", "assets.cost"),
        ("UPDATE assets SET cost = acquisition_cost WHERE cost IS NULL AND acquisition_cost IS NOT NULL;", "backfill assets.cost"),

        # 🔹 ایندکس برای trans_files (پیوست‌های تراکنش)
        ("CREATE INDEX IF NOT EXISTS ix_trans_files_trans ON trans_files(trans_id);", "ix trans_files.trans_id"),

        # سیاست پیش‌فرض نرم‌افزاری
        ("INSERT INTO app_settings(key, value) VALUES ('allow_quarantine_consumption','false') ON CONFLICT (key) DO NOTHING;", "policy quarantine consumption default"),
        ("INSERT INTO sequences(name) VALUES ('TRANS_DOC') ON CONFLICT (name) DO NOTHING;", "seed TRANS_DOC"),
    ]

    print("INFO: (TX 2/3) Running database migrations...")
    for sql, desc in migrations:
        try:
            with db_instance._conn() as conn:
                with conn.cursor() as cur:
                    if "backfill recipes.part_type=PACKAGING" in desc:
                        cur.execute(sql, (CATEGORY_PACKAGING,))
                    else:
                        cur.execute(sql)
                conn.commit()
            print(f"SUCCESS: Migration '{desc}' applied.")
        except (psycopg2.errors.DuplicateColumn,
                psycopg2.errors.DuplicateObject,
                psycopg2.errors.UndefinedColumn,
                psycopg2.errors.DuplicateTable):
            print(f"INFO: Migration '{desc}' already applied or skipped safely.")
        except psycopg2.Error as db_err:
            print(f"WARNING: Non-critical migration error on '{desc}': {db_err}")

    # ---------- TX 3: داده‌های اولیه ----------
    try:
        with db_instance._conn() as conn:
            with conn.cursor() as cur:
                print("INFO: (TX 3/3) Seeding initial data...")
                db_instance._seed_initial_permissions_and_roles(cur)
                cur.execute(f"INSERT INTO warehouses(name) VALUES ('{MAIN_WAREHOUSE_NAME}') ON CONFLICT (name) DO NOTHING;")
                cur.execute(f"INSERT INTO locations(warehouse_id, rack, shelf, bin) SELECT id, 'A','1','1' FROM warehouses WHERE name='{MAIN_WAREHOUSE_NAME}' ON CONFLICT DO NOTHING;")
                cur.execute(f"INSERT INTO warehouses(name) VALUES ('{PRODUCTION_WAREHOUSE_NAME}') ON CONFLICT (name) DO NOTHING;")
                cur.execute(f"INSERT INTO locations(warehouse_id, rack, shelf, bin) SELECT id, 'FLOOR','A','1' FROM warehouses WHERE name='{PRODUCTION_WAREHOUSE_NAME}' ON CONFLICT DO NOTHING;")
                cur.execute("INSERT INTO app_settings(key, value) VALUES ('last_cleared_trans_id', '0') ON CONFLICT(key) DO NOTHING;")
                cur.execute("INSERT INTO units(name, abbreviation) VALUES ('عدد','Adad'), ('کیلوگرم','Kg'), ('گرم','g'), ('متر','m'), ('لیتر','L') ON CONFLICT (name) DO NOTHING;")
            conn.commit()
        print("SUCCESS: Initial data seeded.")
    except Exception as e:
        print(f"CRITICAL ERROR during data seeding: {e}")
        raise

    print("INFO: Database initialization and migration complete.")
                
class DB:
    """PostgreSQL Wrapper با: Min/Max, Expiry, Users, AuditLog"""
# در کلاس DB، کل متد __init__ را با این نسخه جایگزین کنید


    def __init__(self, config: dict):
        """
        نسخه نهایی: در هنگام شروع، یک استخر اتصال (Connection Pool) ایجاد می‌کند.
        """
        if not config:
            raise ValueError("Configuration data is required to initialize the DB.")
        self.config = config
        self.signals = DBsignals()
        self._pool = None

        try:
            # ایجاد استخر اتصالات با حداقل 1 و حداکثر 10 اتصال همزمان
            self._pool = psycopg2.pool.SimpleConnectionPool(1, 10, **self.config)
            print("SUCCESS: Database connection pool created.")
        except Exception as e:
            raise ConnectionError(f"Could not create connection pool. Please check config. Error: {e}")

    @contextmanager
    def _get_conn(self):
        """
        یک اتصال از استخر گرفته و پس از اتمام کار، آن را باز می‌گرداند.
        این متد جایگزین _conn() قبلی می‌شود.
        """
        if self._pool is None:
            raise ConnectionError("Connection pool is not available.")

        conn = None
        try:
            conn = self._pool.getconn()
            yield conn
        finally:
            if conn:
                self._pool.putconn(conn)

    def execute_query(self, query: str, params: tuple = (), fetch_one: bool = False, cursor=None):
        """
        نسخه نهایی (با پشتیبانی از Pool): از استخر اتصالات برای اجرای کوئری‌ها استفاده می‌کند.
        """
        if cursor is not None:
            cursor.execute(query, params)
            if cursor.description:
                return cursor.fetchone() if fetch_one else cursor.fetchall()
            return None

        with self._get_conn() as conn:
            with conn.cursor(cursor_factory=DictCursor) as cur:
                cur.execute(query, params)
                if cur.description:
                    return cur.fetchone() if fetch_one else cur.fetchall()
                return None

    @contextmanager
    def transaction(self):
        """
        یک محیط امن برای تراکنش‌ها با استفاده از استخر اتصالات فراهم می‌کند.
        """
        with self._get_conn() as conn:
            try:
                with conn.cursor(cursor_factory=DictCursor) as cur:
                    yield cur
                conn.commit()
            except Exception as e:
                conn.rollback()
                print(f"Transaction failed. Rolling back. Error: {e}")
                raise
                                
# در کلاس DB، این متد را جایگزین کنید
    def _conn(self):
        """
        نسخه نهایی و قطعی (V4.0):
        - با استفاده از RealDictCursor تضمین می‌کند که خروجی همیشه به صورت دیکشنری واقعی پایتون باشد.
        """
        try:
            from psycopg2.extras import RealDictCursor

            connection_params = {
                'host': self.config.get("host"),
                'port': self.config.get("port"),
                'dbname': self.config.get("dbname"),
                'user': self.config.get("user"),
                'password': self.config.get("password"),
                'sslmode': self.config.get("sslmode", 'prefer')
            }

            c = psycopg2.connect(**connection_params, 
                                 cursor_factory=RealDictCursor,
                                 connect_timeout=5)
            return c
        except psycopg2.OperationalError as e:
            print(f"خطا در اتصال به دیتابیس PostgreSQL: {e}")
            raise ConnectionError(
                "برنامه قادر به اتصال به دیتابیس نیست.\n"
                "لطفاً از روشن بودن سرویس PostgreSQL و صحت اطلاعات در فایل config.json اطمینان حاصل کنید."
            )
            
        # <<< IMPROVEMENT
    def execute(self, query: str, params=None) -> int:
        """
        اجرای INSERT/UPDATE/DELETE.
        خروجی: تعداد ردیف‌های متاثر.
        """
        with self.transaction() as cur:
            cur.execute(query, params or ())
            return cur.rowcount

    # <<< IMPROVEMENT
    def query_all(self, query: str, params=None):
        """
        اجرای SELECT و برگرداندن تمام ردیف‌ها (list of dict یا list of tuple مطابق نوع cursor).
        """
        with self.transaction() as cur:
            cur.execute(query, params or ())
            return cur.fetchall()

    # <<< IMPROVEMENT
    def query_one(self, query: str, params=None):
        """
        اجرای SELECT و برگرداندن یک ردیف (dict یا tuple) یا None اگر نبود.
        """
        with self.transaction() as cur:
            cur.execute(query, params or ())
            return cur.fetchone()

    # <<< IMPROVEMENT
    def query_value(self, query: str, params=None, default=None):
        """
        اجرای SELECT و برگرداندن 'اولین مقدارِ' اولین ردیف.
        هم با DictCursor و هم با tuple کار می‌کند.
        """
        row = self.query_one(query, params)
        if row is None:
            return default
        # DictCursor
        if isinstance(row, dict):
            try:
                # اولویت: اگر فقط یک کلید دارد همان را بده؛ وگرنه اولین کلید را
                if len(row) == 1:
                    return next(iter(row.values()))
                return row[next(iter(row.keys()))]
            except Exception:
                return default
        # Tuple cursor
        try:
            return row[0]
        except Exception:
            return default

    # <<< IMPROVEMENT
    def exists(self, query: str, params=None) -> bool:
        """
        بررسی وجود داده: اگر دست‌کم یک ردیف باشد True برمی‌گرداند.
        """
        with self.transaction() as cur:
            cur.execute(query, params or ())
            return cur.fetchone() is not None

    # <<< IMPROVEMENT
    def insert_row(self, table: str, data: dict, returning: str = 'id'):
        """
        INSERT ایمن بر اساس dict {ستون: مقدار}.
        اگر 'returning' ست شود، مقدار آن ستون را برمی‌گرداند؛ وگرنه تعداد ردیف‌ها.
        """
        # برای ساخت ایمن شناسه‌ها از psycopg2.sql استفاده می‌کنیم (داخل متد import می‌شود تا جای دیگری تغییر ندهیم)
        from psycopg2 import sql as _sql

        cols = list(data.keys())
        vals = list(data.values())
        placeholders = [_sql.Placeholder() for _ in cols]

        q = _sql.SQL("INSERT INTO {tbl} ({cols}) VALUES ({vals})").format(
            tbl=_sql.Identifier(table),
            cols=_sql.SQL(', ').join(map(_sql.Identifier, cols)),
            vals=_sql.SQL(', ').join(placeholders),
        )

        if returning:
            q = q + _sql.SQL(" RETURNING {ret}").format(ret=_sql.Identifier(returning))

        with self.transaction() as cur:
            cur.execute(q, vals)
            if returning:
                r = cur.fetchone()
                # DictCursor یا tuple
                if isinstance(r, dict):
                    return r.get(returning)
                return r[0] if r else None
            return cur.rowcount

    # <<< IMPROVEMENT
    def update_rows(self, table: str, data: dict, where: dict) -> int:
        """
        UPDATE ایمن: data را روی سطر/سطرهای where اعمال می‌کند.
        خروجی: تعداد ردیف‌های متاثر.
        """
        from psycopg2 import sql as _sql

        set_cols = list(data.keys())
        set_vals = list(data.values())

        where_cols = list(where.keys())
        where_vals = list(where.values())

        q = _sql.SQL("UPDATE {tbl} SET {sets} WHERE {conds}").format(
            tbl=_sql.Identifier(table),
            sets=_sql.SQL(', ').join(
                _sql.SQL("{} = {}").format(_sql.Identifier(c), _sql.Placeholder()) for c in set_cols
            ),
            conds=_sql.SQL(' AND ').join(
                _sql.SQL("{} = {}").format(_sql.Identifier(c), _sql.Placeholder()) for c in where_cols
            ),
        )

        with self.transaction() as cur:
            cur.execute(q, set_vals + where_vals)
            return cur.rowcount

                            

                                                
    def stats(self):
        """آمار کلی انبار را بر اساس موجودی واقعی در جدول stock محاسبه می‌کند."""
        with self.transaction() as cur:
            q1 = "SELECT COUNT(*) as cnt FROM items;"
            q2 = """
                SELECT i.category, SUM(s.qty) as total_qty
                FROM stock s
                JOIN items i ON s.item_id = i.id
                GROUP BY i.category;
            """
            count_res = self.execute_query(q1, cursor=cur)
            cat_res = self.execute_query(q2, cursor=cur)

        cnt = count_res[0]['cnt'] if count_res else 0
        return cnt, cat_res
        
# در کلاس DB، این متد را نیز با نسخه جدید جایگزین کنید
    def get_item_by_name(self, item_name: str):
        """یک کالا را بر اساس نام دقیق آن جستجو کرده و اطلاعاتش را برمی‌گرداند."""
        # حالا فراخوانی به درستی انجام می‌شود
        return self.execute_query("SELECT * FROM items WHERE name = %s", (item_name,), fetch_one=True)
    
            
                                
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def create_purchase_request(self, item_id: int, qty: float, user_id: int, original_dept_id: int, notes: str):
        """یک درخواست خرید جدید ثبت کرده و رویداد آن را برای شروع فرآیند احتمالی، به موتور مرکزی ارسال می‌کند."""
        
        # --- *** منطق جدید و هوشمند برای جلوگیری از خطا *** ---
        # اگر دپارتمان به صورت مستقیم ارسال نشده بود، آن را از اطلاعات کاربر پیدا کن
        if not original_dept_id:
            user_dept_rec = self.execute_query("SELECT department_id FROM users WHERE id = %s", (user_id,), fetch_one=True)
            if user_dept_rec and user_dept_rec.get('department_id'):
                original_dept_id = user_dept_rec['department_id']
                print(f"WARNING: 'original_dept_id' was missing. Inferred department ID {original_dept_id} from user ID {user_id}.")
            else:
                # اگر کاربر هم دپارتمان نداشت، یک خطای واضح و کامل نمایش بده
                raise ValueError(f"برای ثبت درخواست خرید، مشخص کردن واحد درخواست‌دهنده الزامی است (کاربر ID:{user_id} فاقد واحد سازمانی است).")
        # --- ****************************************** ---

        with self.transaction() as cur:
            # گام ۱: ثبت درخواست خرید با وضعیت اولیه 'ایجاد شده'
            result = self.execute_query(
                """INSERT INTO purchase_requests (item_id, requested_qty, requester_id, original_department_id, status, notes)
                   VALUES (%s, %s, %s, %s, %s, %s) RETURNING id""",
                (item_id, qty, user_id, original_dept_id, TransactionStatus.PR_CREATED.value, notes),
                fetch_one=True,
                cursor=cur
            )
            request_id = result['id']
            
            log_details = f"PR ID:{request_id}, Item ID:{item_id}, Qty:{qty}, Dept ID:{original_dept_id}"
            self._log_atomic(cur, user_id, 'CREATE_PURCHASE_REQUEST', log_details)

        # گام ۲: اطلاع‌رسانی به موتور مرکزی (خارج از تراکنش اولیه)
        self.trigger_event('PURCHASE_REQUEST_CREATED', request_id, 'purchase_requests', user_id)
        
        return request_id
    
    
    def reject_material_request(self, request_id: int, user_id: int, reason: str):
        """یک درخواست مواد اولیه را به صورت اتمیک رد کرده و دلیل آن را ثبت می‌کند."""
        with self.transaction() as cur:
            notes = f"درخواست توسط انباردار رد شد. دلیل: {reason}"
            query = """
                UPDATE material_requests 
                SET status=%s, processed_by_user_id=%s, processed_at=NOW(), notes=%s 
                WHERE id=%s
            """
            params = (TransactionStatus.REJECTED.value, user_id, notes, request_id)
            self.execute_query(query, params, cursor=cur)
                                                        
# در کلاس DB، این متد را جایگزین کنید

    def trigger_event(self, event_name: str, record_id: int, table_name: str, user_id: int, context_data: dict = None):
        """
        یک رویداد سیستمی را بررسی کرده، داده‌های آن را واکشی و فرآیند متصل به آن را با آن داده‌ها آغاز می‌کند.
        FIX: شناسه کاربر (user_id) به درستی به start_workflow_instance پاس داده می‌شود.
        """
        with self.transaction() as cur:
            mapping = self.execute_query(
                "SELECT workflow_id FROM system_event_mappings WHERE event_name = %s",
                (event_name,), fetch_one=True, cursor=cur
            )
            
            if not mapping or not mapping.get('workflow_id'):
                print(f"INFO: No workflow mapped for event '{event_name}'.")
                return

            workflow_id = mapping['workflow_id']
            print(f"INFO: Event '{event_name}' triggered. Starting workflow ID {workflow_id} for {table_name} ID {record_id}.")

            final_context = context_data or {}
            
            # واکشی داده‌های زمینه (Context) برای پیش‌جمعیت کردن فرم
            prepopulation_data = self.get_prepopulation_data(table_name, record_id)
            if prepopulation_data:
                final_context['prepopulation'] = dict(prepopulation_data)

            try:
                # --- *** اصلاح کلیدی اینجاست: افزودن user_id به فراخوانی *** ---
                self.start_workflow_instance(
                    workflow_id, record_id, table_name, cur, user_id, 
                    context_data=final_context if final_context else None
                )
                self._log_atomic(cur, user_id, 'WORKFLOW_TRIGGERED', f"Event:{event_name} started WF:{workflow_id} for {table_name}:{record_id}")
            except ValueError as e:
                print(f"WARNING: Could not start workflow for {table_name} ID:{record_id}. Reason: {e}")
                # به‌روزرسانی وضعیت رکورد مرتبط در صورت بروز خطا
                status_update_query = f"UPDATE {table_name} SET status = 'خطا در شروع فرآیند' WHERE id = %s"
                try:
                    self.execute_query(status_update_query, (record_id,), cursor=cur)
                except Exception as update_err:
                    print(f"Could not update status for failed workflow trigger: {update_err}")
                                    
                                
# در کلاس DB، این متد را جایگزین کنید

    def get_pending_purchase_requests(self, user_role_id: int):
        """درخواست‌های خریدی را برمی‌گرداند که در مرحله‌ای منتظر اقدام نقش کاربر فعلی هستند."""
        if not user_role_id:
            return []
            
        query = """
            SELECT 
                v_pr.id,
                i.name as item_name,
                v_pr.requested_qty,
                u.username as requester_name,
                v_pr.request_date,
                v_pr.status, -- این ستون اکنون از VIEW خوانده می‌شود
                v_pr.notes,
                ws.step_name
            FROM v_purchase_requests_with_status v_pr -- <<< استفاده از VIEW جدید
            JOIN process_instances pi ON v_pr.id = pi.related_record_id AND pi.related_table_name = 'purchase_requests'
            JOIN workflow_steps ws ON pi.current_step_id = ws.id
            JOIN items i ON v_pr.item_id = i.id
            LEFT JOIN users u ON v_pr.requester_id = u.id
            WHERE 
                pi.status = 'IN_PROGRESS'
                AND ws.approver_type = 'ROLE'
                AND ws.approver_role_id = %s
            ORDER BY v_pr.request_date ASC;
        """
        return self.execute_query(query, (user_role_id,))
        
                
# در کلاس DB، این متد را جایگزین کنید
    def process_purchase_request(self, request_id: int, user_id: int, is_approved: bool, reason: str = ""):
        """یک درخواست خرید را برای ارسال به مدیر واحد، تایید اولیه کرده یا به طور کامل رد می‌کند."""
        with self.transaction() as cur:
            cur.execute("SELECT status FROM purchase_requests WHERE id = %s FOR UPDATE", (request_id,))
            request = cur.fetchone()
            if not request or request['status'] != 'در انتظار تایید بازرگانی':
                raise ValueError("این درخواست معتبر نیست یا قبلاً پردازش شده است.")

            if is_approved:
                new_status = 'در انتظار تایید مدیر واحد'
                notes = "درخواست توسط بازرگانی بررسی و جهت تایید به مدیر واحد ارجاع داده شد."
            else:
                new_status = 'رد شده توسط بازرگانی'
                notes = f"درخواست توسط بازرگانی رد شد. دلیل: {reason}"

            cur.execute(
                """UPDATE purchase_requests 
                   SET status = %s, notes = %s, processed_by_id = %s, processed_date = NOW()
                   WHERE id = %s""",
                (new_status, notes, user_id, request_id)
            )
            
            log_action = 'FORWARD_PURCHASE_REQUEST' if is_approved else 'REJECT_PURCHASE_REQUEST'
            self._log_atomic(cur, user_id, log_action, f"PR ID:{request_id}, Reason:{reason}")
                
# در کلاس DB، این متد را با نسخه کامل و اصلاح شده زیر جایگزین کنید
    def get_fifo_pick_plan(self, item_id: int, qty_needed: float, warehouse_name: str, cursor=None) -> list:
        """
        نسخه 2.1 (اصلاح شده):
        - شناسه کالا (item_id) را نیز در خروجی پلن برداشت قرار می‌دهد تا باگ KeyError برطرف شود.
        """
        query = """
            SELECT
                s.id as stock_id, s.qty, s.batch_no, s.expiry_date, s.location_id
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0.001 AND w.name = %s
            ORDER BY s.id ASC;
        """
        available_batches = self.execute_query(query, (item_id, warehouse_name), cursor=cursor)

        def get_readable_names():
            item_name_rec = self.execute_query("SELECT name FROM items WHERE id = %s", (item_id,), fetch_one=True, cursor=cursor)
            item_name = item_name_rec['name'] if item_name_rec else f"کالای ناشناخته (ID={item_id})"
            return item_name, warehouse_name

        if not available_batches:
            item_name, fa_warehouse_name = get_readable_names()
            raise ValueError(f"موجودی کافی برای کالای «{item_name}» در انبار «{fa_warehouse_name}» یافت نشد.")

        total_available = sum(b['qty'] for b in available_batches)
        if total_available < qty_needed:
            item_name, fa_warehouse_name = get_readable_names()
            raise ValueError(f"موجودی کل برای کالای «{item_name}» در انبار «{fa_warehouse_name}» کافی نیست.\nنیاز: {qty_needed}\nموجود: {total_available}")

        picks = []
        remaining_needed = qty_needed
        for batch in available_batches:
            if remaining_needed <= 0: break
            
            pick_qty = min(batch['qty'], remaining_needed)
            
            picks.append({
                'item_id': item_id,  # <<< --- اصلاح کلیدی و نهایی اینجاست ---
                'stock_id': batch['stock_id'], 'location_id': batch['location_id'],
                'batch_no': batch['batch_no'], 'expiry_date': batch['expiry_date'],
                'pick_qty': pick_qty
            })
            
            remaining_needed -= pick_qty
            
        return picks
        
# در کلاس DB، این متد را با نسخه تشخیصی و اصلاح شده زیر جایگزین کنید

    def process_packing_event(self, packing_data: dict, user_id: int) -> int:
        """
        نسخه نهایی، امن و استاندارد شده:
        - تمام مراحل بسته‌بندی را به صورت اتمیک انجام می‌دهد.
        - تمام کوئری‌ها را از طریق execute_query استاندارد اجرا می‌کند.
        - شناسه لاگ حسابرسی (audit_id) را برای اتصال به موتور رویداد برمی‌گرداند.
        """
        print("\n--- STARTING PACKAGING TRANSACTION ---")
        try:
            with self.transaction() as cur:
                bulk_components = packing_data.get('components', [])
                output_product = packing_data['output_product']
                packaging_option_id = packing_data.get('packaging_option_id')
                num_packs_produced = output_product['qty']
                
                prod_loc_id = self.get_production_floor_location()
                if not prod_loc_id:
                    raise ValueError("لوکیشن 'کف کارگاه' تعریف نشده است.")

                # مرحله ۱: کسر موجودی محصولات فله
                print("DEBUG (Packing): Attempting to consume bulk components...")
                for comp_data in bulk_components:
                    print(f"  -> Consuming {comp_data['qty_to_consume']} from delivery_id {comp_data['delivery_id']}")
                    current_record = self.execute_query("SELECT quantity FROM production_deliveries WHERE id = %s AND status = 'تولید شده' FOR UPDATE", (comp_data['delivery_id'],), fetch_one=True, cursor=cur)
                    if not current_record: raise ValueError(f"بچ تولیدی با شناسه {comp_data['delivery_id']} یافت نشد یا وضعیت آن برای مصرف مناسب نیست.")
                    current_qty = current_record['quantity']
                    if comp_data['qty_to_consume'] > current_qty: raise ValueError(f"مقدار مصرفی ({comp_data['qty_to_consume']}) از موجودی بچ ({current_qty}) بیشتر است.")
                    new_qty = current_qty - comp_data['qty_to_consume']
                    new_status = 'مصرف شده' if new_qty < 0.001 else 'تولید شده'
                    self.execute_query("UPDATE production_deliveries SET quantity = %s, status = %s WHERE id = %s", (new_qty, new_status, comp_data['delivery_id']), cursor=cur)
                print("DEBUG (Packing): Bulk components consumed successfully.")

                # مرحله ۲: کسر موجودی لوازم بسته‌بندی
                print("DEBUG (Packing): Attempting to consume packaging supplies...")
                if packaging_option_id:
                    packaging_bom = self.get_bom_for_product(output_product['name'])
                    if packaging_bom:
                        for supply in packaging_bom:
                            total_needed = supply['quantity'] * num_packs_produced
                            supply_item_id = supply['component_item_id']
                            print(f"  -> Consuming {total_needed} of supply '{supply['component_name']}'")
                            # --- *** اصلاح کلیدی: استفاده از رشته متنی صحیح *** ---
                            supply_pick_plan = self.get_fifo_pick_plan(supply_item_id, total_needed, 'Production', cursor=cur)
                            for pick in supply_pick_plan:
                                self._upd_stock(cur, item_id=supply_item_id, location_id=pick['location_id'], qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'], expiry_date=pick['expiry_date'])
                print("DEBUG (Packing): Packaging supplies consumed successfully.")
                
                # مرحله ۳: افزودن محصول نهایی بسته‌بندی شده به جدول stock
                print("DEBUG (Packing): Attempting to add final packaged product to stock...")
                final_packed_item_rec = self.get_item_by_name(output_product['name'])
                if not final_packed_item_rec:
                    raise ValueError(f"کالای نهایی با نام «{output_product['name']}» در سیستم تعریف نشده است.")
                
                self._upd_stock(cur, item_id=final_packed_item_rec['id'], location_id=prod_loc_id, qty_change=abs(output_product['qty']), batch_no=output_product['batch'], expiry_date=output_product.get('expiry_date'))
                print("DEBUG (Packing): Final product added to stock successfully.")

                # مرحله ۴: ثبت لاگ و برگرداندن ID آن
                log_details = json.dumps(packing_data, ensure_ascii=False, default=str)
                audit_id = self._log_atomic(cur, user_id, 'PACKING_EVENT_V6', log_details)
                
                print("--- PACKAGING TRANSACTION COMMITTED SUCCESSFULLY ---")
                return audit_id

        except Exception as e:
            print(f"--- PACKAGING TRANSACTION FAILED AND ROLLED BACK ---")
            print(f"ERROR DETAILS: {e}")
            raise e
                        
                
    def get_items_by_category(self, category_name: str):
        """لیست کالاهای یک دسته با واحد صحیح."""
        return self.execute_query(
            """
            SELECT i.id, i.name, COALESCE(u.name,'') AS unit
            FROM items i
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE i.category = %s
            ORDER BY i.name
            """,
            (category_name,)
        )
    

    def get_next_packed_batch_no(self, sku_prefix: str) -> str:
        """برای یک SKU مشخص، بچ نامبر بسته‌بندی بعدی را تولید می‌کند."""
        now_jalali = jd.datetime.now()
        year_short = str(now_jalali.year)[-2:]
        month_str = f"{now_jalali.month:02d}"
        
        # بچ نامبر نهایی به این شکل خواهد بود: PACK-SKU-YYMM-NNN
        search_pattern = f"PACK-{sku_prefix}-{year_short}{month_str}-%"
        
        # ما در جدول stock دنبال بچ نامبرهای قبلی می‌گردیم
        query = "SELECT MAX(batch_no) as last_batch FROM stock WHERE batch_no LIKE %s"
        last_batch_rec = self.execute_query(query, (search_pattern,), fetch_one=True)
        
        last_batch = last_batch_rec.get('last_batch') if last_batch_rec else None
        
        next_serial = 1
        if last_batch:
            try:
                last_serial_str = last_batch.split('-')[-1]
                next_serial = int(last_serial_str) + 1
            except (IndexError, ValueError):
                next_serial = 1
                
        return f"PACK-{sku_prefix}-{year_short}{month_str}-{next_serial:03d}"
                
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def add_lab_delivery_trans(self, item_id: int, qty: float, batch_no: str, expiry_date: dt.date, notes: str, user_id: int):
        """
        یک تراکنش خروج به آزمایشگاه ثبت کرده و موجودی را از انبار تولید کسر می‌کند.
        این عملیات اتمیک و امن است.
        """
        prod_loc_id = self.get_production_floor_location()
        if not prod_loc_id:
            raise ValueError("انبار 'کف کارگاه' (Production) در سیستم تعریف نشده است.")

        with self.transaction() as cur:
            # گام ۱: کسر موجودی از انبار تولید
            self._upd_stock(cur, item_id, prod_loc_id, -abs(qty), batch_no, expiry_date)

            # گام ۲: ثبت تراکنش خروج به آزمایشگاه
            cur.execute(
                """INSERT INTO trans (item_id, t_type, qty, notes, user_id, src_loc, status, batch_no, expiry_date, t_date, t_no)
                   VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s) RETURNING id""",
                (
                    item_id,
                    TransactionType.EXIT_TO_LAB.value, # <-- اصلاح کلیدی: استفاده از Enum
                    qty,
                    notes,
                    user_id,
                    prod_loc_id,
                    TransactionStatus.APPROVED.value,
                    batch_no,
                    expiry_date,
                    f"LAB-{item_id}-{int(dt.datetime.now().timestamp())}"
                )
            )
            trans_id = cur.fetchone()['id']
            
            # گام ۳: ثبت لاگ حسابرسی
            log_details = f"Sent to lab: trans_id:{trans_id}, item_id:{item_id}, qty:{qty}, batch:{batch_no}"
            self._log_atomic(cur, user_id, 'LAB_DELIVERY', log_details)
            
            return trans_id
                
# در کلاس DB، این متد را با نسخه جدید و امن جایگزین کنید
    def get_next_bulk_batch_no(self, part_type: str) -> str:
        """
        نسخه ۲.۰ (امن و اتمیک):
        با استفاده از یک جدول سکانس در دیتابیس، بچ نامبر بعدی را به صورت کاملاً امن
        و بدون ریسک تکرار (Race Condition) تولید می‌کند.
        """
        if part_type.upper() not in ['R', 'H', 'P']:
            raise ValueError("نوع پارت برای بچ نامبر باید 'R', 'H' یا 'P' باشد.")

        prefix = part_type.upper()
        now_jalali = jd.datetime.now()
        year_short = str(now_jalali.year)[-2:]
        month_str = f"{now_jalali.month:02d}"
        
        # نام سکانس بر اساس پیشوند، سال و ماه ساخته می‌شود تا هر ماه از ۱ شروع شود
        sequence_name = f"batch_{prefix}_{year_short}{month_str}"

        try:
            with self.transaction() as cur:
                # ابتدا بررسی می‌کنیم که آیا سکانس برای این ماه وجود دارد یا خیر
                cur.execute("SELECT 1 FROM sequences WHERE name = %s", (sequence_name,))
                if cur.fetchone() is None:
                    # اگر وجود نداشت، آن را ایجاد می‌کنیم
                    cur.execute("INSERT INTO sequences (name, value) VALUES (%s, 0)", (sequence_name,))

                # حالا شماره بعدی را به صورت اتمیک از دیتابیس درخواست می‌کنیم
                result = self.execute_query(
                    "SELECT get_next_seq(%s) as next_val",
                    (sequence_name,),
                    fetch_one=True,
                    cursor=cur
                )
                next_serial = result['next_val']

            return f"{prefix}-{year_short}{month_str}-{next_serial:03d}"
            
        except Exception as e:
            # در صورت بروز هرگونه خطا، یک پیام واضح برای تحلیل مشکل برمی‌گردانیم
            raise RuntimeError(f"خطا در هنگام تولید شماره بچ از سکانس دیتابیس: {e}")
        
                        
    def get_all_units(self):
            """لیست تمام واحدهای اندازه‌گیری تعریف شده را برمی‌گرداند."""
            return self.execute_query("SELECT id, name, abbreviation FROM units ORDER BY name")

    def add_or_update_unit(self, name: str, abbreviation: str, unit_id: int = None):
        """یک واحد جدید را اضافه یا یک واحد موجود را ویرایش می‌کند."""
        if not name:
            raise ValueError("نام واحد نمی‌تواند خالی باشد.")
        with self.transaction() as cur:
            if unit_id:
                cur.execute("UPDATE units SET name = %s, abbreviation = %s WHERE id = %s", (name, abbreviation, unit_id))
            else:
                cur.execute("INSERT INTO units (name, abbreviation) VALUES (%s, %s) ON CONFLICT (name) DO NOTHING", (name, abbreviation))

# در کلاس DB، این متد را جایگزین کنید

    def delete_unit(self, unit_id: int):
        """یک واحد را به صورت اتمیک حذف می‌کند، به شرطی که توسط هیچ کالایی استفاده نشده باشد."""
        with self.transaction() as cur:
            # ابتدا چک می‌کنیم که آیا این واحد در حال استفاده است یا خیر
            in_use = self.execute_query(
                "SELECT 1 FROM items WHERE unit_id = %s LIMIT 1",
                (unit_id,),
                cursor=cur,
                fetch_one=True
            )
            if in_use:
                raise ValueError("این واحد توسط یک یا چند کالا در حال استفاده است و قابل حذف نیست.")
            
            # اگر استفاده نشده بود، حذف کن
            self.execute_query("DELETE FROM units WHERE id = %s", (unit_id,), cursor=cur)
                                                    
# این متد جدید را به کلاس DB اضافه کنید
    def void_asset_transaction(self, trans_id_to_void: int, user_id: int):
        """یک تراکنش دارایی را باطل کرده و وضعیت دارایی را به حالت قبل برمی‌گرداند."""
        with self.transaction() as cur:
            # گام ۱: تراکنش اصلی را برای ابطال پیدا کن
            cur.execute("SELECT * FROM asset_trans WHERE id = %s FOR UPDATE", (trans_id_to_void,))
            orig_trans = cur.fetchone()

            if not orig_trans: raise ValueError("تراکنش مورد نظر یافت نشد.")
            if orig_trans['status'] == 'باطل شده': raise ValueError("این تراکنش قبلاً باطل شده است.")
            
            asset_id = orig_trans['asset_id']
            
            # گام ۲: پیدا کردن آخرین وضعیت دارایی قبل از این تراکنش
            cur.execute(
                "SELECT t_type FROM asset_trans WHERE asset_id = %s AND id < %s ORDER BY id DESC LIMIT 1",
                (asset_id, trans_id_to_void)
            )
            prev_trans = cur.fetchone()

            previous_status = 'در انبار' # حالت پیش‌فرض اگر هیچ تراکنش قبلی نباشد
            if prev_trans:
                if prev_trans['t_type'] in ["خروج (تعمیرات)", "خروج (پروژه)"]:
                    previous_status = prev_trans['t_type']
                elif prev_trans['t_type'] == "بازگشت به انبار":
                    previous_status = "در انبار"
                elif prev_trans['t_type'] == "اسقاط":
                    previous_status = "اسقاط شده"

            # گام ۳: آپدیت وضعیت خود دارایی به حالت قبلی
            cur.execute("UPDATE assets SET status = %s WHERE id = %s", (previous_status, asset_id))

            # گام ۴: ثبت تراکنش ابطال
            void_note = f"ابطال تراکنش شماره {trans_id_to_void} ({orig_trans['t_type']})"
            cur.execute(
                """INSERT INTO asset_trans (asset_id, t_type, t_no, t_date, notes, user_id, status, voids_trans_id)
                   VALUES (%s, %s, %s, %s, %s, %s, %s, %s)""",
                (asset_id, f"ابطال {orig_trans['t_type']}", orig_trans['t_no'], datetime.now(), void_note, user_id, 'تایید شده', trans_id_to_void)
            )

            # گام ۵: علامت‌گذاری تراکنش اصلی به عنوان "باطل شده"
            cur.execute("UPDATE asset_trans SET status = 'باطل شده' WHERE id = %s", (trans_id_to_void,))

            self._log_atomic(cur, user_id, 'VOID_ASSET_TRANS', f"Voided asset_trans_id: {trans_id_to_void}")
            
            
                                    
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def _seed_initial_permissions_and_roles(self, cur):
        """
        نسخه نهایی و جامع (بازطراحی شده):
        - تمام دسترسی‌های ممکن در سیستم را به صورت گروه‌بندی شده و شفاف تعریف می‌کند.
        - دسترسی‌های جدید برای ماژول‌های فروش و کنترل کیفیت را شامل می‌شود.
        """
        permissions = [
            # --- دسترسی‌های مشاهده صفحات اصلی ---
            ('page:view:dashboard', 'مشاهده داشبورد'),
            ('page:view:items', 'مشاهده کالاها و دارایی‌ها'),
            ('page:view:transactions', 'مشاهده تراکنش‌ها'),
            ('page:view:purchasing', 'مشاهده ماژول بازرگانی'),
            ('page:view:qa', 'مشاهده ماژول تضمین کیفیت (QA)'),
            ('page:view:qc', 'مشاهده ماژول کنترل کیفیت (QC)'),
            ('page:view:sales', 'مشاهده ماژول فروش'),
            ('page:view:production', 'مشاهده مدیریت تولید'),
            ('page:view:inventory', 'مشاهده انبارگردانی'),
            ('page:view:forms', 'مشاهده فرم‌های عمومی'),
            ('page:view:settings', 'مشاهده تنظیمات'),

            # --- دسترسی‌های ماژول کالاها و دارایی‌ها ---
            ('items:create', 'ایجاد کالای جدید'),
            ('items:edit', 'ویرایش کالا'),
            ('items:delete', 'حذف کالا'),
            ('items:view_cost', 'مشاهده ارزش ریالی'),
            ('items:recalc_minmax', 'محاسبه حد سفارش'),
            ('assets:create', 'تعریف دارایی'),
            ('assets:edit', 'ویرایش دارایی'),
            ('assets:delete', 'حذف دارایی'),
            ('assets:transact', 'ثبت تراکنش دارایی'),

            # --- دسترسی‌های ماژول تراکنش‌ها و انبار ---
            ('transactions:create_entry', 'ثبت تراکنش ورود'),
            ('transactions:create_exit', 'ثبت تراکنش خروج'),
            ('transactions:create_other', 'ثبت سایر تراکنش‌ها (ضایعات، برگشت)'),
            ('transactions:transfer', 'انجام انتقال داخلی بین انبارها'),
            ('transactions:void', 'ابطال تراکنش‌های تایید شده'),
            ('transactions:cancel_pending', 'لغو تراکنش‌های در انتظار'),
            ('warehouse:approve_void', 'تایید نهایی ابطال (مدیر انبار)'),
            ('warehouse:fulfill_request', 'رسیدگی به درخواست مواد اولیه/داخلی'),
            ('warehouse:approve_delivery', 'تایید دریافت محصول از تولید'),
            ('warehouse:approve_return', 'تایید برگشت مواد از تولید'),

            # --- دسترسی‌های ماژول بازرگانی ---
            ('purchasing:manage_suppliers', 'مدیریت تامین‌کنندگان'),
            ('purchasing:create_request', 'ایجاد درخواست خرید'),
            ('purchasing:manage_quotes', 'مدیریت استعلام‌ها و پیشنهاد قیمت'),
            ('purchasing:create_po', 'ایجاد سفارش خرید (PO)'),
            ('purchasing:receive_po', 'ثبت رسید سفارش خرید'),

            # --- دسترسی‌های ماژول فروش (جدید) ---
            ('sales:create_order', 'ثبت سفارش فروش جدید'),
            ('sales:manage_customers', 'مدیریت مشتریان'),
            ('sales:start_proforma_process', 'شروع فرآیند پیش‌فاکتور'),
            ('sales:export_pdf', 'دریافت خروجی PDF پیش‌فاکتور'),
            ('sales:inquire_qc', 'استعلام سوابق کیفی بچ‌ها'),

            # --- دسترسی‌های ماژول تضمین کیفیت (QA) ---
            ('qa:manage_workflows', 'طراحی و مدیریت فرآیندها'),
            ('qa:approve_workflows', 'تایید نهایی و ابلاغ فرآیندها (مدیرعامل)'),
            ('qa:manage_forms', 'طراحی و مدیریت فرم‌های QA'),
            ('qa:manage_org_chart', 'مدیریت چارت سازمانی'),
            ('qa:map_events', 'اتصال فرآیندها به رویدادها و عملیات'),

            # --- دسترسی‌های ماژول کنترل کیفیت (QC) (جدید) ---
            ('qc:manage_quarantine', 'تایید یا رد کیفی کالاهای ورودی'),
            ('qc:resolve_nonconforming', 'تعیین تکلیف کالاهای نامنطبق (مرجوعی/ضایعات)'),
            ('qc:view_history', 'مشاهده و جستجو در بایگانی گزارش‌های کیفی'),

            # --- دسترسی‌های ماژول تولید ---
            ('production:manage_recipes', 'مدیریت فرمول‌های ساخت (BOM)'),
            ('production:report', 'ثبت گزارش تولید (محصول فله)'),
            ('production:packing', 'انجام عملیات بسته‌بندی (محصول نهایی)'),
            ('production:request_materials', 'ثبت درخواست مواد از انبار'),
            ('production:approve_transfer', 'تایید دریافت مواد اولیه از انبار'),
            ('production:void_production', 'ابطال بچ تولید یا عملیات بسته‌بندی'),

            # --- دسترسی‌های ماژول انبارگردانی ---
            ('inventory:start_count', 'شروع انبارگردانی جدید'),
            ('inventory:perform_count', 'انجام شمارش و ثبت مقادیر'),
            ('inventory:review_count', 'بازبینی مغایرت‌ها و تایید نهایی'),

            # --- دسترسی‌های ماژول تنظیمات ---
            ('settings:manage_users', 'مدیریت کاربران و نقش‌ها'),
            ('settings:manage_locations', 'مدیریت انبارها و لوکیشن‌ها'),
            ('settings:manage_units', 'مدیریت واحدهای شمارش'),
            ('settings:manage_app', 'تغییر تنظیمات کلی برنامه'),
            ('settings:backup_restore', 'پشتیبان‌گیری و بازیابی اطلاعات'),
            ('settings:factory_reset', 'ریست کامل برنامه (بسیار خطرناک)'),
        ]
        
        cur.executemany("INSERT INTO permissions (code, description) VALUES (%s, %s) ON CONFLICT (code) DO NOTHING", permissions)
        cur.execute("INSERT INTO roles (name, dashboard_type) VALUES ('Admin', 'ADMIN') ON CONFLICT (name) DO NOTHING")
        cur.execute("SELECT id FROM roles WHERE name = 'Admin'")
        admin_role_id_rec = cur.fetchone()
        if admin_role_id_rec:
            admin_role_id = admin_role_id_rec['id']
            cur.execute("SELECT id FROM permissions")
            all_perm_ids = [p['id'] for p in cur.fetchall()]
            perms_to_insert = [(admin_role_id, perm_id) for perm_id in all_perm_ids]
            if perms_to_insert:
                cur.execute("DELETE FROM role_permissions WHERE role_id = %s", (admin_role_id,))
                cur.executemany("INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s) ON CONFLICT DO NOTHING", perms_to_insert)
        
        admin_pass_hash = hash_password('admin')
        cur.execute("INSERT INTO users(username, passhash, role_id) VALUES (%s, %s, %s) ON CONFLICT (username) DO NOTHING", 
                    ('admin', admin_pass_hash, admin_role_id if admin_role_id_rec else None))
        
                    
        

        
                    
                        
                                                                                                                                                        
    def get_warehouse_default_location(self, warehouse_name: str):
            """ID لوکیشن پیش‌فرض یک انبار مشخص را برمی‌گرداند."""
            query = """SELECT l.id FROM locations l JOIN warehouses w ON l.warehouse_id = w.id WHERE w.name = %s ORDER BY l.id LIMIT 1;"""
            res = self.execute_query(query, (warehouse_name,), fetch_one=True)
            return res['id'] if res else None
    

    def get_stock_for_warehouse(self, warehouse_name: str):
        """موجودی همهٔ کالاها در یک انبار مشخص به‌همراه واحد و شناسهٔ والد."""
        query = """
            SELECT 
                i.id          AS item_id,
                i.name,
                i.category,
                i.parent_item_id,
                COALESCE(u.name,'') AS unit,
                i.min_qty,
                s.batch_no,
                SUM(s.qty)   AS total_qty,
                MIN(s.expiry_date) AS expiry_date
            FROM stock s
            JOIN items i       ON i.id = s.item_id
            LEFT JOIN units u  ON u.id = i.unit_id
            JOIN locations l   ON l.id = s.location_id
            JOIN warehouses w  ON w.id = l.warehouse_id
            WHERE w.name = %s
            GROUP BY i.id, i.name, i.category, i.parent_item_id, u.name, i.min_qty, s.batch_no
            ORDER BY i.name
        """
        return self.execute_query(query, (warehouse_name,))
        
# این دو متد جدید را به کلاس DB اضافه کنید

    def get_pending_returns_from_production(self):
        """تمام تراکنش‌های برگشت از تولید که منتظر تایید انبار هستند را برمی‌گرداند."""
        query = """
            SELECT
                t.id, i.name as item_name, t.qty, t.notes, u.username as requester_name, 
                t.t_date, t.batch_no
            FROM trans t
            JOIN items i ON t.item_id = i.id
            JOIN users u ON t.user_id = u.id
            WHERE t.t_type = 'برگشت از تولید' AND t.status = 'در انتظار تایید انبار'
            ORDER BY t.id ASC;
        """
        return self.execute_query(query)

    def approve_material_return(self, trans_id: int, approver_user_id: int, dest_loc_id: int):
        with self.transaction() as cur:
            cur.execute("SELECT * FROM trans WHERE id = %s AND status = 'در انتظار تایید انبار' FOR UPDATE", (trans_id,))
            trans_rec = cur.fetchone()
            if not trans_rec:
                raise ValueError("این درخواست برگشت معتبر نیست یا قبلاً پردازش شده است.")

            item_id     = trans_rec['item_id']
            qty         = trans_rec['qty']
            src_loc     = trans_rec['src_loc']
            batch_no    = trans_rec['batch_no']
            expiry_date = trans_rec.get('expiry_date')

            self._upd_stock(cur, item_id, src_loc,      -abs(qty), batch_no, expiry_date)
            self._upd_stock(cur, item_id, dest_loc_id,   abs(qty), batch_no, expiry_date)

            cur.execute(
                "UPDATE trans SET status = 'تایید شده', approved_by = %s, approved_at = NOW(), dest_loc = %s WHERE id = %s",
                (approver_user_id, dest_loc_id, trans_id)
            )
            self._log_atomic(cur, approver_user_id, 'APPROVE_RETURN',
                            f"Approved return for trans_id:{trans_id} -> dest_loc:{dest_loc_id}")

        self.trigger_event(
            event_name='STOCK_TRANSACTION_APPROVED',
            record_id=trans_id,
            table_name='trans',
            user_id=approver_user_id,
            context_data={
                't_type': 'برگشت',
                'item_id': item_id,
                'qty': qty,
                'src_loc': src_loc,
                'dest_loc': dest_loc_id,
                'batch_no': batch_no,
                'expiry_date': str(expiry_date) if expiry_date else None
            }
        )

                                                        
# در کلاس DB، این متد را با نسخه استاندارد زیر جایگزین کنید

    def get_setting(self, key: str, default: str = None):
        """یک مقدار را از جدول تنظیمات می‌خواند."""
        query = "SELECT value FROM app_settings WHERE key = %s"
        res = self.execute_query(query, (key,), fetch_one=True)
        return res['value'] if res else default
    
    
    def set_setting(self, key: str, value: str):
            """
            نسخه دیباگ نهایی برای تست جداگانه دستورات UPDATE و INSERT.
            """
            with self.transaction() as cur:
                # گام ۱: ابتدا تلاش می‌کنیم ردیف موجود را UPDATE کنیم
                print(f"DEBUG: Attempting to UPDATE key '{key}' to value '{value}'")
                cur.execute("UPDATE app_settings SET value = %s WHERE key = %s", (str(value), key))
                
                # گام ۲: بررسی می‌کنیم که آیا ردیفی آپدیت شد یا خیر
                if cur.rowcount > 0:
                    print(f"DEBUG: UPDATE successful. {cur.rowcount} row(s) affected.")
                else:
                    # گام ۳: اگر هیچ ردیفی آپدیت نشد، یعنی کلید وجود نداشته، پس آن را INSERT می‌کنیم
                    print(f"DEBUG: UPDATE affected 0 rows. Key '{key}' not found or no permission. Attempting to INSERT.")
                    try:
                        cur.execute(
                            "INSERT INTO app_settings (key, value) VALUES (%s, %s)",
                            (key, str(value))
                        )
                        print(f"DEBUG: INSERT successful for key '{key}'.")
                    except Exception as e:
                        print(f"DEBUG: INSERT failed for key '{key}'. Error: {e}")

    def add_file(self, trans_id: int, path: str):
            """یک فایل پیوست به یک تراکنش با استفاده از رویه استاندارد اضافه می‌کند."""
            with self.transaction() as cur:
                cur.execute("INSERT INTO trans_files(trans_id, path) VALUES (%s,%s)",
                            (trans_id, path))

    def list_files(self, trans_id: int):
        """لیست فایل‌های پیوست یک تراکنش را با استفاده از رویه استاندارد برمی‌گرداند."""
        return self.execute_query("SELECT id, path FROM trans_files WHERE trans_id=%s", (trans_id,))

    def delete_file(self, file_id: int):
        """یک فایل پیوست را با استفاده از رویه استاندارد حذف می‌کند."""
        with self.transaction() as cur:
            cur.execute("DELETE FROM trans_files WHERE id=%s", (file_id,))
            
    def _log(self, user_id: int, act: str, det: str):
        """
        وقایع را با استفاده از user_id عددی و در یک تراکنش امن و مستقل ثبت می‌کند.
        """
        # استفاده از ابزار استاندارد برای ثبت یک لاگ به صورت اتمیک
        with self.transaction() as cur:
            cur.execute('INSERT INTO audit(stamp, user_id, action, details) VALUES (%s, %s, %s, %s)',
                        (datetime.now(dt.timezone.utc), user_id, act, det))
        
    # در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def verify(self, u, p):
        """
        کاربر را تایید می‌کند. اگر هش قدیمی بود، آن را به صورت خودکار به فرمت جدید ارتقا می‌دهد.
        """
        from passlib.exc import UnknownHashError

        with self.transaction() as cur:
            # گام ۱: کاربر را فقط بر اساس نام کاربری پیدا کن
            cur.execute(
                """SELECT u.id, u.username, u.passhash, r.id as role_id, r.name as role_name, r.dashboard_type
                FROM users u
                LEFT JOIN roles r ON u.role_id = r.id
                WHERE u.username=%s""",
                (u,))
            user_info = cur.fetchone()

            if not user_info:
                return None

            # گام ۲: تلاش برای بررسی رمز با روش جدید و امن
            try:
                if verify_password(p, user_info['passhash']):
                    # اگر موفق بود، یعنی هش از قبل به‌روز است.
                    pass
                else:
                    # اگر موفق نبود، یعنی رمز اشتباه است.
                    return None
            except UnknownHashError:
                # اگر با خطای UnknownHashError مواجه شدیم، یعنی هش از نوع قدیمی sha256 است
                print(f"INFO: Old hash format detected for user '{u}'. Attempting legacy verification...")
                if _hash_legacy(p) == user_info['passhash']:
                    # رمز با روش قدیمی صحیح است. حالا آن را به فرمت جدید آپدیت می‌کنیم.
                    print(f"INFO: Legacy password verified. Upgrading hash for user '{u}'...")
                    new_hash = hash_password(p)
                    cur.execute("UPDATE users SET passhash = %s WHERE id = %s", (new_hash, user_info['id']))
                else:
                    # رمز با روش قدیمی هم اشتباه است.
                    return None
            
            # (بقیه کد برای خواندن دسترسی‌ها بدون تغییر است)
            result = dict(user_info)
            if not user_info['role_id']:
                result['permissions'] = []
                result['dashboards'] = []
            else:
                role_id = user_info['role_id']
                cur.execute(
                    "SELECT p.code FROM permissions p JOIN role_permissions rp ON p.id = rp.permission_id WHERE rp.role_id = %s",
                    (role_id,))
                result['permissions'] = [p['code'] for p in cur.fetchall()]
                
                cur.execute(
                    "SELECT dashboard_key FROM role_dashboards WHERE role_id = %s",
                    (role_id,)
                )
                result['dashboards'] = [d['dashboard_key'] for d in cur.fetchall()]

            return result    
                                                                                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    # در کلاس DB، این متد را با نسخه جدید جایگزین کنید
    def add_trans(self, tup, usr):
        """
        نسخه اصلاح شده و ایمن: این تابع منسوخ شده و تمام درخواست‌ها را به
        تابع جدید و قدرتمند add_trans_extended هدایت می‌کند.
        FIX: این تابع حالا به جای تاپل، یک دیکشنری استاندارد می‌سازد.
        """
        print("WARNING: Deprecated function 'add_trans' was called. Redirecting to 'add_trans_extended'.")
        
        item_id = tup[0]
        # پیدا کردن یک لوکیشن پیش‌فرض برای کالا
        loc_id_res = self.execute_query("SELECT default_loc FROM items WHERE id=%s", (item_id,), fetch_one=True)
        loc_id = loc_id_res['default_loc'] if loc_id_res and loc_id_res['default_loc'] else self.get_warehouse_default_location('Main')

        # ساخت دیکشنری کامل به جای تاپل ناقص
        trans_data = {
            'item_id': item_id,
            't_type': tup[1],
            'doc_no': tup[2],
            't_date': tup[3],
            'qty': tup[4],
            'notes': tup[5],
            'attach_path': tup[6] if len(tup) > 6 else '',
            'loc_id': loc_id,
            'batch_no': 'LEGACY_DATA', # <<-- اصلاح کلیدی: بچ نامبر واضح‌تر
            'expiry_date': None
        }
        # ارسال دیکشنری به تابع جدید
        self.add_trans_extended(trans_data, usr)
    

    
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def delete_user(self, username: str):
        """یک کاربر را بر اساس نام کاربری به صورت اتمیک حذف می‌کند."""
        if username.lower() == 'admin':
            raise ValueError("کاربر 'admin' به دلایل امنیتی قابل حذف نیست.")
        
        with self.transaction() as cur:
            # استفاده از ابزار استاندارد execute_query برای هماهنگی کامل
            self.execute_query("DELETE FROM users WHERE username = %s", (username,), cursor=cur)
                            
    # جایگزین شود
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def min_alert(self):
        """هشدار کسری موجودی را بر اساس مجموع موجودی واقعی در تمام انبارهای غیرتولیدی محاسبه می‌کند."""
        query = """
            SELECT i.name
            FROM items i
            LEFT JOIN (
                SELECT s.item_id, SUM(s.qty) as total_qty
                FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE w.name != 'Production'
                GROUP BY s.item_id
            ) sq ON i.id = sq.item_id
            WHERE COALESCE(sq.total_qty, 0) < i.min_qty AND i.min_qty > 0;
        """
        rows = self.execute_query(query)
        return [r['name'] for r in rows] if rows else []
    
    def exp_alert(self):
            """
            نسخه نهایی: هشدار کالاهای در شرف انقضا را بر اساس بازه زمانی تعریف شده
            در جدول app_settings محاسبه می‌کند.
            """
            # خواندن تنظیمات از دیتابیس با یک مقدار پیش‌فرض امن
            days_str = self.get_setting('expiry_alert_days', '30')
            try:
                days = int(days_str)
            except (ValueError, TypeError):
                days = 30 # اگر مقدار ذخیره شده در دیتابیس معتبر نبود، از ۳۰ استفاده کن

            query = """
                SELECT DISTINCT 
                    i.name,
                    s.batch_no,
                    s.expiry_date
                FROM stock s
                JOIN items i ON s.item_id = i.id
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE 
                    w.name = 'Main' 
                    AND s.qty > 0 
                    AND s.expiry_date IS NOT NULL 
                    AND s.expiry_date BETWEEN NOW() AND NOW() + INTERVAL '%s day'
                ORDER BY s.expiry_date ASC;
            """
            return self.execute_query(query, (days,))
        
    def get_items_count_by_category(self, category_name: str) -> int:
        """تعداد کل کالاها در یک دسته‌بندی (با نادیده‌گرفتن فاصله و نیم‌فاصله)"""
        query = """
            SELECT COUNT(id) AS total
            FROM items
            WHERE REPLACE(REPLACE(COALESCE(category,''), E'\u200c',''), ' ','')
                = REPLACE(REPLACE(%s, E'\u200c',''), ' ','')
        """
        result = self.execute_query(query, (category_name,), fetch_one=True)
        return result['total'] if result else 0


    def items_brief(self, category_filter: str, limit: int, offset: int):
        """
        برگرداندن لیست صفحه‌بندی‌شده‌ی اقلامِ یک دسته (فاصله/نیم‌فاصله نادیده گرفته می‌شود)
        + اتصال اطلاعات واحد و موجودی غیرتولیدی.
        """
        query = """
        WITH paged_items AS (
            SELECT id, unit_id, parent_item_id, name, category, cost, min_qty, max_qty,
                supplier, ent_date, notes, reporting_group, sku, is_packed,
                is_parent_product, net_weight
            FROM items
            WHERE REPLACE(REPLACE(COALESCE(category,''), E'\u200c',''), ' ','')
                = REPLACE(REPLACE(%s, E'\u200c',''), ' ','')
            ORDER BY name
            LIMIT %s OFFSET %s
        )
        SELECT
            pi.*,
            u.name AS unit,
            p.name AS parent_name,
            COALESCE(s.non_prod_qty, 0) AS non_prod_qty
        FROM paged_items pi
        LEFT JOIN units u ON pi.unit_id = u.id
        LEFT JOIN items p ON pi.parent_item_id = p.id
        LEFT JOIN (
            SELECT s.item_id, SUM(s.qty) AS non_prod_qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE w.name != 'Production'
            GROUP BY s.item_id
        ) s ON pi.id = s.item_id
        ORDER BY pi.name;
        """
        return self.execute_query(query, (category_filter, limit, offset))

    def get_all_items_for_selection(self):
        """
        یک لیست بهینه شده از تمام کالاها را برای استفاده در لیست‌های کشویی برمی‌گرداند.
        این متد جایگزین فراخوانی‌های ناهماهنگ به items_brief می‌شود.
        """
        query = """
            SELECT
                i.id, i.name, i.category, i.unit_id, i.is_parent_product, i.parent_item_id,
                u.name as unit,
                COALESCE(s.non_prod_qty, 0) as non_prod_qty
            FROM items i
            LEFT JOIN units u ON i.unit_id = u.id
            LEFT JOIN (
                SELECT
                    s.item_id,
                    SUM(s.qty) AS non_prod_qty
                FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE w.name != 'Production'
                GROUP BY s.item_id
            ) s ON i.id = s.item_id
            ORDER BY i.name;
        """
        return self.execute_query(query)
            
    
# در کلاس DB، این متد را با نسخه اصلاح شده زیر جایگزین کنید
    def loc_label(self, loc_id):
        """
        یک لیبل خوانا برای لوکیشن بر اساس ID آن برمی‌گرداند.
        نسخه اصلاح شده: از متد استاندارد execute_query استفاده می‌کند.
        """
        if not loc_id:
            return ''
        
        query = """
            SELECT w.name || '|' || rack || '-' || shelf || '-' || bin AS lbl
            FROM locations l
            JOIN warehouses w ON w.id = l.warehouse_id
            WHERE l.id = %s
        """
        # به جای باز کردن کانکشن دستی، از ابزار استاندارد استفاده می‌کنیم
        row = self.execute_query(query, (loc_id,), fetch_one=True)
        return row['lbl'] if row else ''
        
    def stock_breakdown(self, item_id: int):
        """
        جزئیات موجودی آیتم در همه لوکیشن‌ها + واحد کالا.
        - ستون loc برای سازگاری با UI برگردانده می‌شود (label کامل لوکیشن).
        """
        query = """
            SELECT
                s.id,
                s.location_id,
                w.name AS warehouse_name,
                l.rack, l.shelf, l.bin,
                -- برچسب سازگار با UI
                (COALESCE(w.name, '') || ' / ' ||
                COALESCE(l.rack, '-') || '-' ||
                COALESCE(l.shelf, '-') || '-' ||
                COALESCE(l.bin, '-')) AS loc,
                s.batch_no,
                s.expiry_date,
                s.qty,
                s.status,
                s.received_at,
                s.last_moved_at,
                COALESCE(u.name, '') AS unit
            FROM stock s
            JOIN items i        ON i.id = s.item_id
            LEFT JOIN units u   ON u.id = i.unit_id
            LEFT JOIN locations l ON l.id = s.location_id
            LEFT JOIN warehouses w ON w.id = l.warehouse_id
            WHERE s.item_id = %s
            ORDER BY COALESCE(s.expiry_date, DATE '9999-12-31'),
                    w.name, l.rack, l.shelf, l.bin
        """
        return self.execute_query(query, (item_id,))

                                    
    def items_in_location(self, loc_id: int):
        """کالاهای موجود در یک لوکیشن خاص را برمی‌گرداند."""
        query = """
            SELECT  i.name, s.qty, COALESCE(u.name,'') AS unit
            FROM    stock s
            JOIN    items i ON i.id = s.item_id
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE   s.location_id = %s AND s.qty > 0
            ORDER BY i.name
        """
        return self.execute_query(query, (loc_id,))
    
    def trans_recent(self, limit=40):
        """آخرین تراکنش‌ها را برای نمایش در داشبورد برمی‌گرداند."""
        query = '''SELECT t.id,i.name,t.t_type,t.qty,t.t_date
                   FROM trans t JOIN items i ON t.item_id=i.id
                   ORDER BY t.id DESC LIMIT %s'''
        return self.execute_query(query, (limit,))
        

    def list_assets_in_stock(self):
        """فقط دارایی‌هایی را برمی‌گرداند که وضعیتشان 'در انبار' است."""
        query = "SELECT * FROM assets WHERE status='در انبار' ORDER BY name"
        return self.execute_query(query)
    

    def asset_trans_recent(self, limit: int = 100):
        """
        نسخه نهایی و کامل: جزئیات تراکنش‌های دارایی را به همراه نام کاربر و تعداد پیوست‌ها برمی‌گرداند.
        """
        query = """
        SELECT  at.id,
                a.code || ' – ' || a.name AS asset_lbl,
                at.t_type,
                at.t_date,
                at.t_no,
                at.notes,
                u.username as user_name,
                (SELECT COUNT(*) FROM asset_trans_files WHERE asset_trans_id = at.id) as files_count
        FROM    asset_trans AS at
        JOIN    assets      AS a  ON a.id = at.asset_id
        LEFT JOIN users     AS u  ON u.id = at.user_id
        ORDER BY at.id DESC
        LIMIT   %s
        """
        return self.execute_query(query, (limit,))
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_consumption(self, item_id: int, include_asset_exit: bool = True):
            """
            نسخه نهایی و بهینه‌سازی شده (V5.2):
            - تابع TRIM از کوئری حذف شد تا به PostgreSQL اجازه استفاده از ایندکس را بدهد.
            """
            import pandas as pd
            
            days_back = int(self.get_setting('reorder_analysis_days', '90'))
            
            out_types = ['خروج', 'خروج به تولید', 'ضایعات', 'کسری انبارگردانی', 'خروج دارایی']
            if not include_asset_exit:
                out_types.remove('خروج دارایی')

            placeholders = ','.join(['%s'] * len(out_types))
            
            # --- *** اصلاح کلیدی: حذف TRIM() از دو خط زیر *** ---
            q = f"""
                SELECT  t.t_date::date AS d, SUM(t.qty) AS total_out
                FROM    trans t
                WHERE   t.item_id = %s
                AND     t.t_type IN ({placeholders})
                AND     t.status = 'تایید شده' 
                AND     t.t_date IS NOT NULL 
                AND     t.t_date >= NOW() - (%s * INTERVAL '1 day')
                GROUP BY d
                ORDER BY d;
            """
            
            params = (item_id, *out_types, days_back)
            rows = self.execute_query(q, params)

            if not rows:
                return pd.Series(dtype=float)

            df = pd.DataFrame(rows, columns=['date', 'qty'])
            df['qty'] = df['qty'].abs()
            df['date'] = pd.to_datetime(df['date'])
            
            end_date = datetime.now().date()
            full_range = pd.date_range(end=end_date, periods=days_back, freq='D')
            
            ser = df.set_index('date')['qty']
            ser = ser.reindex(full_range, fill_value=0)
            
            return ser
                                            
# این متد جدید را به کلاس DB اضافه کنید
    def get_delivery_details(self, delivery_id: int):
        """جزئیات یک رکورد خاص از جدول production_deliveries را برمی‌گرداند."""
        return self.execute_query(
            "SELECT * FROM production_deliveries WHERE id = %s",
            (delivery_id,),
            fetch_one=True
        )
        
                
                    
    def calc_min_max(self, item_id: int, lead_days: int) -> bool:
            """نسخه دیباگ برای چاپ جزئیات محاسبات آماری."""
            import pandas as pd
            from math import sqrt, isnan
            print(f"\n[DEBUG] --- Running calc_min_max for item_id: {item_id} ---")

            service_level = float(self.get_setting('reorder_service_level', '0.95'))
            max_multiplier = float(self.get_setting('reorder_max_multiplier', '1.5'))
            print(f"[DEBUG] Settings: service_level={service_level}, max_multiplier={max_multiplier}")

            ser = self.get_consumption(item_id)
            
            if ser.empty or ser.sum() == 0:
                print("[DEBUG] >>> Calculation stopped: Consumption series is empty or sum is zero.")
                return False

            mu, sigma = ser.mean(), ser.std()
            print(f"[DEBUG] Stats: mean(mu)={mu:.4f}, std_dev(sigma)={sigma:.4f}")
            
            if isnan(mu) or isnan(sigma) or sigma == 0:
                min_q = int(round(mu * lead_days))
                print(f"[DEBUG] Calculated (simple): min_q={min_q}")
            else:
                z = 1.65 if service_level >= 0.95 else (1.28 if service_level >= 0.90 else 1.04)
                safety = z * sigma * sqrt(lead_days)
                min_q = int(round((mu * lead_days) + safety))
                print(f"[DEBUG] Calculated (statistical): z={z}, safety_stock={safety:.2f}, min_q={min_q}")
            
            max_q = int(round(min_q * max_multiplier))
            print(f"[DEBUG] Final calculated values: Min={min_q}, Max={max_q}")
            
            if min_q > 0 or max_q > 0:
                print("[DEBUG] >>> Updating database with new values.")
                with self.transaction() as cur:
                    cur.execute("""UPDATE items SET min_qty = %s, max_qty = %s WHERE id = %s""",
                                (min_q, max_q, item_id))
                return True
            
            print("[DEBUG] >>> Calculation result is zero, no update performed.")
            return False
                
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def add_warehouse(self, name: str):
        """
        یک انبار جدید اضافه کرده یا ID انبار موجود را برمی‌گرداند.
        نسخه نهایی: از context manager برای تضمین اتمی بودن عملیات استفاده می‌کند.
        """
        with self.transaction() as cur:
            # دستور ON CONFLICT DO NOTHING تضمین می‌کند که در صورت وجود انبار، خطایی رخ نمی‌دهد
            self.execute_query(
                "INSERT INTO warehouses(name) VALUES (%s) ON CONFLICT (name) DO NOTHING",
                (name,),
                cursor=cur
            )
            # همیشه ID انبار با نام مشخص شده را برمی‌گردانیم (چه جدید باشد چه از قبل موجود)
            result = self.execute_query(
                "SELECT id FROM warehouses WHERE name=%s",
                (name,),
                fetch_one=True,
                cursor=cur
            )
            return result['id'] if result else None
        
# در کلاس DB، این متد را جایگزین کنید
    def add_location(self, wh_id: int, rack: str, shelf: str, bin_: str):
        """
        یک لوکیشن جدید اضافه کرده و ID آن را برمی‌گرداند.
        نسخه نهایی: از ابزار استاندارد execute_query و مدیریت خطای شفاف استفاده می‌کند.
        """
        query = """
            INSERT INTO locations(warehouse_id, rack, shelf, bin)
            VALUES (%s, %s, %s, %s)
            RETURNING id
        """
        # اگر ورودی برای طبقه خالی بود، مقدار پیش‌فرض '1' را در نظر می‌گیریم
        params = (wh_id, rack, shelf, bin_ if bin_ else '1')
        
        try:
            # این یک عملیات واحد است، پس مستقیماً از execute_query استفاده می‌کنیم.
            result = self.execute_query(query, params, fetch_one=True)
            return result['id'] if result else None
            
        except psycopg2.errors.UniqueViolation:
            # این خطا زمانی رخ می‌دهد که لوکیشن از قبل وجود داشته باشد.
            # یک خطای خواناتر به لایه‌های بالاتر (UI) ارسال می‌کنیم تا به کاربر نمایش داده شود.
            raise ValueError(f"لوکیشن '{rack}-{shelf}-{bin_ or '1'}' از قبل در این انبار وجود دارد.")
        except Exception as e:
            # برای سایر خطاهای پیش‌بینی نشده
            print(f"ERROR in add_location: {e}")
            raise
                    
                        

    def get_item_locations_excluding_warehouse(self, item_id: int, warehouse_to_exclude: str):
        """لیست لوکیشن‌هایی که یک کالا موجودی دارد را به جز در یک انبار خاص، برمی‌گرداند."""
        query = """
            SELECT l.id, w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label, s.qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0 AND w.name != %s
            ORDER BY w.name, l.rack, l.shelf, l.bin;
        """
        return self.execute_query(query, (item_id, warehouse_to_exclude))
                                                
    def list_locations(self, include_warehouses: list = None, exclude_warehouses: list = None):
        """
        نسخه ساده و اولیه: لیست تمام لوکیشن‌ها را برمی‌گرداند.
        """
        query = """
            SELECT l.id, w.name AS wh, l.rack, l.shelf, l.bin,
                   w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label
            FROM locations l
            JOIN warehouses w ON w.id = l.warehouse_id
        """
        params = []
        conditions = []

        if include_warehouses:
            placeholders = ','.join(['%s'] * len(include_warehouses))
            conditions.append(f"w.name IN ({placeholders})")
            params.extend(include_warehouses)
        
        if exclude_warehouses:
            placeholders = ','.join(['%s'] * len(exclude_warehouses))
            conditions.append(f"w.name NOT IN ({placeholders})")
            params.extend(exclude_warehouses)

        if conditions:
            query += " WHERE " + " AND ".join(conditions)
        
        query += " ORDER BY w.name, l.rack, l.shelf, l.bin;"
        
        return self.execute_query(query, tuple(params))
        
            
            
    def add_or_update_location(self, loc_data: dict, loc_id: int = None):
        """یک لوکیشن جدید را با تمام جزئیات گرافیکی اضافه یا ویرایش می‌کند."""
        with self.transaction() as cur:
            wh_id = self.add_warehouse(loc_data['wh_name'])
            params = {**loc_data, 'wh_id': wh_id, 'id': loc_id, 'bin': loc_data.get('bin') or '1'}

            if loc_id: # حالت ویرایش
                query = """
                    UPDATE locations SET
                        warehouse_id = %(wh_id)s, rack = %(rack)s, shelf = %(shelf)s, bin = %(bin)s,
                        aisle_sequence = %(aisle_sequence)s, rack_sequence = %(rack_sequence)s, shelf_sequence = %(shelf_sequence)s,
                        pos_x = %(pos_x)s, pos_y = %(pos_y)s, width = %(width)s, height = %(height)s
                    WHERE id = %(id)s
                """
            else: # حالت افزودن
                query = """
                    INSERT INTO locations (warehouse_id, rack, shelf, bin, aisle_sequence, rack_sequence, shelf_sequence, pos_x, pos_y, width, height)
                    VALUES (%(wh_id)s, %(rack)s, %(shelf)s, %(bin)s, %(aisle_sequence)s, %(rack_sequence)s, %(shelf_sequence)s, %(pos_x)s, %(pos_y)s, %(width)s, %(height)s)
                """
            try:
                self.execute_query(query, params, cursor=cur)
            except psycopg2.errors.UniqueViolation:
                raise ValueError("لوکیشنی با این مشخصات (انبار، راهرو، قفسه، طبقه) از قبل وجود دارد.")
                        
                                                
                
    def stock_qty(self, item_id: int, loc_id: int, batch_no: str):
        """موجودی یک بچ مشخص از یک کالا در یک لوکیشن خاص را برمی‌گرداند."""
        query = 'SELECT qty FROM stock WHERE item_id=%s AND location_id=%s AND batch_no=%s'
        # استفاده از ابزار استاندارد برای کوتاهی و پایداری
        row = self.execute_query(query, (item_id, loc_id, batch_no), fetch_one=True)
        return row['qty'] if row else 0
                    
    def _upd_stock(self, cur, item_id: int, location_id: int, qty_change: float,
                batch_no: str, expiry_date: dt.date = None, status: str = None,
                return_stock_id: bool = False, entry_status: str = 'تایید شده',
                source_po_item_id: int = None):
        """
        Policy-aware:
        - مصرف از قرنطینه به‌صورت پیش‌فرض ممنوع است و از طریق app_settings قابل تنظیم است:
        key = 'allow_quarantine_consumption'  (true/false)
        - سایر رفتارهای قبلی حفظ شده: timestamps, entry_value, source_po_item_id, به‌روزرسانی status هنگام افزایش.
        """
        import datetime as _dt
        if not batch_no:
            raise ValueError("برای تغییر موجودی، بچ نامبر باید مشخص باشد.")
        if not location_id:
            raise ValueError("لوکیشن نامعتبر است.")

        stock_id_to_return = None
        now_ts = _dt.datetime.now(_dt.timezone.utc)
        final_status = status or entry_status or 'تایید شده'

        # قیمت واحد جهت محاسبه entry_value (فقط برای ورودی)
        item_cost_rec = self.execute_query("SELECT cost FROM items WHERE id=%s", (item_id,), fetch_one=True, cursor=cur)
        item_cost = (item_cost_rec.get('cost', 0.0) if item_cost_rec else 0.0)
        delta_value = item_cost * (qty_change if qty_change > 0 else 0.0)

        if qty_change > 0:
            # اگر ردیف موجودی هست: افزایش + به‌روزرسانی وضعیت و زمان‌ها
            existing = self.execute_query(
                """SELECT id FROM stock
                WHERE item_id=%s AND location_id=%s AND batch_no=%s
                    AND expiry_date IS NOT DISTINCT FROM %s
                FOR UPDATE""",
                (item_id, location_id, batch_no, expiry_date), fetch_one=True, cursor=cur
            )
            if existing:
                cur.execute(
                    """
                    UPDATE stock
                    SET qty = qty + %s,
                        last_moved_at = %s,
                        status = %s,
                        received_at = COALESCE(received_at, %s),
                        entry_value = COALESCE(entry_value, 0) + %s,
                        source_po_item_id = COALESCE(%s, source_po_item_id)
                    WHERE id = %s
                    RETURNING id
                    """,
                    (qty_change, now_ts, final_status, now_ts, delta_value, source_po_item_id, existing['id'])
                )
            else:
                # ایجاد ردیف جدید
                cur.execute(
                    """
                    INSERT INTO stock
                        (item_id, location_id, qty, batch_no, expiry_date,
                        status, received_at, last_moved_at, entry_value, source_po_item_id)
                    VALUES (%s, %s, %s, %s, %s,
                            %s, %s, %s, %s, %s)
                    RETURNING id
                    """,
                    (item_id, location_id, qty_change, batch_no, expiry_date,
                    final_status, now_ts, now_ts, delta_value, source_po_item_id)
                )
            res = cur.fetchone()
            if res:
                stock_id_to_return = res['id'] if isinstance(res, dict) else res[0]

        elif qty_change < 0:
            # سیاست مصرف قرنطینه (قابل‌تنظیم از app_settings)
            allow_q = False
            rec = self.execute_query("SELECT value FROM app_settings WHERE key='allow_quarantine_consumption'", fetch_one=True, cursor=cur)
            if rec and isinstance(rec.get('value'), str):
                allow_q = rec['value'].strip().lower() in ('1', 'true', 'yes', 'on')

            allowed_statuses = ['تایید شده', 'موجود']
            if allow_q:
                allowed_statuses.append('قرنطینه')

            cur.execute(
                """
                SELECT id, qty FROM stock
                WHERE item_id=%s AND location_id=%s AND batch_no=%s
                AND expiry_date IS NOT DISTINCT FROM %s
                AND status = ANY(%s)
                FOR UPDATE
                """,
                (item_id, location_id, batch_no, expiry_date, allowed_statuses)
            )
            rec = cur.fetchone()
            current_qty = (rec['qty'] if (rec and isinstance(rec, dict)) else (rec[1] if rec else None))
            if not rec or current_qty < abs(qty_change):
                item_name_rec = self.execute_query("SELECT name FROM items WHERE id=%s", (item_id,), fetch_one=True, cursor=cur)
                item_name = item_name_rec['name'] if item_name_rec else f"کالای {item_id}"
                loc_label = self.loc_label(location_id)
                raise ValueError(f"موجودی بچ «{batch_no}» از کالای «{item_name}» در «{loc_label}» کافی نیست یا در وضعیت مجاز نیست.")

            target_id = rec['id'] if isinstance(rec, dict) else rec[0]
            cur.execute("UPDATE stock SET qty = qty + %s, last_moved_at = %s WHERE id = %s",
                        (qty_change, now_ts, target_id))

        # پاکسازی اقلام تقریباً صفر
        self.execute_query("DELETE FROM stock WHERE qty < 0.001", cursor=cur)

        if return_stock_id:
            return stock_id_to_return
        
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def fulfill_request_with_fefo(self, request_id: int, item_id: int, qty_needed: float, doc_no: str, user_id: int):
        """
        نسخه 2.0 (پشتیبانی از انجام بخشی):
        - یک درخواست مواد را با استراتژی FEFO انجام می‌دهد.
        - مقدار انجام شده را در ستون fulfilled_qty ثبت کرده و وضعیت را فقط در صورت اتمام کامل، تغییر می‌دهد.
        """
        with self.transaction() as cur:
            # گام ۱: دریافت بچ‌های موجود (بدون تغییر)
            query = """
                SELECT s.id as stock_id, s.qty, s.batch_no, s.expiry_date, s.location_id
                FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE s.item_id = %s AND s.qty > 0.001 AND w.name != %s
                ORDER BY s.expiry_date ASC NULLS LAST, s.id ASC;
            """
            available_batches = self.execute_query(query, (item_id, PRODUCTION_WAREHOUSE_NAME), cursor=cur)
            total_available = sum(b['qty'] for b in available_batches)
            if total_available < qty_needed:
                raise ValueError(f"موجودی کل برای این کالا کافی نیست. نیاز: {qty_needed} / موجود: {total_available}")

            # گام ۲: ساختن پلن برداشت (بدون تغییر)
            picks = []
            remaining_needed = qty_needed
            for batch in available_batches:
                if remaining_needed <= 0: break
                pick_qty = min(batch['qty'], remaining_needed)
                picks.append({
                    'location_id': batch['location_id'],
                    'batch_no': batch['batch_no'],
                    'expiry_date': batch.get('expiry_date'),
                    'pick_qty': pick_qty
                })
                remaining_needed -= pick_qty
            
            # گام ۳: اجرای پلن برداشت (کسر از انبار و ثبت تراکنش)
            dest_loc_id = self.get_production_floor_location()
            if not dest_loc_id:
                raise ValueError("لوکیشن پیش‌فرض تولید تعریف نشده است.")
            
            for pick in picks:
                self._upd_stock(cur, item_id, pick['location_id'], -abs(pick['pick_qty']), pick['batch_no'], pick.get('expiry_date'))
                notes = f"خروج طبق حواله «{doc_no}» برای درخواست #{request_id} (FEFO خودکار)"
                
                # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
                # نوع تراکنش (t_type) باید همیشه ثابت و از نوع TransactionType باشد.
                # وضعیت (status) باید حالت موقت و از نوع TransactionStatus باشد.
                self.execute_query(
                    """INSERT INTO trans (item_id, t_type, t_no, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date, t_date)
                       VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())""",
                    (item_id, 
                     TransactionType.EXIT_TO_PROD.value, # <--- نوع صحیح: 'خروج به تولید'
                     doc_no, 
                     pick['pick_qty'], 
                     notes, 
                     user_id, 
                     pick['location_id'], 
                     dest_loc_id, 
                     TransactionStatus.PENDING_PRODUCTION_APPROVAL.value, # <--- وضعیت صحیح: 'در انتظار تایید تولید'
                     pick['batch_no'], 
                     pick.get('expiry_date')),
                    cursor=cur
                )
                # --- ****************************************** ---

            # گام ۴: به‌روزرسانی هوشمند وضعیت درخواست مادر (بدون تغییر)
            req_info = self.execute_query("SELECT requested_qty, fulfilled_qty, status FROM material_requests WHERE id = %s FOR UPDATE", (request_id,), fetch_one=True, cursor=cur)
            if not req_info:
                raise ValueError(f"درخواست مواد اولیه با شناسه {request_id} یافت نشد.")

            new_fulfilled = req_info['fulfilled_qty'] + qty_needed
            new_status = TransactionStatus.MR_FULFILLED.value if new_fulfilled >= req_info['requested_qty'] else req_info['status']
            
            final_notes = f"مقدار {qty_needed} واحد طی {len(picks)} تراکنش با سند {doc_no} ارسال شد."
            self.execute_query(
                "UPDATE material_requests SET status=%s, fulfilled_qty=%s, notes=%s, processed_by_user_id=%s, processed_at=NOW() WHERE id=%s",
                (new_fulfilled, new_fulfilled, final_notes, user_id, request_id),
                cursor=cur
            )
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')                                                                                    
            

    def add_trans_extended(self, trans_data: dict, user_id: int) -> int:
        """
        V3.3 (fixed):
        - رویداد QA با context_data ارسال می‌شود (نه payload).
        - وضعیت رکورد trans = 'تایید شده' برای سازگاری کارتکس.
        - ورودیِ QCدار در STOCK با وضعیت 'قرنطینه' ثبت می‌شود.
        """
        with self.transaction() as cur:
            t_type = trans_data['t_type']
            is_exit_type = t_type.startswith('خروج') or t_type == 'ضایعات'

            src = trans_data['loc_id'] if is_exit_type else None
            dst = trans_data['loc_id'] if not is_exit_type else None

            delta = trans_data['qty'] if dst else -abs(trans_data['qty'])
            entry_status = 'قرنطینه' if (not is_exit_type and trans_data.get('requires_qc')) else 'تایید شده'

            # موجودی
            self._upd_stock(
                cur=cur,
                item_id=trans_data['item_id'],
                location_id=trans_data['loc_id'],
                qty_change=delta,
                batch_no=trans_data['batch_no'],
                expiry_date=trans_data.get('expiry_date'),
                entry_status=entry_status
            )

            # سند
            row = self.execute_query(
                """
                INSERT INTO trans
                    (item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date)
                VALUES
                    (%s, %s, %s, NOW(), %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
                """,
                (
                    trans_data['item_id'], t_type, trans_data.get('doc_no'),
                    trans_data['qty'], trans_data.get('notes'), user_id,
                    src, dst, 'تایید شده',
                    trans_data['batch_no'], trans_data.get('expiry_date')
                ),
                fetch_one=True, cursor=cur
            )
            trans_id = row['id']

            self._log_atomic(cur, user_id, 'ADD_TRANS_EXT', f"trans_id:{trans_id}")

        # رویداد QA (بعد از commit)
        self.trigger_event(
            'STOCK_TRANSACTION_CREATED',
            trans_id,
            'trans',
            user_id,
            context_data={
                't_type': t_type,
                'qty': trans_data['qty'],
                'src_loc': src,
                'dest_loc': dst,
                'item_id': trans_data['item_id'],
                'batch_no': trans_data.get('batch_no'),
                'expiry_date': str(trans_data.get('expiry_date')) if trans_data.get('expiry_date') else None
            }
        )

        # رویداد قرنطینه
        if not is_exit_type and trans_data.get('requires_qc'):
            with self.transaction() as cur:
                stock_row = self.execute_query(
                    "SELECT id FROM stock WHERE item_id=%s AND location_id=%s AND batch_no=%s AND expiry_date IS NOT DISTINCT FROM %s",
                    (trans_data['item_id'], dst, trans_data['batch_no'], trans_data.get('expiry_date')),
                    fetch_one=True, cursor=cur
                )
            if stock_row:
                self.trigger_event('STOCK_ITEM_QUARANTINED', stock_row['id'], 'stock', user_id)

        return trans_id
    
    def transfer(self, item_id: int, qty: float, src_loc_id: int, dest_loc_id: int,
                user_id: int, notes: str, batch_no: str, expiry_date=None) -> int:
        """
        انتقال داخلی یک‌سندی.
        """
        if src_loc_id == dest_loc_id:
            raise ValueError("مبدا و مقصد نمی‌تواند یکسان باشد.")

        with self.transaction() as cur:
            # کم‌کردن از مبدا
            self._upd_stock(cur=cur, item_id=item_id, location_id=src_loc_id,
                            qty_change=-abs(qty), batch_no=batch_no, expiry_date=expiry_date)
            # افزودن به مقصد
            self._upd_stock(cur=cur, item_id=item_id, location_id=dest_loc_id,
                            qty_change=abs(qty), batch_no=batch_no, expiry_date=expiry_date, entry_status='تایید شده')

            # سند انتقال
            row = self.execute_query(
                """
                INSERT INTO trans
                    (item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date)
                VALUES
                    (%s, %s, get_next_seq('TRANS_DOC')::text, NOW(), %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
                """,
                (
                    item_id, TransactionType.TRANSFER.value, abs(qty), notes, user_id,
                    src_loc_id, dest_loc_id, TransactionStatus.APPROVED.value,
                    batch_no, expiry_date
                ),
                fetch_one=True, cursor=cur
            )
            trans_id = row['id']

            self._log_atomic(cur, user_id, 'TRANSFER',
                            f"item={item_id}, qty={qty}, src={src_loc_id}, dst={dest_loc_id}, trans_id={trans_id}")

        # رویداد QA (بعد از commit) — با context_data
        self.trigger_event(
            'STOCK_TRANSACTION_CREATED',
            trans_id,
            'trans',
            user_id,
            context_data={
                't_type': TransactionType.TRANSFER.value,
                'qty': abs(qty),
                'src_loc': src_loc_id,
                'dest_loc': dest_loc_id,
                'item_id': item_id,
                'batch_no': batch_no,
                'expiry_date': str(expiry_date) if expiry_date else None
            }
        )
        return trans_id

            
# در کلاس DB، این متد را جایگزین کنید

    def total_qty(self, item_id: int):
        """
        مجموع موجودی یک کالا در تمام انبارها را به صورت امن محاسبه می‌کند.
        نسخه نهایی: از ابزار استاندارد execute_query استفاده می‌کند.
        """
        query = "SELECT COALESCE(SUM(qty), 0) AS q FROM stock WHERE item_id=%s"
        result = self.execute_query(query, (item_id,), fetch_one=True)
        return result['q'] if result else 0
    
    
# در کلاس DB، این متد را جایگزین کنید

    def rack_loads(self):
        """
        بار (مجموع مقادیر) هر قفسه را برای نمایش در HeatMap محاسبه می‌کند.
        نسخه نهایی: از ابزار استاندارد execute_query استفاده می‌کند.
        """
        query = """
            SELECT w.name||' / '||rack||'-'||shelf AS loc, SUM(qty) AS load
            FROM stock s
            JOIN locations l ON l.id=s.location_id
            JOIN warehouses w ON w.id=l.warehouse_id
            GROUP BY loc
        """
        return self.execute_query(query)
        

# در کلاس DB، این متد را جایگزین کنید

    def add_form_def(self, name: str, fields: list, user_id: int, form_type: str = 'GENERAL'):
        """یک تعریف فرم جدید را به صورت اتمیک ثبت کرده و ID آن را برمی‌گرداند."""
        with self.transaction() as cur:
            fields_json = json.dumps(fields, ensure_ascii=False)
            query = "INSERT INTO form_defs (name, fields, user_id, form_type) VALUES (%s, %s, %s, %s) RETURNING id"
            params = (name, fields_json, user_id, form_type)
            
            result = self.execute_query(query, params, fetch_one=True, cursor=cur)
            return result['id'] if result else None
                            
                                                        
    def list_form_defs_by_type(self, form_type: str = 'GENERAL', user_id: int = None, is_admin: bool = False):
        """
        لیست فرم‌ها را بر اساس نوع فیلتر می‌کند.
        اگر is_admin نباشد، فرم‌های کاربر مشخص و فرم‌های قدیمی (بدون مالک) را هم نشان می‌دهد.
        """
        if is_admin:
            query = "SELECT * FROM form_defs WHERE form_type = %s ORDER BY name"
            params = (form_type,)
        else:
            query = "SELECT * FROM form_defs WHERE form_type = %s AND (user_id = %s OR user_id IS NULL) ORDER BY name"
            params = (form_type, user_id)
            
        return self.execute_query(query, params)

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def get_form_fields(self, form_id):
        """
        فیلدهای یک فرم را برمی‌گرداند. این نسخه اطلاعات کامل هر فیلد (شامل id) را
        برای فرمت جدید برمی‌گرداند و با فرمت قدیمی نیز سازگار است.
        """
        form_def_row = self.execute_query("SELECT fields FROM form_defs WHERE id=%s", (form_id,), fetch_one=True)
        
        if not form_def_row or not form_def_row.get('fields'):
            return []
        
        fields_data = form_def_row['fields']
        if isinstance(fields_data, str):
            try:
                fields_data = json.loads(fields_data)
            except json.JSONDecodeError:
                return []

        if not isinstance(fields_data, list) or not fields_data:
            return []

        # --- تشخیص هوشمند فرمت ---
        first_field = fields_data[0]
        
        if isinstance(first_field, dict):
            # فرمت جدید: لیست دیکشنری‌ها. کل لیست را برمی‌گردانیم.
            return fields_data
        elif isinstance(first_field, list) and len(first_field) >= 2:
            # فرمت قدیمی: لیست لیست‌ها. آن را به فرمت جدید تبدیل می‌کنیم.
            return [
                {'id': f'legacy_field_{i}', 'label': field[0], 'type': field[1], 'properties': {}}
                for i, field in enumerate(fields_data)
            ]
            
        return []
    # این متد کاملا جدید را به انتهای کلاس DB اضافه کنید
    def get_manual_workflows_for_department(self, department_id: int):
        """لیست فرآیندهای دستی که یک واحد مشخص مالک آنهاست را برمی‌گرداند."""
        return self.execute_query(
            "SELECT id, name FROM workflows WHERE owner_department_id = %s AND is_active = TRUE AND is_manual_start = TRUE",
            (department_id,)
        )
                    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def add_or_update_form_entry(self, form_id: int, user_id: int, data_json: str, entry_id: int = None):
        """
        نسخه نهایی (V3.0): از context manager امن برای مدیریت تراکنش استفاده می‌کند.
        این تابع حالا به صورت کامل با استخر اتصالات (Connection Pool) هماهنگ است.
        """
        with self.transaction() as cur:
            if entry_id:
                # حالت آپدیت: از ابزار استاندارد برای اجرای کوئری در تراکنش فعلی استفاده می‌کنیم
                self.execute_query(
                    "UPDATE form_entries SET data = %s WHERE id = %s",
                    (data_json, entry_id),
                    cursor=cur
                )
                return entry_id
            else:
                # حالت ثبت: کوئری را اجرا کرده و ID جدید را برمی‌گردانیم
                result = self.execute_query(
                    "INSERT INTO form_entries(form_id, user_id, data) VALUES (%s, %s, %s) RETURNING id",
                    (form_id, user_id, data_json),
                    fetch_one=True,
                    cursor=cur
                )
                return result['id'] if result else None
                            
# در کلاس DB، این متد را جایگزین کنید

    def delete_form_entries_many(self, entry_ids: list):
        """چندین رکورد فرم را بر اساس لیست ID هایشان به صورت اتمیک حذف می‌کند."""
        if not entry_ids:
            return
        with self.transaction() as cur:
            # استفاده از ANY برای بهینه‌سازی و امنیت
            self.execute_query("DELETE FROM form_entries WHERE id = ANY(%s)", (entry_ids,), cursor=cur)
                                    
            
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def delete_form_entry(self, entry_id: int):
        """یک رکورد فرم ثبت شده را به صورت اتمیک حذف می‌کند."""
        try:
            with self.transaction() as cur:
                self.execute_query("DELETE FROM form_entries WHERE id=%s", (entry_id,), cursor=cur)
        except Exception as e:
            print(f"ERROR in delete_form_entry: {e}")
            raise RuntimeError(f"قادر به حذف رکورد فرم با شناسه {entry_id} نبود. خطای دیتابیس: {e}")
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def fefo_pick(self, item_id: int, qty_needed: float) -> list:
        """
        نسخه اصلاح‌شده و عملیاتی (V2.0):
        با توجه به مقدار مورد نیاز، بهترین بچ‌ها را برای برداشت بر اساس تاریخ انقضا (FEFO) پیشنهاد می‌دهد.
        این تابع به جای جدول کاتالوگ (items)، جدول موجودی واقعی (stock) را جستجو می‌کند.
        خروجی: لیستی از دیکشنری‌ها شامل لوکیشن، بچ و مقدار پیشنهادی برای برداشت.
        """
        # کوئری برای پیدا کردن تمام بچ‌های موجود یک کالا، مرتب شده بر اساس FEFO
        # بچ‌های بدون تاریخ انقضا در آخر قرار می‌گیرند
        query = """
            SELECT
                s.id as stock_id,
                s.qty,
                s.batch_no,
                s.expiry_date,
                s.location_id,
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0.001 AND w.name != 'Production'
            ORDER BY s.expiry_date ASC NULLS LAST, s.id ASC;
        """
        available_batches = self.execute_query(query, (item_id,))

        if not available_batches:
            return []  # هیچ موجودی برای این کالا یافت نشد

        total_available = sum(b['qty'] for b in available_batches)
        if total_available < qty_needed:
            # موجودی کل کافی نیست، می‌توان یک خطا ایجاد کرد یا لیست خالی برگرداند
            # فعلا یک هشدار در کنسول چاپ می‌کنیم
            print(f"WARNING: FEFO Pick - Not enough stock for item {item_id}. Needed: {qty_needed}, Available: {total_available}")
            return []

        picks = []
        remaining_needed = qty_needed
        for batch in available_batches:
            if remaining_needed <= 0:
                break
            
            pick_qty = min(batch['qty'], remaining_needed)
            
            picks.append({
                'stock_id': batch['stock_id'],
                'location_id': batch['location_id'],
                'location_label': batch['loc_label'],
                'batch_no': batch['batch_no'],
                'expiry_date': batch['expiry_date'],
                'pick_qty': pick_qty
            })
            
            remaining_needed -= pick_qty
            
        return picks
    

    def get_batches_in_location(self, item_id: int, location_id: int) -> list:
        """تمام بچ‌های موجود یک کالا در یک لوکیشن خاص را به همراه موجودی برمی‌گرداند."""
        query = """
            SELECT batch_no, qty 
            FROM stock 
            WHERE item_id = %s AND location_id = %s AND qty > 0.001
            ORDER BY expiry_date ASC NULLS LAST, id ASC;
        """
        return self.execute_query(query, (item_id, location_id))    


# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def add_bom(self, product_code: str, raw_item_id: int, raw_batch: str, qty: float, user_id: int):
        """
        یک ردیف مصرف مواد را به صورت اتمیک ثبت می‌کند (همراه با لاگ حسابرسی).
        نسخه نهایی: از context manager برای تضمین یکپارچگی داده و لاگ استفاده می‌کند.
        """
        with self.transaction() as cur:
            query = """
                INSERT INTO bill_of_materials (product_code, raw_item_id, raw_batch, qty, ts, user_id)
                VALUES (%s, %s, %s, %s, NOW(), %s)
            """
            params = (product_code, raw_item_id, raw_batch, qty, user_id)
            
            # اجرای دستور اصلی
            self.execute_query(query, params, cursor=cur)
            
            # ثبت لاگ در *همان* تراکنش برای تضمین یکپارچگی
            log_details = json.dumps({'prod': product_code, 'raw': raw_item_id, 'qty': qty})
            self._log_atomic(cur, user_id, 'ADD_BOM', log_details)
            
# در کلاس DB، این متد را جایگزین کنید

    def add_asset(self, code: str, name: str, brand: str = '', model: str = '', cost: float = 0.0, user_id: int | None = None) -> int:
        """یک دارایی را به صورت اتمیک ثبت یا ویرایش کرده و لاگ آن را نیز ثبت می‌کند."""
        with self.transaction() as cur:
            query = """
                INSERT INTO assets(code, name, brand, model, cost) VALUES (%s, %s, %s, %s, %s)
                ON CONFLICT(code) DO UPDATE SET
                    name  = EXCLUDED.name,
                    brand = EXCLUDED.brand,
                    model = EXCLUDED.model,
                    cost  = EXCLUDED.cost
                RETURNING id
            """
            params = (code, name, brand, model, cost)
            
            result = self.execute_query(query, params, fetch_one=True, cursor=cur)
            asset_id = result['id']
            
            # ثبت لاگ در همان تراکنش برای تضمین یکپارچگی
            self._log_atomic(cur, user_id or 0, 'ADD_ASSET', f'code={code}')
            
            return asset_id
            
        
# در کلاس DB
    def get_assets_by_assignee(self):
        """دارایی‌هایی که در اختیار پرسنل هستند را به تفکیک تحویل‌گیرنده برمی‌گرداند."""
        query = """
            WITH LatestAssetTrans AS (
                SELECT
                    asset_id,
                    notes,
                    t_type,
                    ROW_NUMBER() OVER(PARTITION BY asset_id ORDER BY t_date DESC) as rn
                FROM asset_trans
            )
            SELECT
                a.code, a.name, a.brand, a.model,
                -- استخراج نام کارمند از یادداشت
                substring(lat.notes from 'تحویل به: (.*)') as employee_name
            FROM assets a
            JOIN LatestAssetTrans lat ON a.id = lat.asset_id
            WHERE lat.rn = 1 AND lat.t_type = 'تحویل به پرسنل'
            ORDER BY employee_name, a.name;
        """
        return self.execute_query(query)

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def asset_exit(self, asset_id: int, t_no: str, t_date, notes: str, user_id: int) -> int:
        """
        تراکنش خروج یک دارایی را ثبت کرده و وضعیت آن را به صورت اتمیک به‌روز می‌کند.
        """
        with self.transaction() as cur:
            # گام ۱: ثبت تراکنش خروج و دریافت ID آن
            trans_result = self.execute_query(
                """INSERT INTO asset_trans(asset_id, t_no, t_date, notes, user_id)
                   VALUES (%s, %s, %s, %s, %s) RETURNING id""",
                (asset_id, t_no, t_date, notes, user_id),
                fetch_one=True,
                cursor=cur
            )
            new_id = trans_result['id']
            
            # گام ۲: به‌روزرسانی وضعیت خود دارایی با استفاده از ثابت استاندارد
            self.execute_query(
                "UPDATE assets SET status=%s WHERE id=%s",
                (AssetStatus.DELIVERED.value, asset_id),
                cursor=cur
            )

            # گام ۳: ثبت لاگ در همان تراکنش
            self._log_atomic(cur, user_id, 'ASSET_EXIT', f'id={asset_id}')
            
            return new_id
        
    def save_form_entry(self, form_id, data_json, user_id):
            """نسخه اصلاح شده نهایی: usr به user_id عددی تغییر کرد."""
            with self.transaction() as cur:
                cur.execute("""INSERT INTO form_entries(form_id,ts,data,user_id)
                            VALUES (%s,%s,%s,%s)""",
                            (form_id, datetime.now(dt.timezone.utc), data_json, user_id))
                                                
# در کلاس DB، این بلوک جایگزین شود

    def get_transactions_for_asset(self, asset_id: int):
        """تمام تراکنش‌های ثبت شده برای یک دارایی خاص را برمی‌گرداند."""
        query = """
            SELECT 
                at.t_type, at.t_no, at.t_date, at.notes, u.username
            FROM asset_trans at
            LEFT JOIN users u ON at.user_id = u.id
            WHERE at.asset_id = %s
            ORDER BY at.t_date DESC
        """
        return self.execute_query(query, (asset_id,))                                               

    def check_batch_expiry_consistency(self, item_id: int, batch_no: str, new_expiry_date: dt.date | None):
        """
        بررسی می‌کند که آیا یک بچ نامبر مشخص، قبلاً با تاریخ انقضای متفاوتی ثبت شده است یا خیر.
        خروجی: (True, None) اگر مشکلی نبود، (False, existing_date) اگر مغایرت وجود داشت.
        """
        # فقط بچ‌هایی را چک می‌کنیم که تاریخ انقضای معتبر دارند
        query = """
            SELECT DISTINCT expiry_date 
            FROM stock 
            WHERE item_id = %s AND batch_no = %s AND expiry_date IS NOT NULL
        """
        existing_records = self.execute_query(query, (item_id, batch_no))
        
        if not existing_records:
            return True, None # این بچ قبلاً ثبت نشده یا تاریخ انقضا نداشته، پس مشکلی نیست

        existing_date = existing_records[0]['expiry_date']

        # اگر تاریخ جدیدی وارد نشده بود، مشکلی نیست
        if new_expiry_date is None:
            return True, None

        # اگر تاریخ جدید با تاریخ موجود مغایرت داشت
        if existing_date != new_expiry_date:
            return False, existing_date
            
        return True, None
                
                
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def reject_raw_material_transfer(self, trans_id: int, rejector_user_id: int, reason: str):
        """
        نسخه 4.0 (معماری فرآیند صحیح و یکپارچه):
        - یک انتقال را رد کرده و موجودی را به انبار مبدأ برمی‌گرداند.
        - به جای ایجاد یک درخواست بازکاری جدید، وضعیت "درخواست اصلی" را به‌روز کرده
          و آن را مجدداً به کارتابل انبار باز می‌گرداند. این کار از ایجاد داده‌های متناقض جلوگیری می‌کند.
        """
        with self.transaction() as cur:
            # گام ۱: پیدا کردن و قفل کردن تراکنش اصلی برای جلوگیری از پردازش همزمان
            cur.execute(
                "SELECT * FROM trans WHERE id = %s AND status = %s FOR UPDATE",
                (trans_id, TransactionStatus.PENDING_PRODUCTION_APPROVAL.value)
            )
            trans = cur.fetchone()
            if not trans:
                raise ValueError("این تراکنش معتبر نیست یا قبلاً پردازش شده است.")

            # گام ۲: بازگرداندن موجودی به انبار مبدأ (منطق فعلی شما - بدون تغییر)
            self._upd_stock(cur, trans['item_id'], trans['src_loc'], abs(trans['qty']), trans['batch_no'], trans.get('expiry_date'))
            
            # گام ۳: به‌روزرسانی وضعیت تراکنش انتقال به "رد شده"
            notes_update = f"دلیل رد توسط تولید: {reason}"
            cur.execute(
                "UPDATE trans SET status = %s, approved_by=%s, approved_at=NOW(), notes = COALESCE(notes, '') || ' | ' || %s WHERE id = %s",
                (TransactionStatus.REJECTED.value, rejector_user_id, notes_update, trans_id)
            )

            # --- *** بخش جدید و استراتژیک: بازگرداندن درخواست اصلی به چرخه *** ---
            
            # گام ۴: پیدا کردن درخواست مادر اصلی از روی یادداشت‌های تراکنش
            # نکته: این روش همچنان به متن یادداشت وابسته است. در آینده می‌توان با افزودن یک ستون dedicated این ارتباط را قوی‌تر کرد.
            original_notes = trans.get('notes', '')
            parent_request_id = None
            if 'برای درخواست #' in original_notes:
                try:
                    import re
                    match = re.search(r'#(\d+)', original_notes)
                    if match:
                        parent_request_id = int(match.group(1))
                except (AttributeError, ValueError) as e:
                    print(f"WARNING: Could not parse parent request ID from notes for trans_id #{trans_id}. Reason: {e}")

            # گام ۵: اگر درخواست مادر پیدا شد، وضعیت آن را اصلاح کن
            if parent_request_id:
                # قفل کردن رکورد درخواست اصلی برای آپدیت امن
                parent_req = self.execute_query("SELECT * FROM material_requests WHERE id = %s FOR UPDATE", (parent_request_id,), fetch_one=True, cursor=cur)
                if parent_req:
                    # کم کردن مقدار رد شده از مقدار "انجام شده" قبلی
                    new_fulfilled = parent_req.get('fulfilled_qty', 0) - abs(trans['qty'])
                    
                    # افزودن دلیل رد شدن به یادداشت‌های درخواست اصلی
                    rework_note = f"بازبینی مورد نیاز: حواله با سند «{trans.get('t_no', '')}» توسط تولید رد شد. دلیل: {reason}"
                    
                    self.execute_query(
                        """UPDATE material_requests 
                           SET status = %s, fulfilled_qty = %s, notes = %s, processed_by_user_id = NULL
                           WHERE id = %s""",
                        (
                            TransactionStatus.MR_REWORK_WAREHOUSE.value, # وضعیت جدید برای نمایش در کارتابل انبار
                            max(0, new_fulfilled), # جلوگیری از منفی شدن
                            rework_note,
                            parent_request_id
                        ),
                        cursor=cur
                    )
            # --- ***************************************************************** ---
            
            self._log_atomic(cur, rejector_user_id, 'TRANSFER_REJECTED_V3', f"Rejected trans_id:{trans_id}, reverted parent request.")
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        return True
        
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def reject_void_transaction(self, trans_id_to_reject: int, user_id: int, reason: str):
        """
        نسخه نهایی: درخواست ابطال یک تراکنش را رد کرده و از استخر اتصالات استفاده می‌کند.
        """
        # به جای with self._conn() از with self.transaction() استفاده می‌کنیم
        with self.transaction() as cur:
            # کوئری‌ها حالا از طریق execute_query استاندارد و با cursor موجود اجرا می‌شوند
            trans_info = self.execute_query(
                "SELECT status, notes FROM trans WHERE id = %s FOR UPDATE", 
                (trans_id_to_reject,), 
                fetch_one=True, 
                cursor=cur
            )
            
            if not trans_info or trans_info['status'] != 'در انتظار تایید ابطال':
                raise ValueError("این تراکنش در وضعیت مناسب برای رد ابطال نیست.")

            new_notes = (trans_info['notes'] or '') + f" | [دلیل رد ابطال: {reason}]"

            self.execute_query(
                "UPDATE trans SET status = 'تایید شده', notes = %s WHERE id = %s",
                (new_notes, trans_id_to_reject),
                cursor=cur
            )
            
            # فراخوانی نسخه اتمیک لاگ که از تراکنش فعلی استفاده می‌کند
            log_details = f"درخواست ابطال برای تراکنش #{trans_id_to_reject} رد شد. دلیل: {reason}"
            self._log_atomic(cur, user_id, 'VOID_REJECTED', log_details)


# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید (متد _log قدیمی حذف خواهد شد)

    def _log_atomic(self, cur, user_id: int, act: str, det: str) -> int:
        """
        نسخه امن برای ثبت وقایع که یک cursor موجود را می‌پذیرد
        و ID لاگ ثبت شده را برمی‌گرداند.
        """
        result = self.execute_query(
            'INSERT INTO audit(stamp, user_id, action, details) VALUES (NOW(), %s, %s, %s) RETURNING id',
            (user_id, act, det),
            fetch_one=True,
            cursor=cur
        )
        return result['id'] if result else None
                                                                                
    # این دو متد جدید را به انتهای کلاس DB اضافه کنید
    def get_pending_raw_material_transfers(self):
        """تمام درخواست‌های انتقال مواد اولیه که منتظر تایید تولید هستند را برمی‌گرداند."""
        query = """
            SELECT
                t.id, i.name as item_name, t.t_no, t.qty, u.username as requester, t.t_date
            FROM trans t
            JOIN items i ON t.item_id = i.id
            JOIN users u ON t.user_id = u.id
            WHERE t.status = 'در انتظار تایید تولید'
            ORDER BY t.id DESC;
        """
        return self.execute_query(query)

# در کلاس DB، این متد را جایگزین کنید

    def approve_raw_material_transfer(self, trans_id: int, approver_user_id: int) -> bool:
        """
        نسخه نهایی (اصلاح شده): انتقال مواد اولیه را تایید کرده و با استفاده از استخر اتصالات (Connection Pool)،
        موجودی را به صورت اتمیک به‌روزرسانی و وضعیت تراکنش را به 'تایید شده' تغییر می‌دهد.
        """
        try:
            with self.transaction() as cur:
                # گام ۱: انتخاب تراکنش و تایید وضعیت
                # FOR UPDATE تضمین می‌کند که هیچ فرآیند دیگری همزمان روی این ردیف کار نکند
                cur.execute(
                    "SELECT * FROM trans "
                    "WHERE id = %s "
                    "AND status = 'در انتظار تایید تولید' "
                    "AND t_type = 'خروج به تولید' "
                    "FOR UPDATE",
                    (trans_id,)
                )
                trans = cur.fetchone()
                if not trans:
                    raise ValueError("تراکنش یافت نشد یا قبلاً پردازش شده است.")
                
                # گام ۲: استخراج اطلاعات لازم
                item_id = trans['item_id']
                dest_loc_id = trans['dest_loc']
                qty_needed = trans['qty']
                batch_no = trans['batch_no']
                expiry_date = trans.get('expiry_date')
                
                # گام ۳: افزودن موجودی به انبار مقصد (تولید)
                self._upd_stock(
                    cur,
                    item_id,
                    dest_loc_id,
                    abs(qty_needed),
                    batch_no=batch_no,
                    expiry_date=expiry_date
                )
                
                # گام ۴: آپدیت وضعیت خود تراکنش به "تایید شده"
                cur.execute(
                    "UPDATE trans "
                    "SET status = %s, approved_by = %s, approved_at = NOW() "
                    "WHERE id = %s",
                    (TransactionStatus.APPROVED.value, approver_user_id, trans_id)
                )
                
                # گام ۵: ثبت لاگ عملیات در همان تراکنش
                self._log_atomic(
                    cur,
                    approver_user_id,
                    'TRANSFER_APPROVAL',
                    f"تایید دریافت مواد اولیه برای تراکنش #{trans_id}"
                )
                
            # با خروج از بلوک with، عملیات به صورت خودکار Commit می‌شود.
            # سیگنال برای آپدیت اعلان‌ها پس از کامیت موفق ارسال می‌شود.
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            return True
            
        except (Exception, psycopg2.Error) as e:
            # context manager به صورت خودکار Rollback را انجام می‌دهد.
            print(f"ERROR during material transfer approval: {e}")
            traceback.print_exc()
            raise  # خطا را دوباره ارسال می‌کنیم تا لایه‌های بالاتر متوجه شوند.            
                                            
# در کلاس DB، این متد را جایگزین کنید

    def add_bom_file(self, bom_id: int, path: str):
        """یک فایل پیوست به یک رکورد BOM به صورت اتمیک اضافه می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "INSERT INTO bom_files(bom_id, path) VALUES (%s, %s)",
                (bom_id, path),
                cursor=cur
            )
            
# در کلاس DB، این متد را جایگزین کنید

    def delete_bom_file(self, file_id: int):
        """یک فایل پیوست BOM را به صورت اتمیک حذف می‌کند."""
        with self.transaction() as cur:
            self.execute_query("DELETE FROM bom_files WHERE id=%s", (file_id,), cursor=cur)
                        
    # ═════════════════════════════════════════════
    #         متدهای جدید برای مدیریت تولید
    # ═════════════════════════════════════════════

    def get_production_floor_location(self):
            """
            نسخه نهایی و صحیح: ID لوکیشن پیش‌فرض انبار «Production» را برمی‌گرداند.
            این تابع دیگر به آدرس‌های قدیمی و حذف شده وابسته نیست.
            """
            # ما از تابع عمومی که قبلاً برای پیدا کردن لوکیشن پیش‌فرض یک انبار داشتیم، استفاده می‌کنیم
            # این روش بسیار مطمئن‌تر و پویاتر است.
            return self.get_warehouse_default_location('Production')
    

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_recipes(self):
        """
        نسخه نهایی: فقط فرمول‌های فعال (ACTIVE) را برمی‌گرداند و اطلاعات محصول خروجی را نیز شامل می‌شود.
        """
        query = """
            SELECT 
                r.id, r.product_name, r.yield_percentage, r.notes, r.part_type,
                r.produces_item_id,
                i.name as produced_item_name -- نام محصولی که واقعا تولید می‌شود
            FROM recipes r
            LEFT JOIN items i ON r.produces_item_id = i.id
            WHERE 
                (r.part_type IS NULL OR r.part_type != 'PACKAGING')
                AND r.status = 'ACTIVE' -- <<<<---- اصلاح کلیدی اینجاست
            ORDER BY r.product_name
        """
        return self.execute_query(query)
                                
# در کلاس DB، این متد را جایگزین کنید

    def get_recipe_details(self, recipe_id: int):
        """
        جزئیات کامل یک فرمول را به صورت اتمیک واکشی می‌کند.
        نسخه نهایی: از context manager و ابزار استاندارد execute_query استفاده می‌کند.
        """
        with self.transaction() as cur:
            recipe_data = self.execute_query(
                "SELECT * FROM recipes WHERE id=%s",
                (recipe_id,),
                fetch_one=True,
                cursor=cur
            )
            
            ingredients_data = self.execute_query(
                """
                SELECT ri.id, i.name, ri.percentage, ri.raw_material_item_id
                FROM recipe_ingredients ri
                JOIN items i ON i.id = ri.raw_material_item_id
                WHERE ri.recipe_id = %s
                """,
                (recipe_id,),
                cursor=cur
            )
            
            return {'recipe': recipe_data, 'ingredients': ingredients_data or []}
        
    
                                                
# در کلاس DB، این متد را جایگزین کنید

    def delete_recipe(self, recipe_id: int):
        """یک فرمول را به صورت اتمیک و کامل حذف می‌کند."""
        with self.transaction() as cur:
            # به لطف ON DELETE CASCADE در دیتابیس، با حذف فرمول،
            # تمام مواد اولیه مرتبط با آن نیز به صورت خودکار حذف می‌شوند.
            self.execute_query("DELETE FROM recipes WHERE id=%s", (recipe_id,), cursor=cur)
            
    def get_detailed_items_in_location(self, loc_id: int):
        """اطلاعات کامل کالاها به همراه حداقل موجودی در یک لوکیشن."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT i.name, s.qty, COALESCE(u.name,'') AS unit, i.min_qty
                    FROM stock AS s
                    JOIN items AS i ON i.id = s.item_id
                    LEFT JOIN units u ON u.id = i.unit_id
                    WHERE s.location_id = %s AND s.qty > 0
                    ORDER BY i.name
                """, (loc_id,))
                return cur.fetchall()
                                
                                                
# این متد جدید را به کلاس DB اضافه کنید
    def _get_bom_user_column_info(self):
        """ساختار ستون کاربر در جدول BOM را بررسی کرده و نام و نوع آن را برمی‌گرداند."""
        if hasattr(self, '_bom_user_col_info'):
            return self._bom_user_col_info

        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT column_name, data_type 
                    FROM information_schema.columns 
                    WHERE table_name = 'bill_of_materials' AND column_name = 'user_id'
                """)
                res = cur.fetchone()
                if res:
                    self._bom_user_col_info = ('user_id', 'INTEGER')
                    return self._bom_user_col_info
                
                self._bom_user_col_info = ('user_', 'TEXT')
                return self._bom_user_col_info
                            
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def list_producible_items(self):
        """لیست محصولاتی که تولید شده‌اند و آماده تحویل به انبار هستند را برمی‌گرداند."""
        query = """
            SELECT id, product_name, production_batch_no, quantity 
            FROM production_deliveries 
            WHERE status = %s
            ORDER BY id DESC
        """
        # استفاده از ثابت استاندارد به جای متن خام
        return self.execute_query(query, (TransactionStatus.PRODUCED.value,))
        
    
# در کلاس DB، این متد را جایگزین کنید

    def submit_delivery_request(self, delivery_id: int) -> bool:
        """
        وضعیت یک بچ تولید شده را برای ارسال به انبار، به صورت اتمیک به‌روز می‌کند.
        نسخه نهایی: از transaction و ثابت‌های استاندارد وضعیت استفاده می‌کند.
        """
        with self.transaction() as cur:
            query = """
                UPDATE production_deliveries 
                SET status = %s 
                WHERE id = %s AND status = %s
            """
            params = (
                TransactionStatus.PENDING_PRODUCTION_APPROVAL.value, 
                delivery_id, 
                TransactionStatus.PRODUCED.value
            )
            self.execute_query(query, params, cursor=cur)
            # rowcount تعداد ردیف‌های تغییر کرده را برمی‌گرداند
            return cur.rowcount > 0
                    
# در کلاس DB، این متد را بررسی و در صورت نیاز با این نسخه جایگزین کنید

    def get_pending_deliveries(self):
        """
        نسخه نهایی: لیست محصولات منتظر تایید انباردار را به همراه نام محصول مادر برمی‌گرداند.
        """
        query = """
            SELECT 
                pd.id, 
                pd.product_name, 
                p.name as parent_name, -- <<< ستون جدید برای نام محصول مادر
                pd.production_batch_no, 
                pd.quantity,
                u.username as supervisor_name,
                pd.created_at
            FROM production_deliveries pd
            JOIN users u ON pd.supervisor_user_id = u.id
            JOIN items i ON pd.product_name = i.name
            LEFT JOIN items p ON i.parent_item_id = p.id -- <<< اتصال جدید برای پیدا کردن مادر
            WHERE pd.status = 'در انتظار تایید انبار'
            AND i.is_packed = TRUE
            ORDER BY pd.id ASC
        """
        return self.execute_query(query)
                    
    def finalize_delivery(self, delivery_id: int, approver_user_id: int, dest_loc_id: int):
        with self.transaction() as cur:
            record = self.execute_query(
                "SELECT * FROM production_deliveries WHERE id = %s AND status = 'در انتظار تایید انبار' FOR UPDATE",
                (delivery_id,), fetch_one=True, cursor=cur
            )
            if not record:
                raise ValueError("این درخواست دیگر معتبر نیست یا قبلاً پردازش شده است.")
            
            item_id     = record.get('product_item_id')
            if not item_id:
                raise ValueError(f"اطلاعات شناسه کالا برای درخواست تحویل شماره {delivery_id} یافت نشد.")
            quantity    = record['quantity']
            batch_no    = record['production_batch_no']
            expiry_date = record.get('expiry_date')
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            self._upd_stock(cur, item_id, prod_loc_id, -abs(quantity), batch_no, expiry_date)
            self._upd_stock(cur, item_id, dest_loc_id,  abs(quantity), batch_no, expiry_date)

            trans_id = self.execute_query(
                """
                INSERT INTO trans (item_id, t_type, qty, notes, user_id, dest_loc, status, batch_no, expiry_date, t_no, src_loc, t_date)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW()) RETURNING id
                """,
                (item_id, 'ورود از تولید', quantity, f"تحویل از تولید - شناسه: {delivery_id}",
                approver_user_id, dest_loc_id, 'تایید شده', batch_no, expiry_date,
                record.get('production_batch_no'), prod_loc_id),
                fetch_one=True, cursor=cur
            )['id']

            self.execute_query(
                "UPDATE production_deliveries SET status = 'تایید شده', approved_by = %s, processed_at = NOW(), final_trans_id = %s WHERE id = %s",
                (approver_user_id, trans_id, delivery_id), cursor=cur
            )

            prod_order_info = self.execute_query(
                "SELECT source_sales_order_id FROM production_orders WHERE id = (SELECT production_order_id FROM production_deliveries WHERE id = %s)",
                (delivery_id,), fetch_one=True, cursor=cur
            )
            if prod_order_info and prod_order_info.get('source_sales_order_id'):
                sales_order_id = prod_order_info['source_sales_order_id']
                self.execute_query(
                    "UPDATE sales_orders SET status = 'آماده ارسال' WHERE id = %s AND status = 'در حال تولید'",
                    (sales_order_id,), cursor=cur
                )
                self._log_atomic(cur, approver_user_id, 'SO_STATUS_UPDATE', f"Status for SO ID:{sales_order_id} -> 'آماده ارسال'")

            self._log_atomic(cur, approver_user_id, 'PROD_DELIVERY_APPROVED',
                            f"Delivery #{delivery_id} approved; trans_id={trans_id}, dest_loc={dest_loc_id}")

        self.trigger_event(
            event_name='PRODUCTION_DELIVERY_APPROVED',
            record_id=delivery_id,
            table_name='production_deliveries',
            user_id=approver_user_id,
            context_data={
                'final_trans_id': trans_id,
                'product_item_id': item_id,
                'qty': quantity,
                'dest_loc_id': dest_loc_id,
                'batch_no': batch_no
            }
        )
                                                                                                                                            
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def list_bom(self, limit:int = 500):
        """نسخه اصلاح شده: ستون status را نیز برای نمایش در UI واکشی می‌کند."""
        query = """
            SELECT 
                b.id, b.product_code, raw.name as raw_item_name, b.raw_batch, 
                b.qty, b.ts, u.username as user_,
                b.status, -- <<< این خط جدید است
                COALESCE(
                    (SELECT r.product_name FROM recipes r WHERE r.id = b.recipe_id),
                    'محصول نامشخص'
                ) AS product_name,
                (SELECT COUNT(*) FROM bom_files bf WHERE bf.bom_id = b.id) as files_count
            FROM bill_of_materials b
            JOIN items raw ON raw.id = b.raw_item_id
            LEFT JOIN users u ON u.id = b.user_id
            ORDER BY b.id DESC
            LIMIT %s
        """
        rows = self.execute_query(query, (limit,))
        return rows
                                            
                                
            
# این متد جدید را برای دیباگ به کلاس DB اضافه کنید
    def get_raw_stock_report(self, item_name: str):
        """
        یک گزارش خام از تمام موجودی‌های یک کالا با نام مشخص را برمی‌گرداند.
        """
        query = """
            SELECT 
                i.name as item_name,
                s.qty,
                s.batch_no,
                w.name as warehouse_name,
                l.rack, l.shelf, l.bin
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE i.name = %s AND s.qty > 0
        """
        print(f"--- DEBUG: Fetching raw stock for item: {item_name} ---")
        results = self.execute_query(query, (item_name,))
        print("--- DEBUG: Raw data from DB ---")
        for row in results:
            print(row)
        print("---------------------------------")
        return results
                                    
# در کلاس DB، این متد را جایگزین کنید

    def get_deliveries_by_supervisor(self, user_id: int):
            """تاریخچه تمام درخواست‌های تحویل ثبت شده توسط یک سرپرست خاص را برمی‌گرداند."""
            query = """
                SELECT
                    pd.id, pd.product_name, pd.production_batch_no, pd.quantity,
                    pd.created_at, pd.status, pd.rejection_reason, 
                    approver.username as approver_name,
                    rejecter.username as rejecter_name
                FROM production_deliveries pd
                LEFT JOIN users approver ON pd.approver_user_id = approver.id
                LEFT JOIN users rejecter ON pd.rejected_by_user_id = rejecter.id
                WHERE pd.supervisor_user_id = %s
                ORDER BY pd.id DESC;
            """
            return self.execute_query(query, (user_id,))
                                
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_main_warehouse_location(self):
        """ID لوکیشن پیش‌فرض انبار اصلی را برمی‌گرداند."""
        query = """
            SELECT id FROM locations 
            WHERE rack='A' AND shelf='1' AND bin='1' 
            AND warehouse_id=(SELECT id FROM warehouses WHERE name=%s LIMIT 1)
        """
        # استفاده از پارامتر به جای قرار دادن مستقیم متن در کوئری
        res = self.execute_query(query, ('Main',), fetch_one=True)
        return res['id'] if res else None
                
    def consume_materials_and_log_bom(self, recipe_id: int, production_batch_no: str, consumption_plan: dict, user_id: int):
            """
            فقط مواد اولیه را مصرف کرده و گزارش BOM را ثبت می‌کند.
            این تابع به هیچ وجه موجودی محصول نهایی را تغییر نمی‌دهد.
            """
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("خطا: لوکیشن 'کف کارگاه' تعریف نشده است.")

            with self.transaction() as cur:
                for material_name, batches_to_consume in consumption_plan.items():
                    for batch_info in batches_to_consume:
                        self._upd_stock(
                            cur, 
                            item_id=batch_info['item_id'], 
                            location_id=prod_loc_id, 
                            qty_change=-abs(batch_info['qty_to_consume']), 
                            batch_no=batch_info['batch_no'],
                            expiry_date=batch_info.get('expiry_date')
                        )
                        cur.execute(
                            """INSERT INTO bill_of_materials (product_code, raw_item_id, raw_batch, qty, ts, user_id, recipe_id)
                            VALUES (%s, %s, %s, %s, NOW(), %s, %s)""",
                            (production_batch_no, batch_info['item_id'], batch_info['batch_no'], batch_info['qty_to_consume'], user_id, recipe_id)
                        )
                
                self._log_atomic(cur, user_id, 'CONSUME_FOR_PRODUCTION', f"Consumed materials for Batch:{production_batch_no}")    

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_all_transactions_detailed(self, t_type_filter: str = None):
        """
        نسخه 3.0 (بهینه‌سازی شده و نهایی):
        - کوئری همبسته برای شمارش فایل‌ها با یک JOIN بهینه جایگزین شد تا سرعت به شدت افزایش یابد.
        - باگ مربوط به ستون unit برطرف شد.
        """
        query = """
            SELECT
                t.*,
                i.name as item_name,
                p.name as parent_name,
                un.name as unit, -- <<<--- اصلاح کلیدی اینجاست
                u.username,
                COALESCE(tf.files_count, 0) AS files_count,
                (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin) AS src_loc_full,
                (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin) AS dst_loc_full,
                CASE
                    WHEN t.t_type = 'انتقال' THEN
                        'از: ' || (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin) ||
                        ' به: ' || (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin)
                    ELSE
                        COALESCE(
                            (src_w.name || '|' || src_l.rack || '-' || src_l.shelf || '-' || src_l.bin),
                            (dst_w.name || '|' || dst_l.rack || '-' || dst_l.shelf || '-' || dst_l.bin),
                            ''
                        )
                END AS loc_label
            FROM
                trans t
            LEFT JOIN items i ON i.id = t.item_id
            LEFT JOIN units un ON i.unit_id = un.id -- <<<--- اصلاح کلیدی اینجاست
            LEFT JOIN items p ON i.parent_item_id = p.id
            LEFT JOIN users u ON u.id = t.user_id
            LEFT JOIN locations src_l ON t.src_loc = src_l.id
            LEFT JOIN warehouses src_w ON src_l.warehouse_id = src_w.id
            LEFT JOIN locations dst_l ON t.dest_loc = dst_l.id
            LEFT JOIN warehouses dst_w ON dst_l.warehouse_id = dst_w.id
            LEFT JOIN (
                SELECT trans_id, COUNT(*) as files_count
                FROM trans_files
                GROUP BY trans_id
            ) tf ON t.id = tf.trans_id
        """

        params = []
        if t_type_filter and t_type_filter != 'همه':
            query += " WHERE t.t_type = %s"
            params.append(t_type_filter)

        query += " ORDER BY t.id DESC"

        return self.execute_query(query, tuple(params))                                
                                    
                                                                                
# در کلاس DB، این متد را با نسخه زیر جایگزین کنید
    def submit_delivery_to_warehouse(self, product_item_id: int, quantity: float, batch_no: str, supervisor_user_id: int):
        """
        نسخه نهایی و صحیح: یک تراکنش 'دریافتی از تولید' با وضعیت 'در انتظار تایید' و با استفاده از user_id صحیح ثبت می‌کند.
        """
        prod_loc_id = self.get_production_floor_location()
        main_wh_loc = self.get_main_warehouse_location()
        if not prod_loc_id or not main_wh_loc:
            raise ValueError("خطا: لوکیشن‌های 'تولید' یا 'انبار اصلی' در سیستم تعریف نشده‌اند.")

        with self._conn() as conn:
            with conn.cursor() as cur:
                # ۱. چک کردن موجودی در کف کارگاه (مبدا)
                cur.execute("SELECT qty FROM stock WHERE item_id = %s AND location_id = %s", (product_item_id, prod_loc_id))
                stock_record = cur.fetchone()
                if not stock_record or stock_record.get('qty', 0) < quantity:
                    raise ValueError(f"موجودی بچ '{batch_no}' در کف کارگاه برای تحویل کافی نیست (موجود: {stock_record.get('qty', 0) if stock_record else 0}).")

                # ۲. ثبت تراکنش با استفاده از ستون user_id به جای user_
                cur.execute(
                    """
                    INSERT INTO trans (
                        t_type, item_id, t_no, qty, notes, user_id, 
                        src_loc, dest_loc, status, t_date, attach_path
                    )
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s)
                    """,
                    (
                        'دریافتی از تولید', 
                        product_item_id, 
                        batch_no, 
                        quantity, 
                        f"درخواست تحویل بچ {batch_no} به انبار اصلی", 
                        supervisor_user_id, # <-- FIX: استفاده از ID عددی کاربر
                        prod_loc_id,      # مبدا: کف کارگاه
                        main_wh_loc,      # مقصد: انبار اصلی
                        'در انتظار تایید',
                        ''                # مقدار پیش‌فرض برای attach_path
                    )
                )
                conn.commit()
                                                                                                                            
    def process_delivery(self, delivery_id: int, approver_user: str, approve: bool):
        """یک درخواست تحویل را تایید یا رد می‌کند و در صورت تایید، موجودی انبار اصلی را افزایش می‌دهد."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                new_status = 'approved' if approve else 'rejected'
                
                if approve:
                    cur.execute("SELECT product_item_id, quantity FROM production_deliveries WHERE id=%s", (delivery_id,))
                    delivery_data = cur.fetchone()
                    if delivery_data:
                        cur.execute("SELECT id FROM locations WHERE warehouse_id=(SELECT id FROM warehouses WHERE name='Main') AND rack='A' AND shelf='1' AND bin='1'")
                        main_loc = cur.fetchone()['id']
                        
                        self._upd_stock(delivery_data['product_item_id'], main_loc, delivery_data['quantity'])
                        self._refresh_item_qty(delivery_data['product_item_id'])

                cur.execute("UPDATE production_deliveries SET status = %s, approver_user = %s, processed_at = NOW() WHERE id = %s",
                            (new_status, approver_user, delivery_id))
            conn.commit()
            

    # در کلاس DB، این متد را به طور کامل جایگزین کنید
    def save_recipe(self, recipe_data: dict, ingredients: list, recipe_id_to_revise: int = None):
        """
        ذخیره/ویرایش نسخه‌ی فرمول.
        - دو نوع دارد: MIX (فرمول تولید) و PACKAGING (BOM بسته‌بندی).
        - اگر part_type صریح داده نشده باشد، از روی دسته‌ی اقلام حدس می‌زند:
            اگر همهٔ اقلام CATEGORY_PACKAGING → PACKAGING
            در غیر این‌صورت → MIX
        - ستون yield_percentage فقط وقتی به INSERT اضافه می‌شود که:
            a) part_type != 'PACKAGING'  و
            b) ستون واقعاً در DB وجود داشته باشد.
        (اگر ستون نباشد، مقدارش را داخل properties JSONB ذخیره می‌کنیم تا داده از دست نرود.)
        - نسخه‌گذاری: اگر recipe_id_to_revise داده شود، نسخهٔ قبلی آرشیو، نسخهٔ جدید با +1 ذخیره می‌شود.
        - فقط اقلامِ متناسب با نوع فرمول ذخیره می‌شوند:
            MIX  → مواد غیرِ CATEGORY_PACKAGING
            PACKAGING → فقط CATEGORY_PACKAGING
        - ورودی ingredients می‌تواند کلیدهای متفاوت داشته باشد:
            raw_material_item_id | component_item_id | item_id
            و برای مقدار: percentage | quantity | qty
        """
        import datetime as _dt

        def _pick_item_id(row):
            return (row.get('raw_material_item_id')
                    or row.get('component_item_id')
                    or row.get('item_id'))

        def _pick_qty(row):
            return (row.get('percentage')
                    or row.get('quantity')
                    or row.get('qty'))

        # 1) پیش‌پردازش پایه
        product_name = (recipe_data.get('product_name') or '').strip()
        if not product_name:
            raise ValueError("نام محصول برای فرمول مشخص نیست.")

        notes       = recipe_data.get('notes')
        props_in    = recipe_data.get('properties') or {}

        # 2) تشخیص وجود ستون yield_percentage در جدول recipes
        has_yield_col = bool(self.execute_query(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = current_schema()
            AND table_name   = 'recipes'
            AND column_name  = 'yield_percentage'
            LIMIT 1
            """,
            fetch_one=True
        ))

        # 3) تعیین part_type
        explicit_part_type = recipe_data.get('part_type')
        item_ids = [ _pick_item_id(r) for r in (ingredients or []) if _pick_item_id(r) ]
        cats_map = {}
        if item_ids:
            # نقشهٔ id→category برای فیلتر کردن
            q = "SELECT id, category FROM items WHERE id = ANY(%s)"
            rows = self.execute_query(q, (item_ids,))
            cats_map = { r['id']: r['category'] for r in (rows or []) }

        inferred_packaging = (len(item_ids) > 0 and all(cats_map.get(i) == CATEGORY_PACKAGING for i in item_ids))
        part_type = (explicit_part_type or ('PACKAGING' if inferred_packaging else 'MIX'))

        # 4) آماده‌سازی لیست نهایی اقلام بر اساس part_type
        filtered_ingredients = []
        for row in (ingredients or []):
            iid = _pick_item_id(row)
            qty = _pick_qty(row)
            if iid is None or qty is None:
                continue
            cat = cats_map.get(iid)
            if part_type == 'PACKAGING':
                # فقط بسته‌بندی
                if cat == CATEGORY_PACKAGING:
                    filtered_ingredients.append({'raw_material_item_id': iid, 'percentage': float(qty)})
            else:
                # MIX: بسته‌بندی‌ها حذف شوند
                if cat != CATEGORY_PACKAGING:
                    filtered_ingredients.append({'raw_material_item_id': iid, 'percentage': float(qty)})

        # 5) تعیین yield (فقط برای MIX معنا دارد)
        yield_pct_in = recipe_data.get('yield_percentage')
        yield_pct_to_store = None
        props_out = dict(props_in) if isinstance(props_in, dict) else {}
        if part_type != 'PACKAGING' and yield_pct_in is not None:
            try:
                yield_pct_to_store = float(yield_pct_in)
            except (TypeError, ValueError):
                yield_pct_to_store = None
            if not has_yield_col and yield_pct_to_store is not None:
                # اگر ستون نداریم، توی properties نگه می‌داریم
                props_out['yield_percentage'] = yield_pct_to_store

        # 6) نسخه‌گذاری
        with self.transaction() as cur:
            if recipe_id_to_revise:
                # نسخه قبلی را آرشیو کن و نسخه جدید با +1 بساز
                prev = self.execute_query(
                    "SELECT product_name, version FROM recipes WHERE id=%s",
                    (recipe_id_to_revise,), fetch_one=True, cursor=cur
                )
                if not prev:
                    raise ValueError("شناسهٔ فرمول برای ویرایش معتبر نیست.")
                product_name_for_ver = prev['product_name']
                # آرشیو نسخه قبلی
                self.execute_query("UPDATE recipes SET status='ARCHIVED' WHERE id=%s", (recipe_id_to_revise,), cursor=cur)
                # نسخه جدید
                next_ver_row = self.execute_query(
                    "SELECT COALESCE(MAX(version),0)+1 AS v FROM recipes WHERE product_name=%s",
                    (product_name_for_ver,), fetch_one=True, cursor=cur
                )
                new_version = int(next_ver_row['v'])
            else:
                # نسخه‌گذاری از ابتدا/جدید
                next_ver_row = self.execute_query(
                    "SELECT COALESCE(MAX(version),0)+1 AS v FROM recipes WHERE product_name=%s",
                    (product_name,), fetch_one=True, cursor=cur
                )
                new_version = int(next_ver_row['v'])

            # 7) INSERT recipes (دینامیک: yield فقط اگر ستون هست و MIX است)
            cols = ["product_name", "version", "status", "properties", "notes", "part_type", "created_at"]
            vals = [product_name, new_version, 'ACTIVE', props_out if props_out else None, notes, part_type, _dt.datetime.now(_dt.timezone.utc)]
            placeholders = ["%s"] * len(cols)

            if (part_type != 'PACKAGING') and has_yield_col and (yield_pct_to_store is not None):
                cols.append("yield_percentage")
                vals.append(yield_pct_to_store)
                placeholders.append("%s")

            insert_sql = f"INSERT INTO recipes ({', '.join(cols)}) VALUES ({', '.join(placeholders)}) RETURNING id"
            cur.execute(insert_sql, tuple(vals))
            recipe_id = cur.fetchone()[0]

            # 8) درج مواد
            # پاکسازی احتمالی قدیمی‌ها (اگر revise می‌کنیم) لازم نیست چون به id جدید می‌ریزیم
            if filtered_ingredients:
                args = [
                    (recipe_id, row['raw_material_item_id'], row['percentage'])
                    for row in filtered_ingredients
                ]
                # executemany
                cur.executemany(
                    "INSERT INTO recipe_ingredients (recipe_id, raw_material_item_id, percentage) VALUES (%s, %s, %s)",
                    args
                )

            # 9) لاگ
            self._log_atomic(cur, recipe_data.get('created_by_id') or recipe_data.get('user_id'),
                            'SAVE_RECIPE',
                            f"product={product_name}, version={new_version}, part_type={part_type}, id={recipe_id}")

            return recipe_id
                
# این دو متد جدید را به کلاس DB اضافه کنید
    def get_available_bulk_products(self):
        """تمام بچ‌های محصول فله که تولید شده و هنوز مصرف یا تحویل نشده‌اند را برمی‌گرداند."""
        query = """
            SELECT id, product_name, production_batch_no, quantity, expiry_date 
            FROM production_deliveries
            WHERE status = 'تولید شده' AND quantity > 0.001
            ORDER BY id ASC;
        """
        return self.execute_query(query)

    def consume_bulk_product(self, delivery_id: int, qty_to_consume: float, user_id: int):
        """مقداری از یک بچ محصول فله را کسر می‌کند (معمولا در فرآیند بسته‌بندی)."""
        with self.transaction() as cur:
            # ابتدا رکورد را برای آپدیت قفل می‌کنیم تا از برداشت همزمان جلوگیری شود
            cur.execute("SELECT quantity FROM production_deliveries WHERE id = %s AND status = 'تولید شده' FOR UPDATE", (delivery_id,))
            current_record = cur.fetchone()
            if not current_record:
                raise ValueError("این بچ تولیدی یافت نشد یا وضعیت آن دیگر 'تولید شده' نیست.")
            
            current_qty = current_record['quantity']
            if qty_to_consume > current_qty:
                raise ValueError(f"مقدار مصرفی ({qty_to_consume}) از موجودی بچ ({current_qty}) بیشتر است.")

            new_qty = current_qty - qty_to_consume
            # اگر تمام موجودی مصرف شد، وضعیت را تغییر می‌دهیم
            new_status = 'مصرف شده' if new_qty < 0.001 else 'تولید شده'
            
            cur.execute(
                "UPDATE production_deliveries SET quantity = %s, status = %s WHERE id = %s",
                (new_qty, new_status, delivery_id)
            )
            self._log_atomic(cur, user_id, 'CONSUME_BULK', f"Consumed {qty_to_consume} from delivery_id {delivery_id}")
                        
                                
    # در کلاس DB، این متد را به طور کامل جایگزین کن
    def create_delivery_request(self, product_item_id: int, batch_no: str, quantity: float,
                                expiry_date: str | None, supervisor_user_id: int,
                                production_order_id: int | None = None):
        """
        ثبت درخواست تحویل محصول از تولید به انبار + ارسال رویداد بعد از ثبت موفق
        """
        with self.transaction() as cur:
            cur.execute(
                """
                INSERT INTO production_deliveries
                    (product_item_id, product_name, production_batch_no, quantity, status,
                    supervisor_user_id, created_at, expiry_date, production_order_id)
                SELECT id, name, %s, %s, %s, %s, NOW(), %s, %s
                FROM items
                WHERE id = %s
                RETURNING id
                """,
                (
                    batch_no, quantity,
                    TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value,  # همان وضعیت فعلی‌ات
                    supervisor_user_id, expiry_date, production_order_id,
                    product_item_id
                )
            )
            new_id = cur.fetchone()['id']

            self._log_atomic(
                cur, supervisor_user_id, 'QUEUE_DELIVERY_REQUEST',
                f"Queued item_id:{product_item_id}, Batch:{batch_no}, Qty:{quantity}"
            )
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

        # ❗️بعد از کامیت: ارسال رویداد برای گیت QC/تحویل انبار
        try:
            self.trigger_event(
                event_name='PRODUCTION_DELIVERY_REQUEST_CREATED',
                record_id=new_id,
                table_name='production_deliveries',
                user_id=supervisor_user_id,
                context_data={'batch_no': batch_no, 'quantity': quantity}
            )
        except Exception as e:
            print("WARN: trigger_event failed for PRODUCTION_DELIVERY_REQUEST_CREATED:", e)

        return new_id   
        
# در کلاس DB، این متد را جایگزین کنید

    def get_category_value_stats(self):
            """
            مجموع ارزش ریالی کالاها را به تفکیک دسته‌بندی محاسبه می‌کند.
            FIX: این نسخه انبار تولید (WIP) را از محاسبات ارزش کل انبار مستثنی می‌کند.
            """
            query = """
                SELECT
                    i.category,
                    SUM(s.qty * i.cost) as total_value
                FROM stock s
                JOIN items i ON s.item_id = i.id
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE
                    s.qty > 0
                    AND i.cost > 0
                    AND w.name != %s
                GROUP BY i.category
                HAVING SUM(s.qty * i.cost) > 0
            """
            return self.execute_query(query, (PRODUCTION_WAREHOUSE_NAME,))
            
                
    # در کلاس DB، این متد را با نسخه صحیح و کامل زیر جایگزین کنید
    def get_item_details(self, item_id: int):
        """جزئیات کامل یک کالا، شامل تمام فیلدهای جدید را برمی‌گرداند."""
        query = """
            SELECT 
                i.id, i.name, i.category, i.unit_id, i.cost, i.min_qty, i.max_qty, 
                i.supplier, i.ent_date, i.notes, i.sku, i.is_packed, i.default_loc, 
                i.expiry_lead_days, i.reporting_group, i.is_parent_product,
                i.parent_item_id, -- <<<--- اصلاح کلیدی و نهایی اینجاست
                i.net_weight,
                (w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin) AS location_name
            FROM items i
            LEFT JOIN locations l ON i.default_loc = l.id
            LEFT JOIN warehouses w ON l.warehouse_id = w.id
            WHERE i.id = %s
        """
        return self.execute_query(query, (item_id,), fetch_one=True)

    def get_child_items(self, parent_item_id: int):
        """
        تمام کالاهای فرزند (پک‌ها) برای یک محصول مادر را برمی‌گرداند.
        فقط فرزندانی را برمی‌گرداند که از نوع 'محصول نهایی' باشند.
        خروجی حاوی نام واحد به‌صورت 'unit' است (با JOIN روی جدول units).
        """
        query = """
            SELECT
                i.id,
                i.sku,
                i.name,
                u.name AS unit
            FROM items i
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE i.parent_item_id = %s
            AND i.category = %s
            ORDER BY i.name
        """
        return self.execute_query(query, (parent_item_id, CATEGORY_FINAL_PRODUCT))
    
    def add_item_with_locations(self, item_data: dict, stock_data: list, user_id: int, ignore_batch_check: bool = False):
        """
        ایجاد آیتم جدید به‌همراه ثبت موجودی اولیه در لوکیشن‌ها.
        - قبل از درج، یکتایی name و sku با نادیده‌گرفتن فاصله/نیم‌فاصله بررسی می‌شود.
        - در صورت دو جزئی بودن، اقلام جزء A و B (و در حالت مادرِ غیر دو جزئی، پارت P) ساخته می‌شوند.
        - برای موجودی‌های اولیه، هم در stock ثبت می‌شود و هم سند trans ایجاد می‌گردد.
        """
        import re, datetime as dt

        # --- نرمال‌سازی نام ---
        item_name = item_data.get('name', '') or ''
        item_name_normalized = re.sub(r'\s+', ' ', item_name).strip()
        if not item_name_normalized:
            raise ValueError("نام کالا نمی‌تواند خالی باشد.")
        item_data['name'] = item_name_normalized

        # --- چک یکتایی نام و SKU (پیش از INSERT) ---
        sku_value = (item_data.get('sku') or '').strip()
        dup_check_sql = """
        WITH in_norm AS (
            SELECT
                LOWER(REPLACE(REPLACE(%s, E'\u200c',''), ' ', '')) AS nname,
                NULLIF(TRIM(%s), '') AS nsku
        )
        SELECT
            EXISTS(
                SELECT 1 FROM items i, in_norm
                WHERE LOWER(REPLACE(REPLACE(i.name, E'\u200c',''), ' ', '')) = in_norm.nname
                AND i.parent_item_id IS NULL
            ) AS name_exists_root,
            EXISTS(
                SELECT 1 FROM items i, in_norm
                WHERE in_norm.nsku IS NOT NULL
                AND i.sku IS NOT NULL
                AND TRIM(i.sku) = in_norm.nsku
            ) AS sku_exists;
        """

        with self.transaction() as cur:
            row = self.execute_query(dup_check_sql, (item_name_normalized, sku_value), fetch_one=True, cursor=cur) or {}
            errs = []
            if not item_data.get('parent_item_id') and row.get('name_exists_root'):
                errs.append(f"کالایی با نام «{item_name_normalized}» از قبل در سیستم وجود دارد.")
            if sku_value and row.get('sku_exists'):
                errs.append(f"کد کالا (SKU) «{sku_value}» تکراری است.")
            if errs:
                raise ValueError(' '.join(errs))

            # --- درج آیتم اصلی ---
            insert_sql = """
                INSERT INTO items (
                    name, category, unit_id, cost, min_qty, max_qty, supplier, reporting_group,
                    ent_date, expiry_lead_days, notes, default_loc, is_packed, sku,
                    is_parent_product, parent_item_id, net_weight, is_two_component, requires_qc
                )
                VALUES (
                    %(name)s, %(category)s, %(unit_id)s, %(cost)s, %(min_qty)s, %(max_qty)s, %(supplier)s, %(reporting_group)s,
                    %(ent_date)s, %(expiry_lead_days)s, %(notes)s, %(default_loc)s, %(is_packed)s, %(sku)s,
                    %(is_parent_product)s, %(parent_item_id)s, %(net_weight)s, %(is_two_component)s, %(requires_qc)s
                )
                RETURNING id
            """
            cur.execute(insert_sql, {
                'name': item_data.get('name'),
                'category': item_data.get('category'),
                'unit_id': item_data.get('unit_id'),
                'cost': item_data.get('cost'),
                'min_qty': item_data.get('min_qty'),
                'max_qty': item_data.get('max_qty'),
                'supplier': item_data.get('supplier'),
                'reporting_group': item_data.get('reporting_group'),
                'ent_date': item_data.get('ent_date'),
                'expiry_lead_days': item_data.get('expiry_lead_days'),
                'notes': item_data.get('notes'),
                'default_loc': item_data.get('default_loc'),
                'is_packed': item_data.get('is_packed'),
                'sku': sku_value or None,
                'is_parent_product': item_data.get('is_parent_product'),
                'parent_item_id': item_data.get('parent_item_id'),
                'net_weight': item_data.get('net_weight'),
                'is_two_component': item_data.get('is_two_component'),
                'requires_qc': item_data.get('requires_qc'),
            })
            item_id = cur.fetchone()[0]

            # --- اگر کالا دو جزئی باشد: ساخت پارت‌های A و B ---
            if item_data.get('is_two_component'):
                parent_name = item_data['name']
                kg_unit = self.execute_query("SELECT id FROM units WHERE name = 'کیلوگرم'", fetch_one=True, cursor=cur)
                kg_unit_id = kg_unit['id'] if kg_unit else None
                for nm in (f"{parent_name} - پارت A", f"{parent_name} - پارت B"):
                    self.execute_query(
                        """INSERT INTO items (name, category, unit_id, is_parent_product, parent_item_id, is_two_component, requires_qc)
                        VALUES (%s, %s, %s, FALSE, %s, FALSE, FALSE)
                        ON CONFLICT (name) DO NOTHING""",
                        (nm, 'محصول فله', kg_unit_id, item_id), cursor=cur
                    )

            # --- اگر فقط مادر بود ولی دوجزئی نبود: پارت P بساز ---
            elif item_data.get('is_parent_product'):
                parent_name = item_data['name']
                kg_unit = self.execute_query("SELECT id FROM units WHERE name = 'کیلوگرم'", fetch_one=True, cursor=cur)
                kg_unit_id = kg_unit['id'] if kg_unit else None
                self.execute_query(
                    """INSERT INTO items (name, category, unit_id, is_parent_product, parent_item_id, is_two_component, requires_qc)
                    VALUES (%s, %s, %s, FALSE, %s, FALSE, FALSE)
                    ON CONFLICT (name) DO NOTHING""",
                    (f"{parent_name} - پارت P", 'محصول فله', kg_unit_id, item_id), cursor=cur
                )

            # --- ثبت موجودی اولیه و تراکنش ورود (برچسب: «موجودی اولیه») ---
            if stock_data:
                for stock_row in stock_data:
                    loc_id = stock_row.get('location_id') or stock_row.get('loc_id')
                    if not loc_id:
                        raise ValueError("لوکیشنِ موجودی اولیه مشخص نیست.")
                    qty = stock_row.get('qty') or 0
                    batch_no = stock_row.get('batch_no')
                    expiry_date = stock_row.get('expiry_date')

                    # 1) ثبت موجودی
                    self._upd_stock(cur=cur, item_id=item_id, location_id=loc_id,
                                    qty_change=qty, batch_no=batch_no, expiry_date=expiry_date,
                                    status='تایید شده')

                    # 2) تراکنش ورود با عنوان دقیق «موجودی اولیه»
                    t_no = f"INIT-{item_id}-{int(dt.datetime.now(dt.timezone.utc).timestamp())}"
                    cur.execute(
                        """INSERT INTO trans (item_id, t_type, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date, t_date, t_no)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s)""",
                        (
                            item_id,
                            'موجودی اولیه',      # <<<<<<<<<<<<<<
                            qty,
                            'ثبت موجودی اولیه هنگام تعریف کالا',
                            user_id,
                            None,
                            loc_id,
                            'تایید شده',
                            batch_no,
                            expiry_date,
                            t_no
                        )
                    )

            # لاگ سیستمی
            self._log_atomic(cur, user_id, 'ADD_ITEM_WITH_STOCK', f"name={item_data['name']}, id={item_id}")
            return item_id

    def update_item_with_locations(self, item_id: int, item_data: dict, user_id: int):
        import re
        with self.transaction() as cur:
            rec = self.execute_query(
                "SELECT id, parent_item_id, is_parent_product FROM items WHERE id=%s",
                (item_id,), fetch_one=True, cursor=cur
            )
            if not rec:
                raise ValueError("آیتم موردنظر یافت نشد.")

            parent_id_db = rec.get('parent_item_id')
            is_parent_db = bool(rec.get('is_parent_product'))

            # نرمال‌سازی نام
            item_name = (item_data.get('name') or '')
            item_name_normalized = re.sub(r'\s+', ' ', item_name).strip()
            if not item_name_normalized:
                raise ValueError("نام کالا نمی‌تواند خالی باشد.")
            item_data['name'] = item_name_normalized

            sku_value = (item_data.get('sku') or '').strip() or None
        
            # چک یکتایی طبق حالت
            if parent_id_db:
                dup_check_sql = """
                WITH in_norm AS (
                    SELECT LOWER(REPLACE(REPLACE(%s, E'\u200c',''), ' ', '')) AS nname,
                        NULLIF(TRIM(%s), '') AS nsku,
                        %s::INT AS my_id,
                        %s::INT AS pid
                )
                SELECT
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE i.parent_item_id = in_norm.pid
                        AND LOWER(REPLACE(REPLACE(i.name, E'\u200c',''), ' ', '')) = in_norm.nname
                        AND i.id <> in_norm.my_id
                    ) AS name_exists_under_parent,
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE in_norm.nsku IS NOT NULL
                        AND i.sku IS NOT NULL
                        AND TRIM(i.sku) = in_norm.nsku
                        AND i.id <> in_norm.my_id
                    ) AS sku_exists;
                """
                row = self.execute_query(dup_check_sql, (item_name_normalized, sku_value, item_id, parent_id_db), fetch_one=True, cursor=cur) or {}
                if row.get('name_exists_under_parent'):
                    raise ValueError(f"نام «{item_name_normalized}» در همین محصولِ مادر تکراری است.")
            else:
                dup_check_sql = """
                WITH in_norm AS (
                    SELECT LOWER(REPLACE(REPLACE(%s, E'\u200c',''), ' ', '')) AS nname,
                        NULLIF(TRIM(%s), '') AS nsku,
                        %s::INT AS my_id
                )
                SELECT
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE i.parent_item_id IS NULL
                        AND LOWER(REPLACE(REPLACE(i.name, E'\u200c',''), ' ', '')) = in_norm.nname
                        AND i.id <> in_norm.my_id
                    ) AS name_exists,
                    EXISTS(
                        SELECT 1 FROM items i, in_norm
                        WHERE in_norm.nsku IS NOT NULL
                        AND i.sku IS NOT NULL
                        AND TRIM(i.sku) = in_norm.nsku
                        AND i.id <> in_norm.my_id
                    ) AS sku_exists;
                """
                row = self.execute_query(dup_check_sql, (item_name_normalized, sku_value, item_id), fetch_one=True, cursor=cur) or {}
                if row.get('name_exists'):
                    raise ValueError(f"کالایی با نام «{item_name_normalized}» از قبل در سیستم وجود دارد.")
            if sku_value and row.get('sku_exists'):
                raise ValueError(f"کد کالا (SKU) «{sku_value}» تکراری است.")

            if parent_id_db:
                parent = self.execute_query("SELECT id, is_two_component FROM items WHERE id=%s", (parent_id_db,), fetch_one=True, cursor=cur)
                if not parent:
                    raise ValueError("کالای مادر مربوط به این بسته‌بندی یافت نشد.")
                item_data['is_parent_product'] = False
                item_data['is_two_component']  = bool(parent['is_two_component'])
                item_data['category']          = CATEGORY_FINAL_PRODUCT
                item_data['is_packed']         = True
            elif is_parent_db:
                # مادر: دسته اجباری = محصول نهایی
                item_data['is_parent_product'] = True
                item_data['is_two_component']  = bool(item_data.get('is_two_component', False))
                item_data['category']          = CATEGORY_FINAL_PRODUCT   # ← مهم: تحمیل دسته
                item_data['is_packed']         = False
            else:
                item_data['is_parent_product'] = False
                item_data['is_two_component']  = False
            item_data['id'] = item_id
            self.execute_query("""
                UPDATE items SET 
                    name=%(name)s, category=%(category)s, unit_id=%(unit_id)s, cost=%(cost)s, 
                    min_qty=%(min_qty)s, max_qty=%(max_qty)s, supplier=%(supplier)s, 
                    notes=%(notes)s, sku=%(sku)s, is_packed=%(is_packed)s,
                    default_loc=%(default_loc)s, expiry_lead_days=%(expiry_lead_days)s,
                    reporting_group=%(reporting_group)s, is_parent_product=%(is_parent_product)s,
                    net_weight=%(net_weight)s, is_two_component=%(is_two_component)s, requires_qc=%(requires_qc)s
                WHERE id=%(id)s
            """, {**item_data, 'sku': sku_value}, cursor=cur)

            # مادر: ساخت A/B یا P (idempotent) — با ON CONFLICT DO NOTHING
            if (parent_id_db is None) and item_data.get('is_parent_product'):
                parent_name = item_data['name']
                kg_unit_id_rec = self.execute_query("SELECT id FROM units WHERE name = 'کیلوگرم'", fetch_one=True, cursor=cur)
                kg_unit_id = kg_unit_id_rec['id'] if kg_unit_id_rec else None
                if item_data.get('is_two_component'):
                    for suffix in ('A','B'):
                        self.execute_query(
                            "INSERT INTO items (name, category, unit_id, is_parent_product, parent_item_id, is_two_component, requires_qc) "
                            "VALUES (%s, %s, %s, FALSE, %s, FALSE, FALSE) ON CONFLICT DO NOTHING",
                            (f"{parent_name} - پارت {suffix}", 'محصول فله', kg_unit_id, item_id), cursor=cur
                        )
                else:
                    self.execute_query(
                        "INSERT INTO items (name, category, unit_id, is_parent_product, parent_item_id, is_two_component, requires_qc) "
                        "VALUES (%s, %s, %s, FALSE, %s, FALSE, FALSE) ON CONFLICT DO NOTHING",
                        (f"{parent_name} - پارت P", 'محصول فله', kg_unit_id, item_id), cursor=cur
                    )

            self._log_atomic(cur, user_id, 'EDIT_ITEM', f"name={item_data['name']}, id={item_id}")
            
    def create_new_count_session(self, count_type: str, notes: str, user_id: int) -> int:
            """
            نسخه ۲.۰ (اصلاح منطق انبارداری):
            - اسنپ‌شات موجودی در سطح بچ/لوکیشن گرفته می‌شود تا شمارش دقیق و واقعی باشد.
            - فقط موجودی انبارهای غیرتولیدی در شمارش لحاظ می‌شود.
            """
            with self.transaction() as cur:
                cur.execute(
                    "INSERT INTO inventory_counts (type, notes, created_by, status) VALUES (%s, %s, %s, %s) RETURNING id",
                    (count_type, notes, user_id, 'OPEN')
                )
                count_id = cur.fetchone()['id']

                # کوئری جدید برای گرفتن اسنپ‌شات دقیق از هر بچ در هر لوکیشن
                cur.execute("""
                    SELECT s.item_id, s.location_id, s.batch_no, s.expiry_date, s.qty
                    FROM stock s
                    JOIN locations l ON s.location_id = l.id
                    JOIN warehouses w ON l.warehouse_id = w.id
                    WHERE s.qty > 0 AND w.name != 'Production'
                """)
                stock_snapshot = cur.fetchall()
                
                if not stock_snapshot:
                    raise ValueError("هیچ کالایی با موجودی مثبت در انبارهای اصلی برای شمارش یافت نشد.")

                # آماده‌سازی داده‌ها برای جدول جدید و دقیق
                count_items_data = [
                    (count_id, rec['item_id'], rec['location_id'], rec['batch_no'], rec.get('expiry_date'), rec['qty'])
                    for rec in stock_snapshot
                ]
                
                cur.executemany(
                    """
                    INSERT INTO inventory_count_items 
                        (count_id, item_id, location_id, batch_no, expiry_date, system_qty) 
                    VALUES (%s, %s, %s, %s, %s, %s)
                    """,
                    count_items_data
                )
                
                self._log_atomic(cur, user_id, 'START_INVENTORY_COUNT', f"id={count_id}, type={count_type}, items_snapshot_count={len(stock_snapshot)}")
                
            return count_id
            
# این متد جدید را به کلاس DB اضافه کنید
    def get_count_sessions(self):
        """لیست تمام اسناد انبارگردانی را برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                # --- اصلاح کلیدی در این کوئری انجام شده است ---
                # اتصال c.created_by به u.id به جای u.username
                cur.execute("""
                    SELECT c.id, c.type, c.status, c.created_at, u.username as created_by
                    FROM inventory_counts c
                    LEFT JOIN users u ON c.created_by = u.id
                    ORDER BY c.id DESC
                """)
                return cur.fetchall()
                        
    def get_items_for_count(self, count_id: int):
            """
            نسخه ۲.۰: اطلاعات کامل شمارش را به تفکیک بچ و لوکیشن، به همراه لیبل خوانای لوکیشن برمی‌گرداند.
            این تابع، زیربنای دیالوگ‌های جدید شمارش و بازبینی است.
            """
            with self.transaction() as cur:
                cur.execute("""
                    SELECT 
                        ci.id AS count_item_id,
                        i.id AS item_id,
                        i.name AS item_name,
                        l.id as location_id,
                        w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label,
                        ci.batch_no,
                        ci.expiry_date,
                        ci.system_qty,
                        ci.counted_qty
                    FROM inventory_count_items ci
                    JOIN items i ON i.id = ci.item_id
                    JOIN locations l ON l.id = ci.location_id
                    JOIN warehouses w ON w.id = l.warehouse_id
                    WHERE ci.count_id = %s
                    ORDER BY loc_label, i.name, ci.batch_no
                """, (count_id,))
                return cur.fetchall()
        
        
    def update_counted_quantity(self, count_item_id: int, counted_qty: float):
        """مقدار شمارش شده یک آیتم در یک سند را به‌روزرسانی می‌کند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    "UPDATE inventory_count_items SET counted_qty = %s WHERE id = %s",
                    (counted_qty, count_item_id)
                )
                conn.commit()

    def change_count_status(self, count_id: int, new_status: str):
        """وضعیت یک سند انبارگردانی را تغییر می‌دهد."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    "UPDATE inventory_counts SET status = %s WHERE id = %s",
                    (new_status, count_id)
                )
                conn.commit()
                
# این متد را در کلاس DB با نسخه کامل زیر جایگزین کنید
    def apply_inventory_adjustment(self, item_id: int, counted_qty: float, location_id: int, batch_no: str, reason: str, user_id: int):
        """
        نسخه نهایی: موجودی یک بچ مشخص در یک لوکیشن را اصلاح کرده و سند ثبت می‌کند.
        """
        with self._conn() as conn:
            with conn.cursor() as cur:
                try:
                    # موجودی فعلی بچ مشخص در لوکیشن مشخص
                    cur.execute("SELECT qty FROM stock WHERE item_id = %s AND location_id = %s AND batch_no = %s", (item_id, location_id, batch_no))
                    stock_record = cur.fetchone()
                    system_qty = stock_record['qty'] if stock_record else 0.0

                    adjustment_qty = counted_qty - system_qty

                    if abs(adjustment_qty) < 0.001:
                        return # نیازی به اصلاح نیست

                    # ثبت تراکنش اصلاحی با دلیل و بچ نامبر
                    cur.execute(
                        """INSERT INTO trans (item_id, t_type, t_no, t_date, qty, notes, user_id, status, src_loc, batch_no)
                           VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id""",
                        (item_id, 'اصلاح انبارگردانی', f'ADJ-{item_id}', datetime.now(dt.timezone.utc), 
                         adjustment_qty, reason, user_id, TransactionStatus.APPROVED.value, location_id, batch_no)
                    )
                    trans_id = cur.fetchone()['id']

                    # به‌روزرسانی جدول stock با استفاده از تابع داخلی
                    self._upd_stock(cur, item_id, location_id, adjustment_qty, batch_no)

                    self._log(user_id, 'INVENTORY_ADJUSTMENT', f"trans_id:{trans_id}, item_id:{item_id}, change:{adjustment_qty}, reason:{reason}")
                    
                    conn.commit()

                except (Exception, psycopg2.Error) as e:
                    conn.rollback()
                    raise e                            
            

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def void_transaction(self, trans_id_to_void: int, user_id: int) -> TransactionStatus:
        """
        نسخه نهایی و قطعی (V3.4 - با رفع باگ انتقال):
        - باگ ابطال تراکنش‌های انتقال را به طور کامل برطرف می‌کند.
        - سایر منطق‌های مربوط به لغو و درخواست ابطال را حفظ می‌کند.
        """
        with self.transaction() as cur:
            cur.execute("SELECT * FROM trans WHERE id = %s FOR UPDATE", (trans_id_to_void,))
            orig_trans = cur.fetchone()

            if not orig_trans: raise ValueError("تراکنش مورد نظر یافت نشد")

            current_status = orig_trans['status']
            t_type = orig_trans['t_type']

            if current_status in [TransactionStatus.PENDING_PRODUCTION_APPROVAL.value, TransactionStatus.PENDING_WAREHOUSE_APPROVAL.value, TransactionStatus.PENDING_APPROVAL.value]:
                if t_type.startswith('خروج') or t_type == 'برگشت از تولید':
                    self._upd_stock(cur, orig_trans['item_id'], orig_trans['src_loc'], orig_trans['qty'], orig_trans['batch_no'], orig_trans.get('expiry_date'))
                notes = orig_trans.get('notes', '')
                if 'برای درخواست #' in notes:
                    try:
                        import re
                        request_id = int(re.search(r'#(\d+)', notes).group(1))
                        cur.execute(
                            "UPDATE material_requests SET status = 'PENDING', notes = %s, processed_by_user_id = NULL, processed_at = NULL WHERE id = %s",
                            ("تراکنش مربوطه توسط انباردار لغو شد. لطفاً مجدداً رسیدگی شود.", request_id)
                        )
                    except (AttributeError, ValueError) as e:
                        print(f"WARNING: Could not revert material_request status from notes. Reason: {e}")
                cur.execute("UPDATE trans SET status = %s WHERE id = %s", (TransactionStatus.CANCELLED.value, trans_id_to_void))
                self._log_atomic(cur, user_id, 'CANCEL_PENDING_TRANS', f"تراکنش در انتظار #{trans_id_to_void} لغو شد")
                return TransactionStatus.CANCELLED

            elif current_status == TransactionStatus.PENDING_VOID_APPROVAL.value:
                cur.execute("UPDATE trans SET status = %s, notes = COALESCE(notes, '') || ' | ' || %s WHERE id = %s", 
                            (TransactionStatus.APPROVED.value, f"درخواست ابطال توسط کاربر #{user_id} پس گرفته شد.", trans_id_to_void))
                self._log_atomic(cur, user_id, 'CANCEL_VOID_REQUEST', f"درخواست ابطال برای تراکنش #{trans_id_to_void} لغو شد")
                return TransactionStatus.CANCELLED

            elif current_status == TransactionStatus.APPROVED.value:
                if t_type.startswith('ابطال'): raise ValueError("امکان ابطال یک تراکنش 'ابطال' وجود ندارد.")
                if t_type == 'خروج به تولید':
                    cur.execute("UPDATE trans SET status = %s WHERE id = %s", (TransactionStatus.PENDING_VOID_APPROVAL.value, trans_id_to_void))
                    self._log_atomic(cur, user_id, 'REQUEST_VOID_PRODUCTION', f"درخواست ابطال برای خروج به تولید #{trans_id_to_void}")
                    return TransactionStatus.PENDING_VOID_APPROVAL

                item_id, qty, batch_no, expiry_date = orig_trans['item_id'], orig_trans['qty'], orig_trans.get('batch_no'), orig_trans.get('expiry_date')
                if not batch_no: raise ValueError("اطلاعات بچ برای ابطال یافت نشد.")

                # --- *** بلوک جدید و حیاتی برای رفع باگ *** ---
                if t_type == TransactionType.TRANSFER.value:
                    src_loc, dest_loc = orig_trans.get('src_loc'), orig_trans.get('dest_loc')
                    if src_loc and dest_loc:
                        # ۱. موجودی از مقصد کسر می‌شود
                        self._upd_stock(cur, item_id, dest_loc, -abs(qty), batch_no, expiry_date)
                        # ۲. موجودی به مبدأ بازگردانده می‌شود
                        self._upd_stock(cur, item_id, src_loc, abs(qty), batch_no, expiry_date)
                # --- ************************************** ---
                else: # منطق قبلی برای سایر تراکنش‌ها
                    is_entry_type = t_type.startswith('ورود') or t_type == 'برگشت'
                    reversal_qty = -qty if is_entry_type else abs(qty)
                    loc_to_fix = orig_trans.get('dest_loc') or orig_trans.get('src_loc')
                    if loc_to_fix: self._upd_stock(cur, item_id, loc_to_fix, reversal_qty, batch_no, expiry_date)
                
                # ثبت تراکنش ابطال (این بخش تغییری نکرده است)
                new_void_type = f"ابطال {t_type}"
                notes = f"ابطال تراکنش '{t_type}' (سند اصلی: {orig_trans.get('t_no', 'ندارد')})"
                cur.execute("""INSERT INTO trans (item_id, t_type, t_no, qty, notes, user_id, status, voids_trans_id, batch_no, expiry_date, t_date)
                            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())""",
                            (item_id, new_void_type, orig_trans.get('t_no'), -qty, notes, user_id, 
                            TransactionStatus.APPROVED.value, trans_id_to_void, batch_no, expiry_date))
                
                cur.execute("UPDATE trans SET status = 'باطل شده' WHERE id = %s", (trans_id_to_void,))
                self._log_atomic(cur, user_id, 'VOID_EXECUTE', f"ابطال تراکنش #{trans_id_to_void} انجام شد")
                return TransactionStatus.VOIDED

            else:
                raise ValueError(f"این تراکنش در وضعیت '{current_status}' قرار دارد و قابل ابطال یا لغو نیست.")
                    
                                                            
    def approve_void_transaction(self, trans_id_to_void: int, user_id: int):
        """
        نسخه نهایی (V2.7): ابطال را تایید کرده و مقدار تراکنش ابطال را با علامت صحیح ثبت می‌کند.
        """
        with self.transaction() as cur:
            cur.execute(
                "SELECT * FROM trans WHERE id = %s AND status = 'در انتظار تایید ابطال' FOR UPDATE",
                (trans_id_to_void,)
            )
            orig_trans = cur.fetchone()
            if not orig_trans:
                raise ValueError("تراکنش مورد نظر برای تایید ابطال یافت نشد یا قبلاً پردازش شده است.")

            item_id, qty, src_loc, dest_loc = orig_trans['item_id'], orig_trans['qty'], orig_trans['src_loc'], orig_trans['dest_loc']
            batch_no, expiry_date = orig_trans.get('batch_no'), orig_trans.get('expiry_date')

            if not batch_no: raise ValueError("اطلاعات بچ نامبر برای ابطال تراکنش موجود نیست")

            # **اصلاح کلیدی**: مقدار برگشتی به انبار مثبت است
            reversal_qty = abs(qty)

            self._upd_stock(cur, item_id, dest_loc, -reversal_qty, batch_no, expiry_date)
            self._upd_stock(cur, item_id, src_loc, reversal_qty, batch_no, expiry_date)

            new_void_type = f"ابطال {orig_trans['t_type']}"
            notes = f"ابطال تایید شده برای تراکنش {orig_trans['t_type']} (سند: {orig_trans.get('t_no', 'ندارد')})"
            
            # **اصلاح کلیدی**: مقداری که در سند ثبت می‌شود، دقیقاً همان مقدار برگشتی به انبار اصلی است.
            cur.execute(
                """INSERT INTO trans 
                   (item_id, t_type, t_no, t_date, qty, notes, user_id, status, voids_trans_id, batch_no, expiry_date)
                   VALUES (%s, %s, %s, NOW(), %s, %s, %s, %s, %s, %s, %s)""",
                (
                    item_id, new_void_type, orig_trans.get('t_no'), reversal_qty, notes, user_id,
                    TransactionStatus.APPROVED.value, trans_id_to_void, batch_no, expiry_date
                )
            )

            cur.execute(
                "UPDATE trans SET status = %s, approved_by = %s, approved_at = NOW() WHERE id = %s",
                (TransactionStatus.VOIDED.value, user_id, trans_id_to_void)
            )

            self._log_atomic(cur, user_id, 'VOID_APPROVED', f"ابطال تراکنش #{trans_id_to_void} تایید شد")
            
                                                                                                                                    
    
    # ═════════════════════════════════════════════════════
    # توابع کامل و نهایی برای ماژول مدیریت محرمانگی
    # ═════════════════════════════════════════════════════
    def get_all_reporting_groups(self):
        """لیستی از تمام نام‌های گروه گزارش‌دهی که توسط کاربر تعریف شده را برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                query = "SELECT DISTINCT reporting_group FROM items WHERE reporting_group IS NOT NULL AND reporting_group != '' ORDER BY reporting_group"
                cur.execute(query)
                return [row['reporting_group'] for row in cur.fetchall()]

    def get_raw_materials_for_grouping(self):
        """لیست تمام مواد اولیه را برای نمایش در پنجره مدیریت گروه‌ها برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, name, reporting_group FROM items WHERE category='مواد اولیه' ORDER BY name")
                return cur.fetchall()

            
# ══════════════════════════════════════════════════════════
    # توابع جدید برای ماژول پیشرفته «مرکز کنترل محرمانگی»
    # ══════════════════════════════════════════════════════════
    
# در کلاس DB، این متد را جایگزین کنید

    def get_distinct_main_groups(self):
        """گروه‌های اصلی مواد اولیه را به صورت خودکار و امن استخراج می‌کند."""
        query = """
            SELECT DISTINCT SUBSTRING(name from '^[A-Z_]+') as main_group 
            FROM items 
            WHERE category=%s AND name ~ '^[A-Z_]+[0-9]+'
            ORDER BY main_group;
        """
        # استفاده از ثابت استاندارد به جای متن خام
        rows = self.execute_query(query, (CATEGORY_RAW_MATERIAL,))
        return [row['main_group'] for row in rows] if rows else []
    
# در کلاس DB، این متد را جایگزین کنید

    def get_items_for_main_group(self, group_prefix: str):
        """تمام مواد اولیه‌ای که به یک گروه اصلی تعلق دارند را به صورت امن برمی‌گرداند."""
        query = "SELECT id, name, reporting_group FROM items WHERE category=%s AND name LIKE %s ORDER BY name"
        params = (CATEGORY_RAW_MATERIAL, f"{group_prefix}%")
        return self.execute_query(query, params)
    
# در کلاس DB، این متد را جایگزین کنید

    def save_confidentiality_rule(self, group_prefix: str, report_name: str, exception_ids: list):
        """یک قانون کلی را برای یک گروه به همراه استثناهای آن به صورت اتمیک و امن در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            # گام ۱: اعمال قانون کلی برای تمام اعضای گروه
            # اگر report_name وجود داشته باشد، به عنوان گروه تنظیم می‌شود؛ در غیر این صورت NULL می‌شود.
            main_query = "UPDATE items SET reporting_group = %s WHERE category=%s AND name LIKE %s"
            main_params = (report_name if report_name else None, CATEGORY_RAW_MATERIAL, f"{group_prefix}%")
            self.execute_query(main_query, main_params, cursor=cur)

            # گام ۲: اعمال استثناها (در صورت وجود)
            if exception_ids:
                # اگر قانون اصلی محرمانه بودن است (report_name دارد)، استثناها را شفاف (NULL) کن
                if report_name:
                    except_query = "UPDATE items SET reporting_group = NULL WHERE id = ANY(%s)"
                    except_params = (exception_ids,)
                # اگر قانون اصلی شفاف بودن است، استثناها را محرمانه کن
                else:
                    except_query = "UPDATE items SET reporting_group = %s WHERE id = ANY(%s)"
                    # استفاده نکردن از رشته جادویی برای نام گروه استثنا
                    except_params = (f"گروه محرمانه {group_prefix}", exception_ids)
                
                self.execute_query(except_query, except_params, cursor=cur)
                
            
# در کلاس DB، این متد را جایگزین کنید

    def save_reporting_rules(self, rules: list):
        """لیستی از قوانین گزارش‌دهی را به صورت اتمیک در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            for rule in rules:
                self.execute_query(
                    "UPDATE items SET reporting_group = %s WHERE id = %s",
                    (rule['group_name'], rule['id']),
                    cursor=cur
                )
                            

            

            
# در کلاس DB، این متد را جایگزین کنید

    def get_distinct_product_codes(self):
        """لیستی از تمام بچ‌های محصول نهایی که BOM دارند را برمی‌گرداند."""
        query = "SELECT DISTINCT product_code FROM bill_of_materials ORDER BY product_code DESC"
        rows = self.execute_query(query)
        return [row['product_code'] for row in rows] if rows else []
    
    
    def get_bom_for_product(self, product_name: str):
        # آیا ستون part_type داریم؟
        has_part_type = self.execute_query(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = current_schema()
            AND table_name = 'recipes'
            AND column_name = 'part_type'
            LIMIT 1
            """,
            fetch_one=True
        )

        if has_part_type:
            query = """
                SELECT 
                    ri.id,
                    i.name AS component_name,
                    i.id   AS component_item_id,
                    ri.percentage AS quantity,
                    COALESCE(u.name, '') AS unit
                FROM recipe_ingredients ri
                JOIN recipes r ON r.id = ri.recipe_id
                JOIN items   i ON i.id = ri.raw_material_item_id
                LEFT JOIN units u ON u.id = i.unit_id
                WHERE r.product_name = %s
                AND r.status = 'ACTIVE'
                AND r.part_type = 'PACKAGING'
                ORDER BY i.name
            """
            params = (product_name,)
        else:
            # فیلتر بر اساس دستهٔ جزء (PACKAGING)
            query = """
                SELECT 
                    ri.id,
                    i.name AS component_name,
                    i.id   AS component_item_id,
                    ri.percentage AS quantity,
                    COALESCE(u.name, '') AS unit
                FROM recipe_ingredients ri
                JOIN recipes r ON r.id = ri.recipe_id
                JOIN items   i ON i.id = ri.raw_material_item_id
                LEFT JOIN units u ON u.id = i.unit_id
                WHERE r.product_name = %s
                AND r.status = 'ACTIVE'
                AND i.category = %s
                ORDER BY i.name
            """
            params = (product_name, CATEGORY_PACKAGING)

        return self.execute_query(query, params)
    
# در کلاس DB، این متد را جایگزین کنید

    def list_bom_financial(self, pcode: str):
        """گزارش BOM مالی را برای یک بچ خاص با منطق گروه‌بندی ایجاد می‌کند."""
        query = """
            SELECT raw.name as raw_item_name, raw.reporting_group, b.qty
            FROM bill_of_materials b
            JOIN items raw ON raw.id = b.raw_item_id
            WHERE b.product_code = %s
        """
        raw_rows = self.execute_query(query, (pcode,))
        
        report_data = {}
        # منطق پردازش داده بدون تغییر باقی می‌ماند
        for row in raw_rows:
            rep_group = row.get('reporting_group')
            if rep_group and rep_group.strip():
                group_name = rep_group
                if group_name not in report_data: report_data[group_name] = 0
                report_data[group_name] += row['qty']
            else:
                item_name = row['raw_item_name']
                report_data[item_name] = report_data.get(item_name, 0) + row['qty']
        
        return [{'ماده اولیه': name, 'مقدار مصرف': value} for name, value in report_data.items()]        

            

    def get_available_batches(self, item_name: str, location_id: int):
        """
        لیست بچ‌های مختلف یک کالا با نام مشخص را در یک لوکیشن خاص،
        به همراه موجودی هر بچ، و مرتب شده بر اساس تاریخ ورود (FIFO) برمی‌گرداند.
        """
        with self._conn() as conn:
            with conn.cursor() as cur:
                # این کوئری تمام آیتم‌هایی (بچ‌های مختلف) که نام یکسان دارند
                # و در لوکیشن مورد نظر موجودی دارند را واکشی می‌کند.
                query = """
                    SELECT
                        i.id,
                        i.batch,
                        s.qty,
                        i.ent_date
                    FROM stock s
                    JOIN items i ON s.item_id = i.id
                    WHERE i.name = %s AND s.location_id = %s AND s.qty > 0
                    ORDER BY i.ent_date ASC, i.id ASC
                """
                cur.execute(query, (item_name, location_id))
                return cur.fetchall()
     
# در کلاس DB، این متد را جایگزین کنید
    def get_production_summary_last_n_days(self, days: int = 7):
        """
        مجموع مقدار محصولات نهایی تایید شده در n روز گذشته را به تفکیک روز برمی‌گرداند.
        نسخه اصلاح شده با پارامترگذاری امن.
        """
        query = """
            SELECT 
                DATE(processed_at) as production_date,
                SUM(quantity) as total_quantity
            FROM production_deliveries
            WHERE 
                status = 'تایید شده' AND 
                processed_at >= NOW() - (%s * INTERVAL '1 day')
            GROUP BY production_date
            ORDER BY production_date ASC;
        """
        return self.execute_query(query, (days,))
    
    
    # این متد جدید را به کلاس DB اضافه کنید
    def get_components_at_production_location(self):
        """تمام محصولات موجود در کف کارگاه (برای استفاده به عنوان جزء) را برمی‌گرداند."""
        prod_loc_id = self.get_production_floor_location()
        if not prod_loc_id:
            return []
        # این کوئری دیگر فیلتر is_packed را ندارد
        return self.get_finished_goods_at_location(prod_loc_id, packed_only=False)

    def get_finished_goods_at_location(self, location_id: int, packed_only: bool = True):
        """کالاهای 'محصول نهایی' در یک لوکیشن به‌همراه واحد و parent."""
        query = """
            SELECT i.id AS item_id, i.name, i.parent_item_id,
                s.batch_no, s.qty, COALESCE(u.name,'') AS unit, s.expiry_date
            FROM stock s
            JOIN items i      ON s.item_id = i.id
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE s.location_id = %s AND i.category = %s AND s.qty > 0
        """
        params = [location_id, CATEGORY_FINAL_PRODUCT]
        if packed_only:
            query += " AND i.is_packed = TRUE"
        query += " ORDER BY i.name, s.batch_no"
        return self.execute_query(query, tuple(params))
                                                                
    # در کلاس DB
    def request_delivery_from_production(self, product_name: str, batch_no: str, quantity: float, supervisor_user_id: int, expiry_date: dt.date = None):
        with self.transaction() as cur:
            cur.execute(
                "INSERT INTO production_deliveries (product_name, production_batch_no, quantity, status, supervisor_user_id, expiry_date) "
                "VALUES (%s, %s, %s, 'تولید شده', %s, %s) RETURNING id",
                (product_name, batch_no, quantity, supervisor_user_id, expiry_date)
            )
            # --- اصلاح کلیدی: برگرداندن ID ---
            new_id = cur.fetchone()['id']
            self._log_atomic(cur, supervisor_user_id, 'REQUEST_DELIVERY', f"Product:{product_name}, Batch:{batch_no}, Qty:{quantity}")
            return new_id
                    
# در کلاس DB، این متد را با نسخه زیر جایگزین کنید
    def get_item_locations_with_stock(self, item_id: int, include_warehouses: list = None, exclude_warehouses: list = None):
        """
        نسخه نهایی و صحیح:
        لیست تمام بچ‌های یک کالا را از تمام لوکیشن‌های داخل انبارهای مشخص شده برمی‌گرداند.
        """
        query = """
            SELECT 
                l.id, 
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label, 
                s.qty, 
                s.batch_no
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0
        """
        params = [item_id]

        conditions = []
        if include_warehouses:
            # ایجاد placeholder به تعداد اعضای لیست
            placeholders = ','.join(['%s'] * len(include_warehouses))
            conditions.append(f"w.name IN ({placeholders})")
            params.extend(include_warehouses)
        
        if exclude_warehouses:
            placeholders = ','.join(['%s'] * len(exclude_warehouses))
            conditions.append(f"w.name NOT IN ({placeholders})")
            params.extend(exclude_warehouses)

        if conditions:
            query += " AND " + " AND ".join(conditions)
        
        query += " ORDER BY w.name, l.rack, s.batch_no;"
        
        return self.execute_query(query, tuple(params))
        
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def delete_items_by_ids(self, item_ids: list, user_id: int):
        """
        نسخه نهایی و امن:
        کالاها را فقط در صورتی حذف می‌کند که هیچ سابقه تاریخی یا وابستگی در هیچ ماژولی نداشته باشند.
        """
        if not item_ids:
            return

        with self.transaction() as cur:
            placeholders = ','.join(['%s'] * len(item_ids))
            
            # چک کردن وابستگی به عنوان محصول مادر (بدون تغییر)
            query_check_children = f"SELECT parent_item_id FROM items WHERE parent_item_id IN ({placeholders}) LIMIT 1"
            parent_in_use = self.execute_query(query_check_children, tuple(item_ids), fetch_one=True, cursor=cur)
            if parent_in_use:
                parent_id = parent_in_use['parent_item_id']
                parent_name_rec = self.execute_query("SELECT name FROM items WHERE id = %s", (parent_id,), fetch_one=True, cursor=cur)
                parent_name = parent_name_rec['name'] if parent_name_rec else "کالای انتخاب شده"
                raise ValueError(f"کالای «{parent_name}» قابل حذف نیست زیرا به عنوان محصول مادر برای یک یا چند پک دیگر تعریف شده است.")

            # --- *** اصلاح کلیدی: افزودن جداول فراموش شده به لیست بررسی *** ---
            tables_to_check = {
                'trans': 'تراکنش‌ها',
                'stock': 'موجودی انبار',
                'purchase_requests': 'درخواست‌های خرید',
                'purchase_order_items': 'اقلام سفارشات خرید',
                'sales_order_items': 'اقلام سفارشات فروش',
                'recipe_ingredients': 'دستورهای ساخت (BOM)'
            }
            # --- ********************************************************** ---

            for table, fa_name in tables_to_check.items():
                column = 'raw_material_item_id' if table == 'recipe_ingredients' else 'item_id'
                
                query_check = f"SELECT {column} FROM {table} WHERE {column} IN ({placeholders}) LIMIT 1"
                
                referenced_item = self.execute_query(query_check, tuple(item_ids), fetch_one=True, cursor=cur)
                
                if referenced_item:
                    item_id_with_history = referenced_item[column]
                    item_name_rec = self.execute_query("SELECT name FROM items WHERE id = %s", (item_id_with_history,), fetch_one=True, cursor=cur)
                    item_name = item_name_rec['name'] if item_name_rec else "کالای حذف شده"
                    raise ValueError(f"کالای «{item_name}» قابل حذف نیست زیرا در بخش «{fa_name}» دارای سابقه است.")

            # اگر هیچ سابقه‌ای پیدا نشد، حذف کن
            query_delete = f"DELETE FROM items WHERE id IN ({placeholders})"
            self.execute_query(query_delete, tuple(item_ids), cursor=cur)
            
            log_details = f"Deleted item IDs with no history: {item_ids}"
            self._log_atomic(cur, user_id, 'DELETE_ITEMS_SAFE', log_details)
                        
                                                                            
    def list_locations_for_warehouse(self, warehouse_name: str):
            """لیست تمام لوکیشن‌های یک انبار مشخص را برمی‌گرداند."""
            query = """
                SELECT l.id, w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label
                FROM locations l
                JOIN warehouses w ON w.id = l.warehouse_id
                WHERE w.name = %s
                ORDER BY l.id
            """
            return self.execute_query(query, (warehouse_name,))
            
            

            
            
                                
    def get_pending_voids(self):
        """نسخه جدید: تراکنش‌هایی که وضعیتشان 'در انتظار تایید ابطال' است را واکشی می‌کند."""
        query = """
            SELECT t.id, t.id as voids_trans_id, t.t_type as original_type, i.name AS item_name, t.qty 
            FROM trans AS t
            JOIN items AS i ON t.item_id = i.id
            WHERE t.status = 'در انتظار تایید ابطال'
        """
        return self.execute_query(query)            
    # ═════════════════════════════════════════════
    #         توابع جدید برای مدیریت نقش‌ها
    # ═════════════════════════════════════════════
# در کلاس DB، این متد را جایگزین کنید

    def get_all_roles(self):
        """
        تمام نقش‌های تعریف شده در سیستم را برمی‌گرداند.
        نسخه نهایی: از ابزار استاندارد execute_query استفاده می‌کند.
        """
        return self.execute_query("SELECT id, name FROM roles ORDER BY name")
    
    def get_all_permissions(self):
        """تمام دسترسی‌های ممکن در سیستم را برمی‌گرداند."""
        return self.execute_query("SELECT id, code, description FROM permissions ORDER BY code")

    def get_permissions_for_role(self, role_id: int):
        """تمام IDهای دسترسی برای یک نقش خاص را برمی‌گرداند."""
        rows = self.execute_query("SELECT permission_id FROM role_permissions WHERE role_id = %s", (role_id,))
        return [row['permission_id'] for row in rows]

# در کلاس DB، این متد را جایگزین کنید

    def add_role(self, role_name: str):
        """یک نقش جدید به سیستم به صورت اتمیک اضافه می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "INSERT INTO roles (name) VALUES (%s) ON CONFLICT (name) DO NOTHING",
                (role_name,),
                cursor=cur
            )
            
    def check_role_in_use(self, role_id: int):
            """
            بررسی می‌کند که آیا یک نقش به کاربری اختصاص یافته یا خیر و لیست کاربران را برمی‌گرداند.
            """
            # **FIX**: استفاده از تابع صحیح execute_query به جای _execute
            users_with_role = self.execute_query("SELECT username FROM users WHERE role_id = %s", (role_id,))
            
            if users_with_role:
                # اگر کاربری وجود داشت، لیست نام‌هایشان را برگردان
                return [u['username'] for u in users_with_role]
            # اگر هیچ کاربری نبود، None برگردان
            return None
    
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def delete_role(self, role_id: int):
        """یک نقش را به صورت اتمیک حذف می‌کند."""
        # ابتدا بررسی می‌کنیم که آیا نقشی به کاربری اختصاص یافته یا خیر
        users_in_role = self.check_role_in_use(role_id)
        if users_in_role:
            user_list = ", ".join(users_in_role)
            # اگر نقش در حال استفاده بود، یک خطای واضح به لایه بالاتر ارسال می‌کنیم
            raise ValueError(f"این نقش به کاربران زیر تخصیص یافته و قابل حذف نیست: {user_list}")

        with self.transaction() as cur:
            # به لطف ON DELETE CASCADE در جدول role_permissions،
            # با حذف نقش، تمام دسترسی‌های مرتبط با آن نیز حذف می‌شوند.
            self.execute_query("DELETE FROM roles WHERE id = %s", (role_id,), cursor=cur)
                            
# در کلاس DB، این متد را با نسخه نهایی و قطعی زیر جایگزین کنید
    def update_permissions_for_role(self, role_id: int, permission_ids: list):
        """
        نسخه نهایی و استاندارد (V2.0):
        - از context manager استاندارد برنامه برای تضمین ثبت قطعی تغییرات استفاده می‌کند.
        """
        try:
            with self.transaction() as cur:
                # گام ۱: حذف دسترسی‌های قدیمی
                cur.execute("DELETE FROM role_permissions WHERE role_id = %s", (role_id,))
                
                # گام ۲: افزودن دسترسی‌های جدید
                if permission_ids:
                    args_list = [(role_id, perm_id) for perm_id in permission_ids]
                    cur.executemany(
                        "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s)",
                        args_list
                    )
            print(f"SUCCESS: Permissions for role_id {role_id} transaction block finished.")
        except Exception as e:
            print(f"ERROR during permission update. Transaction should have rolled back. Reason: {e}")
            # خطا را دوباره ارسال می‌کنیم تا به کاربر نمایش داده شود
            raise e
        
        
    def get_item_locations_in_warehouse(self, item_id: int, warehouse_name: str):
        """لیست و موجودی لوکیشن‌هایی که یک کالا در یک انبار خاص دارد را برمی‌گرداند."""
        query = """
            SELECT l.id, w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS loc_label, s.qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND s.qty > 0 AND w.name = %s
            ORDER BY l.rack, l.shelf, l.bin;
        """
        return self.execute_query(query, (item_id, warehouse_name))
    
                                                
                                                                    
    
    def get_packed_batches_in_location(self, location_id: int):
        """
        لیست تمام بچ‌های محصولات بسته‌بندی شده که در یک لوکیشن خاص موجودی دارند را برمی‌گرداند.
        """
        query = """
            SELECT s.batch_no, i.name, s.qty
            FROM stock s
            JOIN items i ON s.item_id = i.id
            WHERE s.location_id = %s AND i.is_packed = TRUE AND s.qty > 0
            ORDER BY s.id DESC;
        """
        return self.execute_query(query, (location_id,))
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def submit_material_request(self, item_id: int, requested_qty: float, requester_id: int, notes: str = ''):
        """
        نسخه نهایی و هوشمند:
        - کمبود موجودی را مدیریت کرده و خطا ایجاد نمی‌کند.
        - سیگنال لازم برای رفرش شدن برنامه را ارسال می‌کند.
        """
        with self.transaction() as cur:
            # این کوئری برای بررسی موجودی، باید فقط انبارهای غیرتولیدی را در نظر بگیرد
            query_check = """
                SELECT COALESCE(SUM(s.qty), 0) as total_available
                FROM stock s JOIN locations l ON s.location_id = l.id JOIN warehouses w ON l.warehouse_id = w.id
                WHERE s.item_id = %s AND w.name != %s;
            """
            cur.execute(query_check, (item_id, PRODUCTION_WAREHOUSE_NAME))
            available_qty = cur.fetchone()['total_available']

            # اگر موجودی انبار اصلی کمتر از نیاز بود، به کاربر اطلاع می‌دهیم اما درخواست را ثبت می‌کنیم
            if available_qty < requested_qty:
                notes += f" | توجه: موجودی انبار اصلی ({available_qty}) از مقدار درخواستی کمتر است. نیازمند تامین."

            cur.execute(
                """INSERT INTO material_requests (item_id, requested_qty, requester_user_id, status, created_at, notes)
                   VALUES (%s, %s, %s, %s, NOW(), %s) RETURNING id""",
                (item_id, requested_qty, requester_id, TransactionStatus.MR_PENDING.value, notes)
            )
            request_id = cur.fetchone()['id']
            self._log_atomic(cur, requester_id, 'SUBMIT_MATERIAL_REQUEST', f"Request ID:{request_id}")
            
            # ارسال سیگنال برای رفرش شدن تمام بخش‌های برنامه
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            
            return request_id        
            
# در کلاس DB، این متد را جایگزین کنید
    def get_pending_material_requests(self):
        """لیست تمام درخواست‌های مواد اولیه که در وضعیت انتظار یا نیازمند بازبینی هستند را برمی‌گرداند."""
        query = """
            SELECT 
                mr.id,
                mr.item_id,
                i.name as item_name,
                mr.requested_qty,
                u.username as requester_name,
                mr.created_at,
                mr.status, -- <-- ستون وضعیت برای نمایش در UI اضافه شد
                mr.notes   -- <-- ستون یادداشت‌ها برای نمایش دلیل بازبینی اضافه شد
            FROM material_requests mr
            JOIN items i ON mr.item_id = i.id
            JOIN users u ON mr.requester_id = u.id -- <<< --- اصلاح کلیدی اینجاست
            WHERE mr.status IN (%s, %s) -- <-- شرط کلیدی برای خواندن هر دو وضعیت
            ORDER BY mr.created_at ASC;
        """
        # --- اصلاح کلیدی: ارسال هر دو وضعیت به کوئری ---
        return self.execute_query(query, (TransactionStatus.MR_PENDING.value, TransactionStatus.MR_REWORK_WAREHOUSE.value))    
        
    def get_request_history_for_user(self, user_id: int):
        """تاریخچه تمام درخواست‌های ثبت شده توسط یک کاربر خاص را برمی‌گرداند."""
        query = """
            SELECT 
                mr.id, i.name as item_name, mr.requested_qty, mr.status, 
                mr.created_at, mr.processed_at, mr.notes
            FROM material_requests mr
            JOIN items i ON mr.item_id = i.id
            WHERE mr.requester_user_id = %s
            ORDER BY mr.id DESC;
        """
        return self.execute_query(query, (user_id,))    
        
    def fulfill_material_request(self, request_id: int, user_id: int, trans_data: dict):
            """
            نسخه نهایی و ادغام شده:
            - از transaction manager امن برای مدیریت عملیات استفاده می‌کند.
            - تاریخ تراکنش (t_date) را به درستی ثبت می‌کند تا در محاسبات مصرف لحاظ شود.
            """
            with self.transaction() as cur:
                # گام ۱: کسر موجودی از انبار مبدا (منطق شما)
                self._upd_stock(
                    cur, 
                    trans_data['item_id'], 
                    trans_data['src_loc_id'], 
                    -abs(trans_data['qty']), 
                    trans_data['batch_no'], 
                    trans_data.get('expiry_date')
                )

                # گام ۲: ثبت تراکنش با وضعیت جدید و تاریخ صحیح
                cur.execute(
                    """INSERT INTO trans (item_id, t_type, t_no, qty, notes, user_id, src_loc, dest_loc, status, batch_no, expiry_date, t_date)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW()) RETURNING id""",
                    (
                        trans_data['item_id'], 
                        'خروج به تولید', 
                        trans_data['doc_no'], 
                        trans_data['qty'], 
                        trans_data['notes'], 
                        user_id, 
                        trans_data['src_loc_id'], 
                        self.get_production_floor_location(), 
                        TransactionStatus.PENDING_PRODUCTION_APPROVAL.value, 
                        trans_data['batch_no'], 
                        trans_data.get('expiry_date')
                    )
                )
                trans_id = cur.fetchone()['id']
                
                # گام ۳: آپدیت خود درخواست مواد اولیه (منطق شما)
                notes = f"این درخواست طی تراکنش خروج به تولید با شماره ID {trans_id} انجام شد."
                cur.execute(
                    "UPDATE material_requests SET status='FULFILLED', processed_by_user_id=%s, processed_at=NOW(), notes=%s WHERE id=%s",
                    (user_id, notes, request_id)
                )
                
                # گام ۴: ثبت لاگ (منطق شما)
                self._log_atomic(cur, user_id, 'INITIATE_TRANSFER', f"trans_id:{trans_id} for request:{request_id}")
                
                return trans_id
        
# در کلاس DB، این متد جدید را اضافه کنید
    def get_pending_transfers_to_production(self):
        """تمام تراکنش‌های خروج به تولید که منتظر تایید سرپرست تولید هستند را برمی‌گرداند."""
        query = """
            SELECT
                t.id, i.name as item_name, t.t_no, t.qty, u.username as requester, t.t_date, t.batch_no
            FROM trans t
            JOIN items i ON t.item_id = i.id
            JOIN users u ON t.user_id = u.id
            WHERE t.status = 'در انتظار تایید تولید'
            ORDER BY t.id DESC;
        """
        return self.execute_query(query)

    def finalize_transfer_to_production(self, request_id: int, approver_user_id: int, notes: str = ''):
        """
        تایید نهایی «خروج به تولید».
        """
        with self.transaction() as cur:
            rows = self.execute_query(
                """
                SELECT t.id, t.item_id, t.qty, t.src_loc, t.dest_loc, t.batch_no, t.expiry_date, t.t_no
                FROM trans t
                WHERE t.t_type = %s
                AND t.status = %s
                AND EXISTS (
                        SELECT 1
                        FROM material_requests mr
                        WHERE mr.id = %s
                        AND mr.request_no = t.t_no
                )
                """,
                (TransactionType.EXIT_TO_PROD.value, TransactionStatus.PENDING_PRODUCTION_APPROVAL.value, request_id),
                cursor=cur
            ) or []

            if not rows:
                raise ValueError("هیچ تراکنش در انتظار تاییدِ تولید برای این درخواست پیدا نشد.")

            for r in rows:
                self.execute_query(
                    "UPDATE trans SET status=%s, approved_by=%s, approved_at=NOW(), notes=COALESCE(notes,'') || %s WHERE id=%s",
                    (TransactionStatus.APPROVED.value, approver_user_id, f"\n[تایید تولید] {notes or ''}", r['id']),
                    cursor=cur
                )

            self.execute_query(
                "UPDATE material_requests SET status=%s, processed_by_user_id=%s, processed_at=NOW(), notes=COALESCE(notes,'') || %s WHERE id=%s",
                (TransactionStatus.MR_DELIVERED_TO_PROD.value, approver_user_id, "\n[مواد تحویل خط تولید شد]", request_id),
                cursor=cur
            )
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

        # شلیک رویدادها پس از commit (با context_data)
        for r in rows:
            self.trigger_event(
                'STOCK_TRANSACTION_APPROVED',
                r['id'],
                'trans',
                approver_user_id,
                context_data={
                    't_type': TransactionType.EXIT_TO_PROD.value,
                    't_no': r['t_no'],
                    'qty': r['qty'],
                    'src_loc': r['src_loc'],
                    'dest_loc': r['dest_loc'],
                    'item_id': r['item_id'],
                    'batch_no': r['batch_no'],
                    'expiry_date': str(r['expiry_date']) if r['expiry_date'] else None
                }
            )

                            
    def register_pending_delivery(self, product_name: str, batch_no: str, quantity: float, supervisor_user_id: int, expiry_date: dt.date):
            """
            نسخه 3.0:
            - تاریخ انقضا را به عنوان یک پارامتر از پیش محاسبه شده دریافت می‌کند.
            """
            with self._conn() as conn:
                cur = conn.cursor()
                cur.execute(
                    "INSERT INTO production_deliveries "
                    "(product_name, production_batch_no, quantity, status, supervisor_user_id, expiry_date) "
                    "VALUES (%s, %s, %s, 'تولید شده', %s, %s)",
                    (product_name, batch_no, quantity, supervisor_user_id, expiry_date)
                )
                conn.commit()
                            
    def reject_delivery(self, delivery_id: int, reason: str, rejecting_user_id: int):
            """
            نسخه 3.0 (امن‌تر):
            - ابتدا درخواست را واکشی و قفل کرده و وضعیت آن را در پایتون چک می‌کند.
            - سپس موجودی را بازگردانده و وضعیت را آپدیت می‌کند.
            """
            with self.transaction() as cur:
                # گام ۱: اطلاعات کامل تحویل را برای بازگرداندن موجودی، واکشی و قفل کن
                cur.execute(
                    "SELECT * FROM production_deliveries WHERE id = %s FOR UPDATE",
                    (delivery_id,)
                )
                delivery = cur.fetchone()
                
                # گام ۲: وضعیت را در پایتون چک کن
                if not delivery or delivery['status'] != 'در انتظار تایید انبار':
                    raise ValueError("این درخواست دیگر معتبر نیست یا قبلاً پردازش شده است.")

                # گام ۳: پیدا کردن ID محصول و لوکیشن تولید
                # (get_item_by_name از کوئری SELECT استفاده می‌کند و نیاز به cursor ندارد)
                item_info = self.get_item_by_name(delivery['product_name'])
                if not item_info:
                    raise ValueError(f"کالای مربوط به این تحویل ({delivery['product_name']}) یافت نشد.")
                
                item_id = item_info['id']
                prod_loc_id = self.get_production_floor_location()
                if not prod_loc_id:
                    raise ValueError("انبار تولید در سیستم تعریف نشده است.")

                # گام ۴: بازگرداندن موجودی به انبار تولید
                self._upd_stock(
                    cur, 
                    item_id=item_id, 
                    location_id=prod_loc_id, 
                    qty_change=abs(delivery['quantity']), # افزایش موجودی
                    batch_no=delivery['production_batch_no'],
                    expiry_date=delivery.get('expiry_date')
                )

                # گام ۵: به‌روزرسانی وضعیت درخواست تحویل به "رد شده"
                cur.execute(
                    """UPDATE production_deliveries 
                    SET status = 'رد شده', 
                        rejection_reason = %s, 
                        rejected_by_user_id = %s, 
                        rejected_at = NOW()
                    WHERE id = %s""", # حالا دیگر نیازی به چک کردن وضعیت در WHERE نیست
                    (reason, rejecting_user_id, delivery_id)
                )
                
                self._log_atomic(cur, rejecting_user_id, 'REJECT_DELIVERY', f"DeliveryID:{delivery_id}, Reason:{reason}")
                self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

                                                                
                        
    def consume_materials_for_production(self, recipe_id: int, production_batch_no: str, consumption_plan: dict, user_id: int):
        """مواد اولیه را از انبار تولید کسر کرده و در BOM با تاریخ انقضای صحیح ثبت می‌کند."""
        prod_loc_id = self.get_production_floor_location()
        if not prod_loc_id:
            raise ValueError("خطا: لوکیشن 'کف کارگاه' تعریف نشده است.")

        with self._conn() as conn:
            with conn.cursor() as cur:
                try:
                    for material_name, batches_to_consume in consumption_plan.items():
                        for batch_info in batches_to_consume:
                            item_id_to_consume = batch_info['item_id']
                            qty_to_consume = batch_info['qty_to_consume']
                            material_batch_no = batch_info['batch_no']
                            # --- اصلاح کلیدی: دریافت تاریخ انقضا ---
                            material_expiry_date = batch_info.get('expiry_date')

                            # حالا cursor و expiry_date را به _upd_stock پاس می‌دهیم
                            self._upd_stock(cur, item_id_to_consume, prod_loc_id, -abs(qty_to_consume), material_batch_no, material_expiry_date)
                            
                            cur.execute(
                                """
                                INSERT INTO bill_of_materials (product_code, raw_item_id, raw_batch, qty, ts, user_id, recipe_id)
                                VALUES (%s, %s, %s, %s, NOW(), %s, %s)
                                """,
                                (production_batch_no, item_id_to_consume, material_batch_no, qty_to_consume, user_id, recipe_id)
                            )
                    conn.commit()
                except (Exception, psycopg2.Error) as error:
                    conn.rollback()
                    raise error                                    
                        
                
        
# این متد جدید را به کلاس DB خود اضافه کنید

    def list_bom_files(self, bom_id: int):
        """لیست تمام فایل‌های پیوست شده به یک رکورد BOM را برمی‌گرداند."""
        # ما از متد execute_query که از قبل وجود دارد، استفاده می‌کنیم
        return self.execute_query(
            "SELECT id, path FROM bom_files WHERE bom_id = %s ORDER BY id",
            (bom_id,)
        )
        
        
    # در کلاس DB، این متد را برای خواندن تاریخ انقضا اصلاح کنید
    def get_available_batches_for_item(self, item_id: int, location_id: int) -> list:
        """
        تمام بچ‌های موجود یک کالا در یک لوکیشن خاص را به همراه موجودی و تاریخ انقضا برمی‌گرداند.
        ***اصلاح کلیدی: این تابع حالا فقط بچ‌هایی را برمی‌گرداند که وضعیت قابل مصرف دارند.***
        """
        query = """
            SELECT id as stock_id, item_id, batch_no, qty, expiry_date 
            FROM stock 
            WHERE item_id = %s 
            AND location_id = %s 
            AND qty > 0.001
            AND status IN ('تایید شده', 'قرنطینه') -- <<-- شرط جدید و کلیدی برای جلوگیری از خطا
            ORDER BY expiry_date ASC NULLS LAST, id ASC;
        """
        return self.execute_query(query, (item_id, location_id))    
            
# این متد جدید را به کلاس DB اضافه کنید
    def item_exists(self, item_name: str, exclude_id: int = None) -> bool:
        """
        بررسی می‌کند که آیا کالایی با نام مشخص در دیتابیس وجود دارد یا خیر.
        در حالت ویرایش، می‌توان ID کالای فعلی را مستثنی کرد.
        """
        with self._conn() as conn:
            with conn.cursor() as cur:
                query = "SELECT id FROM items WHERE name = %s"
                params = [item_name]
                if exclude_id is not None:
                    query += " AND id != %s"
                    params.append(exclude_id)
                
                cur.execute(query, tuple(params))
                return cur.fetchone() is not None
                        
# In the DB class

    def factory_reset(self):
            """
            نسخه نهایی و جامع: تمام داده‌های کاربری از تمام جداول را پاک می‌کند.
            فقط جداول کاربران و نقش‌ها باقی می‌مانند.
            """
            # --- لیست کامل جداول برای پاکسازی ---
            tables_to_truncate = [
                'audit', 'asset_trans_files', 'asset_trans', 'assets',
                'bom_files', 'bill_of_materials', 'recipe_ingredients', 'recipes',
                'form_entries', 'form_fields', 'form_defs',
                'inventory_count_items', 'inventory_counts',
                'material_requests', 'production_deliveries', 'trans_files', 'stock', 'trans',
                'items', 'locations', 'warehouses', 'units'
            ]
            
            with self.transaction() as cur:
                print("--- FACTORY RESET INITIATED ---")
                for table in tables_to_truncate:
                    try:
                        # دستور CASCADE تضمین می‌کند که وابستگی‌ها نیز مدیریت شوند
                        print(f"Truncating table: {table}")
                        cur.execute(f"TRUNCATE TABLE {table} RESTART IDENTITY CASCADE;")
                    except psycopg2.Error as e:
                        print(f"Could not truncate table {table}. It might not exist. Error: {e}")
                
                # پاک کردن تنظیمات به جز رمز ریست
                cur.execute("DELETE FROM app_settings WHERE key != 'factory_reset_password_hash'")
                print("Truncating table: app_settings (partial)")

            # راه‌اندازی مجدد داده‌های اولیه
            print("Re-initializing default data...")
            self._init_db()
                
# این سه متد جدید را به انتهای کلاس DB اضافه کنید

# در کلاس DB، این متد را جایگزین کنید

    def add_asset_file(self, asset_trans_id: int, path: str):
        """یک فایل پیوست به یک تراکنش دارایی به صورت اتمیک اضافه می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "INSERT INTO asset_trans_files(asset_trans_id, path) VALUES (%s, %s)",
                (asset_trans_id, path),
                cursor=cur
            )
            
            
    def list_asset_files(self, asset_trans_id: int):
        """لیست تمام فایل‌های پیوست یک تراکنش دارایی را برمی‌گرداند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, path FROM asset_trans_files WHERE asset_trans_id=%s", (asset_trans_id,))
                return cur.fetchall()

    def delete_asset_file(self, file_id: int):
        """یک فایل پیوست دارایی را حذف می‌کند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM asset_trans_files WHERE id=%s", (file_id,))
            conn.commit()
            
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def log_asset_event(self, asset_id: int, t_type: str, notes: str, t_no: str, user_id: int):
        """
        نسخه 2.0:
        - یک رویداد برای دارایی ثبت می‌کند و وضعیت آن را به‌روز می‌کند.
        - پس از تغییر، رویداد ASSET_STATUS_CHANGED را اعلام می‌کند.
        """
        new_status_map = {
            "خروج (تعمیرات)": AssetStatus.OUT_FOR_REPAIR.value,
            "خروج (پروژه)": AssetStatus.OUT_FOR_PROJECT.value,
            "بازگشت به انبار": AssetStatus.IN_STOCK.value,
            "اسقاط": AssetStatus.SCRAPPED.value,
            "تحویل به پرسنل": AssetStatus.ASSIGNED.value
        }
        new_status = new_status_map.get(t_type)
        
        with self.transaction() as cur:
            asset = self.execute_query("SELECT status FROM assets WHERE id = %s FOR UPDATE", (asset_id,), fetch_one=True, cursor=cur)
            if not asset: raise ValueError("دارایی مورد نظر یافت نشد.")

            if t_type != 'بازگشت به انبار' and asset['status'] != AssetStatus.IN_STOCK.value:
                if asset['status'] != AssetStatus.ASSIGNED.value or t_type == 'تحویل به پرسنل':
                     raise ValueError(f"این دارایی با وضعیت '{asset['status']}' در انبار موجود نیست و این عملیات روی آن مجاز نیست.")

            trans_id = self.execute_query(
                """INSERT INTO asset_trans (asset_id, t_type, t_no, t_date, notes, user_id)
                   VALUES (%s, %s, %s, NOW(), %s, %s) RETURNING id""",
                (asset_id, t_type, t_no, notes, user_id),
                fetch_one=True, cursor=cur
            )['id']
            
            if new_status:
                self.execute_query("UPDATE assets SET status = %s WHERE id = %s", (new_status, asset_id), cursor=cur)

            self._log_atomic(cur, user_id, 'ASSET_EVENT', f"AssetID:{asset_id}, Type:{t_type}")

        # --- بخش جدید: اعلام رویداد پس از اتمام موفق تراکنش ---
        if new_status:
            event_context = {'asset_id': asset_id, 'trans_id': trans_id, 'new_status': new_status, 't_type': t_type, 'user_id': user_id}
            self.trigger_event(
                event_name='ASSET_STATUS_CHANGED',
                record_id=asset_id,
                table_name='assets',
                user_id=user_id,
                context_data=event_context
            )
                                
        
    def get_asset_details(self, asset_id: int):
        """جزئیات کامل یک دارایی را بر اساس ID آن برمی‌گرداند."""
        return self.execute_query("SELECT * FROM assets WHERE id = %s", (asset_id,), fetch_one=True)
    
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def apply_inventory_adjustments(self, count_id: int, user_id: int, discrepancies_with_reasons: list, doc_no: str):
        """
        نسخه 2.2:
        - پس از ثبت تمام اصلاحیه‌ها، یک رویداد INVENTORY_ADJUSTMENT_APPLIED را اعلام می‌کند.
        """
        with self.transaction() as cur:
            now_utc = datetime.now(dt.timezone.utc)
            if not doc_no:
                doc_no = f"COUNT-{count_id}"
            
            total_discrepancy_value = 0
            
            for item in discrepancies_with_reasons:
                item_details = self.get_item_details(item['item_id'])
                item_cost = item_details.get('cost', 0) if item_details else 0
                total_discrepancy_value += abs(item['adjustment_qty'] * item_cost)
                
                adjustment_qty = item['adjustment_qty']
                if abs(adjustment_qty) < 1e-9: continue
                
                t_type = 'اضافه شدنی انبارگردانی' if adjustment_qty > 0 else 'کسری انبارگردانی'
                trans_note = f"{t_type} طبق سند {doc_no}. دلیل: {item['reason']}"
                
                cur.execute("""INSERT INTO trans 
                                (item_id, t_type, t_no, t_date, qty, notes, user_id, status, src_loc, dest_loc, batch_no, expiry_date)
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) 
                                RETURNING id""",
                            (item['item_id'], t_type, doc_no, now_utc, adjustment_qty, trans_note, 
                             user_id, TransactionStatus.APPROVED.value, 
                             item['location_id'] if adjustment_qty < 0 else None,
                             item['location_id'] if adjustment_qty > 0 else None,
                             item['batch_no'], item.get('expiry_date')))
                
                trans_id = cur.fetchone()['id']
                self._upd_stock(cur, item['item_id'], item['location_id'], adjustment_qty, item['batch_no'], item.get('expiry_date'))
            
            cur.execute("UPDATE inventory_counts SET status = 'APPROVED', finalized_by = %s, finalized_at = %s WHERE id = %s",
                        (user_id, now_utc, count_id))
            
            self._log_atomic(cur, user_id, 'INVENTORY_APPROVAL', f"Approved inventory count {count_id} with doc no {doc_no}")
        
        # --- بخش جدید: اعلام رویداد پس از اتمام موفق تراکنش ---
        event_context = {'count_id': count_id, 'doc_no': doc_no, 'total_discrepancy_value': total_discrepancy_value, 'user_id': user_id}
        self.trigger_event(
            event_name='INVENTORY_ADJUSTMENT_APPLIED',
            record_id=count_id,
            table_name='inventory_counts',
            user_id=user_id,
            context_data=event_context
        )
                                                                    
                
    # این متد را به کلاس DB اضافه کنید
    def reject_material_return(self, trans_id: int, user_id: int, reason: str):
        """یک درخواست برگشت مواد را رد می‌کند."""
        with self.transaction() as cur:
            notes = f"درخواست توسط انباردار رد شد. دلیل: {reason}"
            cur.execute(
                "UPDATE trans SET status = 'رد شده', approved_by=%s, approved_at=NOW(), notes=%s WHERE id=%s AND status='در انتظار تایید انبار'",
                (user_id, notes, trans_id)
            )
            if cur.rowcount == 0:
                raise ValueError("این درخواست معتبر نیست یا قبلاً پردازش شده است.")
            self._log_atomic(cur, user_id, 'REJECT_RETURN', f"Rejected return for trans_id:{trans_id}")
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

                
# این متد جدید را به کلاس DB اضافه کنید
    def _run_migration_v2_0(self, cur):
        """
        یک اسکریپت یک‌بار مصرف برای اصلاح ساختار جدول stock.
        محدودیت UNIQUE را طوری تغییر می‌دهد که تاریخ انقضا را نیز شامل شود.
        """
        try:
            print("MIGRATION V2.0: Attempting to modify UNIQUE constraint on 'stock' table...")
            # ابتدا محدودیت قدیمی را حذف می‌کنیم (اگر وجود داشته باشد)
            # نام محدودیت معمولاً به صورت table_name_column_names_key است.
            cur.execute("ALTER TABLE stock DROP CONSTRAINT IF EXISTS stock_item_id_location_id_batch_no_key;")
            
            # سپس محدودیت جدید و صحیح را اضافه می‌کنیم
            cur.execute("ALTER TABLE stock ADD CONSTRAINT stock_item_id_location_id_batch_no_expiry_date_key UNIQUE (item_id, location_id, batch_no, expiry_date);")
            
            print("SUCCESS: UNIQUE constraint on 'stock' table updated to include expiry_date.")
        except Exception as e:
            # اگر خطایی رخ داد، به این معنی است که احتمالاً محدودیت به شکل دیگری نامگذاری شده یا مشکلی وجود دارد
            print(f"INFO: Could not automatically modify constraint on 'stock'. This might be okay if it was already updated. Error: {e}")
            pass # از خطا رد می‌شویم تا برنامه متوقف نشود
        
    # این متد جدید را به کلاس DB اضافه کنید
    def request_material_return(self, component_data: dict, qty_to_return: float, reason: str, user_id: int):
        """یک درخواست برای بازگرداندن مواد اولیه از تولید به انبار ثبت می‌کند."""
        with self.transaction() as cur:
            # یک تراکنش با نوع جدید و وضعیت "در انتظار تایید" ایجاد می‌کنیم
            cur.execute(
                """INSERT INTO trans (item_id, t_type, qty, notes, user_id, status, src_loc, batch_no, expiry_date)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)""",
                (
                    component_data['item_id'], 'برگشت از تولید', qty_to_return, reason, user_id,
                    'در انتظار تایید انبار', self.get_production_floor_location(),
                    component_data['batch_no'], component_data.get('expiry_date')
                )
            )
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

            
    # این متد جدید را به کلاس DB اضافه کنید
    def get_all_user_initiated_requests(self, user_id: int):
        """تمام درخواست‌های ثبت شده توسط یک کاربر (چه درخواست مواد و چه برگشت) را برمی‌گرداند."""
        query = """
        (SELECT 
            id, 
            item_id, 
            requested_qty as qty, 
            requester_user_id as user_id, 
            status, 
            created_at, 
            processed_at, 
            notes,
            'درخواست مواد' as request_type 
        FROM material_requests 
        WHERE requester_user_id = %s)
        UNION ALL
        (SELECT 
            id, 
            item_id, 
            qty, 
            user_id, 
            status, 
            t_date as created_at, 
            approved_at as processed_at, 
            notes,
            'برگشت مواد' as request_type
        FROM trans 
        WHERE user_id = %s AND t_type = 'برگشت از تولید')
        ORDER BY created_at DESC;
        """
        # ما user_id را دو بار به عنوان پارامتر ارسال می‌کنیم، یک بار برای هر SELECT
        return self.execute_query(query, (user_id, user_id))
    
    
# در کلاس DB، این متد را با نسخه اصلاح شده جایگزین کنید
    def void_production_batch(self, product_batch_no: str, user_id: int, reason: str):
        """نسخه نهایی (معماری صحیح): بچ تولید را باطل کرده و دلیل آن را در ستون صحیح ثبت می‌کند."""
        with self.transaction() as cur:
            cur.execute("SELECT * FROM bill_of_materials WHERE product_code = %s AND status = 'ACTIVE'", (product_batch_no,))
            bom_entries = cur.fetchall()
            if not bom_entries: raise ValueError(f"هیچ گزارش مصرف فعالی برای بچ تولید '{product_batch_no}' یافت نشد.")

            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id: raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # برگرداندن موجودی مواد اولیه
            for entry in bom_entries:
                self._upd_stock(cur, item_id=entry['raw_item_id'], location_id=prod_loc_id, qty_change=abs(entry['qty']), batch_no=entry['raw_batch'], expiry_date=entry.get('raw_material_expiry_date'))
            
            # --- اصلاح کلیدی: استفاده از ستون rejection_reason به جای notes ---
            update_note = f"ابطال توسط کاربر {user_id}: {reason}"
            cur.execute(
                "UPDATE production_deliveries SET status = 'باطل شده', rejection_reason = %s WHERE production_batch_no = %s AND status = 'تولید شده'",
                (update_note, product_batch_no)
            )
            if cur.rowcount == 0:
                raise ValueError("این بچ تولیدی یافت نشد یا قبلا مصرف/تحویل شده و قابل ابطال نیست.")

            # باطل کردن ردیف‌های مصرف در جدول BOM
            bom_ids_to_void = [entry['id'] for entry in bom_entries]
            if bom_ids_to_void:
                placeholders = ','.join(['%s'] * len(bom_ids_to_void))
                cur.execute(f"UPDATE bill_of_materials SET status = 'باطل شده' WHERE id IN ({placeholders})", tuple(bom_ids_to_void))
            
            self._log_atomic(cur, user_id, 'VOID_PRODUCTION_BATCH', f"ابطال کامل بچ تولید: {product_batch_no}. دلیل: {reason}")
                        
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def void_packing_operation(self, packed_product_batch_no: str, user_id: int, reason: str):
        """
        نسخه نهایی و امن (V2):
        - با افزودن یک شرط به کوئری، از بروز خطا به دلیل وجود لاگ‌های قدیمی و غیر JSON جلوگیری می‌کند.
        - عملیات بسته‌بندی را باطل کرده و موجودی تمام اجزا را به درستی برمی‌گرداند.
        """
        with self.transaction() as cur:
            # گام ۱: پیدا کردن لاگ عملیات اصلی با یک کوئری امن
            # --- اصلاح کلیدی: افزودن شرط `details LIKE '{%%}'` ---
            # این شرط تضمین می‌کند که فقط رکوردهایی که ساختار JSON دارند، پردازش شوند.
            cur.execute("""
                SELECT id, details FROM audit 
                WHERE action LIKE 'PACKING_EVENT%%' 
                  AND details LIKE '{%%}' 
                  AND (details::jsonb) #>> '{output_product,batch}' = %s 
                ORDER BY id DESC LIMIT 1
            """, (packed_product_batch_no,))
            audit_log = cur.fetchone()
            if not audit_log:
                raise ValueError(f"هیچ عملیات بسته‌بندی قابل ابطالی با بچ «{packed_product_batch_no}» یافت نشد. (ممکن است سوابق قدیمی فاقد جزئیات باشند)")

            packing_data = json.loads(audit_log['details'])
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id: raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # گام ۲: بازگرداندن موجودی محصول نهایی بسته‌بندی شده
            output_product = packing_data['output_product']
            output_item_info = self.get_item_by_name(output_product['name'])
            if output_item_info:
                expiry_date_str = output_product.get('expiry_date')
                expiry_date = dt.date.fromisoformat(expiry_date_str) if expiry_date_str and expiry_date_str != 'None' else None
                self._upd_stock(cur, item_id=output_item_info['id'], location_id=prod_loc_id, qty_change=-abs(output_product['qty']), batch_no=output_product['batch'], expiry_date=expiry_date)

            # گام ۳: بازگرداندن موجودی محصولات فله مصرف شده
            for component in packing_data.get('components', []):
                cur.execute(
                    "UPDATE production_deliveries SET quantity = quantity + %s, status = 'تولید شده' WHERE id = %s",
                    (abs(component['qty_to_consume']), component['delivery_id'])
                )

            # گام ۴: بازگرداندن موجودی لوازم بسته‌بندی
            packaging_bom = self.get_bom_for_product(output_product['name'])
            if packaging_bom:
                for supply in packaging_bom:
                    total_needed = supply['quantity'] * output_product['qty']
                    self._upd_stock(cur, item_id=supply['component_item_id'], location_id=prod_loc_id, qty_change=abs(total_needed), batch_no=f"VOID-RETURN-{packed_product_batch_no}", ignore_batch_check=True)

            # گام ۵: ثبت لاگ حسابرسی برای عملیات ابطال
            self._log_atomic(cur, user_id, 'VOID_PACKING_EVENT', f"ابطال بسته‌بندی برای بچ محصول: {packed_product_batch_no}. دلیل: {reason}")

# این متد را در کلاس DB به طور کامل جایگزین کنید
    def get_actionable_notifications(self, permissions: set, user_id: int, role_name: str):
        """
        یک لیست کامل از تمام موارد نیازمند اقدام را برمی‌گرداند.
        نسخه نهایی: برای ادمین، اعلان کلی نامه‌های سیستم را نیز نمایش می‌دهد.
        """
        notifications = []
        
        # --- *** بخش جدید و هوشمند برای اعلان نامه‌ها *** ---
        if role_name == 'Admin':
            # ادمین تعداد کل نامه‌های خوانده نشده در سیستم را می‌بیند
            total_unread = self.execute_query("SELECT COUNT(*) as count FROM memo_recipients WHERE read_at IS NULL", fetch_one=True)['count']
            if total_unread > 0:
                 notifications.append({
                    "type": "نامه داخلی (کل سیستم)", "priority": 3,
                    "details": f"در کل سیستم {total_unread} نامه جدید خوانده نشده وجود دارد.",
                    "date": datetime.now(), "action_key": "VIEW_COMMUNICATIONS", "action_data": None
                })
        else:
            # کاربران عادی فقط اعلان نامه‌های خودشان را می‌بینند
            unread_memos_count = self.get_unread_memos_count(user_id)
            if unread_memos_count > 0:
                notifications.append({
                    "type": "نامه داخلی", "priority": 3,
                    "details": f"شما {unread_memos_count} نامه جدید خوانده نشده دارید.",
                    "date": datetime.now(), "action_key": "VIEW_COMMUNICATIONS", "action_data": None
                })
        # --- ****************************************** ---

        # (بقیه منطق اعلان‌ها بدون تغییر باقی می‌ماند)
        if 'qa:approve_workflows' in permissions:
            pending_approvals = self.get_pending_workflows_for_approval()
            for pa in pending_approvals:
                notifications.append({"type": "تایید فرآیند", "priority": 1, "details": f"فرآیند «{pa['name']}» منتظر تایید نهایی شماست", "date": pa['created_at'], "action_key": "CEO_APPROVE_WORKFLOW", "action_data": pa['id']})
        if 'qa:manage_workflows' in permissions:
            rejected_workflows = self.execute_query("SELECT id, name, created_at FROM workflows WHERE status = 'DRAFT' AND created_by = %s AND description LIKE '%%رد شده توسط%%'", (user_id,))
            for rw in rejected_workflows:
                 notifications.append({"type": "فرآیند بازگردانده شده", "priority": 1, "details": f"فرآیند «{rw['name']}» برای بازبینی به شما بازگردانده شده است.", "date": rw['created_at'], "action_key": "REWORK_WORKFLOW", "action_data": rw['id']})
        if 'warehouse:fulfill_request' in permissions:
            pending_requests = self.get_pending_material_requests()
            for req in pending_requests:
                notifications.append({"type": "درخواست مواد", "priority": 2, "details": f"درخواست {req['requested_qty']} واحد «{req['item_name']}» توسط {req['requester_name']}", "date": req['created_at'], "action_key": "FULFILL_REQUEST", "action_data": req['id']})
        if 'warehouse:approve_delivery' in permissions:
            pending_returns = self.get_pending_returns_from_production()
            for ret in pending_returns:
                notifications.append({"type": "برگشت از تولید", "priority": 2, "details": f"درخواست برگشت {ret['qty']} واحد «{ret['item_name']}» توسط {ret['requester_name']}", "date": ret['t_date'], "action_key": "APPROVE_RETURN", "action_data": ret['id']})
            pending_deliveries = self.get_pending_deliveries()
            for delivery in pending_deliveries:
                notifications.append({"type": "تحویل از تولید", "priority": 1, "details": f"محصول «{delivery['product_name']}» (بچ: {delivery['production_batch_no']}) منتظر تایید دریافت", "date": delivery['created_at'], "action_key": "APPROVE_DELIVERY", "action_data": delivery['id']})
        if 'production:approve_transfer' in permissions:
            pending_transfers = self.get_pending_transfers_to_production()
            for trans in pending_transfers:
                notifications.append({"type": "انتقال به تولید", "priority": 1, "details": f"کالای «{trans['item_name']}» (بچ: {trans['batch_no']}) منتظر تایید دریافت شماست", "date": trans['t_date'], "action_key": "APPROVE_TRANSFER", "action_data": trans['id']})

        notifications.sort(key=lambda x: (x['priority'], x['date']), reverse=False)
        return notifications
                                
            
                            
                        
                                    
# این متد را در کلاس DB به طور کامل جایگزین کنید
    def get_active_production_batches(self):
        """لیستی از تمام بچ‌های تولیدی که فعال هستند را به ترتیب جدیدترین برمی‌گرداند."""
        # این کوئری جدید و صحیح، مشکل مرتب‌سازی با DISTINCT را حل می‌کند
        query = """
            SELECT product_code
            FROM (
                SELECT product_code, MAX(id) as max_id
                FROM bill_of_materials
                WHERE status = 'ACTIVE'
                GROUP BY product_code
            ) as subquery
            ORDER BY subquery.max_id DESC;
        """
        rows = self.execute_query(query)
        return [row['product_code'] for row in rows] if rows else []
    
    
# این متدها را به انتهای کلاس DB اضافه کنید

# در کلاس DB، این متد را جایگزین کنید

    def get_all_suppliers(self, active_only=False):
        """
        لیست تمام تامین‌کنندگان را به صورت امن برمی‌گرداند.
        نسخه نهایی: از کوئری پارامترایز شده برای جلوگیری از مشکلات امنیتی استفاده می‌کند.
        """
        query = "SELECT * FROM suppliers"
        params = []
        
        if active_only:
            query += " WHERE is_active = %s"
            params.append(True)
            
        query += " ORDER BY name"
        return self.execute_query(query, tuple(params))
    
# در کلاس DB، این متد را جایگزین کنید

    def add_or_update_supplier(self, supplier_data: dict, supplier_id: int = None):
        """یک تامین‌کننده جدید را به صورت اتمیک اضافه یا ویرایش می‌کند."""
        if not supplier_data.get('name'):
            raise ValueError("نام تامین‌کننده نمی‌تواند خالی باشد.")
        
        with self.transaction() as cur:
            if supplier_id:  # حالت ویرایش
                query = """
                    UPDATE suppliers SET 
                        name = %(name)s, contact_person = %(contact_person)s, phone = %(phone)s,
                        email = %(email)s, address = %(address)s, economic_code = %(economic_code)s,
                        notes = %(notes)s, is_active = %(is_active)s
                    WHERE id = %(id)s
                """
                # ادغام ID در دیکشنری پارامترها
                params = {**supplier_data, 'id': supplier_id}
                self.execute_query(query, params, cursor=cur)
            else:  # حالت افزودن
                query = """
                    INSERT INTO suppliers (name, contact_person, phone, email, address, economic_code, notes, is_active)
                    VALUES (%(name)s, %(contact_person)s, %(phone)s, %(email)s, %(address)s, %(economic_code)s, %(notes)s, %(is_active)s)
                """
                self.execute_query(query, supplier_data, cursor=cur)
                
# در کلاس DB، این متد را جایگزین کنید

# در کلاس DB، این متد را جایگزین کنید

    def add_or_update_unit(self, name: str, abbreviation: str, unit_id: int = None):
        """یک واحد جدید را به صورت اتمیک اضافه یا ویرایش می‌کند."""
        if not name:
            raise ValueError("نام واحد نمی‌تواند خالی باشد.")
        
        with self.transaction() as cur:
            if unit_id:
                query = "UPDATE units SET name = %s, abbreviation = %s WHERE id = %s"
                params = (name, abbreviation, unit_id)
                self.execute_query(query, params, cursor=cur)
            else:
                query = "INSERT INTO units (name, abbreviation) VALUES (%s, %s) ON CONFLICT (name) DO NOTHING"
                params = (name, abbreviation)
                self.execute_query(query, params, cursor=cur)
                                        
# این متدها را به انتهای کلاس DB اضافه کنید

    def get_all_users_brief(self):
        """لیست خلاصه‌ای از تمام کاربران (ID و نام) را برمی‌گرداند."""
        return self.execute_query("SELECT id, username FROM users ORDER BY username")



                                    
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_workflows(self):
        """لیست تمام فرآیندهای اصلی تعریف شده را برمی‌گرداند."""
        return self.execute_query("SELECT * FROM workflows ORDER BY name, version")

    def get_workflow_steps(self, workflow_id: int):
        """لیست تمام مراحل تعریف شده برای یک فرآیند خاص را برمی‌گرداند."""
        query = """
            SELECT ws.*, r.name as role_name
            FROM workflow_steps ws
            LEFT JOIN roles r ON ws.approver_role_id = r.id
            WHERE ws.workflow_id = %s
            ORDER BY ws.step_order
        """
        return self.execute_query(query, (workflow_id,))

        
    def get_actionable_purchase_requests(self):
        """لیست درخواست‌های خریدی که منتظر اقدام واحد بازرگانی هستند را برمی‌گرداند."""
        query = """
            SELECT pr.id, i.name as item_name, pr.requested_qty, pr.urgency, pr.status
            FROM purchase_requests pr
            JOIN items i ON pr.item_id = i.id
            WHERE pr.status IN ('آماده اقدام بازرگانی', 'در حال استعلام', 'تامین‌کننده انتخاب شد')
            ORDER BY pr.request_date ASC
        """
        return self.execute_query(query)
                    
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def save_workflow(self, data: dict, user_id: int, accessible_dept_ids: list, workflow_id: int = None):
        """یک فرآیند را به همراه لیست دپارتمان‌های مجاز برای شروع دستی، ذخیره یا ویرایش می‌کند."""
        with self.transaction() as cur:
            # آماده‌سازی پارامترها برای کوئری اصلی
            # توجه: owner_department_id حذف شده و initial_action_key اضافه شده است
            params = {
                'name': data['name'],
                'description': data['description'],
                'process_type_key': data['process_type_key'],
                'is_active': data.get('is_active', False),
                'is_manual_start': data.get('is_manual_start', True),
                'form_def_id': data.get('form_def_id'),
                'final_action_key': data.get('final_action_key'),
                'initial_action_key': data.get('initial_action_key'), # <-- فیلد جدید برای فرآیندهای دستی
                'user_id': user_id,
                'id': workflow_id
            }
            
            if workflow_id:
                # حالت ویرایش: کوئری UPDATE بدون owner_department_id
                cur.execute("""
                    UPDATE workflows SET 
                        name = %(name)s, description = %(description)s, process_type_key = %(process_type_key)s, 
                        is_active = %(is_active)s, is_manual_start = %(is_manual_start)s, 
                        form_def_id = %(form_def_id)s, 
                        final_action_key = %(final_action_key)s,
                        initial_action_key = %(initial_action_key)s
                    WHERE id = %(id)s RETURNING id
                """, params)
            else:
                # حالت افزودن: کوئری INSERT بدون owner_department_id
                cur.execute("""
                    INSERT INTO workflows (name, description, process_type_key, created_by, is_active, 
                                        is_manual_start, form_def_id, final_action_key, initial_action_key)
                    VALUES (%(name)s, %(description)s, %(process_type_key)s, %(user_id)s, %(is_active)s, 
                            %(is_manual_start)s, %(form_def_id)s, %(final_action_key)s, %(initial_action_key)s)
                    RETURNING id
                """, params)
            
            saved_workflow_id = cur.fetchone()['id']

            # --- *** منطق جدید و کلیدی برای ذخیره دسترسی دپارتمان‌ها *** ---
            # ابتدا تمام دسترسی‌های قدیمی این فرآیند را پاک می‌کنیم
            self.execute_query("DELETE FROM manual_workflow_access WHERE workflow_id = %s", (saved_workflow_id,), cursor=cur)

            # سپس دسترسی‌های جدید انتخاب شده را در جدول ارتباطی ثبت می‌کنیم
            if accessible_dept_ids:
                args_list = [(saved_workflow_id, dept_id) for dept_id in accessible_dept_ids]
                cur.executemany(
                    "INSERT INTO manual_workflow_access (workflow_id, department_id) VALUES (%s, %s)",
                    args_list
                )
            # --- ******************************************************* ---
            
            return saved_workflow_id
                            
    def advance_workflow_instance(self, process_instance_id: int, user_id: int, outcome: str, reason: str = ""):
            """
            نسخه نهایی (با پشتیبانی از تایید خودکار):
            یک نمونه فرآیند را پیش می‌برد و در صورتی که تایید کننده مرحله بعد همان کاربر فعلی باشد،
            آن مرحله را نیز به صورت خودکار تایید می‌کند.
            """
            with self.transaction() as cur:
                instance = self.execute_query("SELECT * FROM process_instances WHERE id = %s FOR UPDATE", (process_instance_id,), fetch_one=True, cursor=cur)
                if not instance or instance['status'] != 'IN_PROGRESS':
                    raise ValueError("این فرآیند معتبر نیست یا قبلاً پردازش شده است.")

                current_step = self.execute_query("SELECT * FROM workflow_steps WHERE id = %s", (instance['current_step_id'],), fetch_one=True, cursor=cur)
                
                # --- بخش اول: ثبت اقدام کاربر (بدون تغییر) ---
                log_details = { "process_instance_id": instance['id'], "step_name": current_step['step_name'], "user_id": user_id, "outcome": outcome, "reason": reason }
                self._log_atomic(cur, user_id, 'WORKFLOW_STEP_ACTION', json.dumps(log_details, ensure_ascii=False))

                if outcome == 'REJECTED':
                    final_status = current_step.get('failure_status_text') or "رد شده"
                    self.execute_query(f"UPDATE {instance['related_table_name']} SET status = %s WHERE id = %s", (final_status, instance['related_record_id']), cursor=cur)
                    self.execute_query("UPDATE process_instances SET status = 'REJECTED', completed_at = NOW() WHERE id = %s", (instance['id'],), cursor=cur)
                    return

                # --- بخش دوم: منطق اصلی پیشبرد فرآیند ---
                next_step = self.execute_query("SELECT * FROM workflow_steps WHERE workflow_id = %s AND step_order > %s ORDER BY step_order ASC LIMIT 1", (instance['workflow_id'], current_step['step_order']), fetch_one=True, cursor=cur)

                if next_step:
                    next_status_text = next_step.get('success_status_text') or f"در انتظار: {next_step.get('step_name')}"
                    self.execute_query(f"UPDATE {instance['related_table_name']} SET status = %s WHERE id = %s", (next_status_text, instance['related_record_id']), cursor=cur)
                    self.execute_query("UPDATE process_instances SET current_step_id = %s WHERE id = %s", (next_step['id'], instance['id']), cursor=cur)

                    # --- *** بخش جدید و هوشمند: بررسی برای تایید خودکار *** ---
                    next_approver_user_id = None
                    if next_step['approver_type'] == 'ROLE' and next_step['approver_role_id']:
                        # فرض می‌کنیم هر نقش فقط یک کاربر دارد (در آینده می‌توان این بخش را کامل‌تر کرد)
                        user_rec = self.execute_query("SELECT id FROM users WHERE role_id = %s LIMIT 1", (next_step['approver_role_id'],), fetch_one=True, cursor=cur)
                        if user_rec: next_approver_user_id = user_rec['id']
                    elif next_step['approver_type'] == 'REQUESTER_MANAGER':
                        next_approver_user_id = self.get_manager_of_department_by_user(instance['initiator_user_id'])
                    
                    if next_approver_user_id is not None and next_approver_user_id == user_id:
                        print(f"AUTO-APPROVE TRIGGERED: User {user_id} is also the approver for the next step '{next_step['step_name']}'.")
                        # فراخوانی بازگشتی همین تابع برای پیشبرد خودکار
                        self.advance_workflow_instance(process_instance_id, user_id, "APPROVED", reason="تایید خودکار سیستمی (کاربر یکسان)")

                else: # این آخرین مرحله بود
                    self.execute_query("UPDATE process_instances SET status = 'COMPLETED', completed_at = NOW() WHERE id = %s", (instance['id'],), cursor=cur)
                    final_status = current_step.get('success_status_text') or "تکمیل شده"
                    self.execute_query(f"UPDATE {instance['related_table_name']} SET status = %s WHERE id = %s", (final_status, instance['related_record_id']), cursor=cur)
                                                
                                                
                                                                                                    

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def start_workflow_instance(self, workflow_id: int, related_record_id: int, related_table_name: str, cur, user_id: int, context_data: dict = None):
        """یک نمونه فرآیند جدید را آغاز کرده و شناسه آن را برمی‌گرداند."""
        first_step = self.execute_query("SELECT id, step_name FROM workflow_steps WHERE workflow_id = %s ORDER BY step_order ASC LIMIT 1", (workflow_id,), fetch_one=True, cursor=cur)
        if not first_step:
            raise ValueError(f"فرآیند با ID={workflow_id} هیچ مرحله‌ای برای شروع ندارد.")
            
        final_context = context_data or {}
        prepopulation_data = self.get_prepopulation_data(related_table_name, related_record_id)
        if prepopulation_data:
            final_context['prepopulation'] = dict(prepopulation_data)
        context_json = json.dumps(final_context, ensure_ascii=False, default=str) if final_context else None
        
        # --- *** اصلاح کلیدی: دریافت و برگرداندن ID نمونه فرآیند *** ---
        result = self.execute_query("""
            INSERT INTO process_instances (workflow_id, related_record_id, related_table_name, current_step_id, status, context, initiator_user_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING id
        """, (workflow_id, related_record_id, related_table_name, first_step['id'], 'IN_PROGRESS', context_json, user_id), fetch_one=True, cursor=cur)
        
        process_instance_id = result['id']
        # --- ************************************************* ---

        initial_status = f"در انتظار: {first_step.get('step_name', 'مرحله اول')}"
        if related_table_name == 'sales_orders':
            self.execute_query(f"UPDATE sales_orders SET status = %s WHERE id = %s", (initial_status, related_record_id), cursor=cur)
        elif related_table_name == 'form_entries':
            status_json_data = json.dumps({'status': initial_status})
            self.execute_query("UPDATE form_entries SET data = data || %s::jsonb WHERE id = %s", (status_json_data, related_record_id), cursor=cur)
        
        self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        
        # شناسه فرآیند ایجاد شده را برمی‌گردانیم
        return process_instance_id
    
        
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_all_process_instances_for_workflow(self, workflow_id: int):
        """
        تمام نمونه‌های فرآیند فعال برای یک گردش کار مشخص را به همراه جزئیات لازم برای نمایش در مانیتور، برمی‌گرداند.
        """
        if not workflow_id:
            return []
        
        # این کوئری بر اساس نوع سند، جزئیات متفاوتی را استخراج می‌کند (فعلا برای درخواست خرید)
        query = """
            SELECT 
                pi.id,
                pi.related_record_id,
                pi.current_step_id,
                ws.step_name,
                initiator.username as initiator_name,
                pi.started_at,
                -- استخراج هوشمند جزئیات بر اساس نوع سند
                CASE
                    WHEN pi.related_table_name = 'purchase_requests' THEN
                        jsonb_build_object(
                            'item_name', i.name,
                            'requested_qty', pr.requested_qty
                        )
                    ELSE
                        '{}'::jsonb
                END as document_details
            FROM process_instances pi
            JOIN workflow_steps ws ON pi.current_step_id = ws.id
            JOIN users initiator ON pi.initiator_user_id = initiator.id
            LEFT JOIN purchase_requests pr ON pi.related_record_id = pr.id AND pi.related_table_name = 'purchase_requests'
            LEFT JOIN items i ON pr.item_id = i.id
            WHERE pi.workflow_id = %s AND pi.status = 'IN_PROGRESS'
            ORDER BY pi.started_at;
        """
        return self.execute_query(query, (workflow_id,))
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_user_process_history(self, user_id: int):
        """تمام فرآیندهایی که کاربر آغاز کرده یا در آن اقدامی انجام داده را برمی‌گرداند."""
        query = """
            SELECT DISTINCT ON (pi.id)
                pi.id,
                w.name as workflow_name,
                pi.status,
                pi.started_at,
                pi.completed_at,
                initiator.username as initiator_name,
                ws.step_name as current_step_name
            FROM process_instances pi
            JOIN workflows w ON pi.workflow_id = w.id
            JOIN users initiator ON pi.initiator_user_id = initiator.id
            LEFT JOIN workflow_steps ws ON pi.current_step_id = ws.id
            -- *** اصلاح کلیدی: فقط لاگ‌های مربوط به فرآیندها را بررسی می‌کنیم ***
            LEFT JOIN audit a ON (a.details::jsonb->>'process_instance_id')::int = pi.id AND a.action = 'WORKFLOW_STEP_ACTION'
            WHERE pi.initiator_user_id = %s OR a.user_id = %s
            ORDER BY pi.id DESC;
        """
        return self.execute_query(query, (user_id, user_id))
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید


    def get_process_instance_history(self, process_instance_id: int):
        """تاریخچه کامل اقدامات انجام شده روی یک نمونه فرآیند را برمی‌گرداند."""
        query = """
            SELECT a.details, a.stamp, u.username
            FROM audit a
            LEFT JOIN users u ON a.user_id = u.id
            WHERE a.action = 'WORKFLOW_STEP_ACTION'
            AND a.details::jsonb->>'process_instance_id' = %s
            ORDER BY a.stamp ASC;
        """
        # PostgreSQL's "->>" operator queries the JSONB field for a key and returns it as text.
        rows = self.execute_query(query, (str(process_instance_id),))
        
        history = []
        if rows:
            for row in rows:
                try:
                    details = json.loads(row['details'])
                    details['timestamp'] = row['stamp']
                    details['actor_username'] = row.get('username', 'کاربر سیستمی')
                    history.append(details)
                except (json.JSONDecodeError, KeyError):
                    continue # Ignore malformed logs
        return history
                
    def get_delegations(self, user_id: int):
        """لیست تمام تفویض اختیارهای ثبت شده برای یک کاربر را برمی‌گرداند."""
        query = """
            SELECT d.id, u_del.username as delegate_name, w.name as workflow_name, d.start_date, d.end_date, d.notes
            FROM delegations d
            JOIN users u_del ON d.delegate_id = u_del.id
            LEFT JOIN workflows w ON d.workflow_id = w.id
            WHERE d.delegator_id = %s ORDER BY d.start_date DESC
        """
        return self.execute_query(query, (user_id,))

    def add_delegation(self, data: dict):
        """یک رکورد تفویض اختیار جدید ثبت می‌کند."""
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO delegations (delegator_id, delegate_id, workflow_id, start_date, end_date, notes)
                VALUES (%(delegator_id)s, %(delegate_id)s, %(workflow_id)s, %(start_date)s, %(end_date)s, %(notes)s)
            """, data)
        
    def revoke_delegation(self, delegation_id: int):
        """یک تفویض اختیار را حذف می‌کند."""
        with self.transaction() as cur:
            cur.execute("DELETE FROM delegations WHERE id = %s", (delegation_id,))


                
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def _evaluate_rules(self, rules: dict, record_data: dict) -> bool:
        """
        نسخه 2.1 (هوشمند):
        قوانین شرطی تودرتو را با پشتیبانی از انواع فیلد و عملگرهای جدید ارزیابی می‌کند.
        """
        if not rules or 'logic' not in rules:
            return False

        logic_tree = rules['logic']
        
        def evaluate_node(node):
            if not isinstance(node, dict):
                return False

            if 'condition' in node:
                cond = node['condition']
                field_label = cond.get('field') # در فرمت جدید، از لیبل استفاده می‌کنیم
                operator = cond.get('operator')
                value_to_compare_str = cond.get('value')
                
                record_value = record_data.get(field_label) # داده‌ها با لیبل ذخیره می‌شوند
                
                # مدیریت مقادیر خالی
                if operator == 'خالی باشد': return not record_value
                if operator == 'خالی نباشد': return bool(record_value)

                # اگر شرط برای خالی بودن نیست ولی مقداری وجود ندارد، شرط برقرار نیست
                if record_value is None: return False

                # مدیریت چک‌باکس
                if isinstance(record_value, bool):
                    if operator == 'تیک خورده باشد': return record_value is True
                    if operator == 'تیک نخورده باشد': return record_value is False
                
                try: # مقایسه عددی
                    val_compare_num = float(value_to_compare_str)
                    rec_val_num = float(record_value)
                    if operator == 'بزرگتر از': return rec_val_num > val_compare_num
                    if operator == 'کوچکتر از': return rec_val_num < val_compare_num
                    if operator == 'برابر با': return rec_val_num == val_compare_num
                    if operator == 'مخالف با': return rec_val_num != val_compare_num
                except (ValueError, TypeError): # مقایسه متنی
                    if operator == 'شامل': return str(value_to_compare_str) in str(record_value)
                    if operator == 'برابر با': return str(value_to_compare_str) == str(record_value)
                    if operator == 'مخالف با': return str(value_to_compare_str) != str(record_value)
                return False

            elif 'and' in node:
                return all(evaluate_node(child) for child in node['and'])
            
            elif 'or' in node:
                return any(evaluate_node(child) for child in node['or'])
            
            return False

        return evaluate_node(logic_tree)
        
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def get_pending_tasks_for_user_role(self, user_id: int, user_role_id: int):
        """
        نسخه نهایی (با جزئیات غنی و هوشمند):
        تمام کارهای منتظر اقدام را به همراه جزئیات کامل و وابسته به نوع سند، برمی‌گرداند.
        """
        if not user_id or not user_role_id: return []
        
        query = """
            SELECT 
                pi.id as process_instance_id, pi.related_record_id, pi.related_table_name,
                w.name as workflow_name, ws.step_name, pi.started_at,
                pi.context,
                -- --- *** بخش جدید و استراتژیک برای استخراج جزئیات هوشمند *** ---
                CASE
                    WHEN pi.related_table_name = 'purchase_requests' THEN
                        (SELECT json_build_object('item_name', i.name, 'requester', u.username, 'qty', pr.requested_qty)
                         FROM purchase_requests pr
                         JOIN items i ON pr.item_id = i.id
                         LEFT JOIN users u ON pr.requester_id = u.id
                         WHERE pr.id = pi.related_record_id)
                    WHEN pi.related_table_name = 'stock' THEN
                        (SELECT json_build_object('item_name', i.name, 'batch_no', s.batch_no, 'reason', pi.context->>'notes')
                         FROM stock s
                         JOIN items i ON s.item_id = i.id
                         WHERE s.id = pi.related_record_id)
                    ELSE '{}'::json
                END as details,
                -- --- ****************************************************** ---
                CASE WHEN ws.approver_role_id = %(user_role_id)s THEN FALSE ELSE TRUE END as is_delegated,
                (SELECT r.name FROM roles r WHERE r.id = ws.approver_role_id LIMIT 1) as original_approver_role
            FROM process_instances pi
            JOIN workflow_steps ws ON pi.current_step_id = ws.id
            JOIN workflows w ON pi.workflow_id = w.id
            WHERE 
                pi.status = 'IN_PROGRESS'
                AND (
                    (ws.approver_type = 'ROLE' AND ws.approver_role_id = %(user_role_id)s)
                    OR
                    (ws.approver_type = 'ROLE' AND EXISTS (
                        SELECT 1 FROM delegations d
                        JOIN users u_del ON d.delegator_id = u_del.id
                        WHERE d.delegate_id = %(user_id)s 
                          AND u_del.role_id = ws.approver_role_id
                          AND NOW() BETWEEN d.start_date AND d.end_date
                          AND (d.workflow_id IS NULL OR d.workflow_id = pi.workflow_id)
                    ))
                    OR
                    (ws.approver_type = 'REQUESTER_MANAGER' AND %(user_id)s = (
                        SELECT d.manager_user_id
                        FROM users u_req
                        JOIN departments d ON u_req.department_id = d.id
                        WHERE u_req.id = pi.initiator_user_id
                    ))
                )
            ORDER BY pi.started_at ASC;
        """
        params = {'user_id': user_id, 'user_role_id': user_role_id}
        return self.execute_query(query, params)
    
            
        
    def update_department_position(self, dept_id: int, pos_x: float, pos_y: float):
        """موقعیت گرافیکی یک واحد را در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE departments SET pos_x = %s, pos_y = %s WHERE id = %s",
                (pos_x, pos_y, dept_id)
            )

    def reset_all_department_positions(self):
        """تمام موقعیت‌های سفارشی ذخیره شده را برای بازگشت به حالت خودکار پاک می‌کند."""
        with self.transaction() as cur:
            cur.execute("UPDATE departments SET pos_x = NULL, pos_y = NULL")



                
    
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_event_mappings(self):
        """نگاشت فعلی رویدادها به فرآیندها را برمی‌گرداند."""
        query = """
            SELECT em.event_name, w.id as workflow_id, w.name as workflow_name
            FROM system_event_mappings em
            JOIN workflows w ON em.workflow_id = w.id
        """
        rows = self.execute_query(query)
        return {row['event_name']: {'workflow_id': row['workflow_id'], 'workflow_name': row['workflow_name']} for row in rows}

    def save_event_mappings(self, mappings: dict):
        """نگاشت جدید رویدادها به فرآیندها را در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            cur.execute("TRUNCATE TABLE system_event_mappings;")
            for event, workflow_id in mappings.items():
                if workflow_id:
                    cur.execute(
                        "INSERT INTO system_event_mappings (event_name, workflow_id) VALUES (%s, %s)",
                        (event, workflow_id)
                    )
                    
    def set_purchase_request_urgency(self, request_id: int, urgency: str, user_id: int):
        """فوریت یک درخواست خرید را ثبت کرده و فرآیند مربوط به آن را تکمیل می‌کند."""
        with self.transaction() as cur:
            # ۱. آپدیت خود درخواست خرید
            cur.execute(
                "UPDATE purchase_requests SET urgency = %s, urgency_set_by_id = %s, status = 'آماده اقدام بازرگانی' WHERE id = %s",
                (urgency, user_id, request_id)
            )
            if cur.rowcount == 0:
                raise ValueError("درخواست خرید یافت نشد یا در وضعیت مناسبی برای تعیین فوریت نیست.")
            
            # ۲. پیدا کردن و تکمیل کردن فرآیند در حال اجرا
            cur.execute(
                "UPDATE process_instances SET status = 'COMPLETED', completed_at = NOW() WHERE related_record_id = %s AND related_table_name = 'purchase_requests' AND status = 'IN_PROGRESS'",
                (request_id,)
            )
            
            self._log_atomic(cur, user_id, 'SET_PR_URGENCY', f"Urgency for PR ID:{request_id} set to '{urgency}'")
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_departments_tree(self):
        """
        نسخه نهایی: علاوه بر نام مدیر، شناسه کاربری (ID) او را نیز برای اتصال صحیح داده‌ها برمی‌گرداند.
        """
        query = """
            SELECT 
                d.id, 
                d.name, 
                d.parent_id, 
                u.username as manager_name,
                d.manager_user_id -- <<< --- اصلاح کلیدی و نهایی اینجاست
            FROM departments d
            LEFT JOIN users u ON d.manager_user_id = u.id
            ORDER BY d.name
        """
        return self.execute_query(query)
    
    
    def update_department(self, dept_id: int, name: str, parent_id: int, manager_user_id: int):
        """اطلاعات یک واحد سازمانی را به‌روزرسانی می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE departments SET name = %s, parent_id = %s, manager_user_id = %s WHERE id = %s",
                (name, parent_id, manager_user_id, dept_id)
            )

    def add_department(self, name: str, parent_id: int):
        """یک واحد سازمانی جدید اضافه می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "INSERT INTO departments (name, parent_id) VALUES (%s, %s) RETURNING id",
                (name, parent_id)
            )
            return cur.fetchone()['id']

    def delete_department(self, dept_id: int):
        """یک واحد سازمانی را حذف می‌کند."""
        # در آینده می‌توان چک کرد که آیا کاربری به این واحد متصل است یا خیر
        with self.transaction() as cur:
            cur.execute("DELETE FROM departments WHERE id = %s", (dept_id,))

    def get_manager_of_department_by_user(self, user_id: int):
        """مدیر واحدی که کاربر در آن قرار دارد را پیدا می‌کند."""
        query = """
            SELECT d.manager_user_id 
            FROM users u
            JOIN departments d ON u.department_id = d.id
            WHERE u.id = %s
        """
        result = self.execute_query(query, (user_id,), fetch_one=True)
        return result['manager_user_id'] if result else None
    
    def update_department_parent(self, dept_id: int, new_parent_id: int):
        """والد یک واحد سازمانی را در چارت تغییر می‌دهد."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE departments SET parent_id = %s WHERE id = %s",
                (new_parent_id, dept_id)
            )
            
    def get_users_in_department(self, department_id: int):
        """لیست کاربرانی که به یک واحد سازمانی خاص اختصاص یافته‌اند را برمی‌گرداند."""
        if not department_id:
            return []
        query = "SELECT username FROM users WHERE department_id = %s ORDER BY username"
        return self.execute_query(query, (department_id,))
    
    # در کلاس DB، این متد را جایگزین کنید
    def submit_workflow_for_approval(self, workflow_id: int, user_id: int):
        """وضعیت یک فرآیند را به 'در انتظار تایید' تغییر می‌دهد (با تضمین Commit)."""
        try:
            with self.transaction() as cur: # استفاده از transaction manager استاندارد
                cur.execute(
                    "UPDATE workflows SET status = 'PENDING_APPROVAL' WHERE id = %s AND status = 'DRAFT'",
                    (workflow_id,)
                )
                if cur.rowcount == 0:
                    raise ValueError("این فرآیند در وضعیت مناسب برای ارسال نیست یا قبلاً ارسال شده است.")

                self._log_atomic(cur, user_id, 'SUBMIT_WORKFLOW', f"Workflow ID:{workflow_id} submitted for approval.")

            # --- اصلاح کلیدی: سیگنال پس از کامیت موفق ارسال می‌شود ---
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

        except Exception as e:
            print(f"CRITICAL ERROR during submit_workflow_for_approval: {e}")
            raise
                        
    def get_pending_workflows_for_approval(self):
        """لیست فرآیندهایی که منتظر تایید نهایی هستند را برمی‌گرداند."""
        query = """
            SELECT w.id, w.name, w.description, u.username as created_by, w.created_at
            FROM workflows w
            LEFT JOIN users u ON w.created_by = u.id
            WHERE w.status = 'PENDING_APPROVAL'
            ORDER BY w.created_at
        """
        # استفاده از execute_query که همیشه یک اتصال جدید و تازه باز می‌کند
        return self.execute_query(query)
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def approve_workflow(self, workflow_id: int, user_id: int):
        """یک فرآیند را تایید نهایی و فعال می‌کند و تمام نسخه‌های قدیمی‌تر را به صورت خودکار غیرفعال می‌کند."""
        with self.transaction() as cur:
            # گام ۱: اطلاعات نسخه جدید را برای پیدا کردن نام آن بخوان
            workflow_to_approve = self.execute_query("SELECT name FROM workflows WHERE id = %s", (workflow_id,), fetch_one=True, cursor=cur)
            if not workflow_to_approve:
                raise ValueError("فرآیند مورد نظر برای تایید یافت نشد.")
            
            workflow_name = workflow_to_approve['name']

            # گام ۲: تمام نسخه‌های فعال دیگر با همین نام را پیدا و غیرفعال کن
            self.execute_query(
                "UPDATE workflows SET is_active = FALSE, status = 'ARCHIVED' WHERE name = %s AND is_active = TRUE",
                (workflow_name,),
                cursor=cur
            )
            
            # گام ۳: نسخه جدید را فعال کن
            cur.execute(
                "UPDATE workflows SET status = 'ACTIVE', is_active = TRUE, approved_by_id = %s, approved_at = NOW() WHERE id = %s",
                (user_id, workflow_id)
            )
            self._log_atomic(cur, user_id, 'WORKFLOW_APPROVED', f"Workflow ID:{workflow_id} was approved and is now active.")

        self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        
# این متد کاملا جدید را به کلاس DB اضافه کنید

    def delete_workflow(self, workflow_id: int) -> str:
        """
        یک فرآیند را حذف یا آرشیو می‌کند.
        - اگر فرآیند دارای نمونه‌های اجرایی (process instances) باشد، آن را آرشیو می‌کند.
        - اگر هیچ سابقه‌ای نداشته باشد، آن را به طور کامل حذف می‌کند.
        در نهایت وضعیت عملیات ('DELETED' یا 'ARCHIVED') را برمی‌گرداند.
        """
        with self.transaction() as cur:
            # بررسی اینکه آیا این فرآیند حداقل یک بار اجرا شده است یا خیر
            in_use = self.execute_query(
                "SELECT 1 FROM process_instances WHERE workflow_id = %s LIMIT 1",
                (workflow_id,),
                fetch_one=True,
                cursor=cur
            )

            if in_use:
                # اگر سابقه داشت، فقط آن را آرشیو و غیرفعال کن
                self.execute_query(
                    "UPDATE workflows SET status = 'ARCHIVED', is_active = FALSE WHERE id = %s",
                    (workflow_id,),
                    cursor=cur
                )
                return "ARCHIVED"
            else:
                # اگر هیچ سابقه‌ای نداشت، آن را به طور کامل حذف کن
                # (ON DELETE CASCADE در پایگاه داده، مراحل آن را نیز حذف خواهد کرد)
                self.execute_query(
                    "DELETE FROM workflows WHERE id = %s",
                    (workflow_id,),
                    cursor=cur
                )
                return "DELETED"
            
    # در کلاس DB، این متد را جایگزین کنید
    def reject_workflow(self, workflow_id: int, user_id: int, reason: str):
        """یک فرآیند را رد کرده و به حالت پیش‌نویس باز می‌گرداند."""
        with self.transaction() as cur:
            notes = f"رد شده توسط مدیرعامل (کاربر #{user_id}): {reason}"
            cur.execute(
                "UPDATE workflows SET status = 'DRAFT', description = COALESCE(description, '') || ' | ' || %s WHERE id = %s",
                (notes, workflow_id)
            )
            self._log_atomic(cur, user_id, 'WORKFLOW_REJECTED', f"Workflow ID:{workflow_id} was rejected. Reason: {reason}")

        # --- اصلاح کلیدی: سیگنال به خارج از بلوک تراکنش منتقل شد ---
        self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
            
    def get_items_below_minimum(self):
        """لیست تمام کالاهایی که موجودی آنها از حد سفارش کمتر است را به همراه جزئیات کامل برمی‌گرداند."""
        query = """
            SELECT
                i.id, i.name, i.category, u.name as unit, i.min_qty, i.max_qty,
                COALESCE(s.non_prod_qty, 0) as current_qty,
                (i.max_qty - COALESCE(s.non_prod_qty, 0)) as suggested_qty
            FROM items i
            LEFT JOIN units u ON i.unit_id = u.id
            LEFT JOIN (
                SELECT
                    item_id,
                    SUM(CASE WHEN w.name != 'Production' THEN qty ELSE 0 END) as non_prod_qty
                FROM stock
                JOIN locations l ON stock.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                GROUP BY item_id
            ) s ON i.id = s.item_id
            WHERE COALESCE(s.non_prod_qty, 0) < i.min_qty AND i.min_qty > 0 AND i.is_parent_product = FALSE
            ORDER BY i.name;
        """
        return self.execute_query(query)


    # در کلاس DB، این متد را به طور کامل جایگزین کن
    def create_internal_request(self, user_id: int, item_id: int, quantity: float, notes: str):
        """
        ثبت درخواست داخلی + ارسال رویداد سیستم بعد از ثبت موفق (بدون تخریب منطق موجود)
        """
        with self.transaction() as cur:
            # محاسبه موجودی خارج از انبار تولید
            query_check = """
                SELECT COALESCE(SUM(s.qty), 0) AS total_available
                FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE s.item_id = %s AND w.name != %s;
            """
            cur.execute(query_check, (item_id, PRODUCTION_WAREHOUSE_NAME))
            available_qty = cur.fetchone()['total_available']

            # اگر موجودی کافی باشد → در انتظار رسیدگی انبار؛ وگرنه → نیازمند تامین
            new_status = (
                TransactionStatus.IR_PENDING_FULFILLMENT.value
                if available_qty >= quantity else
                TransactionStatus.IR_PENDING_PURCHASE.value
            )

            # ثبت درخواست
            cur.execute(
                """
                INSERT INTO internal_requests (requester_user_id, item_id, quantity, status, notes, created_at)
                VALUES (%s, %s, %s, %s, %s, NOW())
                RETURNING id
                """,
                (user_id, item_id, quantity, new_status, notes)
            )
            request_id = cur.fetchone()['id']

            # لاگ و نوتیف
            self._log_atomic(cur, user_id, 'CREATE_INTERNAL_REQUEST',
                            f"Internal request ID:{request_id} created with status '{new_status}'.")
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')

        # ❗️خارج از تراکنش (بعد از کامیت): ارسال رویداد برای شروع گردش‌کار
        try:
            self.trigger_event(
                event_name='INTERNAL_REQUEST_CREATED',
                record_id=request_id,
                table_name='internal_requests',
                user_id=user_id,
                context_data={'item_id': item_id, 'quantity': quantity, 'status': new_status}
            )
        except Exception as e:
            print("WARN: trigger_event failed for INTERNAL_REQUEST_CREATED:", e)

        return {"type": "internal_request", "id": request_id, "status": new_status}
        
                
    def get_internal_requests_by_user(self, user_id: int):
        """تاریخچه درخواست‌های داخلی ثبت شده توسط یک کاربر را برمی‌گرداند."""
        query = """
            SELECT ir.id, i.name as item_name, ir.quantity, ir.status, ir.created_at
            FROM internal_requests ir
            JOIN items i ON ir.item_id = i.id
            WHERE ir.requester_user_id = %s ORDER BY ir.id DESC
        """
        return self.execute_query(query, (user_id,))
    
# این کد را جایگزین نسخه فعلی get_pending_internal_requests_for_warehouse در کلاس DB کنید
    def get_pending_internal_requests_for_warehouse(self):
        """
        نسخه ارتقا یافته: لیست تمام درخواست‌های داخلی که منتظر اقدام انباردار هستند
        (چه برای ارسال کالا و چه برای ایجاد درخواست خرید) را برمی‌گرداند.
        """
        query = """
            SELECT ir.id, i.id as item_id, i.name as item_name, u.username as requester_name, d.name as department_name, ir.quantity, ir.created_at, ir.status
            FROM internal_requests ir
            JOIN items i ON ir.item_id = i.id
            JOIN users u ON ir.requester_user_id = u.id
            LEFT JOIN departments d ON u.department_id = d.id
            WHERE ir.status IN (%s, %s) ORDER BY ir.id ASC
        """
        params = (TransactionStatus.IR_PENDING_FULFILLMENT.value, TransactionStatus.IR_PENDING_PURCHASE.value)
        return self.execute_query(query, params)
        
    def save_role_details(self, role_id: int, name: str, permission_ids: list, dashboard_keys: list):
        """اطلاعات کامل یک نقش (نام، دسترسی‌ها و داشبوردها) را ذخیره یا ایجاد می‌کند."""
        with self.transaction() as cur:
            if role_id: # حالت ویرایش
                cur.execute("UPDATE roles SET name = %s WHERE id = %s", (name, role_id))
                cur.execute("DELETE FROM role_permissions WHERE role_id = %s", (role_id,))
                cur.execute("DELETE FROM role_dashboards WHERE role_id = %s", (role_id,))
            else: # حالت ایجاد نقش جدید
                # داشبورد پیش‌فرض برای نقش جدید، پنل استاندارد است
                cur.execute("INSERT INTO roles (name, dashboard_type) VALUES (%s, 'DEFAULT') RETURNING id", (name,))
                role_id = cur.fetchone()['id']

            if permission_ids:
                args_list = [(role_id, perm_id) for perm_id in permission_ids]
                cur.executemany(
                    "INSERT INTO role_permissions (role_id, permission_id) VALUES (%s, %s)",
                    args_list
                )
            
            if dashboard_keys:
                args_list_dash = [(role_id, key) for key in dashboard_keys]
                cur.executemany(
                    "INSERT INTO role_dashboards (role_id, dashboard_key) VALUES (%s, %s)",
                    args_list_dash
                )
            return role_id
            
        
# این متد را در کلاس DB جایگزین کنید
    def get_all_purchase_orders(self):
        """لیست تمام سفارشات خرید را به همراه جزئیات تکمیلی برای نمایش در تاریخچه هوشمند برمی‌گرداند."""
        query = """
            SELECT 
                po.id, 
                po.po_number, 
                s.name as supplier_name, 
                po.issue_date, 
                po.total_amount, 
                po.status,
                creator.username as creator_name,
                (SELECT string_agg(i.name, ', ') FROM purchase_order_items poi JOIN items i ON poi.item_id = i.id WHERE poi.purchase_order_id = po.id) as items_list
            FROM purchase_orders po
            JOIN suppliers s ON po.supplier_id = s.id
            LEFT JOIN users creator ON po.created_by_id = creator.id
            ORDER BY po.id DESC
        """
        return self.execute_query(query)
        
                            
    def get_next_memo_number(self):
        """یک شماره سریال جدید برای نامه‌های داخلی تولید می‌کند."""
        now_jalali = jd.datetime.now()
        year_short = str(now_jalali.year)[-2:]
        prefix = f"MEMO-{year_short}-"
        
        query = "SELECT MAX(memo_number) as last_memo FROM internal_memos WHERE memo_number LIKE %s"
        last_memo_rec = self.execute_query(query, (f"{prefix}%",), fetch_one=True)
        
        next_serial = 1
        if last_memo_rec and last_memo_rec.get('last_memo'):
            try:
                last_serial_str = last_memo_rec['last_memo'].split('-')[-1]
                next_serial = int(last_serial_str) + 1
            except (IndexError, ValueError):
                next_serial = 1
                
        return f"{prefix}{next_serial:05d}" # 5 رقم برای شماره سریال

# این متد را در کلاس DB به طور کامل جایگزین کنید
    def create_memo(self, author_id: int, subject: str, body: str, to_user_ids: list, cc_user_ids: list):
        """یک نامه داخلی جدید ایجاد کرده و پس از موفقیت، سیگنال تغییر داده را منتشر می‌کند."""
        with self.transaction() as cur:
            memo_number = self.get_next_memo_number()
            cur.execute(
                "INSERT INTO internal_memos (memo_number, subject, body, author_user_id) VALUES (%s, %s, %s, %s) RETURNING id",
                (memo_number, subject, body, author_id)
            )
            memo_id = cur.fetchone()['id']
            recipients_to_insert = []
            if to_user_ids:
                recipients_to_insert.extend([(memo_id, user_id, 'TO') for user_id in to_user_ids])
            if cc_user_ids:
                recipients_to_insert.extend([(memo_id, user_id, 'CC') for user_id in cc_user_ids])
            if recipients_to_insert:
                cur.executemany(
                    "INSERT INTO memo_recipients (memo_id, recipient_user_id, recipient_type) VALUES (%s, %s, %s)",
                    recipients_to_insert
                )
            self._log_atomic(cur, author_id, 'CREATE_MEMO', f"Memo {memo_number} created.")
        
        # --- انتشار سیگنال در انتهای عملیات موفق ---
        self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        return memo_id
    
    def get_user_inbox(self, user_id: int):
        """تمام نامه‌های دریافتی یک کاربر را برمی‌گرداند."""
        query = """
            SELECT m.id, m.memo_number, m.subject, u.username as author_name, m.created_at, mr.read_at
            FROM internal_memos m
            JOIN memo_recipients mr ON m.id = mr.memo_id
            JOIN users u ON m.author_user_id = u.id
            WHERE mr.recipient_user_id = %s
            ORDER BY m.created_at DESC
        """
        return self.execute_query(query, (user_id,))

    def get_user_sent_items(self, user_id: int):
        """تمام نامه‌های ارسالی یک کاربر را برمی‌گرداند."""
        query = """
            SELECT id, memo_number, subject, created_at FROM internal_memos
            WHERE author_user_id = %s
            ORDER BY created_at DESC
        """
        return self.execute_query(query, (user_id,))

    def mark_memo_as_read(self, memo_id: int, user_id: int):
        """یک نامه را برای کاربر مشخص به عنوان خوانده شده علامت می‌زند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE memo_recipients SET read_at = NOW() WHERE memo_id = %s AND recipient_user_id = %s AND read_at IS NULL",
                (memo_id, user_id)
            )
            
    def get_memo_details(self, memo_id: int, user_id: int):
        """جزئیات کامل یک نامه شامل فرستنده، گیرندگان و متن را برمی‌گرداند و آن را خوانده شده علامت می‌زند."""
        with self.transaction() as cur:
            # ابتدا نامه را به عنوان خوانده شده علامت می‌زنیم
            cur.execute(
                "UPDATE memo_recipients SET read_at = NOW() WHERE memo_id = %s AND recipient_user_id = %s AND read_at IS NULL",
                (memo_id, user_id)
            )
            
            # سپس جزئیات کامل را واکشی می‌کنیم
            query = """
                SELECT m.memo_number, m.subject, m.body, u_author.username as author_name, m.created_at,
                    (SELECT array_agg(u.username) FROM memo_recipients mr JOIN users u ON mr.recipient_user_id = u.id WHERE mr.memo_id = m.id AND mr.recipient_type = 'TO') as to_list,
                    (SELECT array_agg(u.username) FROM memo_recipients mr JOIN users u ON mr.recipient_user_id = u.id WHERE mr.memo_id = m.id AND mr.recipient_type = 'CC') as cc_list
                FROM internal_memos m
                JOIN users u_author ON m.author_user_id = u_author.id
                WHERE m.id = %s
            """
            return self.execute_query(query, (memo_id,), fetch_one=True, cursor=cur)
        
    def get_user_sent_items_detailed(self, user_id: int):
        """تمام نامه‌های ارسالی یک کاربر را به همراه لیست گیرندگان برمی‌گرداند."""
        query = """
            SELECT m.id, m.memo_number, m.subject, m.created_at,
                (SELECT string_agg(u.username, ', ') FROM memo_recipients mr JOIN users u ON mr.recipient_user_id = u.id WHERE mr.memo_id = m.id) as recipients_list
            FROM internal_memos m
            WHERE m.author_user_id = %s
            ORDER BY m.created_at DESC
        """
        return self.execute_query(query, (user_id,))
    
    def get_document_history(self, doc_identifier: str):
        """تاریخچه کامل یک سند را با جستجو در جداول مختلف پیدا کرده و برمی‌گرداند."""
        doc_identifier = doc_identifier.strip()
        history = []
        
        # جستجو در درخواست‌های خرید
        pr_query = """
            SELECT 'درخواست خرید' as doc_type, pr.status, pr.created_at, u.username as creator, i.name as item_name
            FROM purchase_requests pr
            JOIN users u ON pr.requester_id = u.id
            JOIN items i ON pr.item_id = i.id
            WHERE pr.id::text = %s
        """
        pr_result = self.execute_query(pr_query, (doc_identifier,), fetch_one=True)
        if pr_result:
            history.append(f"نوع سند: {pr_result['doc_type']} برای کالای «{pr_result['item_name']}»")
            history.append(f"ایجاد شده توسط: {pr_result['creator']} در تاریخ {to_shamsi(pr_result['created_at'])}")
            history.append(f"وضعیت فعلی: {pr_result['status']}")
            return history

        # جستجو در سفارشات خرید
        po_query = """
            SELECT 'سفارش خرید' as doc_type, po.status, po.issue_date, u.username as creator, s.name as supplier_name
            FROM purchase_orders po
            JOIN users u ON po.created_by_id = u.id
            JOIN suppliers s ON po.supplier_id = s.id
            WHERE po.po_number = %s
        """
        po_result = self.execute_query(po_query, (doc_identifier,), fetch_one=True)
        if po_result:
            history.append(f"نوع سند: {po_result['doc_type']} برای تامین‌کننده «{po_result['supplier_name']}»")
            history.append(f"ایجاد شده توسط: {po_result['creator']} در تاریخ {to_shamsi(po_result['issue_date'])}")
            history.append(f"وضعیت فعلی: {po_result['status']}")
            return history
            
        # در آینده می‌توان جستجو در جداول دیگر را نیز به اینجا اضافه کرد

        return ["سندی با این شناسه یافت نشد."]
    
    def get_user_tasks_for_kanban(self, user_id: int, user_role_id: int):
        """تمام وظایف یک کاربر را برای نمایش در بورد کانبان، به همراه وضعیت آنها برمی‌گرداند."""
        # این متد از همان منطق پیچیده get_pending_tasks_for_user_role استفاده می‌کند
        # اما kanban_state را نیز برمی‌گرداند
        query = """
            SELECT 
                pi.id as process_instance_id, pi.related_record_id, pi.related_table_name,
                w.name as workflow_name, ws.step_name, pi.started_at, pi.kanban_state,
                CASE
                    WHEN pi.related_table_name = 'purchase_requests' THEN
                        (SELECT json_build_object('item_name', i.name, 'requester', u.username, 'qty', pr.requested_qty)
                        FROM purchase_requests pr
                        JOIN items i ON pr.item_id = i.id
                        LEFT JOIN users u ON pr.requester_id = u.id
                        WHERE pr.id = pi.related_record_id)
                    ELSE '{}'::json
                END as details
            FROM process_instances pi
            JOIN workflow_steps ws ON pi.current_step_id = ws.id
            JOIN workflows w ON pi.workflow_id = w.id
            WHERE 
                pi.status = 'IN_PROGRESS'
                AND (
                    -- منطق پیچیده یافتن وظایف مستقیم، تفویضی و مدیریتی در اینجا قرار می‌گیرد
                    (ws.approver_type = 'ROLE' AND ws.approver_role_id = %(user_role_id)s)
                    OR
                    (ws.approver_type = 'ROLE' AND ws.approver_role_id IN (
                        SELECT u.role_id FROM delegations d
                        JOIN users u ON d.delegator_id = u.id
                        WHERE d.delegate_id = %(user_id)s AND NOW() BETWEEN d.start_date AND d.end_date
                    ))
                    OR
                    (ws.approver_type = 'REQUESTER_MANAGER' AND %(user_id)s = (
                        SELECT d.manager_user_id
                        FROM purchase_requests pr
                        JOIN departments d ON pr.original_department_id = d.id
                        WHERE pr.id = pi.related_record_id
                    ))
                )
            ORDER BY pi.id;
        """
        params = {'user_id': user_id, 'user_role_id': user_role_id}
        return self.execute_query(query, params)

    def update_task_kanban_state(self, process_instance_id: int, new_state: str):
        """وضعیت کانبان یک وظیفه را به‌روزرسانی می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE process_instances SET kanban_state = %s WHERE id = %s",
                (new_state, process_instance_id)
            )
            
    def get_new_tasks_count(self, user_id: int, user_role_id: int):
        """تعداد کل وظایف منتظر اقدام یک کاربر را برمی‌گرداند."""
        # این کوئری از همان منطق پیچیده قبلی استفاده می‌کند اما فقط تعداد را برمی‌گرداند
        query = """
            SELECT COUNT(pi.id) as count
            FROM process_instances pi
            JOIN workflow_steps ws ON pi.current_step_id = ws.id
            WHERE 
                pi.status = 'IN_PROGRESS'
                AND (
                    (ws.approver_type = 'ROLE' AND ws.approver_role_id = %(user_role_id)s)
                    OR
                    (ws.approver_type = 'ROLE' AND ws.approver_role_id IN (
                        SELECT u.role_id FROM delegations d
                        JOIN users u ON d.delegator_id = u.id
                        WHERE d.delegate_id = %(user_id)s AND NOW() BETWEEN d.start_date AND d.end_date
                    ))
                    OR
                    (ws.approver_type = 'REQUESTER_MANAGER' AND %(user_id)s = (
                        SELECT d.manager_user_id
                        FROM purchase_requests pr
                        JOIN departments d ON pr.original_department_id = d.id
                        WHERE pr.id = pi.related_record_id
                    ))
                )
        """
        params = {'user_id': user_id, 'user_role_id': user_role_id}
        result = self.execute_query(query, params, fetch_one=True)
        return result['count'] if result else 0

    def get_unread_memos_count(self, user_id: int):
        """تعداد نامه‌های خوانده نشده یک کاربر را برمی‌گرداند."""
        query = "SELECT COUNT(id) as count FROM memo_recipients WHERE recipient_user_id = %s AND read_at IS NULL"
        result = self.execute_query(query, (user_id,), fetch_one=True)
        return result['count'] if result else 0

# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_user_document_history(self, user_id: int):
        """
        تاریخچه تمام اسناد و فرآیندهای مرتبط با کاربر را برمی‌گرداند.
        نسخه نهایی: شامل فرآیندهای تیم‌های تحت مدیریت کاربر نیز می‌شود.
        """
        query = """
        SELECT DISTINCT ON (pi.id)
            pi.id as process_instance_id,
            w.name as workflow_name,
            pc.display_name as process_category_name,
            pc.handler_key,
            pi.status as process_status,
            ws.step_name as current_step_name,
            pi.started_at,
            pi.completed_at,
            initiator.username as initiator_name,
            pi.related_table_name,
            pi.related_record_id,
            CASE
                WHEN pi.related_table_name = 'purchase_requests' THEN
                    jsonb_build_object(
                        'item_name', i.name,
                        'requested_qty', pr.requested_qty,
                        'status', pr.status
                    )
                WHEN pi.related_table_name = 'form_entries' THEN
                    fe.data
                ELSE
                    '{}'::jsonb
            END as document_details
        FROM process_instances pi
        JOIN workflows w ON pi.workflow_id = w.id
        JOIN users initiator ON pi.initiator_user_id = initiator.id
        LEFT JOIN process_categories pc ON w.process_type_key = pc.category_key
        LEFT JOIN workflow_steps ws ON pi.current_step_id = ws.id
        LEFT JOIN audit a ON (a.details::jsonb->>'process_instance_id')::int = pi.id AND a.action = 'WORKFLOW_STEP_ACTION'
        LEFT JOIN departments d ON initiator.department_id = d.id -- *** اتصال جدید برای پیدا کردن مدیر ***
        LEFT JOIN purchase_requests pr ON pi.related_record_id = pr.id AND pi.related_table_name = 'purchase_requests'
        LEFT JOIN items i ON pr.item_id = i.id
        LEFT JOIN form_entries fe ON pi.related_record_id = fe.id AND pi.related_table_name = 'form_entries'
        WHERE 
            pi.initiator_user_id = %(user_id)s OR 
            a.user_id = %(user_id)s OR
            d.manager_user_id = %(user_id)s -- *** شرط جدید برای مدیران ***
        ORDER BY pi.id DESC, pi.started_at DESC;
        """
        return self.execute_query(query, {'user_id': user_id})
            
        
    def check_form_in_use(self, form_id: int):
        """بررسی می‌کند که آیا یک فرم توسط یک فرآیند در حال استفاده است یا خیر."""
        query = "SELECT id, name FROM workflows WHERE form_def_id = %s"
        return self.execute_query(query, (form_id,), fetch_one=True)
    
    # این متد کاملا جدید را به انتهای کلاس DB اضافه کنید
    def save_advanced_form_def(self, form_data: dict, user_id: int):
        """یک تعریف فرم پیشرفته را از فرم‌ساز جدید، ثبت یا ویرایش می‌کند."""
        with self.transaction() as cur:
            fields_json = json.dumps(form_data['fields'], ensure_ascii=False)
            form_id = form_data.get('id')
            
            if form_id: # حالت ویرایش
                cur.execute(
                    "UPDATE form_defs SET name = %s, fields = %s, form_type = %s WHERE id = %s",
                    (form_data['name'], fields_json, form_data['type'], form_id)
                )
                return form_id
            else: # حالت افزودن
                cur.execute(
                    "INSERT INTO form_defs (name, fields, user_id, form_type) VALUES (%s, %s, %s, %s) RETURNING id",
                    (form_data['name'], fields_json, user_id, form_data['type'])
                )
                return cur.fetchone()['id']
    
# در کلاس DB، این متد را به طور کامل با نسخه امن زیر جایگزین کنید
# در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید

    def delete_form_def(self, fid: int):
        """
        یک تعریف فرم را به صورت امن حذف می‌کند.
        نسخه نهایی: از context manager برای تضمین اتمی بودن عملیات استفاده می‌کند.
        """
        try:
            with self.transaction() as cur:
                # به لطف ON DELETE CASCADE در جدول form_entries،
                # با حذف این ردیف، تمام رکوردهای مرتبط نیز حذف می‌شوند.
                self.execute_query("DELETE FROM form_defs WHERE id=%s", (fid,), cursor=cur)
        except Exception as e:
            # در صورت بروز خطای پیش‌بینی نشده (مثلا وابستگی در جدول دیگر)
            print(f"ERROR in delete_form_def: {e}")
            raise RuntimeError(f"قادر به حذف فرم با شناسه {fid} نبود. ممکن است این فرم در جای دیگری استفاده شده باشد.")
                    

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def save_workflow_step(self, workflow_id: int, step_data: dict, step_id: int = None):
        """یک مرحله فرآیند را ذخیره (ایجاد یا ویرایش) می‌کند."""
        with self.transaction() as cur:
            # تبدیل دیکشنری قوانین به رشته JSON در صورت وجود
            rules_data = step_data.get('rules')
            rules_json = json.dumps(rules_data) if isinstance(rules_data, dict) else rules_data
            
            # اطمینان از اینکه تمام مقادیر از نوع ساده هستند
            params = {
                'workflow_id': int(workflow_id),
                'step_name': str(step_data['step_name']),
                'step_order': int(step_data['step_order']),
                'approver_type': str(step_data['approver_type']),
                'approver_role_id': int(step_data['approver_role_id']) if step_data.get('approver_role_id') is not None else None,
                'success_status_text': str(step_data.get('success_status_text', '')),
                'failure_status_text': str(step_data.get('failure_status_text', '')),
                'rules': rules_json,
                'id': int(step_id) if step_id is not None else None
            }

            if step_id: # حالت ویرایش
                cur.execute("""
                    UPDATE workflow_steps SET
                        step_name = %(step_name)s,
                        step_order = %(step_order)s,
                        approver_type = %(approver_type)s,
                        approver_role_id = %(approver_role_id)s,
                        success_status_text = %(success_status_text)s,
                        failure_status_text = %(failure_status_text)s,
                        rules = %(rules)s
                    WHERE id = %(id)s
                """, params)
            else: # حالت افزودن
                cur.execute("""
                    INSERT INTO workflow_steps (workflow_id, step_name, step_order, approver_type, approver_role_id, success_status_text, failure_status_text, rules)
                    VALUES (%(workflow_id)s, %(step_name)s, %(step_order)s, %(approver_type)s, %(approver_role_id)s, %(success_status_text)s, %(failure_status_text)s, %(rules)s)
                """, params)
                
                
    def delete_workflow_step(self, step_id: int):
        """یک مرحله از فرآیند را حذف می‌کند."""
        with self.transaction() as cur:
            cur.execute("DELETE FROM workflow_steps WHERE id = %s", (step_id,))
            
# این متد جدید را به کلاس DB اضافه کنید
    def get_distinct_item_categories(self):
        """لیستی از تمام دسته‌بندی‌های منحصر به فرد کالاها را برمی‌گرداند."""
        rows = self.execute_query("SELECT DISTINCT category FROM items WHERE category IS NOT NULL AND category != '' ORDER BY category")
        return [row['category'] for row in rows]
    
            
# این متد جدید را به کلاس DB اضافه کنید
    def check_for_stock_triggers(self):
        """
        کالاهایی که به زیر حد سفارش رسیده‌اند و هیچ درخواست خرید فعالی ندارند را پیدا می‌کند.
        """
        query = """
            SELECT i.id, i.name, i.max_qty
            FROM items i
            LEFT JOIN (
                SELECT item_id, SUM(qty) as total_qty
                FROM stock
                GROUP BY item_id
            ) s ON i.id = s.item_id
            WHERE 
                COALESCE(s.total_qty, 0) < i.min_qty 
                AND i.min_qty > 0
                AND NOT EXISTS (
                    SELECT 1 FROM purchase_requests pr
                    WHERE pr.item_id = i.id AND pr.status NOT IN ('تکمیل شده', 'رد شده', 'باطل شده')
                );
        """
        return self.execute_query(query)
    
# این متد جدید را به کلاس DB اضافه کنید
    def get_active_workflows(self):
        """فقط لیست فرآیندهای فعال و تایید شده را برمی‌گرداند."""
        return self.execute_query("SELECT id, name, version FROM workflows WHERE status = 'ACTIVE' ORDER BY name, version")
  
# Add this new method to your DB class
    def form_name_exists(self, name: str, user_id: int, exclude_form_id: int = None) -> bool:
        """Checks if a form with the given name already exists for the specified user."""
        query = "SELECT 1 FROM form_defs WHERE name = %s AND user_id = %s"
        params = [name, user_id]
        if exclude_form_id:
            query += " AND id != %s"
            params.append(exclude_form_id)
        
        result = self.execute_query(query, tuple(params), fetch_one=True)
        return result is not None
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def create_new_version_of_workflow(self, workflow_id: int, user_id: int) -> int:
        """
        از یک فرآیند موجود، یک نسخه جدید با وضعیت 'DRAFT' ایجاد کرده و تمام مراحل آن را به درستی کپی می‌کند.
        (نسخه اصلاح شده با مدیریت صحیح JSON)
        """
        with self.transaction() as cur:
            # گام ۱: خواندن اطلاعات فرآیند اصلی
            original_wf = self.execute_query("SELECT * FROM workflows WHERE id = %s", (workflow_id,), fetch_one=True, cursor=cur)
            if not original_wf:
                raise ValueError("فرآیند اصلی برای نسخه‌برداری یافت نشد.")

            # گام ۲: ایجاد رکورد فرآیند جدید با شماره نسخه بالاتر
            new_version_number = original_wf['version'] + 1
            new_wf_id = self.execute_query(
                """INSERT INTO workflows (name, description, version, is_active, created_by, status, form_def_id, owner_department_id, process_type_key, is_manual_start, initial_action_key, final_action_key)
                   VALUES (%s, %s, %s, FALSE, %s, 'DRAFT', %s, %s, %s, %s, %s, %s) RETURNING id""",
                (
                    original_wf['name'], original_wf['description'], new_version_number, user_id, 
                    original_wf.get('form_def_id'), original_wf.get('owner_department_id'), original_wf.get('process_type_key'),
                    original_wf.get('is_manual_start'), original_wf.get('initial_action_key'), original_wf.get('final_action_key')
                ),
                fetch_one=True, cursor=cur
            )['id']

            # گام ۳: کپی کردن تمام مراحل از نسخه قدیمی به نسخه جدید
            original_steps = self.execute_query("SELECT * FROM workflow_steps WHERE workflow_id = %s", (workflow_id,), cursor=cur)
            if original_steps:
                for step in original_steps:
                    # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
                    # داده‌های JSON را قبل از ارسال به دیتابیس، به رشته تبدیل می‌کنیم
                    rules_data = step.get('rules')
                    rules_json_string = json.dumps(rules_data) if isinstance(rules_data, dict) else rules_data
                    # --- ************************************* ---
                    
                    self.execute_query(
                        """INSERT INTO workflow_steps (workflow_id, step_name, step_order, approver_type, approver_role_id, success_status_text, failure_status_text, rules)
                           VALUES (%s, %s, %s, %s, %s, %s, %s, %s)""",
                        (
                            new_wf_id, step['step_name'], step['step_order'], step['approver_type'], 
                            step['approver_role_id'], step['success_status_text'], step['failure_status_text'], 
                            rules_json_string # ارسال رشته JSON به دیتابیس
                        ),
                        cursor=cur
                    )
            
            self._log_atomic(cur, user_id, 'WORKFLOW_VERSION_CREATED', f"New version {new_version_number} created for workflow '{original_wf['name']}' (New ID: {new_wf_id})")
            return new_wf_id        
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_ceo_approvals(self):
        """لیست فرآیندهایی که منتظر تایید نهایی مدیرعامل هستند را برمی‌گرداند."""
        query = """
            SELECT w.id, w.name, w.description, u.username as created_by, w.created_at
            FROM workflows w
            LEFT JOIN users u ON w.created_by = u.id
            WHERE w.status = 'PENDING_APPROVAL'
            ORDER BY w.created_at
        """
        return self.execute_query(query)
    
# این متدهای جدید را به انتهای کلاس DB اضافه کنید
    def get_process_categories(self):
        """لیست تمام دسته‌بندی‌های فرآیند تعریف شده را برمی‌گرداند."""
        return self.execute_query("SELECT id, category_key, display_name FROM process_categories ORDER BY display_name")

    def add_or_update_process_category(self, display_name: str, category_key: str, handler_key: str, cat_id: int = None):
        """یک دسته‌بندی فرآیند را به همراه کنترل‌گر سیستمی آن اضافه یا ویرایش می‌کند."""
        with self.transaction() as cur:
            if cat_id:
                cur.execute("UPDATE process_categories SET display_name = %s, category_key = %s, handler_key = %s WHERE id = %s", 
                            (display_name, category_key.upper(), handler_key, cat_id))
            else:
                cur.execute("INSERT INTO process_categories (display_name, category_key, handler_key) VALUES (%s, %s, %s)", 
                            (display_name, category_key.upper(), handler_key))
                
    def delete_process_category(self, cat_id: int):
        """یک دسته‌بندی فرآیند را در صورت عدم استفاده، حذف می‌کند."""
        with self.transaction() as cur:
            in_use = self.execute_query("SELECT 1 FROM workflows WHERE process_type_key = (SELECT category_key FROM process_categories WHERE id = %s) LIMIT 1", (cat_id,), fetch_one=True, cursor=cur)
            if in_use:
                raise ValueError("این دسته‌بندی توسط یک یا چند فرآیند در حال استفاده است و قابل حذف نیست.")
            cur.execute("DELETE FROM process_categories WHERE id = %s", (cat_id,))

    def save_system_operation_mappings(self, mappings: dict):
        """نگاشت جدید عملیات‌های سیستمی به فرآیندها را در دیتابیس ذخیره می‌کند."""
        with self.transaction() as cur:
            cur.execute("TRUNCATE TABLE system_operation_mappings;")
            if mappings:
                args_list = list(mappings.items())
                cur.executemany(
                    "INSERT INTO system_operation_mappings (operation_key, workflow_id) VALUES (%s, %s)",
                    args_list
                )                
    def delete_process_category(self, cat_id: int):
        """یک دسته‌بندی فرآیند را در صورت عدم استفاده، حذف می‌کند."""
        with self.transaction() as cur:
            in_use = self.execute_query("SELECT 1 FROM workflows WHERE process_type_key = (SELECT category_key FROM process_categories WHERE id = %s) LIMIT 1", (cat_id,), fetch_one=True, cursor=cur)
            if in_use:
                raise ValueError("این دسته‌بندی توسط یک یا چند فرآیند در حال استفاده است و قابل حذف نیست.")
            cur.execute("DELETE FROM process_categories WHERE id = %s", (cat_id,))
            
    # در کلاس DB، این متد را به طور کامل جایگزین کنید
    def receive_purchase_order(self, po_id: int, received_items: list, user_id: int):
        """
        نسخه 2.1 (رویداد-محور و هوشمند):
        - وضعیت ورودی (قرنطینه یا تایید شده) را بر اساس انتخاب انباردار ثبت می‌کند.
        """
        with self.transaction() as cur:
            new_stock_ids = []

            for item in received_items:
                if not item.get('batch_no') or not item.get('location_id'):
                    raise ValueError("شماره بچ و محل انبارش برای تمام اقلام الزامی است.")

                trans_notes = f"ورود کالا بر اساس PO (شناسه آیتم سفارش: {item['po_item_id']})"
                self.execute_query(
                    """INSERT INTO trans (item_id, t_type, t_no, t_date, qty, notes, user_id, dest_loc, status, batch_no, expiry_date)
                    VALUES (%s, %s, %s, NOW(), %s, %s, %s, %s, %s, %s, %s) RETURNING id""",
                    (item['item_id'], 'ورود', f"PO-{po_id}", item['qty'], trans_notes, 
                    user_id, item['location_id'], 'تایید شده', item['batch_no'], item.get('expiry_date')),
                    cursor=cur
                )

                # --- *** اصلاح کلیدی: ارسال وضعیت ورودی به صورت داینامیک *** ---
                entry_status = 'قرنطینه' if item.get('requires_qc') else 'تایید شده'

                new_stock_id = self._upd_stock(
                    cur, item['item_id'], item['location_id'], item['qty'], item['batch_no'], 
                    item.get('expiry_date'), return_stock_id=True, entry_status=entry_status,
                    source_po_item_id=item['po_item_id']
                )
                if new_stock_id and entry_status == 'قرنطینه':
                    new_stock_ids.append(new_stock_id)

            self.execute_query("UPDATE purchase_orders SET status = 'دریافت شده' WHERE id = %s", (po_id,), cursor=cur)
            self._log_atomic(cur, user_id, 'GOODS_RECEIPT', f"Received items for PO ID: {po_id}")

        for stock_id in new_stock_ids:
            self.trigger_event(
                event_name='STOCK_ITEM_QUARANTINED',
                record_id=stock_id,
                table_name='stock',
                user_id=user_id
            )
                        
                        


    def get_stock_details_by_id(self, stock_id: int):
        """جزئیات کامل یک رکورد خاص از جدول stock را برمی‌گرداند."""
        query = """
            SELECT s.*, i.name as item_name
            FROM stock s
            JOIN items i ON s.item_id = i.id
            WHERE s.id = %s
        """
        return self.execute_query(query, (stock_id,), fetch_one=True)# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_quarantined_stock(self):
            """لیست تمام موجودی‌هایی که در وضعیت 'قرنطینه' هستند را به همراه جزئیات کامل برمی‌گرداند."""
            query = """
                SELECT 
                    s.id as stock_id,
                    i.name as item_name,
                    s.batch_no,
                    s.qty,
                    u.name as unit,
                    w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS location_label,
                    s.expiry_date,
                    (SELECT sup.name FROM suppliers sup JOIN purchase_orders po ON sup.id = po.supplier_id 
                    JOIN purchase_order_items poi ON po.id = poi.purchase_order_id
                    WHERE poi.id = s.source_po_item_id LIMIT 1) as supplier_name
                FROM stock s
                JOIN items i ON s.item_id = i.id
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                LEFT JOIN units u ON i.unit_id = u.id
                WHERE s.status = 'قرنطینه'
                ORDER BY s.id ASC;
            """
            return self.execute_query(query)

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def update_stock_status(self, stock_id: int, new_status: str, user_id: int, notes: str = ''):
        """
        نسخه 3.0 (کاملاً رویداد-محور):
        - وضعیت یک رکورد موجودی را تغییر می‌دهد.
        - پس از تغییر، رویداد مناسب (تایید یا رد) را برای اتصال به فرآیندهای QA اعلام می‌کند.
        """
        # --- *** اصلاح ۱: وضعیت 'موجود' نیز به عنوان وضعیت نهایی تایید شده پذیرفته می‌شود *** ---
        valid_statuses = ['تایید شده', 'موجود', 'رد شده']
        if new_status not in valid_statuses:
            raise ValueError(f"وضعیت جدید نامعتبر است. فقط وضعیت‌های {valid_statuses} مجاز هستند.")

        item_id = None
        with self.transaction() as cur:
            stock_info = self.execute_query("SELECT item_id, batch_no, qty FROM stock WHERE id = %s AND status = 'قرنطینه' FOR UPDATE", (stock_id,), fetch_one=True, cursor=cur)
            if not stock_info:
                raise ValueError("این رکورد موجودی یافت نشد یا دیگر در وضعیت قرنطینه نیست.")
            
            item_id = stock_info['item_id']
            # اگر وضعیت جدید 'موجود' بود، آن را به 'تایید شده' که استاندارد سیستم است تبدیل می‌کنیم
            final_status_for_db = 'تایید شده' if new_status == 'موجود' else new_status
            
            cur.execute("UPDATE stock SET status = %s WHERE id = %s", (final_status_for_db, stock_id))
            log_details = f"Stock ID:{stock_id} status changed to '{final_status_for_db}'. Item ID:{item_id}, Batch:{stock_info['batch_no']}. Notes: {notes}"
            self._log_atomic(cur, user_id, 'STOCK_STATUS_UPDATE', log_details)
        
        # --- *** بخش جدید و استراتژیک: اعلام رویداد مناسب *** ---
        if item_id:
            event_name = None
            if final_status_for_db == 'تایید شده':
                event_name = 'STOCK_ITEM_APPROVED'
            elif final_status_for_db == 'رد شده':
                event_name = 'STOCK_ITEM_REJECTED' # <-- رویداد جدید و کلیدی

            if event_name:
                event_context = {'stock_id': stock_id, 'item_id': item_id, 'new_status': final_status_for_db, 'user_id': user_id, 'notes': notes}
                self.trigger_event(
                    event_name=event_name,
                    record_id=stock_id,
                    table_name='stock',
                    user_id=user_id,
                    context_data=event_context
                )            
            
                        
            
    def get_stock_details_by_id(self, stock_id: int):
        """جزئیات کامل یک رکورد خاص از جدول stock را برمی‌گرداند."""
        query = """
            SELECT s.*, i.name as item_name
            FROM stock s
            JOIN items i ON s.item_id = i.id
            WHERE s.id = %s
        """
        return self.execute_query(query, (stock_id,), fetch_one=True)
    
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def search_qc_form_entries(self, product_name: str = None, batch_no: str = None):
        """
        گزارش‌های ثبت شده کنترل کیفیت را بر اساس نام محصول یا شماره بچ جستجو می‌کند.
        """
        # ابتدا ID فرم "گزارش کنترل کیفیت محصول نهایی" را پیدا می‌کنیم
        # این فرض می‌کند که نام فرم ثابت است. در آینده می‌توان این بخش را هوشمندتر کرد.
        form_def = self.execute_query(
            "SELECT id FROM form_defs WHERE name = 'گزارش کنترل کیفیت محصول نهایی' AND form_type = 'QA' LIMIT 1",
            fetch_one=True
        )
        if not form_def:
            return [] # اگر فرم تعریف نشده باشد، هیچ رکوردی وجود ندارد

        form_id = form_def['id']
        
        query = """
            SELECT 
                fe.id, 
                fe.ts as submission_date, 
                u.username as submitted_by,
                fe.data
            FROM form_entries fe
            LEFT JOIN users u ON fe.user_id = u.id
            WHERE fe.form_id = %s
        """
        params = [form_id]

        if product_name:
            # جستجو در JSON بر اساس بخشی از نام محصول (در فیلد "انتخاب بچ...")
            query += " AND fe.data ->> 'انتخاب بچ تولید جهت بازرسی' ILIKE %s"
            params.append(f"%{product_name}%")
        
        if batch_no:
            # جستجو در JSON بر اساس بخشی از شماره بچ
            query += " AND fe.data ->> 'انتخاب بچ تولید جهت بازرسی' ILIKE %s"
            params.append(f"%{batch_no}%")
            
        query += " ORDER BY fe.id DESC"
        
        return self.execute_query(query, tuple(params))
    
# این دو متد جدید را به انتهای کلاس DB اضافه کنید

    def get_rejected_stock(self):
        """لیست تمام موجودی‌هایی که در وضعیت 'رد شده' هستند را برمی‌گرداند."""
        query = """
            SELECT
                s.id as stock_id,
                i.name as item_name,
                s.batch_no,
                s.qty,
                u.name as unit,
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS location_label
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE s.status = 'رد شده'
            ORDER BY s.id ASC;
        """
        return self.execute_query(query)

    def resolve_rejected_stock(self, stock_id: int, resolution_type: str, user_id: int, notes: str):
        """
        برای یک کالای رد شده تعیین تکلیف کرده، آن را از موجودی کسر و تراکنش مربوطه را ثبت می‌کند.
        """
        valid_resolutions = ['مرجوع به تامین‌کننده', 'ضایعات']
        if resolution_type not in valid_resolutions:
            raise ValueError("نوع تعیین تکلیف نامعتبر است.")

        with self.transaction() as cur:
            # اطلاعات کامل رکورد موجودی را برای ثبت تراکنش واکشی و قفل می‌کنیم
            stock_info = self.execute_query("SELECT * FROM stock WHERE id = %s AND status = 'رد شده' FOR UPDATE", (stock_id,), fetch_one=True, cursor=cur)
            if not stock_info:
                raise ValueError("این رکورد یافت نشد یا دیگر در وضعیت 'رد شده' قرار ندارد.")

            item_id = stock_info['item_id']
            qty = stock_info['qty']
            location_id = stock_info['location_id']
            batch_no = stock_info['batch_no']
            expiry_date = stock_info.get('expiry_date')

            # ۱. ثبت تراکنش خروج (از نوع مرجوعی یا ضایعات)
            trans_type = f"خروج ({resolution_type})"
            doc_no = f"RES-{stock_id}" # Resolution ID
            self.execute_query(
                """INSERT INTO trans (item_id, t_type, t_no, t_date, qty, notes, user_id, src_loc, status, batch_no, expiry_date)
                   VALUES (%s, %s, %s, NOW(), %s, %s, %s, %s, %s, %s, %s)""",
                (item_id, trans_type, doc_no, qty, notes, user_id, location_id, 'تایید شده', batch_no, expiry_date),
                cursor=cur
            )
            
            # ۲. حذف کامل رکورد از جدول موجودی (stock)
            # چون کالا تعیین تکلیف شده، دیگر نباید در موجودی ما (حتی موجودی رد شده) باقی بماند.
            self.execute_query("DELETE FROM stock WHERE id = %s", (stock_id,), cursor=cur)

            log_details = f"Resolved rejected stock ID:{stock_id} as '{resolution_type}'"
            self._log_atomic(cur, user_id, 'REJECTED_STOCK_RESOLVED', log_details)
            
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_all_customers(self, active_only=False):
        """لیست تمام مشتریان را برمی‌گرداند."""
        query = "SELECT * FROM customers"
        params = []
        if active_only:
            query += " WHERE is_active = %s"
            params.append(True)
        query += " ORDER BY name"
        return self.execute_query(query, tuple(params))

    def add_or_update_customer(self, customer_data: dict, customer_id: int = None):
        """یک مشتری جدید را اضافه یا مشتری موجود را ویرایش می‌کند."""
        if not customer_data.get('name'):
            raise ValueError("نام مشتری نمی‌تواند خالی باشد.")
        
        with self.transaction() as cur:
            if customer_id:
                params = {**customer_data, 'id': customer_id}
                query = """
                    UPDATE customers SET 
                        name = %(name)s, contact_person = %(contact_person)s, phone = %(phone)s,
                        email = %(email)s, address = %(address)s, tax_id = %(tax_id)s,
                        notes = %(notes)s, is_active = %(is_active)s
                    WHERE id = %(id)s
                """
                self.execute_query(query, params, cursor=cur)
            else:
                query = """
                    INSERT INTO customers (name, contact_person, phone, email, address, tax_id, notes, is_active)
                    VALUES (%(name)s, %(contact_person)s, %(phone)s, %(email)s, %(address)s, %(tax_id)s, %(notes)s, %(is_active)s)
                """
                self.execute_query(query, customer_data, cursor=cur)

# در کلاس DB، این دو متد را جایگزین کنید

    def delete_customer(self, customer_id: int):
        """یک مشتری را فقط در صورتی حذف می‌کند که هیچ سفارش فروشی نداشته باشد."""
        with self.transaction() as cur:
            # گام ۱: بررسی وابستگی در جدول سفارشات فروش
            in_use = self.execute_query(
                "SELECT 1 FROM sales_orders WHERE customer_id = %s LIMIT 1",
                (customer_id,),
                cursor=cur,
                fetch_one=True
            )
            if in_use:
                raise ValueError("این مشتری دارای سوابق سفارش فروش است و قابل حذف نیست. لطفاً به جای حذف، آن را غیرفعال کنید.")
            
            # گام ۲: اگر وابستگی وجود نداشت، حذف کن
            self.execute_query("DELETE FROM customers WHERE id = %s", (customer_id,), cursor=cur)

    def delete_supplier(self, supplier_id: int):
        """یک تامین‌کننده را فقط در صورتی حذف می‌کند که هیچ سفارش خریدی نداشته باشد."""
        with self.transaction() as cur:
            # گام ۱: بررسی وابستگی در جداول مرتبط (سفارشات خرید و پیشنهاد قیمت)
            in_use_po = self.execute_query(
                "SELECT 1 FROM purchase_orders WHERE supplier_id = %s LIMIT 1",
                (supplier_id,), cursor=cur, fetch_one=True
            )
            in_use_quote = self.execute_query(
                "SELECT 1 FROM supplier_quotes WHERE supplier_id = %s LIMIT 1",
                (supplier_id,), cursor=cur, fetch_one=True
            )
            if in_use_po or in_use_quote:
                raise ValueError("این تامین‌کننده دارای سوابق سفارش خرید یا پیشنهاد قیمت است و قابل حذف نیست. لطفاً به جای حذف، آن را غیرفعال کنید.")
            
            # گام ۲: اگر وابستگی وجود نداشت، حذف کن
            self.execute_query("DELETE FROM suppliers WHERE id = %s", (supplier_id,), cursor=cur)
                        
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_next_so_number(self):
        """یک شماره سریال جدید برای سفارش فروش تولید می‌کند."""
        now_jalali = jd.datetime.now()
        year_month = f"{now_jalali.year}{now_jalali.month:02d}"
        prefix = f"SO-{year_month}-"
        
        query = "SELECT MAX(so_number) as last_so FROM sales_orders WHERE so_number LIKE %s"
        last_so_rec = self.execute_query(query, (f"{prefix}%",), fetch_one=True)
        
        next_serial = 1
        if last_so_rec and last_so_rec.get('last_so'):
            try:
                last_serial_str = last_so_rec['last_so'].split('-')[-1]
                next_serial = int(last_serial_str) + 1
            except (IndexError, ValueError):
                pass # در صورت بروز خطا، از همان ۱ استفاده می‌شود
                
        return f"{prefix}{next_serial:04d}"

    # این متد را در کلاس DB به طور کامل جایگزین کنید
    def create_sales_order(self, so_data: dict, items_data: list, user_id: int):
        """
        یک سفارش فروش جدید را ثبت کرده و در صورت نیاز، رویداد شروع فرآیند را اعلام می‌کند.
        """
        so_id = None
        with self.transaction() as cur:
            so_number = self.get_next_so_number()
            total_amount = sum(item['quantity'] * item['unit_price'] for item in items_data)

            so_result = self.execute_query(
                """INSERT INTO sales_orders 
                (so_number, customer_id, issue_date, status, total_amount, notes, created_by_id, order_type)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING id""",
                (so_number, so_data['customer_id'], so_data['issue_date'], 'ثبت شده', 
                total_amount, so_data['notes'], user_id, so_data.get('order_type', 'STOCK')),
                fetch_one=True, cursor=cur
            )
            so_id = so_result['id']

            items_to_insert = [(so_id, item['item_id'], item['quantity'], item['unit_price']) for item in items_data]
            cur.executemany(
                "INSERT INTO sales_order_items (sales_order_id, item_id, quantity, unit_price) VALUES (%s, %s, %s, %s)",
                items_to_insert
            )
            self._log_atomic(cur, user_id, 'CREATE_SALES_ORDER', f"SO created: {so_number} with type {so_data.get('order_type', 'STOCK')}.")

        # --- *** بخش جدید و کلیدی: فعال‌سازی فرآیند پس از ثبت موفقیت‌آمیز *** ---
        # این کد خارج از بلوک with قرار دارد تا فقط پس از کامیت موفق اجرا شود
        order_type = so_data.get('order_type', 'STOCK')
        if so_id and order_type == 'MTO':
            self.trigger_event(
                event_name='MTO_SALES_ORDER_CREATED',
                record_id=so_id,
                table_name='sales_orders',
                user_id=user_id
            )
        # --- *************************************************************** ---

        return so_id
            
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_all_sales_orders(self):
        """
        نسخه نهایی:
        - علاوه بر اطلاعات قبلی، وضعیت زنده فرآیند (مرحله فعلی) را نیز برمی‌گرداند.
        """
        query = """
            SELECT 
                so.id, so.so_number, c.name as customer_name, so.issue_date, so.total_amount, so.status,
                u.username as creator_name,
                (SELECT SUM(soi.quantity) FROM sales_order_items soi WHERE soi.sales_order_id = so.id) as total_quantity,
                (SELECT string_agg(
                    CASE 
                        WHEN p.name IS NOT NULL THEN p.name || ' - ' || i.name
                        ELSE i.name 
                    END, ', ') 
                 FROM sales_order_items soi 
                 JOIN items i ON soi.item_id = i.id
                 LEFT JOIN items p ON i.parent_item_id = p.id
                 WHERE soi.sales_order_id = so.id) as items_list,
                -- *** بخش جدید برای خواندن وضعیت زنده فرآیند ***
                ws.step_name as current_workflow_step
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            LEFT JOIN users u ON so.created_by_id = u.id
            -- اتصال به نمونه‌های فرآیند در حال اجرا برای این سفارش
            LEFT JOIN process_instances pi ON so.id = pi.related_record_id 
                                          AND pi.related_table_name = 'sales_orders' 
                                          AND pi.status = 'IN_PROGRESS'
            LEFT JOIN workflow_steps ws ON pi.current_step_id = ws.id
            ORDER BY so.id DESC
        """
        return self.execute_query(query)
    
        
        
    def get_slow_moving_stock(self, days_idle: int = 90):
        """
        لیست کالاهایی که برای مدت زمان مشخص شده هیچ جابجایی نداشته‌اند (کالاهای راکد)
        را برمی‌گرداند. این متد از فیلد last_moved_at استفاده می‌کند.
        """
        query = """
            SELECT
                i.name as item_name,
                s.batch_no,
                s.qty,
                u.name as unit,
                w.name || '|' || l.rack || '-' || l.shelf || '-' || l.bin AS location_label,
                s.last_moved_at
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE 
                w.name != 'Production' AND
                s.last_moved_at IS NOT NULL AND
                s.last_moved_at < NOW() - INTERVAL '%s days'
            ORDER BY s.last_moved_at ASC;
        """
        return self.execute_query(query, (days_idle,))
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_abc_analysis_data(self, analysis_period_days: int, mode: str = 'value'):
        """
        نسخه 2.0:
        - داده‌های تحلیل ABC را به همراه نام محصول مادر (در صورت وجود) آماده می‌کند.
        """
        if mode not in ['value', 'movement']:
            raise ValueError("حالت تحلیل باید 'value' یا 'movement' باشد.")

        # بخش اول: محاسبه معیار اصلی برای هر کالا
        if mode == 'value':
            query = """
                SELECT
                    t.item_id, i.name, p.name as parent_name, i.category,
                    COALESCE(SUM(t.qty * i.cost), 0) as total_value
                FROM trans t
                JOIN items i ON t.item_id = i.id
                LEFT JOIN items p ON i.parent_item_id = p.id
                WHERE 
                    t.t_type LIKE 'خروج%%' AND
                    t.status = 'تایید شده' AND
                    t.t_date >= NOW() - INTERVAL '%s days'
                GROUP BY t.item_id, i.name, p.name, i.category
                HAVING COALESCE(SUM(t.qty * i.cost), 0) > 0;
            """
            measure_column = 'total_value'
        else: # mode == 'movement'
            query = """
                SELECT
                    t.item_id, i.name, p.name as parent_name, i.category,
                    COUNT(t.id) as total_movements
                FROM trans t
                JOIN items i ON t.item_id = i.id
                LEFT JOIN items p ON i.parent_item_id = p.id
                WHERE 
                    t.t_type LIKE 'خروج%%' AND
                    t.status = 'تایید شده' AND
                    t.t_date >= NOW() - INTERVAL '%s days'
                GROUP BY t.item_id, i.name, p.name, i.category
                HAVING COUNT(t.id) > 0;
            """
            measure_column = 'total_movements'

        items_data = self.execute_query(query, (analysis_period_days,))
        if not items_data:
            return []

        # بخش دوم: دسته‌بندی A, B, C در پایتون (بدون تغییر)
        try:
            import pandas as pd
            df = pd.DataFrame(items_data)
            df = df.sort_values(by=measure_column, ascending=False)
            df['cumulative_percentage'] = df[measure_column].cumsum() / df[measure_column].sum()
            def assign_class(percentage):
                if percentage <= 0.8: return 'A'
                elif percentage <= 0.95: return 'B'
                else: return 'C'
            df['abc_class'] = df['cumulative_percentage'].apply(assign_class)
            return df.to_dict('records')
        except ImportError:
            return sorted(items_data, key=lambda x: x[measure_column], reverse=True)
        
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_supplier_performance_data(self):
        """
        عملکرد کیفی تامین‌کنندگان را بر اساس تعداد کل بچ‌های دریافتی و تعداد بچ‌های رد شده
        تحلیل کرده و نرخ رد کیفی (Rejection Rate) را برای هر کدام محاسبه می‌کند.
        """
        # این کوئری تمام بچ‌های ورودی که از طریق سفارش خرید ثبت شده‌اند را شمارش می‌کند
        # و سپس تعداد آنهایی که وضعیتشان 'رد شده' است را محاسبه می‌کند.
        # توجه: این کوئری فرض می‌کند که یادداشت تراکنش ورود، حاوی شناسه آیتم سفارش خرید است.
        query = """
            WITH supplier_batches AS (
                SELECT 
                    po.supplier_id,
                    s.id as stock_id,
                    s.status
                FROM stock s
                JOIN trans t ON s.batch_no = t.batch_no AND s.item_id = t.item_id AND s.location_id = t.dest_loc
                JOIN purchase_order_items poi ON t.t_no LIKE 'PO-%%' AND poi.id = CAST(SUBSTRING(t.notes FROM 'PO \(شناسه آیتم سفارش: (\d+)\)') AS INTEGER)
                JOIN purchase_orders po ON poi.purchase_order_id = po.id
                WHERE t.t_type = 'ورود' AND t.status = 'تایید شده'
            )
            SELECT 
                sup.name as supplier_name,
                COUNT(sb.stock_id) as total_batches,
                COUNT(sb.stock_id) FILTER (WHERE sb.status = 'رد شده') as rejected_batches
            FROM suppliers sup
            LEFT JOIN supplier_batches sb ON sup.id = sb.supplier_id
            GROUP BY sup.name
            HAVING COUNT(sb.stock_id) > 0 -- فقط تامین‌کنندگانی که حداقل یک بچ داشته‌اند
            ORDER BY rejected_batches DESC, total_batches DESC;
        """
        
        performance_data = self.execute_query(query)
        
        # محاسبه نرخ رد کیفی در پایتون
        for row in performance_data:
            total = row['total_batches']
            rejected = row.get('rejected_batches', 0)
            if total > 0:
                row['rejection_rate'] = (rejected / total) * 100
            else:
                row['rejection_rate'] = 0
                
        return sorted(performance_data, key=lambda x: x['rejection_rate'], reverse=True)
    
    
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def update_location_position(self, loc_id: int, pos_x: float, pos_y: float):
        """مختصات گرافیکی یک لوکیشن را در دیتابیس به‌روزرسانی می‌کند."""
        with self.transaction() as cur:
            self.execute_query(
                "UPDATE locations SET pos_x = %s, pos_y = %s WHERE id = %s",
                (pos_x, pos_y, loc_id),
                cursor=cur
            )
            
# این دو متد جدید را به انتهای کلاس DB اضافه کنید

    def get_po_details(self, po_id: int):
        """اطلاعات اصلی (هدر) یک سفارش خرید مشخص را برمی‌گرداند."""
        query = """
            SELECT 
                po.*, 
                s.name as supplier_name,
                u.username as creator_name
            FROM purchase_orders po
            JOIN suppliers s ON po.supplier_id = s.id
            LEFT JOIN users u ON po.created_by_id = u.id
            WHERE po.id = %s
        """
        return self.execute_query(query, (po_id,), fetch_one=True)

    def get_po_line_items(self, po_id: int):
        """لیست تمام اقلام (line items) مربوط به یک سفارش خرید را برمی‌گرداند."""
        query = """
            SELECT 
                poi.*,
                i.name as item_name,
                u.name as unit
            FROM purchase_order_items poi
            JOIN items i ON poi.item_id = i.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE poi.purchase_order_id = %s
            ORDER BY i.name
        """
        return self.execute_query(query, (po_id,))
    
# در کلاس DB، این متد را به طور کامل جایگزین کنید

    def get_open_sales_orders(self):
        """لیست تمام سفارشات فروشی که در وضعیت 'آماده ارسال' هستند را برمی‌گرداند."""
        query = """
            SELECT 
                so.id,
                so.so_number,
                c.name as customer_name,
                so.issue_date,
                (SELECT string_agg(i.name || ' (' || soi.quantity::text || ')', ', ') 
                 FROM sales_order_items soi 
                 JOIN items i ON soi.item_id = i.id 
                 WHERE soi.sales_order_id = so.id) as items_summary
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            WHERE so.status = 'آماده ارسال'
            ORDER BY so.issue_date ASC;
        """
        return self.execute_query(query)
        
# این سه متد جدید را به انتهای کلاس DB اضافه کنید

    def get_user_favorites(self, user_id: int):
        """لیست تمام علاقه‌مندی‌های ثبت شده برای یک کاربر را برمی‌گرداند."""
        query = "SELECT favorite_key, display_name FROM user_favorites WHERE user_id = %s ORDER BY display_name"
        return self.execute_query(query, (user_id,))

    def add_to_favorites(self, user_id: int, favorite_key: str, display_name: str):
        """یک آیتم را به لیست علاقه‌مندی‌های کاربر اضافه می‌کند."""
        # ON CONFLICT DO NOTHING از ثبت موارد تکراری جلوگیری می‌کند
        query = """
            INSERT INTO user_favorites (user_id, favorite_key, display_name)
            VALUES (%s, %s, %s) ON CONFLICT (user_id, favorite_key) DO NOTHING
        """
        with self.transaction() as cur:
            self.execute_query(query, (user_id, favorite_key, display_name), cursor=cur)

    def remove_from_favorites(self, user_id: int, favorite_key: str):
        """یک آیتم را از لیست علاقه‌مندی‌های کاربر حذف می‌کند."""
        query = "DELETE FROM user_favorites WHERE user_id = %s AND favorite_key = %s"
        with self.transaction() as cur:
            self.execute_query(query, (user_id, favorite_key), cursor=cur)
            
    def get_production_summary_by_day(self, days_history: int = 30):
        """نسخه 2.0: با CAST کردن تاریخ، از صحت عملکرد JOIN اطمینان حاصل می‌کند."""
        query = """
            WITH date_series AS (
                SELECT generate_series(
                    CURRENT_DATE - INTERVAL '%s days', CURRENT_DATE, '1 day'
                )::date AS report_date
            )
            SELECT 
                d.report_date, COALESCE(SUM(t.qty), 0) AS total_production
            FROM date_series d
            LEFT JOIN trans t ON t.t_date::date = d.report_date 
                             AND t.t_type = 'ورود از تولید' AND t.status = 'تایید شده'
            GROUP BY d.report_date
            ORDER BY d.report_date ASC;
        """
        return self.execute_query(query, (days_history,))
    
                
    def get_sales_summary_by_day(self, days_history: int = 30):
        """نسخه 2.0: با CAST کردن تاریخ، از صحت عملکرد JOIN اطمینان حاصل می‌کند."""
        query = """
            WITH date_series AS (
                SELECT generate_series(
                    CURRENT_DATE - INTERVAL '%s days', CURRENT_DATE, '1 day'
                )::date AS report_date
            )
            SELECT 
                d.report_date, COALESCE(SUM(so.total_amount), 0) AS total_sales
            FROM date_series d
            LEFT JOIN sales_orders so ON so.issue_date::date = d.report_date AND so.status NOT IN ('لغو شده', 'باطل شده')
            GROUP BY d.report_date
            ORDER BY d.report_date ASC;
        """
        return self.execute_query(query, (days_history,))
        
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_sales_summary_by_product(self, days_history: int = 30, top_n: int = 5):
        """
        لیست N محصول پرفروش را بر اساس تعداد کل فروخته شده در بازه زمانی مشخص برمی‌گرداند.
        """
        query = """
            SELECT 
                i.name as product_name,
                SUM(soi.quantity) as total_quantity
            FROM sales_order_items soi
            JOIN sales_orders so ON soi.sales_order_id = so.id
            JOIN items i ON soi.item_id = i.id
            WHERE 
                so.issue_date >= CURRENT_DATE - INTERVAL '%s days'
                AND so.status NOT IN ('لغو شده', 'باطل شده')
            GROUP BY i.name
            ORDER BY total_quantity DESC
            LIMIT %s;
        """
        return self.execute_query(query, (days_history, top_n))
    
    def get_cogs_summary_by_day(self, days_history: int = 30):
        """نسخه 2.0: با CAST کردن تاریخ، از صحت عملکرد JOIN اطمینان حاصل می‌کند."""
        query = """
            WITH date_series AS (
                SELECT generate_series(
                    CURRENT_DATE - INTERVAL '%s days', CURRENT_DATE, '1 day'
                )::date AS report_date
            ),
            sold_items_daily AS (
                SELECT 
                    so.issue_date::date as sale_date, soi.item_id, SUM(soi.quantity) as total_sold_qty
                FROM sales_order_items soi
                JOIN sales_orders so ON soi.sales_order_id = so.id
                WHERE so.status NOT IN ('لغو شده', 'باطل شده')
                GROUP BY so.issue_date::date, soi.item_id
            )
            SELECT 
                d.report_date,
                COALESCE(SUM(
                    (SELECT SUM(bom.qty * raw_item.cost) 
                     FROM bill_of_materials bom
                     JOIN items raw_item ON bom.raw_item_id = raw_item.id
                     WHERE bom.product_code = i.name)
                * sid.total_sold_qty), 0) as total_cogs
            FROM date_series d
            LEFT JOIN sold_items_daily sid ON sid.sale_date = d.report_date
            LEFT JOIN items i ON sid.item_id = i.id
            GROUP BY d.report_date
            ORDER BY d.report_date ASC;
        """
        return self.execute_query(query, (days_history,))
    
# این متد جدید را به انتهای کلاس DB اضافه کنید

    def get_invoice_data_for_sales_order(self, sales_order_id: int):
        """
        تمام اطلاعات لازم برای صدور فاکتور فروش را برای یک سفارش مشخص،
        از جمله جزئیات کامل مشتری و اقلام سفارش (با نام کامل مادر-فرزند)، آماده می‌کند.
        """
        # گام ۱: واکشی اطلاعات اصلی سفارش و مشتری
        header_query = """
            SELECT 
                so.so_number, so.issue_date, so.notes as order_notes,
                c.name as customer_name, c.contact_person, c.phone, 
                c.address, c.tax_id
            FROM sales_orders so
            JOIN customers c ON so.customer_id = c.id
            WHERE so.id = %s
        """
        header_data = self.execute_query(header_query, (sales_order_id,), fetch_one=True)
        
        if not header_data:
            return None

        # گام ۲: واکشی اقلام سفارش با نام کامل
        items_query = """
            SELECT 
                -- *** اصلاح کلیدی اینجاست: ساخت نام کامل ***
                CASE 
                    WHEN p.name IS NOT NULL THEN p.name || ' - ' || i.name
                    ELSE i.name 
                END as full_item_name,
                i.sku,
                soi.quantity, soi.unit_price
            FROM sales_order_items soi
            JOIN items i ON soi.item_id = i.id
            LEFT JOIN items p ON i.parent_item_id = p.id -- اتصال به خود جدول برای پیدا کردن والد
            WHERE soi.sales_order_id = %s
        """
        items_data = self.execute_query(items_query, (sales_order_id,))
        
        return {
            "header": header_data,
            "items": items_data
        }
                
# در کلاس DB، این متد را به طور کامل جایگزین کنید

# در کلاس DB، این متد را به طور کامل جایگزین کنید
    def get_prepopulation_data(self, source_table: str, source_id: int):
        """نسخه نهایی (هوشمند): بر اساس نوع سند، داده‌های صحیح را از جداول مختلف برمی‌گرداند."""
        if not source_table or not source_id:
            return None

        if source_table == 'sales_orders':
            query = """
                SELECT so.so_number AS "SO_NUMBER", c.name AS "CUSTOMER_NAME", c.address AS "CUSTOMER_ADDRESS",
                       c.tax_id AS "CUSTOMER_TAX_ID",
                       (SELECT string_agg(i.name || ' (' || soi.quantity::text || ' ' || u.name || ')', E'\n') 
                        FROM sales_order_items soi JOIN items i ON soi.item_id = i.id
                        LEFT JOIN units u ON i.unit_id = u.id WHERE soi.sales_order_id = so.id) AS "SO_ITEMS_SUMMARY"
                FROM sales_orders so JOIN customers c ON so.customer_id = c.id WHERE so.id = %s
            """
            return self.execute_query(query, (source_id,), fetch_one=True)
        
        # --- *** بخش جدید برای خواندن اطلاعات از اقلام سفارش فروش *** ---
        elif source_table == 'sales_order_items':
            query = """
                SELECT 
                    i.name AS "SO_ITEM_NAME",
                    soi.quantity AS "SO_ITEM_QTY",
                    soi.unit_price AS "SO_ITEM_PRICE",
                    so.so_number AS "SO_NUMBER",
                    c.name AS "CUSTOMER_NAME"
                FROM sales_order_items soi
                JOIN items i ON soi.item_id = i.id
                JOIN sales_orders so ON soi.sales_order_id = so.id
                JOIN customers c ON so.customer_id = c.id
                WHERE soi.id = %s
            """
            return self.execute_query(query, (source_id,), fetch_one=True)
        
        elif source_table == 'purchase_requests':
            query = """
                SELECT i.name as "PR_ITEM_NAME", pr.requested_qty as "PR_REQUESTED_QTY"
                FROM purchase_requests pr JOIN items i ON pr.item_id = i.id WHERE pr.id = %s
            """
            return self.execute_query(query, (source_id,), fetch_one=True)
            
        return None
    
        
# این متد جدید را به کلاس DB اضافه کنید
    def get_proforma_invoice_history(self, user_id: int):
        """تاریخچه تمام پیش‌فاکتورهای در جریان که توسط کاربر فعلی آغاز شده‌اند را برمی‌گرداند."""
        query = """
            SELECT
                so.so_number,
                c.name as customer_name,
                pi.started_at,
                ws.step_name as current_step,
                pi.status as process_status
            FROM process_instances pi
            JOIN sales_orders so ON pi.related_record_id = so.id AND pi.related_table_name = 'sales_orders'
            JOIN customers c ON so.customer_id = c.id
            JOIN workflows w ON pi.workflow_id = w.id
            LEFT JOIN workflow_steps ws ON pi.current_step_id = ws.id
            WHERE pi.initiator_user_id = %s
              AND w.name = 'فرآیند ارسال کالا' -- فرض بر اینکه نام فرآیند ثابت است
            ORDER BY pi.started_at DESC;
        """
        return self.execute_query(query, (user_id,))
    
# این سه متد را جایگزین متد get_traceability_report قبلی در کلاس DB کنید

    def _trace_bulk_batch_to_suppliers(self, product_batch_no: str):
        """
        (داخلی) برای یک بچ محصول فله، مواد اولیه و تامین‌کنندگان را ردیابی می‌کند.
        """
        query = """
            WITH consumed_batches AS (
                SELECT DISTINCT raw_item_id, raw_batch
                FROM bill_of_materials
                WHERE product_code = %s AND status = 'ACTIVE'
            ),
            entry_transactions AS (
                SELECT
                    t.id as trans_id, t.item_id, t.batch_no,
                    CAST(substring(t.notes from '\\(شناسه آیتم سفارش: (\\d+)\\)') AS INTEGER) as po_item_id
                FROM trans t
                JOIN consumed_batches cb ON t.item_id = cb.raw_item_id AND t.batch_no = cb.raw_batch
                WHERE t.t_type = 'ورود' AND t.status = 'تایید شده' AND t.notes LIKE '%%شناسه آیتم سفارش%%'
            )
            SELECT
                cb.raw_batch, i_raw.name as raw_material_name,
                po.po_number, s.name as supplier_name
            FROM consumed_batches cb
            JOIN items i_raw ON cb.raw_item_id = i_raw.id
            LEFT JOIN entry_transactions et ON cb.raw_item_id = et.item_id AND cb.raw_batch = et.batch_no
            LEFT JOIN purchase_order_items poi ON et.po_item_id = poi.id
            LEFT JOIN purchase_orders po ON poi.purchase_order_id = po.id
            LEFT JOIN suppliers s ON po.supplier_id = s.id
            GROUP BY cb.raw_batch, i_raw.name, po.po_number, s.name;
        """
        return self.execute_query(query, (product_batch_no,))

    def _find_bulk_batches_for_packed_batch(self, packed_product_batch_no: str) -> list:
        """
        مرحله اول ردیابی: با جستجو در لاگ بسته‌بندی، بچ(های) محصول فله استفاده شده را پیدا می‌کند.
        """
        query = """
            SELECT details FROM audit 
            WHERE action LIKE 'PACKING_EVENT%%'
              AND details LIKE '{%%}'
              AND details::jsonb -> 'output_product' ->> 'batch' = %s
            ORDER BY id DESC LIMIT 1
        """
        audit_log = self.execute_query(query, (packed_product_batch_no,), fetch_one=True)
        if not audit_log or not audit_log.get('details'):
            return []
            
        try:
            packing_data = json.loads(audit_log['details'])
            bulk_components = packing_data.get('components', [])
            
            bulk_batch_nos = []
            for comp in bulk_components:
                delivery_id = comp.get('delivery_id')
                if delivery_id:
                    delivery_rec = self.get_delivery_details(delivery_id)
                    if delivery_rec and delivery_rec.get('production_batch_no'):
                        bulk_batch_nos.append(delivery_rec['production_batch_no'])
            return list(set(bulk_batch_nos))
        except (json.JSONDecodeError, KeyError):
            return []

    def get_full_traceability_report(self, final_product_batch_no: str) -> dict:
        """
        تابع اصلی و کامل ردیابی سرتاسری.
        """
        report = {}
        # مرحله ۱: پیدا کردن بچ‌های فله
        bulk_batches = self._find_bulk_batches_for_packed_batch(final_product_batch_no)
        
        # اگر بچ فله‌ای از طریق لاگ بسته‌بندی پیدا نشد،
        # شاید بچ ورودی خودش یک بچ فله باشد. پس آن را هم امتحان می‌کنیم.
        if not bulk_batches:
            bulk_batches = [final_product_batch_no]

        # مرحله ۲: ردیابی هر بچ فله به مواد اولیه
        for bulk_batch in bulk_batches:
            raw_materials = self._trace_bulk_batch_to_suppliers(bulk_batch)
            if raw_materials:
                report[bulk_batch] = raw_materials
        
        return report
    
# این متد موقت را برای دیباگ به انتهای کلاس DB اضافه کنید

    def debug_get_packing_audit_log(self, packed_product_batch_no: str):
        """(فقط برای دیباگ) محتوای خام لاگ حسابرسی برای یک بچ بسته‌بندی را جستجو کرده و برمی‌گرداند."""
        try:
            # ابتدا تمام لاگ‌های مربوط به بسته‌بندی را می‌خوانیم
            query = """
                SELECT id, stamp, action, details FROM audit
                WHERE action LIKE 'PACKING_EVENT%%' ORDER BY id DESC
            """
            all_packing_logs = self.execute_query(query)

            if not all_packing_logs:
                return "هیچ لاگ بسته‌بندی (PACKING_EVENT) در جدول audit یافت نشد."

            # در پایتون به دنبال بچ نامبر مورد نظر می‌گردیم تا از خطای SQL جلوگیری کنیم
            for log in all_packing_logs:
                details_str = log.get('details', '')
                if packed_product_batch_no in details_str:
                    # اگر پیدا شد، آن را برای تحلیل برمی‌گردانیم
                    return f"--- Log Found (ID: {log['id']}, Action: {log['action']}) ---\n\n{details_str}"
            
            return f"لاگ بسته‌بندی برای بچ '{packed_product_batch_no}' یافت نشد. لطفاً از وجود چنین لاگی اطمینان حاصل کنید."
        except Exception as e:
            return f"An unexpected error occurred during debug search: {e}"
                        
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def get_stock_details_for_item_in_warehouse(self, item_id: int, warehouse_name: str):
        """جزئیات کامل موجودی یک کالا را فقط در یک انبار مشخص برمی‌گرداند."""
        query = """
            SELECT
                i.name as item_name,
                s.batch_no,
                s.qty,
                u.name as unit,
                s.expiry_date
            FROM stock s
            JOIN items i ON s.item_id = i.id
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            LEFT JOIN units u ON i.unit_id = u.id
            WHERE s.item_id = %s AND w.name = %s AND s.qty > 0.001
            ORDER BY s.expiry_date ASC NULLS LAST, s.batch_no;
        """
        return self.execute_query(query, (item_id, warehouse_name))
    
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def get_all_transactional_items(self):
        """
        شناسه تمام کالاهایی که می‌توانند تراکنش داشته باشند (محصولات مادر نیستند) را برمی‌گرداند.
        """
        query = "SELECT id FROM items WHERE is_parent_product = FALSE"
        return self.execute_query(query)
    
# این متدهای جدید را به انتهای کلاس DB اضافه کنید
    def get_all_users_detailed(self):
        """لیست کامل کاربران را به همراه نام نقش و واحد سازمانی آن‌ها برمی‌گرداند."""
        query = """
            SELECT u.id, u.username, r.name as role_name, d.name as department_name, u.department_id, u.role_id
            FROM users u 
            LEFT JOIN roles r ON u.role_id = r.id
            LEFT JOIN departments d ON u.department_id = d.id
            ORDER BY u.username
        """
        return self.execute_query(query)

    def add_or_update_user(self, username: str, password: str, role_id: int, department_id: int, is_new: bool):
        """یک کاربر جدید را اضافه یا یک کاربر موجود را ویرایش می‌کند."""
        with self._conn() as conn:
            with conn.cursor() as cur:
                if is_new:
                    if not password:
                        raise ValueError("برای کاربر جدید، وارد کردن رمز الزامی است.")
                    cur.execute("""
                        INSERT INTO users(username, passhash, role_id, department_id) VALUES (%s, %s, %s, %s)
                    """, (username, hash_password(password), role_id, department_id))
                else: # حالت ویرایش
                    if password: # اگر رمز جدیدی وارد شده بود
                        cur.execute("UPDATE users SET passhash = %s, role_id = %s, department_id = %s WHERE username = %s", 
                                    (hash_password(password), role_id, department_id, username))
                    else: # اگر رمز جدیدی وارد نشده بود (فقط نقش یا واحد تغییر کرده)
                        cur.execute("UPDATE users SET role_id = %s, department_id = %s WHERE username = %s", 
                                    (role_id, department_id, username))
            conn.commit()
            
    # در کلاس DB، این متد را با نسخه کامل زیر جایگزین کنید
    def create_production_order_from_so(self, sales_order_id: int, user_id: int, cur=None):
        """
        برای یک سفارش فروش مشخص، سفارش(های) تولید متناظر را ایجاد می‌کند.
        این نسخه می‌تواند در یک تراکنش موجود شرکت کند.
        """
        if not cur:
            raise ValueError("A database cursor is required for this operation.")

        so_items = self.execute_query("SELECT item_id, quantity FROM sales_order_items WHERE sales_order_id = %s", (sales_order_id,), cursor=cur)
        if not so_items:
            raise ValueError(f"سفارش فروش با شناسه {sales_order_id} هیچ کالایی برای تولید ندارد.")

        created_ids = []
        for item in so_items:
            res = self.execute_query(
                """INSERT INTO production_orders (source_sales_order_id, item_id, quantity, status, notes)
                VALUES (%s, %s, %s, %s, %s) RETURNING id""",
                (sales_order_id, item['item_id'], item['quantity'], 
                'در انتظار تولید', 'ایجاد شده به صورت خودکار از فرآیند فروش'),
                fetch_one=True, cursor=cur
            )
            created_ids.append(res['id'])

        self.execute_query("UPDATE sales_orders SET status = 'در حال تولید' WHERE id = %s", (sales_order_id,), cursor=cur)
        log_details = f"Created Production Order(s) {created_ids} from Sales Order ID: {sales_order_id}"
        self._log_atomic(cur, user_id, 'CREATE_PROD_ORDER_FROM_SO', log_details)

        return created_ids
            
# این متد جدید را به کلاس DB اضافه کنید
    def get_wip_stock_for_item(self, item_id: int) -> float:
        """موجودی یک کالای فله که تولید شده ولی هنوز به انبار اصلی تحویل نشده را برمی‌گرداند."""
        query = """
            SELECT COALESCE(SUM(quantity), 0) as total_qty
            FROM production_deliveries
            WHERE product_item_id = %s AND status = 'تولید شده'
        """
        result = self.execute_query(query, (item_id,), fetch_one=True)
        return result['total_qty'] if result else 0.0

# متد get_pending_production_orders را در کلاس DB با این نسخه جایگزین کنید
    def get_pending_production_orders(self):
        """لیست تمام سفارشات تولیدی که در وضعیت‌های مختلف 'در انتظار' هستند را برمی‌گرداند."""
        query = """
            SELECT 
                po.id,
                i.name as item_name,
                po.quantity,
                so.so_number,
                c.name as customer_name,
                po.created_at,
                po.status  -- ستون وضعیت اضافه شد
            FROM production_orders po
            JOIN items i ON po.item_id = i.id
            LEFT JOIN sales_orders so ON po.source_sales_order_id = so.id
            LEFT JOIN customers c ON so.customer_id = c.id
            WHERE po.status IN ('در انتظار تولید', 'در انتظار محصول فله', 'در انتظار بسته‌بندی')
            ORDER BY po.created_at ASC;
        """
        return self.execute_query(query)
        
    # این متد جدید را به کلاس DB اضافه کنید
    def create_bulk_request_for_pack_order(self, pack_order_id: int, user_id: int):
        """برای یک سفارش 'پک'، سفارش تولید 'فله' متناظر آن را به صورت خودکار ایجاد می‌کند."""
        with self.transaction() as cur:
            pack_order = self.execute_query("SELECT item_id, quantity FROM production_orders WHERE id = %s", (pack_order_id,), fetch_one=True, cursor=cur)
            if not pack_order: raise ValueError("سفارش تولید اصلی یافت نشد.")

            pack_item_details = self.get_item_details(pack_order['item_id'])
            if not pack_item_details or not pack_item_details.get('parent_item_id'):
                raise ValueError("این کالا یک محصول مادر (فله) ندارد. نمی‌توان برای آن سفارش تولید فله ایجاد کرد.")

            parent_bulk_item_id = pack_item_details['parent_item_id']
            # مقدار فله مورد نیاز بر اساس وزن خالص پک محاسبه می‌شود
            required_bulk_qty = pack_order['quantity'] * (pack_item_details.get('net_weight', 1.0))
            if required_bulk_qty <= 0:
                raise ValueError("وزن خالص برای این پک (net_weight) به درستی تعریف نشده و محاسبه مقدار فله ممکن نیست.")

            existing = self.execute_query("SELECT id FROM production_orders WHERE parent_production_order_id = %s", (pack_order_id,), fetch_one=True, cursor=cur)
            if existing:
                raise ValueError("یک سفارش تولید فله از قبل برای این پک ایجاد شده است.")

            res = self.execute_query(
                """INSERT INTO production_orders (item_id, quantity, status, parent_production_order_id, notes)
                VALUES (%s, %s, %s, %s, %s) RETURNING id""",
                (parent_bulk_item_id, required_bulk_qty, 'در انتظار تولید', pack_order_id, f"تولید فله برای سفارش پک #{pack_order_id}"),
                fetch_one=True, cursor=cur
            )['id']

            # وضعیت سفارش پک اصلی را به‌روزرسانی می‌کنیم
            self.execute_query("UPDATE production_orders SET status = 'در انتظار محصول فله' WHERE id = %s", (pack_order_id,), cursor=cur)

            self._log_atomic(cur, user_id, 'CREATE_BULK_ORDER', f"Created bulk order {res['id']} for pack order {pack_order_id}")
            return res['id']
        
    # این متد را در کلاس DB به طور کامل جایگزین کنید
    def get_diagnostic_report_data(self):
        """داده‌های کلیدی سیستم را برای تحلیل و عیب‌یابی جمع‌آوری می‌کند."""
        report = {}
        # ۱. بررسی پیکربندی فرآیند فروش

        # --- *** اصلاح کلیدی: کوئری به صورت پارامتری و امن نوشته شد *** ---
        query_wf = "SELECT id, name, version, final_action_key, status FROM workflows WHERE name LIKE %s ORDER BY id DESC"
        params_wf = ('%تایید فروش%',)
        report['sales_workflow'] = self.execute_query(query_wf, params_wf, fetch_one=True)

        # ۲. بررسی آخرین فرآیندهای تکمیل شده
        report['last_completed_instances'] = self.execute_query(
            """SELECT pi.id, pi.workflow_id, pi.status, pi.completed_at, w.name 
            FROM process_instances pi JOIN workflows w ON pi.workflow_id = w.id 
            WHERE pi.status = 'COMPLETED' ORDER BY pi.completed_at DESC LIMIT 5"""
        )
        # ۳. بررسی آخرین لاگ‌های حسابرسی مرتبط
        report['last_audit_logs'] = self.execute_query(
            """SELECT stamp, action, details FROM audit 
            WHERE action IN ('WORKFLOW_STEP_ACTION', 'CREATE_PROD_ORDER_FROM_SO') 
            ORDER BY id DESC LIMIT 10"""
        )
        return report
    
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def get_item_stock_in_warehouse(self, item_id: int, warehouse_name: str, cursor=None) -> float:
        """مجموع موجودی یک کالا در یک انبار مشخص را برمی‌گرداند."""
        query = """
            SELECT COALESCE(SUM(s.qty), 0) as total_qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND w.name = %s
        """
        result = self.execute_query(query, (item_id, warehouse_name), fetch_one=True, cursor=cursor)
        return result['total_qty'] if result else 0.0
    
# این متد جدید و بسیار مهم را به انتهای کلاس DB اضافه کنید
    def execute_packing_plan(self, packing_data: dict, user_id: int):
        """
        یک پلن بسته‌بندی کامل را به صورت اتمیک اجرا می‌کند:
        - مواد فله را از انبار اصلی کسر می‌کند.
        - لوازم بسته‌بندی را از انبار تولید کسر می‌کند.
        - محصول نهایی را به انبار تولید اضافه می‌کند.
        - وضعیت سفارش تولید را به‌روز می‌کند.
        - یک لاگ حسابرسی جامع ثبت می‌کند.
        """
        with self.transaction() as cur:
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # ۱. کسر موجودی اجزای فله از انبار اصلی
            for pick in packing_data['bulk_components_plan']:
                self._upd_stock(cur, item_id=pick['item_id'], location_id=pick['location_id'], 
                                qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'], 
                                expiry_date=pick.get('expiry_date'))

            # ۲. کسر موجودی لوازم بسته‌بندی از انبار تولید
            for pick in packing_data['packaging_supplies_plan']:
                self._upd_stock(cur, item_id=pick['item_id'], location_id=pick['location_id'], 
                                qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'], 
                                expiry_date=pick.get('expiry_date'))

            # ۳. افزودن محصول نهایی بسته‌بندی شده به انبار تولید
            output = packing_data['output_product']
            self._upd_stock(cur, item_id=output['item_id'], location_id=prod_loc_id, 
                            qty_change=abs(output['qty']), batch_no=output['batch'], 
                            expiry_date=output.get('expiry_date'))
            
            # ۴. به‌روزرسانی وضعیت سفارش تولید
            self.execute_query(
                "UPDATE production_orders SET status = 'تکمیل شده' WHERE id = %s",
                (packing_data['production_order_id'],),
                cursor=cur
            )

            # ۵. ثبت لاگ حسابرسی
            log_details = json.dumps(packing_data, ensure_ascii=False, default=str)
            self._log_atomic(cur, user_id, 'EXECUTE_PACKING_PLAN', log_details)
            
# این دو متد جدید را به کلاس DB اضافه کنید

    def does_active_material_request_exist(self, production_order_id: int, item_id: int) -> bool:
        """بررسی می‌کند که آیا یک درخواست مواد فعال برای یک سفارش تولید و کالای خاص وجود دارد یا خیر."""
        notes_pattern = f"%سفارش شماره {production_order_id}%"
        query = """
            SELECT 1 FROM material_requests 
            WHERE item_id = %s AND notes LIKE %s 
            AND status = 'PENDING' 
            LIMIT 1
        """
        result = self.execute_query(query, (item_id, notes_pattern), fetch_one=True)
        return result is not None

    
# این متد تشخیصی را در کلاس DB با نسخه کامل‌تر زیر جایگزین کنید
    def debug_get_item_trace(self, item_name: str) -> str:
        """یک گزارش کامل از وضعیت یک کالا در تمام جداول مرتبط برای دیباگ برمی‌گرداند."""
        report = f"--- گزارش ردیابی برای: {item_name} ---\n"
        try:
            item_details = self.get_item_by_name(item_name)
            if not item_details:
                return f"{report}خطا: کالایی با این نام یافت نشد.\n"
            
            item_id = item_details['id']
            report += f"1. اطلاعات کاتالوگ (items):\n"
            report += f"   - ID: {item_id}, Category: {item_details.get('category')}, Parent ID: {item_details.get('parent_item_id')}\n\n"

            # --- بخش جدید و دقیق‌تر برای گزارش موجودی انبار تولید ---
            report += f"2. موجودی در انبار تولید (stock @ Production):\n"
            stock_prod_records = self.execute_query("""
                SELECT qty, status, batch_no FROM stock s
                JOIN locations l ON s.location_id = l.id
                JOIN warehouses w ON l.warehouse_id = w.id
                WHERE s.item_id = %s AND w.name = %s
            """, (item_id, PRODUCTION_WAREHOUSE_NAME))
            
            if not stock_prod_records:
                report += "   - هیچ رکوردی یافت نشد.\n\n"
            else:
                for rec in stock_prod_records:
                    report += f"   - بچ: {rec['batch_no']}, مقدار: {rec['qty']}, وضعیت: **{rec['status']}**\n"
                report += "\n"
            # ----------------------------------------------------

            wip_stock = self.get_wip_stock_for_item(item_id)
            report += f"3. موجودی در حال تولید (production_deliveries @ PRODUCED):\n"
            report += f"   - مجموع موجودی: {wip_stock}\n"
            report += "---------------------------------------\n"
            return report
        except Exception as e:
            return f"خطا در حین اجرای ردیابی: {e}"
        
                
# این متد جدید و بسیار مهم را به انتهای کلاس DB اضافه کنید
    def execute_packing_plan_from_production(self, packing_data: dict, user_id: int):
        """
        یک پلن بسته‌بندی کامل را که از انبار تولید تغذیه می‌شود، به صورت اتمیک اجرا می‌کند.
        این متد هم برای میزکار هوشمند و هم برای بسته‌بندی دستی استفاده می‌شود.
        """
        with self.transaction() as cur:
            prod_loc_id = self.get_production_floor_location()
            if not prod_loc_id:
                raise ValueError("انبار تولید در سیستم تعریف نشده است.")

            # ۱. کسر موجودی تمام اجزاء (فله و لوازم بسته‌بندی) از انبار تولید
            for pick in packing_data['components_plan']:
                self._upd_stock(cur, item_id=pick['item_id'], location_id=pick['location_id'], 
                                qty_change=-abs(pick['pick_qty']), batch_no=pick['batch_no'], 
                                expiry_date=pick.get('expiry_date'))

            # ۲. افزودن محصول نهایی بسته‌بندی شده به انبار تولید
            output = packing_data['output_product']
            self._upd_stock(cur, item_id=output['item_id'], location_id=prod_loc_id, 
                            qty_change=abs(output['qty']), batch_no=output['batch'], 
                            expiry_date=output.get('expiry_date'))
            
            production_order_id = packing_data.get('production_order_id')
            log_action = 'EXECUTE_PACKING_PLAN_FROM_PROD'
            
            # اگر از طریق سفارش تولید بود، آن را آپدیت کن
            if production_order_id:
                self.execute_query(
                    "UPDATE production_orders SET status = 'تکمیل شده', production_batch_no = %s WHERE id = %s",
                    (output['batch'], production_order_id),
                    cursor=cur
                )
            else: # اگر دستی بود، یک اکشن لاگ متفاوت ثبت کن
                log_action = 'EXECUTE_MANUAL_PACKING_PLAN'

            # ۴. ثبت لاگ حسابرسی
            log_details = json.dumps(packing_data, ensure_ascii=False, default=str)
            self._log_atomic(cur, user_id, log_action, log_details)

            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
                        
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def _get_available_stock(self, item_id: int, cursor) -> float:
        """
        موجودی کل قابل فروش یک کالا را (موجودی تمام انبارها به جز انبار تولید)
        در یک تراکنش موجود محاسبه می‌کند.
        """
        query = """
            SELECT COALESCE(SUM(s.qty), 0) as total_qty
            FROM stock s
            JOIN locations l ON s.location_id = l.id
            JOIN warehouses w ON l.warehouse_id = w.id
            WHERE s.item_id = %s AND w.name != %s
        """
        result = self.execute_query(query, (item_id, PRODUCTION_WAREHOUSE_NAME), fetch_one=True, cursor=cursor)
        return result['total_qty'] if result else 0.0
    
# این متد جدید را به کلاس DB اضافه کنید
    def get_roles_for_department(self, department_id: int):
        """لیست تمام نقش‌هایی که برای یک واحد سازمانی مشخص مجاز هستند را برمی‌گرداند."""
        if not department_id:
            return []
        query = """
            SELECT r.id, r.name
            FROM roles r
            JOIN department_roles dr ON r.id = dr.role_id
            WHERE dr.department_id = %s
            ORDER BY r.name
        """
        return self.execute_query(query, (department_id,))
    
# این دو متد جدید را به کلاس DB اضافه کنید

    def get_role_ids_for_department(self, department_id: int) -> set:
        """مجموعه‌ای از ID های نقش‌های تخصیص یافته به یک واحد را برمی‌گرداند."""
        if not department_id:
            return set()
        query = "SELECT role_id FROM department_roles WHERE department_id = %s"
        rows = self.execute_query(query, (department_id,))
        return {row['role_id'] for row in rows}

    def update_roles_for_department(self, department_id: int, role_ids: list):
        """لیست نقش‌های یک واحد را به صورت اتمیک به‌روزرسانی می‌کند."""
        with self.transaction() as cur:
            # ابتدا تمام رکوردهای قدیمی برای این واحد را حذف می‌کنیم
            self.execute_query("DELETE FROM department_roles WHERE department_id = %s", (department_id,), cursor=cur)
            
            # سپس رکوردهای جدید را اضافه می‌کنیم
            if role_ids:
                args_list = [(department_id, role_id) for role_id in role_ids]
                cur.executemany(
                    "INSERT INTO department_roles (department_id, role_id) VALUES (%s, %s)",
                    args_list
                )
                
    def get_all_packaging_supplies(self):
        """
        لیست تمام لوازم بسته‌بندی با واحد نمایشی.
        خروجی برای UI پایدار است و ستونی به نام unit برمی‌گرداند.
        """
        query = """
            SELECT i.id,
                i.sku,
                i.name,
                COALESCE(u.name, '') AS unit
            FROM items i
            LEFT JOIN units u ON u.id = i.unit_id
            WHERE i.category = %s
            ORDER BY i.name
        """
        return self.execute_query(query, (CATEGORY_PACKAGING,))
    
# این متد جدید را به انتهای کلاس DB اضافه کنید
    def validate_item_ids(self, item_ids: list) -> list:
        """
        بررسی می‌کند که آیا لیستی از شناسه‌های کالا در جدول 'items' وجود دارند یا خیر.
        لیستی از شناسه‌هایی که یافت نشدند را برمی‌گرداند.
        """
        if not item_ids:
            return []
        
        # برای جلوگیری از خطای SQL در صورت ارسال لیست خالی
        # این کار کوئری را امن‌تر می‌کند
        placeholders = ','.join(['%s'] * len(item_ids))
        query = f"SELECT id FROM items WHERE id IN ({placeholders})"
        
        found_records = self.execute_query(query, tuple(item_ids))
        found_ids = {rec['id'] for rec in found_records}
        
        missing_ids = [item_id for item_id in item_ids if item_id not in found_ids]
        return missing_ids
    
# این متد جدید را به کلاس DB اضافه کنید

    def fulfill_internal_request(self, request_id: int, trans_id: int, user_id: int):
        """وضعیت یک درخواست داخلی را به 'تحویل شده' تغییر داده و آن را به تراکنش خروج متناظرش متصل می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE internal_requests SET status = %s, processed_by_user_id = %s, processed_at = NOW(), related_trans_id = %s WHERE id = %s",
                (TransactionStatus.IR_FULFILLED.value, user_id, trans_id, request_id)
            )
            self._log_atomic(cur, user_id, 'FULFILL_INTERNAL_REQUEST', f"Fulfilled request ID:{request_id} via transaction ID:{trans_id}")            
                
# این متدهای جدید را به انتهای کلاس DB اضافه کنید

    def get_quotes_for_request(self, request_id: int):
        """لیست تمام پیشنهاد قیمت‌های ثبت شده برای یک درخواست خرید را برمی‌گرداند."""
        if not request_id: return []
        query = """
            SELECT sq.id, s.name as supplier_name, sq.unit_price, sq.lead_time_days, sq.notes
            FROM supplier_quotes sq
            JOIN suppliers s ON sq.supplier_id = s.id
            WHERE sq.purchase_request_id = %s
            ORDER BY sq.unit_price ASC
        """
        return self.execute_query(query, (request_id,))

    def add_quote(self, quote_data: dict, user_id: int):
        """یک پیشنهاد قیمت جدید را برای یک درخواست خرید ثبت می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                """INSERT INTO supplier_quotes (purchase_request_id, supplier_id, unit_price, lead_time_days, notes, quote_document_path, created_by_id)
                   VALUES (%(request_id)s, %(supplier_id)s, %(unit_price)s, %(lead_time)s, %(notes)s, %(doc_path)s, %s)""",
                {**quote_data, 'user_id': user_id}
            )
            # پس از ثبت اولین پیش‌فاکتور، وضعیت درخواست اصلی را به‌روز می‌کنیم
            cur.execute(
                "UPDATE purchase_requests SET status = 'در حال استعلام' WHERE id = %s AND status = 'آماده اقدام بازرگانی'",
                (quote_data['request_id'],)
            )

    def select_winning_quote(self, request_id: int, quote_id: int, user_id: int):
        """یک پیشنهاد قیمت را به عنوان برنده انتخاب کرده و وضعیت درخواست را به‌روز می‌کند."""
        with self.transaction() as cur:
            cur.execute(
                "UPDATE purchase_requests SET selected_quote_id = %s, status = 'تامین‌کننده انتخاب شد' WHERE id = %s",
                (quote_id, request_id)
            )
            self._log_atomic(cur, user_id, 'SELECT_WINNING_QUOTE', f"Quote ID {quote_id} selected for PR ID {request_id}")

            
                
# این سه متد جدید را به انتهای کلاس DB اضافه کنید

    def get_approved_purchase_requests_for_sourcing(self):
        """تمام درخواست‌های خریدی که فرآیند تایید را گذرانده و آماده استعلام قیمت هستند را برمی‌گرداند."""
        query = """
            SELECT pr.id, i.name as item_name, pr.requested_qty, u.username as requester_name, pr.request_date
            FROM purchase_requests pr
            JOIN items i ON pr.item_id = i.id
            LEFT JOIN users u ON pr.requester_id = u.id
            WHERE pr.status = 'تایید نهایی شد - آماده اقدام بازرگانی' OR pr.status = 'در حال استعلام'
            ORDER BY pr.id ASC;
        """
        return self.execute_query(query)

    def get_requests_ready_for_po_grouped_by_supplier(self):
        """درخواست‌هایی که پیشنهاد قیمت برنده دارند را به تفکیک تامین‌کننده برای صدور PO گروه بندی می‌کند."""
        query = """
            SELECT 
                s.id as supplier_id,
                s.name as supplier_name,
                COUNT(pr.id) as request_count,
                json_agg(
                    json_build_object(
                        'pr_id', pr.id,
                        'item_name', i.name,
                        'requested_qty', pr.requested_qty
                    )
                ) as requests
            FROM purchase_requests pr
            JOIN supplier_quotes sq ON pr.selected_quote_id = sq.id
            JOIN suppliers s ON sq.supplier_id = s.id
            JOIN items i ON pr.item_id = i.id
            WHERE pr.status = 'تامین‌کننده انتخاب شد'
            GROUP BY s.id, s.name
            ORDER BY s.name;
        """
        return self.execute_query(query)

    def create_aggregated_purchase_order(self, supplier_id: int, pr_ids: list, user_id: int):
        """برای لیستی از درخواست‌های خرید، یک سفارش خرید agregated (تجمیعی) ایجاد می‌کند."""
        with self.transaction() as cur:
            po_number = f"PO-{datetime.now().year}-{pr_ids[0]}" # شماره گذاری ساده بر اساس اولین درخواست
            total_amount = 0
            
            # ابتدا اقلام را برای محاسبه مبلغ کل واکشی می‌کنیم
            placeholders = ','.join(['%s'] * len(pr_ids))
            items_to_process = self.execute_query(
                f"""SELECT pr.requested_qty, sq.unit_price 
                   FROM purchase_requests pr 
                   JOIN supplier_quotes sq ON pr.selected_quote_id = sq.id 
                   WHERE pr.id IN ({placeholders})""",
                tuple(pr_ids), cursor=cur
            )
            for item in items_to_process:
                total_amount += item['requested_qty'] * item['unit_price']

            # ایجاد هدر سفارش خرید (PO)
            po_res = self.execute_query(
                """INSERT INTO purchase_orders (po_number, supplier_id, issue_date, status, total_amount, created_by_id)
                   VALUES (%s, %s, NOW(), 'تایید شده', %s, %s) RETURNING id""",
                (po_number, supplier_id, total_amount, user_id), fetch_one=True, cursor=cur
            )
            po_id = po_res['id']

            # ایجاد اقلام سفارش خرید (PO Items) برای هر درخواست
            for pr_id in pr_ids:
                pr_data = self.execute_query(
                    """SELECT pr.item_id, pr.requested_qty, sq.unit_price
                       FROM purchase_requests pr
                       JOIN supplier_quotes sq ON pr.selected_quote_id = sq.id
                       WHERE pr.id = %s""",
                    (pr_id,), fetch_one=True, cursor=cur
                )
                self.execute_query(
                    "INSERT INTO purchase_order_items (purchase_order_id, purchase_request_id, item_id, quantity, unit_price) VALUES (%s, %s, %s, %s, %s)",
                    (po_id, pr_id, pr_data['item_id'], pr_data['requested_qty'], pr_data['unit_price']), cursor=cur
                )
                self.execute_query("UPDATE purchase_requests SET status = 'سفارش ایجاد شد' WHERE id = %s", (pr_id,), cursor=cur)
            
            self._log_atomic(cur, user_id, 'CREATE_AGGREGATED_PO', f"PO {po_number} created for PR IDs: {pr_ids}")
            return po_number
        
    # --- [NEW in DB] جدول قوانین SLA + متدهای کمکی -------------------------------

    def ensure_qa_sla_tables(self):
        """
        یک بار اجرا: اگر جدول قوانین SLA نبود، بساز.
        """
        with self.transaction() as cur:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS qa_sla_rules (
                    id SERIAL PRIMARY KEY,
                    workflow_id INTEGER NOT NULL,
                    step_id INTEGER NULL,
                    threshold_minutes INTEGER NOT NULL,
                    severity VARCHAR(16) DEFAULT 'HIGH',
                    active BOOLEAN DEFAULT TRUE
                );
            """)
            # ایندکس‌های پیشنهادی برای سرعت
            cur.execute("CREATE INDEX IF NOT EXISTS idx_sla_wf ON qa_sla_rules (workflow_id, active);")
            cur.execute("CREATE INDEX IF NOT EXISTS idx_sla_step ON qa_sla_rules (step_id);")


    def get_sla_rules(self, workflow_id: int):
        """
        قانون‌های SLA فعال یک Workflow را برمی‌گرداند.
        اگر step_id پر باشد یعنی قانون مخصوص آن مرحله است.
        """
        sql = """
            SELECT id, workflow_id, step_id, threshold_minutes, severity, active
            FROM qa_sla_rules
            WHERE workflow_id=%s AND active=TRUE
            ORDER BY step_id NULLS LAST, threshold_minutes
        """
        return self.execute_query(sql, (workflow_id,))


    def upsert_sla_rule(self, workflow_id: int, threshold_minutes: int, step_id: int | None = None,
                        severity: str = 'HIGH', active: bool = True):
        """
        افزودن قانون SLA جدید (ساده). اگر لازم شد بعداً UI مدیریتی هم براش می‌سازیم.
        """
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO qa_sla_rules (workflow_id, step_id, threshold_minutes, severity, active)
                VALUES (%s, %s, %s, %s, %s)
            """, (workflow_id, step_id, threshold_minutes, severity, active))


    def compute_sla_buckets(self, workflow_id: int, soon_ratio: float = 0.8, default_minutes: int = 240):
        """
        نمونه‌های فعال یک Workflow را به سه باکت تقسیم می‌کند:
        - on_track: سن نمونه < 0.8 * SLA
        - due_soon: 0.8 * SLA <= سن نمونه < SLA
        - overdue:  سن نمونه >= SLA
        سن نمونه = زمان فعلی - زمان شروع یا شروع مرحله فعلی (اگر موجود باشد).
        خروجی: dict با کلیدها: 'on_track', 'due_soon', 'overdue', و نیز map {pi_id: state}
        """
        # 1) نمونه‌های فعال را بگیر
        rows = self.execute_query("""
            SELECT pi.id AS pi_id, pi.workflow_id, pi.current_step_id, pi.started_at,
                pi.updated_at
            FROM process_instances pi
            WHERE pi.workflow_id=%s
            AND (pi.status IS NULL OR pi.status NOT IN ('COMPLETED','CANCELLED','REJECTED'))
            ORDER BY pi.started_at DESC
        """, (workflow_id,))

        # 2) قوانین SLA را بگیر
        rules = self.get_sla_rules(workflow_id)
        # تبدیل قوانین به lookup ساده
        wf_level = None
        step_level = {}
        for r in rules:
            if r['step_id'] is None and wf_level is None:
                wf_level = int(r['threshold_minutes'])
            elif r['step_id'] is not None and r['step_id'] not in step_level:
                step_level[int(r['step_id'])] = int(r['threshold_minutes'])

        def pick_threshold(step_id):
            if step_id and step_id in step_level:
                return step_level[step_id]
            if wf_level:
                return wf_level
            return default_minutes

        # 3) محاسبه باکت‌ها
        now = dt.datetime.utcnow()
        counts = {'on_track': 0, 'due_soon': 0, 'overdue': 0}
        per_instance = {}
        for rec in rows:
            step_id = rec.get('current_step_id')
            th = pick_threshold(step_id if step_id is not None else None)

            # سعی می‌کنیم سن مرحله فعلی را داشته باشیم؛ اگر نبود، از started_at استفاده می‌کنیم
            t0 = rec.get('updated_at') or rec.get('started_at')
            if not t0:
                continue  # داده ناقص؛ ازش عبور کن

            # تضمین تبدیل به datetime
            if isinstance(t0, str):
                try:
                    t0 = dt.datetime.fromisoformat(t0.replace('Z',''))
                except Exception:
                    # اگر نتونستیم پارس کنیم، از همین عبور کن
                    continue

            age_min = (now - t0).total_seconds() / 60.0
            soon_border = th * float(soon_ratio)

            if age_min >= th:
                state = 'overdue'
            elif age_min >= soon_border:
                state = 'due_soon'
            else:
                state = 'on_track'

            counts[state] += 1
            per_instance[int(rec['pi_id'])] = (state, int(th), int(age_min))

        return {'counts': counts, 'per_instance': per_instance}
    
# --- [NEW in DB] جداول سیاست‌های Escalation و لاگ/هشدارها ---------------------

    def ensure_qa_escalation_tables(self):
        """
        یک‌بار اجرا: اگر جداول Escalation نبود، بساز.
        """
        with self.transaction() as cur:
            # قوانین Escalation روی سطح Workflow/Step
            cur.execute("""
                CREATE TABLE IF NOT EXISTS qa_escalation_policies (
                    id SERIAL PRIMARY KEY,
                    workflow_id INTEGER NOT NULL,
                    step_id INTEGER NULL,
                    minutes_overdue INTEGER NOT NULL DEFAULT 0,          -- چند دقیقه بعد از Overdue هشدار بده
                    repeat_every_minutes INTEGER NOT NULL DEFAULT 120,   -- تکرار هشدار برای همان نمونه
                    notify_role VARCHAR(64) NULL,                        -- اختیاری: نقش هدف
                    notify_user_id INTEGER NULL,                         -- اختیاری: کاربر هدف
                    active BOOLEAN NOT NULL DEFAULT TRUE
                );
            """)
            cur.execute("CREATE INDEX IF NOT EXISTS idx_esc_policy_wf ON qa_escalation_policies (workflow_id, active);")
            cur.execute("CREATE INDEX IF NOT EXISTS idx_esc_policy_step ON qa_escalation_policies (step_id);")

            # لاگ هشدارهای صادرشده (برای جلوگیری از تکرار بیش‌ازحد)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS qa_escalation_log (
                    id SERIAL PRIMARY KEY,
                    process_instance_id INTEGER NOT NULL,
                    policy_id INTEGER NULL,
                    last_notified_at TIMESTAMP NOT NULL DEFAULT NOW()
                );
            """)
            cur.execute("CREATE INDEX IF NOT EXISTS idx_esc_log_pi ON qa_escalation_log (process_instance_id);")

            # پیام‌های هشدار برای نمایش در UI (ساده و مستقل)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS qa_escalation_alerts (
                    id SERIAL PRIMARY KEY,
                    process_instance_id INTEGER NOT NULL,
                    workflow_id INTEGER NOT NULL,
                    step_id INTEGER NULL,
                    message TEXT NOT NULL,
                    created_at TIMESTAMP NOT NULL DEFAULT NOW()
                );
            """)
            cur.execute("CREATE INDEX IF NOT EXISTS idx_esc_alerts_time ON qa_escalation_alerts (created_at DESC);")


    def upsert_escalation_policy(self, workflow_id: int, step_id: int | None = None,
                                minutes_overdue: int = 0, repeat_every_minutes: int = 120,
                                notify_role: str | None = None, notify_user_id: int | None = None,
                                active: bool = True):
        """
        یک سیاست Escalation ساده اضافه می‌کند (upsert خیلی ساده: فقط INSERT).
        اگر بعداً خواستی UI مدیریتی بسازی، از همین استفاده کن.
        """
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO qa_escalation_policies
                    (workflow_id, step_id, minutes_overdue, repeat_every_minutes, notify_role, notify_user_id, active)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (workflow_id, step_id, minutes_overdue, repeat_every_minutes, notify_role, notify_user_id, active))


    def _get_escalation_policies(self, workflow_id: int):
        return self.execute_query("""
            SELECT id, workflow_id, step_id, minutes_overdue, repeat_every_minutes, notify_role, notify_user_id, active
            FROM qa_escalation_policies
            WHERE workflow_id=%s AND active=TRUE
            ORDER BY step_id NULLS LAST, minutes_overdue
        """, (workflow_id,))


    def _already_notified_recently(self, pi_id: int, policy_id: int | None, repeat_every: int) -> bool:
        row = self.execute_query("""
            SELECT last_notified_at FROM qa_escalation_log
            WHERE process_instance_id=%s AND (policy_id=%s OR %s IS NULL)
            ORDER BY last_notified_at DESC
            LIMIT 1
        """, (pi_id, policy_id, policy_id))
        if not row:
            return False
        last = row[0]['last_notified_at']
        # تبدیل به datetime (اگر str)
        if isinstance(last, str):
            try:
                last = dt.datetime.fromisoformat(last.replace('Z',''))
            except Exception:
                return False
        return (dt.datetime.utcnow() - last).total_seconds() < repeat_every * 60


    def _log_escalation(self, pi_id: int, policy_id: int | None, message: str, workflow_id: int, step_id: int | None):
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO qa_escalation_log (process_instance_id, policy_id, last_notified_at)
                VALUES (%s, %s, NOW())
            """, (pi_id, policy_id))
            cur.execute("""
                INSERT INTO qa_escalation_alerts (process_instance_id, workflow_id, step_id, message)
                VALUES (%s, %s, %s, %s)
            """, (pi_id, workflow_id, step_id, message))
        # به UI بگو لیست هشدارها تغییر کرده
        try:
            self.signals.dataChanged.emit('NOTIFICATIONS_CHANGED')
        except Exception:
            pass


    def run_sla_escalations(self, default_repeat_minutes: int = 120):
        """
        همهٔ Workflowهای فعال را بررسی می‌کند؛ برای نمونه‌های 'overdue' هشدار می‌سازد
        (اگر اخیراً برای همان نمونه هشدار نداده باشد).
        """
        # 1) همهٔ Workflowهای فعال
        wfs = self.get_active_workflows()  # انتظار: [{'id':..,'name':..,'version':..}, ...]
        now = dt.datetime.utcnow()

        for wf in wfs:
            wf_id = int(wf['id'])

            # 2) محاسبه SLA برای این Workflow
            sla = self.compute_sla_buckets(wf_id)
            per_instance = sla.get('per_instance', {})

            # 3) سیاست‌ها
            policies = self._get_escalation_policies(wf_id)
            # Lookup سیاست: اول Step-specific، بعد Workflow-level
            wf_level = None
            step_level = {}
            for p in policies:
                if p['step_id'] is None and wf_level is None:
                    wf_level = p
                elif p['step_id'] is not None and p['step_id'] not in step_level:
                    step_level[int(p['step_id'])] = p

            # 4) چک تک‌به‌تک نمونه‌های overdue
            # برای هر نمونه overdue، اگر سیاست Step داشتیم از آن استفاده می‌کنیم؛
            # اگر نبود، از سیاست Workflow-level؛ اگر هیچ نبود، از پیش‌فرض: minutes_overdue=0, repeat=default
            # پیام را ثبت می‌کنیم تا در UI دیده شود.
            # همچنین سن نمونه را از per_instance می‌گیریم: (state, th_minutes, age_minutes)
            for pi_id_str, info in per_instance.items():
                # per_instance کلید را int کرده بودیم؛ حتماً int
                pi_id = int(pi_id_str)
                state, th_min, age_min = info
                if state != 'overdue':
                    continue

                # یافتن step_id و نام‌ها برای پیام (اختیاری)
                row = self.execute_query("""
                    SELECT pi.current_step_id, w.name AS wf_name, ws.step_name
                    FROM process_instances pi
                    JOIN workflows w ON w.id = pi.workflow_id
                    LEFT JOIN workflow_steps ws ON ws.id = pi.current_step_id
                    WHERE pi.id=%s
                """, (pi_id,))
                if row:
                    step_id = row[0]['current_step_id']
                    wf_name = row[0].get('wf_name') or f"WF-{wf_id}"
                    step_name = row[0].get('step_name') or '—'
                else:
                    step_id, wf_name, step_name = None, f"WF-{wf_id}", '—'

                # انتخاب سیاست
                policy = step_level.get(int(step_id)) if step_id is not None else None
                if not policy:
                    policy = wf_level
                # پیش‌فرض
                minutes_overdue_needed = int(policy['minutes_overdue']) if policy else 0
                repeat_every = int(policy['repeat_every_minutes']) if policy else int(default_repeat_minutes)
                policy_id = int(policy['id']) if policy else None

                # آیا به حد Escalation رسیده و اخیراً بابتش هشدار نداده‌ایم؟
                overdue_by = max(0, int(age_min - th_min))
                if overdue_by < minutes_overdue_needed:
                    continue
                if self._already_notified_recently(pi_id, policy_id, repeat_every):
                    continue

                # پیام و ثبت
                msg = f"تاخیر در فرآیند «{wf_name}» / مرحله «{step_name}» (نمونه #{pi_id}) — {int(age_min)} دقیقه سپری شده از آستانه SLA."
                self._log_escalation(pi_id, policy_id, msg, wf_id, step_id)
                
                
    # ─────────────────────────────────────────────────────────────────────────────
    # [NEW in DB] جداول و متدهای گِیت‌های QA
    # ─────────────────────────────────────────────────────────────────────────────

    def ensure_qa_gate_tables(self):
        """
        یک‌بار اجرا: اگر جدول قوانین گِیت نبود، بساز.
        هر ردیف یعنی: «برای تغییر وضعیت X روی جدول Y باید فرم Z تکمیل/پاس شود».
        """
        with self.transaction() as cur:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS qa_gates (
                    id SERIAL PRIMARY KEY,
                    table_name VARCHAR(64) NOT NULL,              -- مثلا 'production_deliveries'
                    transition_status VARCHAR(64) NOT NULL,       -- مثلا 'APPROVED' یا 'SHIPPED'
                    form_def_id INTEGER NOT NULL,                 -- فرم الزام‌شده
                    require_pass BOOLEAN NOT NULL DEFAULT TRUE,   -- نتیجه باید PASSED باشد؟
                    min_score INTEGER NULL,                       -- یا حداقل نمره (درصورت وجود امتیاز)
                    active BOOLEAN NOT NULL DEFAULT TRUE
                );
            """)
            cur.execute("CREATE INDEX IF NOT EXISTS idx_qag_table ON qa_gates (table_name);")
            cur.execute("CREATE INDEX IF NOT EXISTS idx_qag_table_status ON qa_gates (table_name, transition_status)")

    def upsert_qa_gate(self, table_name: str, transition_status: str, form_def_id: int,
                    require_pass: bool = True, min_score: int | None = None, active: bool = True):
        """
        افزودن قانون گِیت. (برای سادگی INSERT؛ اگر چندبار زدی، چند قانون می‌شود.)
        """
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO qa_gates (table_name, transition_status, form_def_id, require_pass, min_score, active)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (table_name, transition_status, form_def_id, require_pass, min_score, active))

    def list_qa_gates(self, table_name: str, transition_status: str):
        return self.execute_query("""
            SELECT g.id, g.table_name, g.transition_status, g.form_def_id, g.require_pass, g.min_score, g.active,
                fd.name AS form_name
            FROM qa_gates g
            LEFT JOIN form_defs fd ON fd.id = g.form_def_id
            WHERE g.active = TRUE AND g.table_name=%s AND g.transition_status=%s
            ORDER BY g.id
        """, (table_name, transition_status))

    def check_qa_gates(self, table_name: str, record_id: int, transition_status: str):
        """
        بررسی می‌کند که برای این «تغییر وضعیت» فرم‌های لازم روی رکورد مرتبط وجود دارند یا نه.
        فرض منطقی: جدول form_entries دارای یکی از جفت‌ستون‌های
        (related_table, related_id) یا (target_table, target_id)
        و ستون‌های status ('PASSED'/'FAILED') و score (درصورت امتیاز) است.
        خروجی: (ok:bool, errors:list[str])
        """
        gates = self.list_qa_gates(table_name, transition_status)
        if not gates:
            return True, []  # قانونی تعریف نشده ⇒ عبور آزاد

        errors = []
        for g in gates:
            form_def_id = int(g['form_def_id'])
            form_name = g.get('form_name') or f"Form#{form_def_id}"
            require_pass = bool(g['require_pass'])
            min_score = g.get('min_score')

            # تلاش 1: ستون‌های related_table/related_id
            try:
                rows = self.execute_query("""
                    SELECT id, status, score, created_at
                    FROM form_entries
                    WHERE form_def_id=%s AND related_table=%s AND related_id=%s
                    ORDER BY created_at DESC
                    LIMIT 1
                """, (form_def_id, table_name, record_id))
            except Exception:
                # تلاش 2: ستون‌های target_table/target_id
                rows = self.execute_query("""
                    SELECT id, status, score, created_at
                    FROM form_entries
                    WHERE form_def_id=%s AND target_table=%s AND target_id=%s
                    ORDER BY created_at DESC
                    LIMIT 1
                """, (form_def_id, table_name, record_id))

            if not rows:
                errors.append(f"فرم «{form_name}» برای این رکورد ثبت نشده است.")
                continue

            st = (rows[0].get('status') or '').upper()
            sc = rows[0].get('score')

            passed_cond = (st == 'PASSED') if require_pass else True
            score_cond  = (sc is not None and min_score is not None and int(sc) >= int(min_score)) if min_score is not None else True

            if not (passed_cond and score_cond):
                if require_pass and min_score is not None:
                    errors.append(f"فرم «{form_name}» باید PASSED باشد و حداقل امتیاز {min_score} بگیرد.")
                elif require_pass:
                    errors.append(f"فرم «{form_name}» باید PASSED باشد.")
                else:
                    errors.append(f"فرم «{form_name}» باید حداقل امتیاز {min_score} بگیرد.")

        return (len(errors) == 0), errors
    
        # ─────────────────────────────────────────────────────────────────────────────
    # [ADD to class DB] یابنده/سازندهٔ فرم‌های QC + Upsert امن گِیت + Seeder پیش‌فرض
    # ─────────────────────────────────────────────────────────────────────────────

    def _table_has_column(self, table: str, col: str) -> bool:
        """بررسی وجود ستون در جدول (سازگار با PostgreSQL)."""
        try:
            rows = self.execute_query("""
                SELECT 1 FROM information_schema.columns
                WHERE table_name=%s AND column_name=%s
                LIMIT 1
            """, (table, col))
            return bool(rows)
        except Exception:
            return False  # اگر دیتابیس اجازه نداد، ادامه می‌دهیم

    def get_or_create_form_def(self, code: str, name_persian: str) -> int:
        """
        یک فرم QC با code/name برمی‌گرداند؛ اگر نبود، با اسکیمای حداقلی Pass/Fail می‌سازد.
        اسکیمای حداقلی: یک فیلد 'result' (PASSED/FAILED) و یک فیلد 'score' اختیاری.
        """
        # 1) پیدا کردن اگر هست
        try:
            if self._table_has_column('form_defs', 'code'):
                row = self.execute_query("SELECT id FROM form_defs WHERE code=%s LIMIT 1", (code,))
                if row: return int(row[0]['id'])
            # fallback با name
            row = self.execute_query("SELECT id FROM form_defs WHERE LOWER(name)=LOWER(%s) LIMIT 1", (name_persian,))
            if row: return int(row[0]['id'])
        except Exception:
            pass

        # 2) اگر نبود: بساز (با چند الگوی ممکن بسته به اسکیمای جدول شما)
        schema_min = {
            "title": name_persian,
            "fields": [
                {"name": "result", "type": "enum", "choices": ["PASSED", "FAILED"], "required": True},
                {"name": "score",  "type": "number", "required": False}
            ]
        }
        payloads = []
        # الگوهای احتمالی ستون‌ها:
        if self._table_has_column('form_defs', 'code') and self._table_has_column('form_defs', 'schema_json'):
            payloads.append(("INSERT INTO form_defs (code, name, schema_json, active) VALUES (%s,%s,%s,TRUE) RETURNING id",
                            (code, name_persian, json.dumps(schema_min))))
        if self._table_has_column('form_defs', 'definition'):
            payloads.append(("INSERT INTO form_defs (name, definition, active) VALUES (%s,%s,TRUE) RETURNING id",
                            (name_persian, json.dumps(schema_min))))
        # ساده‌ترین حالت‌ها
        payloads.append(("INSERT INTO form_defs (name, active) VALUES (%s, TRUE) RETURNING id",
                        (name_persian,)))
        payloads.append(("INSERT INTO form_defs (name) VALUES (%s) RETURNING id",
                        (name_persian,)))

        for sql, args in payloads:
            try:
                with self.transaction() as cur:
                    cur.execute(sql, args)
                    new_id = cur.fetchone()['id']
                    return int(new_id)
            except Exception:
                continue

        # اگر هیچ‌کدام جواب نداد:
        raise RuntimeError("ساخت فرم QC پیش‌فرض ممکن نشد؛ لطفاً ساختار جدول form_defs را به من بگو تا فیتش کنم.")

    def safe_upsert_qa_gate(self, table_name: str, transition_status: str, form_def_id: int,
                            require_pass: bool = True, min_score: int | None = None, active: bool = True) -> int:
        """
        گِیت QA را اگر وجود نداشته باشد اضافه می‌کند؛ اگر دقیقاً همین قانون وجود داشته باشد، کاری نمی‌کند.
        خروجی: id قانون (جدید یا موجود)
        """
        # 1) اگر قانون مشابه وجود دارد، همان را برگردان
        try:
            rows = self.execute_query("""
                SELECT id FROM qa_gates
                WHERE table_name=%s AND transition_status=%s AND form_def_id=%s
                AND COALESCE(require_pass, TRUE) = %s
                AND COALESCE(min_score, -1) = COALESCE(%s, -1)
                AND active = %s
                LIMIT 1
            """, (table_name, transition_status, form_def_id, require_pass, min_score, active))
            if rows: return int(rows[0]['id'])
        except Exception:
            pass

        # 2) درج
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO qa_gates (table_name, transition_status, form_def_id, require_pass, min_score, active)
                VALUES (%s, %s, %s, %s, %s, %s)
                RETURNING id
            """, (table_name, transition_status, form_def_id, require_pass, min_score, active))
            return int(cur.fetchone()['id'])

    def seed_default_qa_gates(self):
        """
        فعال‌سازی پیش‌فرض QA روی گذارهای حیاتی سازمان.
        - اگر فرم مناسب موجود نباشد، فرم حداقلی ساخته می‌شود.
        - idempotent: با safe_upsert_qa_gate از تکراری‌شدن جلوگیری می‌کنیم.
        """
        # مطمئن شو جداول گِیت موجودند
        try:
            self.ensure_qa_gate_tables()
        except Exception:
            pass

        # 1) تحویل تولید → انبار (APPROVED): نیاز به QC نهایی تولید
        fd_prod_final = self.get_or_create_form_def('QC_PROD_FINAL', 'QC نهایی تولید')
        self.safe_upsert_qa_gate('production_deliveries', 'APPROVED', fd_prod_final, require_pass=True)

        # 2) رسید انبار ورودی (APPROVED): نیاز به QC ورود
        fd_inbound = self.get_or_create_form_def('QC_INBOUND', 'QC ورود/بازرسی اولیه')
        self.safe_upsert_qa_gate('inbound_receipts', 'APPROVED', fd_inbound, require_pass=True)

        # 3) ارسال فروش (SHIPPED): نیاز به QC قبل از ارسال با حداقل امتیاز
        fd_pre_ship = self.get_or_create_form_def('QC_PRE_SHIPMENT', 'QC قبل از ارسال')
        self.safe_upsert_qa_gate('shipments', 'SHIPPED', fd_pre_ship, require_pass=False, min_score=80)

        # 4) انتقال مواد به تولید (trans → APPROVED): نیاز به QC مواد/بچ
        fd_mat_issue = self.get_or_create_form_def('QC_MAT_ISSUE', 'QC مواد برای تحویل به تولید')
        self.safe_upsert_qa_gate('trans', 'APPROVED', fd_mat_issue, require_pass=True)

        # 5) برگشت به انبار (trans → APPROVED): نیاز به QC برگشتی
        fd_mat_ret = self.get_or_create_form_def('QC_MAT_RETURN', 'QC برگشت به انبار')
        self.safe_upsert_qa_gate('trans', 'APPROVED', fd_mat_ret, require_pass=False, min_score=70)

        # 6) (اختیاری) خروج کالا از انبار به مشتری (اگر مسیر جدا از shipments دارید)
        try:
            fd_dispatch = self.get_or_create_form_def('QC_DISPATCH', 'QC خروج نهایی')
            self.safe_upsert_qa_gate('outbound_dispatch', 'SHIPPED', fd_dispatch, require_pass=True)
        except Exception:
            pass

        # سیگنال برای تازه‌سازی پنل‌ها
        try:
            self.signals.dataChanged.emit('QA_GATES_CHANGED')
        except Exception:
            pass
        
        # ─────────────────────────────────────────────────────────────────────────────
    # [ADD to class DB] متادیتا برای ستون وضعیتِ هر جدول + ساخت ترایگرهای QA Gate
    # ─────────────────────────────────────────────────────────────────────────────

    def ensure_qa_gate_meta_tables(self):
        """
        جدول نگهداری متای جداول هدف: اسم جدول، ستون شناسه، ستون وضعیت.
        """
        with self.transaction() as cur:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS qa_gate_table_meta (
                    id SERIAL PRIMARY KEY,
                    table_name VARCHAR(64) UNIQUE NOT NULL,
                    id_column  VARCHAR(64) NOT NULL DEFAULT 'id',
                    status_column VARCHAR(64) NOT NULL DEFAULT 'status',
                    active BOOLEAN NOT NULL DEFAULT TRUE
                );
            """)

    def register_table_meta(self, table_name: str, id_column: str = 'id', status_column: str = 'status'):
        """
        یک ردیف متا برای جدول ثبت می‌کند (idempotent).
        """
        with self.transaction() as cur:
            cur.execute("""
                INSERT INTO qa_gate_table_meta (table_name, id_column, status_column, active)
                VALUES (%s, %s, %s, TRUE)
                ON CONFLICT (table_name) DO UPDATE
                SET id_column=EXCLUDED.id_column, status_column=EXCLUDED.status_column, active=TRUE
            """, (table_name, id_column, status_column))

    def register_default_gate_meta(self):
        """
        متای پیش‌فرض برای جداول رایج پروژه (اگر نام‌ها فرق دارند، همین‌ها را به نامِ درست تغییر بده).
        """
        self.ensure_qa_gate_meta_tables()
        # جدول‌ها و ستون وضعیتشان را اینجا فهرست می‌کنیم:
        defaults = [
            ('production_deliveries', 'id', 'status'),
            ('inbound_receipts',     'id', 'status'),
            ('shipments',            'id', 'status'),
            ('trans',                'id', 'status'),      # انتقال/برگشت
            ('outbound_dispatch',    'id', 'status'),      # اگر داری
            ('purchase_orders',      'id', 'status'),      # اگر داری
            ('work_orders',          'id', 'status'),      # اگر داری
            ('sales_orders',         'id', 'status'),      # اگر داری
        ]
        for t, idc, sc in defaults:
            try:
                self.register_table_meta(t, idc, sc)
            except Exception:
                pass  # اگر جدولی نداری، رد می‌کنیم

    def ensure_qa_gate_triggers(self):
        """
        برای هر جدول فعال در qa_gate_table_meta، یک تابع PL/pgSQL و دو ترایگر می‌سازد:
        - BEFORE UPDATE OF <status_column> (وقتی وضعیت عوض می‌شود)
        - BEFORE INSERT (اگر رکورد با وضعیت هدف درج شود)
        منطق: اگر برای (table_name, NEW.<status>) قانونی در qa_gates وجود داشته باشد،
        بر اساس form_entries بررسی می‌کند؛ در صورت عدم رعایت، EXCEPTION می‌دهد و عملیات لغو می‌شود.
        """
        metas = self.execute_query("""
            SELECT table_name, id_column, status_column
            FROM qa_gate_table_meta
            WHERE active=TRUE
        """)
        for m in metas:
            tbl = m['table_name']; id_col = m['id_column']; st_col = m['status_column']
            fn_name = f"qa_enforce_gate_{tbl}"
            trg_upd = f"qa_gate_before_update_{tbl}"
            trg_ins = f"qa_gate_before_insert_{tbl}"

            # تابع PL/pgSQL
            fn_sql = f"""
            CREATE OR REPLACE FUNCTION {fn_name}() RETURNS trigger AS $$
            DECLARE
                g RECORD;
                fe RECORD;
            BEGIN
                -- اگر ستونی با نام وضعیت نداریم یا مقدار جدید خالیست، عبور
                IF NEW.{st_col} IS NULL THEN
                    RETURN NEW;
                END IF;

                -- اگر qa_gates برای این جدول و این وضعیت هدفی ندارد، عبور
                FOR g IN
                    SELECT * FROM qa_gates
                    WHERE active=TRUE AND table_name={self._sql_quote(tbl)} AND transition_status=NEW.{st_col}
                LOOP
                    -- آخرین فرم مرتبط با این رکورد را بگیر (هرکدام از دو نگاشت)
                    SELECT id, status, score
                    INTO fe
                    FROM form_entries
                    WHERE form_def_id=g.form_def_id
                    AND (
                            (related_table={self._sql_quote(tbl)} AND related_id=NEW.{id_col})
                            OR
                            (target_table={self._sql_quote(tbl)} AND target_id=NEW.{id_col})
                    )
                    ORDER BY created_at DESC
                    LIMIT 1;

                    IF fe IS NULL THEN
                        RAISE EXCEPTION 'QA gate failed: required form (id=%) is missing for %:%',
                            g.form_def_id, {self._sql_quote(tbl)}, NEW.{id_col};
                    END IF;

                    IF COALESCE(g.require_pass, TRUE) = TRUE AND UPPER(COALESCE(fe.status, '')) <> 'PASSED' THEN
                        RAISE EXCEPTION 'QA gate failed: form must be PASSED for %:%', {self._sql_quote(tbl)}, NEW.{id_col};
                    END IF;

                    IF g.min_score IS NOT NULL THEN
                        IF fe.score IS NULL OR fe.score < g.min_score THEN
                            RAISE EXCEPTION 'QA gate failed: min score % not met for %:%',
                                g.min_score, {self._sql_quote(tbl)}, NEW.{id_col};
                        END IF;
                    END IF;
                END LOOP;

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
            """
            # ترایگرها
            trg_sql = f"""
            DO $$
            BEGIN
                -- حذف ترایگرهای قبلی (اگر بودند) و ساخت دوباره
                IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = '{trg_upd}') THEN
                    EXECUTE 'DROP TRIGGER {trg_upd} ON {tbl}';
                END IF;
                IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = '{trg_ins}') THEN
                    EXECUTE 'DROP TRIGGER {trg_ins} ON {tbl}';
                END IF;

                EXECUTE 'CREATE TRIGGER {trg_upd}
                        BEFORE UPDATE OF {st_col} ON {tbl}
                        FOR EACH ROW
                        WHEN (OLD.{st_col} IS DISTINCT FROM NEW.{st_col})
                        EXECUTE FUNCTION {fn_name}()';

                EXECUTE 'CREATE TRIGGER {trg_ins}
                        BEFORE INSERT ON {tbl}
                        FOR EACH ROW
                        WHEN (NEW.{st_col} IS NOT NULL)
                        EXECUTE FUNCTION {fn_name}()';
            END $$;
            """
            # اجرا
            self.execute_sql_block(fn_sql)
            self.execute_sql_block(trg_sql)

    # Helper: اجرای بلوک SQL چندخطی
    def execute_sql_block(self, sql_block: str):
        with self.transaction() as cur:
            cur.execute(sql_block)

    # Helper: کوتیشن امن اسمی (ساده)
    def _sql_quote(self, s: str) -> str:
        return "'" + s.replace("'", "''") + "'"
    
    # ── SLA Rules: لیست/غیرفعال ────────────────────────────────────────────────
    def list_all_sla_rules(self, workflow_id: int | None = None):
        if workflow_id:
            return self.execute_query("""
                SELECT r.id, r.workflow_id, r.step_id, r.threshold_minutes, r.severity, r.active,
                    w.name AS workflow_name, ws.step_name
                FROM qa_sla_rules r
                LEFT JOIN workflows w ON w.id = r.workflow_id
                LEFT JOIN workflow_steps ws ON ws.id = r.step_id
                WHERE r.workflow_id=%s
                ORDER BY r.active DESC, r.step_id NULLS LAST, r.threshold_minutes
            """, (workflow_id,))
        return self.execute_query("""
            SELECT r.id, r.workflow_id, r.step_id, r.threshold_minutes, r.severity, r.active,
                w.name AS workflow_name, ws.step_name
            FROM qa_sla_rules r
            LEFT JOIN workflows w ON w.id = r.workflow_id
            LEFT JOIN workflow_steps ws ON ws.id = r.step_id
            ORDER BY r.active DESC, r.workflow_id, r.step_id NULLS LAST, r.threshold_minutes
        """)

    def deactivate_sla_rule(self, rule_id: int, active: bool = False):
        with self.transaction() as cur:
            cur.execute("UPDATE qa_sla_rules SET active=%s WHERE id=%s", (active, rule_id))

    # ── Escalation: لیست/غیرفعال ──────────────────────────────────────────────
    def list_escalation_policies(self, workflow_id: int | None = None):
        if workflow_id:
            return self.execute_query("""
                SELECT p.id, p.workflow_id, p.step_id, p.minutes_overdue, p.repeat_every_minutes,
                    p.notify_role, p.notify_user_id, p.active,
                    w.name AS workflow_name, ws.step_name
                FROM qa_escalation_policies p
                LEFT JOIN workflows w ON w.id = p.workflow_id
                LEFT JOIN workflow_steps ws ON ws.id = p.step_id
                WHERE p.workflow_id=%s
                ORDER BY p.active DESC, p.step_id NULLS LAST, p.minutes_overdue
            """, (workflow_id,))
        return self.execute_query("""
            SELECT p.id, p.workflow_id, p.step_id, p.minutes_overdue, p.repeat_every_minutes,
                p.notify_role, p.notify_user_id, p.active,
                w.name AS workflow_name, ws.step_name
            FROM qa_escalation_policies p
            LEFT JOIN workflows w ON w.id = p.workflow_id
            LEFT JOIN workflow_steps ws ON ws.id = p.step_id
            ORDER BY p.active DESC, p.workflow_id, p.step_id NULLS LAST, p.minutes_overdue
        """)

    def deactivate_escalation_policy(self, policy_id: int, active: bool = False):
        with self.transaction() as cur:
            cur.execute("UPDATE qa_escalation_policies SET active=%s WHERE id=%s", (active, policy_id))

    # ── Gates: لیست/فعال/غیرفعال ─────────────────────────────────────────────
    def list_all_qa_gates(self, table_name: str | None = None):
        if table_name:
            return self.execute_query("""
                SELECT g.id, g.table_name, g.transition_status, g.form_def_id, g.require_pass, g.min_score, g.active,
                    fd.name AS form_name
                FROM qa_gates g
                LEFT JOIN form_defs fd ON fd.id = g.form_def_id
                WHERE g.table_name=%s
                ORDER BY g.active DESC, g.table_name, g.transition_status
            """, (table_name,))
        return self.execute_query("""
            SELECT g.id, g.table_name, g.transition_status, g.form_def_id, g.require_pass, g.min_score, g.active,
                fd.name AS form_name
            FROM qa_gates g
            LEFT JOIN form_defs fd ON fd.id = g.form_def_id
            ORDER BY g.active DESC, g.table_name, g.transition_status
        """)

    def set_qa_gate_active(self, gate_id: int, active: bool):
        with self.transaction() as cur:
            cur.execute("UPDATE qa_gates SET active=%s WHERE id=%s", (active, gate_id))
            
    def _ensure_item_uniqueness_or_raise(self, name: str, sku: str | None):
        """
        قبل از درج/ویرایش آیتم: یکتاییِ name و sku را با نادیده‌گرفتن فاصله و نیم‌فاصله چک می‌کند.
        اگر هرکدام در دیتابیس موجود باشد، یک ValueError با پیامِ خوانا raise می‌کند.
        """
        # امن‌سازی ورودی‌ها
        name = (name or "").strip()
        sku  = (sku or "").strip()

        # اگر هیچکدام داده نشد، چیزی برای چک کردن نداریم
        if not name and not sku:
            return

        # یک کوئری سبک که هر دو مورد را هم‌زمان چک می‌کند
        query = """
        WITH in_norm AS (
            SELECT
                LOWER(REPLACE(REPLACE(%s, E'\u200c',''), ' ', '')) AS nname,
                NULLIF(TRIM(%s), '') AS nsku
        ),
        name_hit AS (
            SELECT i.id, i.name
            FROM items i, in_norm
            WHERE LOWER(REPLACE(REPLACE(i.name, E'\u200c',''), ' ', '')) = in_norm.nname
            LIMIT 1
        ),
        sku_hit AS (
            SELECT i.id, i.sku
            FROM items i, in_norm
            WHERE in_norm.nsku IS NOT NULL
            AND i.sku IS NOT NULL
            AND TRIM(i.sku) = in_norm.nsku
            LIMIT 1
        )
        SELECT
            EXISTS(SELECT 1 FROM name_hit) AS name_exists,
            EXISTS(SELECT 1 FROM sku_hit)  AS sku_exists,
            (SELECT name FROM name_hit)     AS existing_name,
            (SELECT sku  FROM sku_hit)      AS existing_sku;
        """
        row = self.execute_query(query, (name, sku), fetch_one=True) or {}
        errs = []
        if row.get("name_exists"):
            errs.append(f"کالایی با نام «{name}» از قبل در سیستم وجود دارد.")
        if sku and row.get("sku_exists"):
            errs.append(f"کد کالا (SKU) «{sku}» تکراری است.")
        if errs:
            # پیامِ جمع‌بندی: هر دو مورد را با هم نشان بده
            raise ValueError(" ".join(errs))
        
    def emergency_reset_admin_password(self, new_password: str = "Admin@123"):
        """
        ریست رمز ادمین به مقدار دلخواه (پیش‌فرض: Admin@123).
        از همان کانتکست bcrypt برنامه استفاده می‌کند و فقط passhash کاربر 'admin' را به‌روزرسانی می‌کند.
        """
        if not new_password or len(new_password.strip()) < 6:
            raise ValueError("رمز جدید معتبر نیست (حداقل ۶ کاراکتر).")

        # استفاده از passlib همان پروژه
        hashed = hash_password(new_password.strip())

        with self._conn() as conn:
            with conn.cursor() as cur:
                # مطمئن شو کاربر admin وجود دارد
                cur.execute("SELECT id FROM users WHERE LOWER(username) = LOWER(%s)", ("admin",))
                row = cur.fetchone()
                if not row:
                    raise ValueError("کاربر 'admin' در دیتابیس یافت نشد.")

                cur.execute("UPDATE users SET passhash = %s WHERE LOWER(username) = LOWER(%s)", (hashed, "admin"))
            conn.commit()
        print("SUCCESS: admin password reset. You can now log in with the new password.")
        
    # داخل کلاس DB
    def prepare_item_for_save(self, payload: dict) -> dict:
        """
        قوانین سفت‌وسخت قبل از ذخیره:
        - اگر parent_item_id دارد → آیتم فرزند است:
            * is_parent_product = False
            * category = CATEGORY_FINAL_PRODUCT
            * is_two_component = inherit from parent
        - اگر is_parent_product=True → موجودی اولیه نادیده گرفته شود و واحد قفل شود.
        - آیتم معمولی → is_two_component همیشه False
        """
        p = dict(payload)  # کپی امن

        parent_id = p.get('parent_item_id')
        is_parent = bool(p.get('is_parent_product', False))

        if parent_id:
            # فرزند بسته‌بندی
            p['is_parent_product'] = False
            p['category'] = CATEGORY_FINAL_PRODUCT
            # ارث‌بری دو‌جزئی از مادر
            parent = self.get_item_by_id(parent_id)
            p['is_two_component'] = bool(parent.get('is_two_component', False))

        elif is_parent:
            # مادر: موجودی اولیه بی‌اثر
            p['initial_stock_rows'] = []    # اگر کلید دیگری دارید، همان را خالی کنید
            # واحد برای مادر عملاً مصرف ندارد؛ اما اگر فیلد لازم است، دست نزنیم
            # فقط مطمئن شو خروجی گزارش‌ها به واحد مادر اتکا نکند

        else:
            # آیتم معمولی مستقل
            p['is_two_component'] = False   # فقط مادر می‌تواند دو‌جزئی باشد

        return p



        


            
  
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class ReturnMaterialDialog(QtWidgets.QDialog):
    """پنجره‌ای برای ثبت درخواست برگشت مواد اولیه از کف کارگاه به انبار اصلی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت درخواست برگشت مواد اولیه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("0.0")
        self.reason_edit = QtWidgets.QLineEdit(placeholderText="مثال: مواد اضافه از تولید بچ X")

        layout.addRow("انتخاب کالا و بچ برای برگشت:", self.item_combo)
        layout.addRow("مقدار برگشتی:", self.qty_edit)
        layout.addRow("دلیل برگشت:", self.reason_edit)

        self.item_combo.currentIndexChanged.connect(self._on_item_selected)

        self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        layout.addRow(self.buttons)

        self._load_items_in_production()

    def _load_items_in_production(self):
        items = self.db.get_stock_for_warehouse('Production')
        raw_materials = [item for item in items if item.get('category') == 'مواد اولیه']
        
        if not raw_materials:
            self.item_combo.addItem("هیچ ماده اولیه‌ای برای برگشت یافت نشد.", None)
            self.item_combo.setEnabled(False)
            self.buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
        else:
            for item in raw_materials:
                # --- اصلاح ۱: استفاده از 'total_qty' ---
                display_text = f"{item['name']} (بچ: {item['batch_no']}, موجودی: {item['total_qty']})"
                self.item_combo.addItem(display_text, item)
    
    def _on_item_selected(self):
        data = self.item_combo.currentData()
        if data:
            # --- اصلاح ۲: استفاده از 'total_qty' ---
            max_qty = data.get('total_qty', 0.0)
            self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, max_qty, 3))
            self.qty_edit.setText(str(max_qty))

    def get_data(self):
        try:
            component = self.item_combo.currentData()
            qty = float(self.qty_edit.text())
            reason = self.reason_edit.text().strip()
            if component and qty > 0 and reason:
                # --- اصلاح ۳: استفاده از 'total_qty' ---
                if qty > component['total_qty']:
                    QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "مقدار برگشتی نمی‌تواند از موجودی بچ بیشتر باشد.")
                    return None
                return {"component": component, "qty": qty, "reason": reason}
        except (ValueError, TypeError):
            pass
        return None
            
class FefoPickDialog(QtWidgets.QDialog):
    """
    نسخه 2.0 (بهبود UI/UX):
    پنجره‌ای برای نمایش لیست برداشت پیشنهادی FEFO با ظاهر گرافیکی بهتر و تفکیک اطلاعات.
    """
    def __init__(self, pick_list, item_name, qty_needed, parent=None):
        super().__init__(parent)
        self.setWindowTitle("پیشنهاد برداشت هوشمند (FEFO)")
        self.setMinimumSize(650, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.manual_override = False

        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(15)

        # بخش 1: مشخصات درخواست
        request_group = QtWidgets.QGroupBox("مشخصات درخواست")
        request_group.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        request_layout = QtWidgets.QFormLayout(request_group)
        request_layout.setSpacing(10)
        
        req_item_label = QtWidgets.QLabel(f"<b>{item_name}</b>")
        req_qty_label = QtWidgets.QLabel(f"<b>{qty_needed}</b> واحد")
        
        request_layout.addRow("کالای درخواستی:", req_item_label)
        request_layout.addRow("مقدار مورد نیاز:", req_qty_label)
        layout.addWidget(request_group)

        # بخش 2: پیشنهاد سیستم
        suggestion_group = QtWidgets.QGroupBox("پیشنهاد سیستم (بر اساس اولین انقضا)")
        suggestion_group.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        suggestion_layout = QtWidgets.QVBoxLayout(suggestion_group)
        
        self.table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'): # اعمال استایل استاندارد برنامه
            parent._style_table(self.table)
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(['مقدار برداشت', 'بچ نامبر', 'تاریخ انقضا', 'محل'])
        self.table.setRowCount(len(pick_list))

        for row, pick in enumerate(pick_list):
            self.table.setItem(row, 0, NumericTableWidgetItem(str(pick['pick_qty'])))
            self.table.setItem(row, 1, QtWidgets.QTableWidgetItem(pick['batch_no']))
            expiry_str = to_shamsi(pick.get('expiry_date')) or 'ندارد'
            self.table.setItem(row, 2, QtWidgets.QTableWidgetItem(expiry_str))
            loc_label = parent.db.loc_label(pick['location_id'])
            self.table.setItem(row, 3, QtWidgets.QTableWidgetItem(loc_label))
        
        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
        suggestion_layout.addWidget(self.table)
        layout.addWidget(suggestion_group)

        # بخش 3: دکمه‌های عملیات
        button_box = QtWidgets.QDialogButtonBox()
        confirm_button = button_box.addButton("✔ تایید پیشنهاد و ادامه", QtWidgets.QDialogButtonBox.AcceptRole)
        manual_button = button_box.addButton("انتخاب دستی بچ...", QtWidgets.QDialogButtonBox.RejectRole)
        
        confirm_button.setProperty("class", "primary")
        confirm_button.setIcon(QtGui.QIcon.fromTheme("emblem-ok"))
        manual_button.setIcon(QtGui.QIcon.fromTheme("preferences-system"))

        button_box.accepted.connect(self.accept)
        manual_button.clicked.connect(self.request_manual_override)
        
        layout.addWidget(button_box)

    def request_manual_override(self):
        self.manual_override = True
        self.reject()
        
            
            
class StartCountDialog(QtWidgets.QDialog):
    """دیالوگی برای دریافت اطلاعات اولیه جهت شروع یک انبارگردانی جدید."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("شروع انبارگردانی جدید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.type_combo = QtWidgets.QComboBox()
        # در فاز اول فقط شمارش کامل را داریم
        self.type_combo.addItems(["شمارش کامل انبار (دوره ای)"])
        
        self.notes_edit = QtWidgets.QTextEdit()
        self.notes_edit.setPlaceholderText("اختیاری: هرگونه توضیح لازم در مورد این شمارش را اینجا بنویسید.")

        layout.addRow("نوع انبارگردانی:", self.type_combo)
        layout.addRow("یادداشت:", self.notes_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ایجاد سند و شروع")
        buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        return self.type_combo.currentText(), self.notes_edit.toPlainText()
                
# کل کلاس DeliverToWarehouseDialog را با این نسخه جایگزین کنید

class DeliverToWarehouseDialog(QtWidgets.QDialog):
    """پنجره‌ای برای انتخاب محصول تولید شده و ارسال درخواست تحویل آن به انبار."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.selected_delivery_id = None

        self.setWindowTitle("ارسال محصول تولید شده به انبار")
        self.setMinimumSize(600, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addWidget(QtWidgets.QLabel("لطفا محصولی که می‌خواهید به انبار تحویل دهید را از لیست زیر انتخاب کنید:"))

        self.products_table = QtWidgets.QTableWidget()
        self._setup_table()
        main_layout.addWidget(self.products_table, 1)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ارسال برای تایید انبار")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        main_layout.addWidget(buttons)
        
        self._load_producible_items()

    def _setup_table(self):
        self.products_table.setColumnCount(4)
        self.products_table.setHorizontalHeaderLabels(['ID', 'نام محصول', 'شماره بچ', 'مقدار تولید شده'])
        self.products_table.setColumnHidden(0, True)
        self.products_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.products_table.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.products_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.products_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _load_producible_items(self):
        items = self.db.list_producible_items()
        self.products_table.setRowCount(len(items))
        for r, item in enumerate(items):
            self.products_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.products_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['product_name']))
            self.products_table.setItem(r, 2, QtWidgets.QTableWidgetItem(item['production_batch_no']))
            self.products_table.setItem(r, 3, NumericTableWidgetItem(str(item['quantity'])))
        
        if not items:
            set_empty_placeholder(self.products_table, "هیچ محصول جدیدی برای تحویل به انبار وجود ندارد.")

    def get_data(self):
        selected_rows = self.products_table.selectionModel().selectedRows()
        if not selected_rows:
            return None
        return int(self.products_table.item(selected_rows[0].row(), 0).text())
    
# کل کلاس ReportProductionDialog را با این نسخه نهایی جایگزین کنید
class ReportProductionDialog(QtWidgets.QDialog):
    """
    نسخه 6.0 (نهایی و قطعی):
    - با خواندن part_type از دیتابیس، پیشوند صحیح (R/H/P) را به تابع تولید بچ‌نامبر ارسال می‌کند.
    - قابلیت دریافت داده‌های اولیه برای پر کردن خودکار فرم را دارد.
    """
    def __init__(self, db: DB, parent=None, prefill_data=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.consumption_plans = {}
        self.prefill_data = prefill_data or {}

        self.setWindowTitle("ثبت گزارش تولید")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        main_layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout(); form_layout.setSpacing(15)

        self.recipe_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit(); self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, 1e9, 3))
        self.batch_edit = QtWidgets.QLineEdit(); self.batch_edit.setPlaceholderText("ابتدا یک فرمول انتخاب کنید...")

        form_layout.addRow("انتخاب محصول (از روی فرمول):", self.recipe_combo)
        form_layout.addRow("مقدار تولید:", self.qty_edit)
        form_layout.addRow("شماره بچ محصول:", self.batch_edit)
        main_layout.addLayout(form_layout)

        self.materials_table = QtWidgets.QTableWidget(); self.materials_table.setColumnCount(3)
        self.materials_table.setHorizontalHeaderLabels(["ماده اولیه مورد نیاز", "مقدار لازم", "وضعیت تخصیص بچ"])
        self.materials_table.verticalHeader().setDefaultSectionSize(70)
        header = self.materials_table.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        main_layout.addWidget(self.materials_table)

        self.status_label = QtWidgets.QLabel("یک فرمول و مقدار تولید را مشخص کنید.")
        main_layout.addWidget(self.status_label)

        button_layout = QtWidgets.QHBoxLayout()
        self.ok_button = QtWidgets.QPushButton("ثبت گزارش تولید"); self.ok_button.setProperty("class", "primary"); self.ok_button.setEnabled(False)
        button_layout.addStretch(); button_layout.addWidget(self.ok_button)
        main_layout.addLayout(button_layout)

        self.recipe_combo.currentIndexChanged.connect(self._on_recipe_change)
        self.qty_edit.textChanged.connect(self._update_ui_from_inputs)
        self.ok_button.clicked.connect(self._validate_and_accept)

        self._populate_recipes()

        # --- *** بخش جدید برای اعمال داده‌های پیش‌فرض *** ---
        if self.prefill_data:
            self.recipe_combo.blockSignals(True)
            self.qty_edit.blockSignals(True)

            product_name_to_select = self.prefill_data.get('product_name')
            quantity_to_set = self.prefill_data.get('quantity')

            if product_name_to_select:
                index = self.recipe_combo.findText(product_name_to_select)
                if index != -1:
                    self.recipe_combo.setCurrentIndex(index)
                    self.recipe_combo.setEnabled(False) # غیرفعال کردن برای جلوگیری از تغییر

            if quantity_to_set:
                self.qty_edit.setText(f"{quantity_to_set:.3f}")

            self.recipe_combo.blockSignals(False)
            self.qty_edit.blockSignals(False)

            # فراخوانی دستی توابع آپدیت پس از تنظیم مقادیر
            self._on_recipe_change()
            self._update_ui_from_inputs()
        # --- ****************************************** ---

    # (بقیه متدهای این کلاس بدون تغییر باقی می‌مانند)
    def _populate_recipes(self):
        self.recipe_combo.blockSignals(True)
        self.recipe_combo.clear(); self.recipe_combo.addItem("--- انتخاب کنید ---", -1)
        for recipe in self.db.get_recipes():
            self.recipe_combo.addItem(recipe['product_name'], dict(recipe))
        self.recipe_combo.blockSignals(False)
        self._on_recipe_change()

    def _on_recipe_change(self):
        self.batch_edit.setReadOnly(False)
        self.batch_edit.clear()

        recipe_data = self.recipe_combo.currentData()
        if not isinstance(recipe_data, dict):
            self.batch_edit.setPlaceholderText("ابتدا یک فرمول انتخاب کنید...")
            self._update_ui_from_inputs()
            return

        part_type = recipe_data.get('part_type')
        part_to_prefix_map = {'A': 'R', 'B': 'H', 'P': 'P'}
        batch_prefix = part_to_prefix_map.get(part_type)

        if batch_prefix:
            try:
                next_batch_no = self.db.get_next_bulk_batch_no(batch_prefix)
                self.batch_edit.setText(next_batch_no)
                self.batch_edit.setReadOnly(True)
            except Exception as e:
                if self.toast: self.toast.show_message(f"خطا در تولید بچ نامبر: {e}", "critical")
                self.batch_edit.setPlaceholderText("خطا در تولید کد!")
        else:
            self.batch_edit.setPlaceholderText("بچ نامبر محصول را دستی وارد کنید...")
            self.batch_edit.setReadOnly(False)

        self._update_ui_from_inputs()

    def _update_ui_from_inputs(self):
        self.consumption_plans.clear(); self.materials_table.setRowCount(0)
        recipe_data = self.recipe_combo.currentData()
        if not isinstance(recipe_data, dict): self.status_label.setText("یک فرمول انتخاب کنید."); self.ok_button.setEnabled(False); return
        try:
            quantity = float(self.qty_edit.text());
            if quantity <= 0: self.ok_button.setEnabled(False); return
        except (ValueError, TypeError): self.ok_button.setEnabled(False); return

        recipe_details = self.db.get_recipe_details(recipe_data['id']); ingredients = recipe_details.get('ingredients', [])
        self.materials_table.setRowCount(len(ingredients))
        for i, ing in enumerate(ingredients):
            needed_qty = quantity * (ing['percentage'] / 100.0)
            self.materials_table.setItem(i, 0, QtWidgets.QTableWidgetItem(ing['name']))
            self.materials_table.setItem(i, 1, NumericTableWidgetItem(f"{needed_qty:.3f}"))
            status_widget = QtWidgets.QWidget(); status_layout = QtWidgets.QHBoxLayout(status_widget); status_layout.setContentsMargins(0,0,0,0)
            status_label = QtWidgets.QLabel("❌ تخصیص نیافته"); status_label.setStyleSheet("color: red;")
            select_btn = QtWidgets.QPushButton("انتخاب بچ‌ها..."); select_btn.clicked.connect(lambda _, row=i: self._open_multi_batch_selector(row))
            status_layout.addWidget(status_label, 1, Qt.AlignCenter); status_layout.addWidget(select_btn)
            self.materials_table.setCellWidget(i, 2, status_widget)
        self._check_overall_status()

    def _open_multi_batch_selector(self, row):
        item_name = self.materials_table.item(row, 0).text()
        needed_qty = float(self.materials_table.item(row, 1).text())
        item_data = self.db.get_item_by_name(item_name)
        if not item_data: return
        prod_loc_id = self.db.get_production_floor_location()
        available_batches = self.db.get_available_batches_for_item(item_data['id'], prod_loc_id)
        if not available_batches: QtWidgets.QMessageBox.warning(self, "موجودی نیست", f"هیچ بچی از کالای «{item_name}» در انبار تولید یافت نشد."); return
        dialog = MultiBatchSelectionDialog(item_name, needed_qty, available_batches, self)
        if dialog.exec_():
            self.consumption_plans[item_name] = dialog.pick_plan
            status_label = self.materials_table.cellWidget(row, 2).findChild(QtWidgets.QLabel)
            status_label.setText("✔ تخصیص داده شد"); status_label.setStyleSheet("color: green; font-weight: bold;")
            self._check_overall_status()

    def _check_overall_status(self):
        all_ok = self.materials_table.rowCount() > 0
        for i in range(self.materials_table.rowCount()):
            if "❌" in self.materials_table.cellWidget(i, 2).findChild(QtWidgets.QLabel).text(): all_ok = False; break
        self.ok_button.setEnabled(all_ok)
        self.status_label.setText("آماده ثبت گزارش" if all_ok else "بچ‌های مورد نیاز برای تمام مواد اولیه باید تخصیص داده شوند.")

    def _validate_and_accept(self):
        if not self.batch_edit.text().strip(): QtWidgets.QMessageBox.warning(self, "خطای ورودی", "وارد کردن «شماره بچ محصول» اجباری است."); return
        self.accept()

    def get_data(self):
        if not self.ok_button.isEnabled(): return None
        final_plan = {name: plan_list for name, plan_list in self.consumption_plans.items()}
        recipe_data = self.recipe_combo.currentData()

        return { 
            'recipe_id': recipe_data['id'], 
            'product_name': recipe_data['product_name'], 
            'quantity': float(self.qty_edit.text()), 
            'batch_no': self.batch_edit.text().strip(), 
            'consumption_plan': final_plan 
        }
                        
                                
class AttachDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, trans_id: int, parent=None):
        super().__init__(parent)
        self.db, self.tid = db, trans_id
        self.setWindowTitle('پیوست‌ها')
        self.resize(380, 320)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        v = QtWidgets.QVBoxLayout(self)
        self.lst = QtWidgets.QListWidget(); v.addWidget(self.lst)

        btn_row = QtWidgets.QHBoxLayout(); v.addLayout(btn_row)
        # **اصلاح کلیدی:** افزودن دکمه اسکن
        btn_scan = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("scanner"), " اسکن"); btn_row.addWidget(btn_scan)
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("add"), " افزودن فایل"); btn_row.addWidget(btn_add)
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("delete"), " حذف");   btn_row.addWidget(btn_del)
        btn_row.addStretch(); btn_close = QtWidgets.QPushButton('بستن'); btn_row.addWidget(btn_close)

        self.lst.itemDoubleClicked.connect(
            lambda itm: QtGui.QDesktopServices.openUrl(
                QtCore.QUrl.fromLocalFile(itm.data(Qt.UserRole))))
        
        btn_scan.clicked.connect(self._scan_and_add)
        btn_add.clicked.connect(self._add)
        btn_del.clicked.connect(self._delete)
        btn_close.clicked.connect(self.accept)

        self._load()

    def _load(self):
        self.lst.clear()
        for rec in self.db.list_files(self.tid):
            itm = QtWidgets.QListWidgetItem(Path(rec['path']).name)
            itm.setData(Qt.UserRole, rec['path'])
            itm.setData(Qt.UserRole+1, rec['id'])
            self.lst.addItem(itm)

    def _add(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if path:
            self.db.add_file(self.tid, path); self._load()
    
    def _scan_and_add(self):
        # **متد جدید:** فراخوانی تابع اسکن و افزودن فایل
        scanned_file_path = scan_document(self)
        if scanned_file_path:
            self.db.add_file(self.tid, scanned_file_path)
            self._load()

    def _delete(self):
        itm = self.lst.currentItem()
        if not itm: return
        fid = itm.data(Qt.UserRole+1)
        if QtWidgets.QMessageBox.question(self, 'حذف', 'مطمئن؟') != QtWidgets.QMessageBox.Yes:
            return
        self.db.delete_file(fid); self._load()
        
# Add this new class to your code
class CanvasFrame(QtWidgets.QFrame):
    """A custom QFrame that correctly handles drop events for the form builder."""
    itemDropped = QtCore.pyqtSignal(str, str) # Emits the item text and its data key

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setObjectName("formCanvas")
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setStyleSheet("#formCanvas { background-color: #ffffff; border: 1px solid #dfe4ea; }")

    def dragEnterEvent(self, event: QtGui.QDragEnterEvent):
        # We accept the event if the source is a QListWidget.
        if isinstance(event.source(), QtWidgets.QListWidget):
            event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event: QtGui.QDropEvent):
        # When the item is dropped, emit a signal with the necessary data.
        source_widget = event.source()
        item_text = source_widget.currentItem().text()
        item_data_key = source_widget.currentItem().data(Qt.UserRole)
        self.itemDropped.emit(item_text, item_data_key)
        event.acceptProposedAction()
                    
            
# کلاس AdvancedFormBuilderDialog را به طور کامل با این نسخه جایگزین کنید
class AdvancedFormBuilderDialog(QtWidgets.QDialog):
    """ویرایشگر فرم پیشرفته (نسخه نهایی با فرمول‌ساز بصری و UI اصلاح شده)."""
    def __init__(self, db: DB, user_id: int, form_id=None, default_form_type='GENERAL', process_type_key=None, parent=None):
        super().__init__(parent)
        self.db = db; self.user_id = user_id; self.form_id = form_id
        self.form_data = self.db.execute_query("SELECT * FROM form_defs WHERE id = %s", (form_id,), fetch_one=True) if form_id else None
        self.selected_field_widget = None; self.toast = getattr(parent, 'toast', None)
        self.default_form_type = default_form_type
        self.process_type_key = process_type_key

        title = "ویرایشگر فرم پیشرفته" if not self.form_data else f"ویرایش فرم: {self.form_data['name']}"
        self.setWindowTitle(title); self.setMinimumSize(1200, 700)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        main_layout = QtWidgets.QHBoxLayout(self); splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal); main_layout.addWidget(splitter)
        left_panel = QtWidgets.QWidget(); left_panel.setFixedWidth(280); left_layout = QtWidgets.QVBoxLayout(left_panel)
        form_details_group = QtWidgets.QGroupBox("مشخصات کلی فرم"); form_details_layout = QtWidgets.QFormLayout(form_details_group)
        self.form_name_edit = QtWidgets.QLineEdit(self.form_data['name'] if self.form_data else ""); form_details_layout.addRow("نام فرم:", self.form_name_edit)
        left_layout.addWidget(form_details_group)
        toolbox_group = QtWidgets.QGroupBox("جعبه ابزار (بکشید و رها کنید)"); toolbox_layout = QtWidgets.QVBoxLayout(toolbox_group)
        self.toolbox = QtWidgets.QListWidget(); self.toolbox.setDragEnabled(True)
        toolbox_items = {"فیلد متنی": "text", "فیلد عددی": "number", "فیلد تاریخ": "date", "چک‌باکس": "checkbox", "لیست کشویی": "dropdown", "لیست کالاها": "item_list", "لیست کاربران": "user_list", "لیست تامین‌کنندگان": "supplier_list", "لیست واحدها (سازمانی)": "department_list"}
        for text, key in toolbox_items.items():
            item = QtWidgets.QListWidgetItem(text, self.toolbox); item.setData(Qt.UserRole, key)
        toolbox_layout.addWidget(self.toolbox); left_layout.addWidget(toolbox_group)
        canvas_panel = QtWidgets.QWidget(); canvas_layout = QtWidgets.QVBoxLayout(canvas_panel)
        self.form_canvas = CanvasFrame(); self.form_canvas.itemDropped.connect(self.canvas_drop_event) 
        self.canvas_layout = QtWidgets.QVBoxLayout(self.form_canvas); self.canvas_layout.setAlignment(Qt.AlignTop)
        scroll_area = QtWidgets.QScrollArea(); scroll_area.setWidgetResizable(True); scroll_area.setWidget(self.form_canvas)
        canvas_layout.addWidget(scroll_area)
        self.properties_panel = QtWidgets.QGroupBox("تنظیمات فیلد"); self.properties_panel.setFixedWidth(380)
        self.properties_stack = QtWidgets.QStackedWidget(self.properties_panel)
        self.prop_placeholder = QtWidgets.QLabel("برای ویرایش، یک فیلد را از بوم انتخاب کنید."); self.prop_placeholder.setAlignment(Qt.AlignCenter); self.prop_placeholder.setWordWrap(True)
        self.properties_stack.addWidget(self.prop_placeholder)
        prop_main_layout = QtWidgets.QVBoxLayout(self.properties_panel); prop_main_layout.addWidget(self.properties_stack)
        splitter.addWidget(left_panel); splitter.addWidget(canvas_panel); splitter.addWidget(self.properties_panel); splitter.setSizes([280, 520, 380])
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره نهایی فرم"); btn_save.setProperty("class", "primary"); btn_save.clicked.connect(self._save_form_definition)
        left_layout.addWidget(btn_save)
        if self.form_data and self.form_data.get('fields'): self._load_form_from_data(self.form_data['fields'])

# در کلاس AdvancedFormBuilderDialog، این متد را به طور کامل جایگزین کنید

    def _build_properties_ui(self, field_widget):
        """پنل تنظیمات را برای فیلد انتخاب شده می‌سازد (با قابلیت تعریف فرمول و اتصال داده هوشمند)."""
        prop_widget = QtWidgets.QWidget()
        scroll_prop = QtWidgets.QScrollArea()
        scroll_prop.setWidgetResizable(True)
        scroll_prop.setWidget(prop_widget)
        scroll_prop.setStyleSheet("border:none;")
        
        layout = QtWidgets.QFormLayout(prop_widget)
        
        label_edit = QtWidgets.QLineEdit(field_widget.properties['label'])
        required_check = QtWidgets.QCheckBox()
        required_check.setChecked(field_widget.properties.get('required', False))
        
        # --- بخش اصلاح شده: ساخت منوی کشویی هوشمند و گروه‌بندی شده ---
        self.data_mapping_combo = QtWidgets.QComboBox()
        model = QtGui.QStandardItemModel()
        placeholder_item = QtGui.QStandardItem("--- (بدون اتصال) ---")
        
        # رفع ارور اول
        placeholder_item.setData(None, Qt.UserRole)
        
        model.appendRow(placeholder_item)

        # نمایش تمام داده‌های سیستمی به صورت گروه‌بندی شده
        for group_key, items in SYSTEM_DATA_CATALOG.items():
            group_name = {"SALES": "داده‌های فروش", "PURCHASING": "داده‌های خرید", "PRODUCTION": "داده‌های تولید"}.get(group_key, group_key)
            group_item = QtGui.QStandardItem(group_name)
            group_item.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
            group_item.setFlags(group_item.flags() & ~Qt.ItemIsSelectable)
            model.appendRow(group_item)
            for key, name in items.items():
                child_item = QtGui.QStandardItem(f"  {name}")
                child_item.setData(key, Qt.UserRole)
                group_item.appendRow(child_item)
        
        self.data_mapping_combo.setModel(model)
        self.data_mapping_combo.setView(QtWidgets.QTreeView())
        self.data_mapping_combo.view().expandAll()

        # --- *** اصلاح کلیدی دوم اینجاست *** ---
        # متد sizeHintForColumn روی view() فراخوانی شده است.
        self.data_mapping_combo.view().setMinimumWidth(self.data_mapping_combo.view().sizeHintForColumn(0) + 30)

        current_mapping = field_widget.properties.get('system_data_key')
        if current_mapping:
            # جستجو در مدل برای پیدا کردن آیتم صحیح
            found = False
            for i in range(1, model.rowCount()):
                parent = model.item(i)
                if not parent: continue
                for j in range(parent.rowCount()):
                    child = parent.child(j)
                    if child and child.data(Qt.UserRole) == current_mapping:
                        # پیدا کردن ایندکس خطی آیتم
                        linear_index = self.data_mapping_combo.findData(current_mapping)
                        if linear_index != -1:
                           self.data_mapping_combo.setCurrentIndex(linear_index)
                        found = True
                        break
                if found:
                    break
        # --- پایان بخش اصلاح شده ---

        layout.addRow("برچسب (*):", label_edit)
        layout.addRow("اجباری:", required_check)
        layout.addRow("اتصال به داده سیستمی:", self.data_mapping_combo)
        
        placeholder_edit = QtWidgets.QLineEdit(field_widget.properties.get('placeholder', ''))
        layout.addRow("متن راهنما (Placeholder):", placeholder_edit)
        
        label_edit.textChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'label', txt))
        required_check.toggled.connect(lambda state, w=field_widget: self._update_property(w, 'required', state))
        placeholder_edit.textChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'placeholder', txt))
        
        # استفاده از سیگنال صحیح currentIndexChanged با منطق جدید مدل
        self.data_mapping_combo.currentIndexChanged.connect(
            lambda index, w=field_widget, combo=self.data_mapping_combo: self._update_property(w, 'system_data_key', combo.model().itemFromIndex(combo.view().currentIndex()).data(Qt.UserRole))
        )

        if field_widget.properties['type'] == 'number':
            min_val = field_widget.properties.get('min')
            max_val = field_widget.properties.get('max')
            min_edit = QtWidgets.QLineEdit(str(min_val) if min_val is not None else "")
            min_edit.setValidator(QtGui.QDoubleValidator())
            max_edit = QtWidgets.QLineEdit(str(max_val) if max_val is not None else "")
            max_edit.setValidator(QtGui.QDoubleValidator())
            layout.addRow("حداقل مقدار:", min_edit)
            layout.addRow("حداکثر مقدار:", max_edit)
            min_edit.textChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'min', txt))
            max_edit.textChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'max', txt))
            
            # بخش فرمول‌ساز بصری
            formula_group = QtWidgets.QGroupBox("فرمول محاسباتی")
            numeric_fields = [
                self.canvas_layout.itemAt(i).widget().properties['label'] 
                for i in range(self.canvas_layout.count()) 
                if isinstance(self.canvas_layout.itemAt(i).widget(), FormFieldWidget) 
                and self.canvas_layout.itemAt(i).widget().properties['type'] == 'number' 
                and self.canvas_layout.itemAt(i).widget().field_id != field_widget.field_id
            ]
            
            formula_builder = FormulaBuilderWidget(numeric_fields, field_widget.properties.get('formula', ''))
            formula_builder.formulaChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'formula', txt))
            formula_group_layout = QtWidgets.QVBoxLayout(formula_group)
            formula_group_layout.addWidget(formula_builder)
            layout.addRow(formula_group)

        if field_widget.properties['type'] == 'dropdown':
            options_edit = QtWidgets.QTextEdit()
            options_edit.setPlaceholderText("هر گزینه در یک خط جداگانه")
            options_text = "\n".join(field_widget.properties.get('options', []))
            options_edit.setText(options_text)
            layout.addRow("گزینه‌ها:", options_edit)
            options_edit.textChanged.connect(lambda w=field_widget, e=options_edit: self._update_property(w, 'options', e.toPlainText().splitlines()))
            
        if field_widget.properties['type'] == 'item_list':
            category_combo = QtWidgets.QComboBox()
            category_combo.addItem("همه دسته‌بندی‌ها", None)
            categories = self.db.get_distinct_item_categories() 
            for cat in categories:
                category_combo.addItem(cat, cat)
            current_filter = field_widget.properties.get('category_filter')
            if current_filter:
                category_combo.setCurrentText(current_filter)
            category_combo.currentTextChanged.connect(lambda txt, w=field_widget: self._update_property(w, 'category_filter', txt if txt != "همه دسته‌بندی‌ها" else None))
            layout.addRow("فیلتر بر اساس دسته‌بندی:", category_combo)
            
        layout.addRow(QtWidgets.QLabel("---"))
        btn_logic = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-sort-descending"), " مدیریت منطق شرطی نمایش...")
        btn_logic.clicked.connect(lambda: self._open_conditional_logic_editor(field_widget))
        layout.addRow(btn_logic)
        
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف این فیلد")
        btn_delete.setProperty("class", "danger")
        btn_delete.clicked.connect(self._delete_selected_field)
        layout.addRow(btn_delete)
        
        current_prop_widget = self.properties_stack.currentWidget()
        if current_prop_widget != self.prop_placeholder:
            self.properties_stack.removeWidget(current_prop_widget)
            current_prop_widget.deleteLater()
            
        self.properties_stack.addWidget(scroll_prop)
        self.properties_stack.setCurrentWidget(scroll_prop)
                                            
    
    def canvas_drop_event(self, field_type_text, field_type_key):
        field_id = f"field_{int(time.time() * 1000)}"
        new_widget = FormFieldWidget(field_id, field_type_text, field_type_key, "برچسب جدید")
        new_widget.selected.connect(self._on_field_selected)
        self.canvas_layout.addWidget(new_widget)
        new_widget.selected.emit(new_widget)

    def _on_field_selected(self, field_widget):
        if self.selected_field_widget: self.selected_field_widget.set_selected(False)
        self.selected_field_widget = field_widget
        if self.selected_field_widget:
            self.selected_field_widget.set_selected(True)
            self._build_properties_ui(field_widget)
            
    def _delete_selected_field(self):
        """فیلد انتخاب شده فعلی را از بوم طراحی حذف می‌کند."""
        if self.selected_field_widget:
            reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف فیلد «{self.selected_field_widget.properties['label']}» مطمئنید؟")
            if reply == QtWidgets.QMessageBox.Yes:
                self.selected_field_widget.deleteLater()
                self.selected_field_widget = None
                self.properties_stack.setCurrentWidget(self.prop_placeholder)

# در کلاس AdvancedFormBuilderDialog، این متد را به طور کامل جایگزین کنید

                        
        
# در کلاس AdvancedFormBuilderDialog، این متد را به طور کامل جایگزین کنید

    def _open_conditional_logic_editor(self, field_widget):
        all_fields = []
        for i in range(self.canvas_layout.count()):
            widget = self.canvas_layout.itemAt(i).widget()
            if isinstance(widget, FormFieldWidget):
                # فقط فیلدهایی که از نوع checkbox, dropdown, یا text هستند می‌توانند محرک باشند
                if widget.properties['type'] in ['checkbox', 'dropdown', 'text', 'number']:
                    all_fields.append({'id': widget.field_id, 'label': widget.properties['label'], 'type': widget.properties['type']})
        
        existing_logic = field_widget.properties.get('conditional_logic')
        
        # --- *** اصلاح کلیدی: فراخوانی با آرگومان‌های صحیح و بدون موارد اضافه *** ---
        dlg = ConditionalLogicDialog(
            all_fields=all_fields, 
            current_field_id=field_widget.field_id, 
            existing_logic=existing_logic, 
            parent=self
        )
        
        if dlg.exec_():
            logic_data = dlg.get_data()
            self._update_property(field_widget, 'conditional_logic', logic_data)
            if self.toast:
                if logic_data: 
                    self.toast.show_message("✔ منطق شرطی برای فیلد ذخیره شد.", "success")
                else: 
                    self.toast.show_message("منطق شرطی حذف شد.", "info")
                    
                    
    def _update_property(self, widget, key, value):
        if key in ['min', 'max']:
            try: value = float(value) if value else None
            except (ValueError, TypeError): value = None
        elif key in ['min_length', 'max_length']:
            try: value = int(value) if value else None
            except (ValueError, TypeError): value = None
            
        widget.properties[key] = value
        widget.update_display()

    def _load_form_from_data(self, fields_json):
        if isinstance(fields_json, str):
            try: fields_json = json.loads(fields_json)
            except json.JSONDecodeError: return

        if not isinstance(fields_json, list) or not fields_json: return
        
        is_new_format = isinstance(fields_json[0], dict)
        
        type_map_reverse = {
            "text": "فیلد متنی", "number": "فیلد عددی", "date": "فیلد تاریخ", "checkbox": "چک‌باکس",
            "dropdown": "لیست کشویی", "item_list": "لیست کالاها", "user_list": "لیست کاربران",
            "supplier_list": "لیست تامین‌کنندگان", "department_list": "لیست واحدها (سازمانی)"
        }

        for i, field_data in enumerate(fields_json):
            if is_new_format:
                field_id = field_data.get('id', f"new_field_{i}"); field_label = field_data.get('label', 'بدون برچسب')
                field_type_key = field_data.get('type', 'text'); properties = field_data
            else:
                field_id = f"legacy_field_{i}"; field_label = field_data[0]; field_type_key = field_data[1]
                properties = {'type': field_type_key, 'label': field_label, 'required': False}

            field_type_text = type_map_reverse.get(field_type_key, "فیلد متنی")
            
            widget = FormFieldWidget(field_id, field_type_text, field_type_key, field_label)
            widget.properties = properties
            widget.update_display()
            widget.selected.connect(self._on_field_selected)
            self.canvas_layout.addWidget(widget)
    
    def _save_form_definition(self):
        form_name = self.form_name_edit.text().strip()
        if not form_name:
            QtWidgets.QMessageBox.warning(self, "Error", "نام فرم نمی‌تواند خالی باشد.")
            return

        if self.db.form_name_exists(form_name, self.user_id, exclude_form_id=self.form_id):
            QtWidgets.QMessageBox.warning(self, "نام تکراری", f"شما قبلاً فرمی با نام «{form_name}» ایجاد کرده‌اید. لطفاً نام دیگری انتخاب کنید.")
            return

        final_fields_json = []
        for i in range(self.canvas_layout.count()):
            widget = self.canvas_layout.itemAt(i).widget()
            if isinstance(widget, FormFieldWidget):
                final_fields_json.append(widget.get_data_for_json())
        
        form_type = self.form_data.get('form_type') if self.form_data else self.default_form_type
        form_data_dict = {
            'id': self.form_id,
            'name': form_name,
            'type': form_type,
            'fields': final_fields_json
        }

        try:
            self.db.save_advanced_form_def(form_data_dict, self.user_id)
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"خطا در هنگام ذخیره فرم:\n{e}")
            
                                    
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید

class LoginDialog(QtWidgets.QDialog):
    def __init__(self, db: DB):
        super().__init__()
        self.db = db
        self.user_info = None
        self.prefs_path = BASE_DIR / 'user_prefs.json'
        
        self.setWindowTitle('ورود')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        form = QtWidgets.QFormLayout(self)
        self.e_user = QtWidgets.QLineEdit()
        self.e_pass = QtWidgets.QLineEdit(); self.e_pass.setEchoMode(self.e_pass.Password)
        
        # --- *** بخش جدید: چک‌باکس "مرا به خاطر بسپار" *** ---
        self.remember_me_check = QtWidgets.QCheckBox("مرا به خاطر بسپار")
        
        form.addRow('نام کاربری', self.e_user)
        form.addRow('کلمه عبور', self.e_pass)
        form.addRow('', self.remember_me_check)
        
        btn = QtWidgets.QPushButton('ورود')
        form.addRow(btn)
        btn.clicked.connect(self._login)
        
        self._load_preferences()

    def _load_preferences(self):
        """اگر نام کاربری ذخیره شده بود، آن را در فیلد مربوطه قرار می‌دهد."""
        try:
            if self.prefs_path.exists():
                with open(self.prefs_path, 'r', encoding='utf-8') as f:
                    prefs = json.load(f)
                    saved_user = prefs.get('saved_username')
                    if saved_user:
                        self.e_user.setText(saved_user)
                        self.remember_me_check.setChecked(True)
                        self.e_pass.setFocus() # فوکوس را به فیلد رمز عبور منتقل می‌کند
        except Exception as e:
            print(f"Could not load user preferences: {e}")

    def _save_preferences(self):
        """نام کاربری را در صورت انتخاب، در فایل تنظیمات ذخیره یا حذف می‌کند."""
        try:
            if self.remember_me_check.isChecked():
                prefs = {'saved_username': self.e_user.text().strip()}
                with open(self.prefs_path, 'w', encoding='utf-8') as f:
                    json.dump(prefs, f)
            elif self.prefs_path.exists():
                # اگر تیک برداشته شده بود، فایل را حذف می‌کنیم
                os.remove(self.prefs_path)
        except Exception as e:
            print(f"Could not save user preferences: {e}")

    def _login(self):
        self.user_info = self.db.verify(self.e_user.text().strip(), self.e_pass.text())
        if self.user_info:
            self._save_preferences() # ذخیره تنظیمات پس از ورود موفق
            self.accept()
        else:
            QtWidgets.QMessageBox.warning(self, 'خطا', 'نام کاربری یا رمز اشتباه است')
                        



# کلاس Toast نسخه 3.1 (Final Polish)

class Toast(QtWidgets.QFrame):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowFlags(QtCore.Qt.ToolTip | QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
        self.setAttribute(QtCore.Qt.WA_StyledBackground, True)

        shadow = QtWidgets.QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(30); shadow.setOffset(4, 4)
        shadow.setColor(QtGui.QColor(0, 0, 0, 40))
        self.setGraphicsEffect(shadow)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.indicator_bar = QtWidgets.QFrame()
        self.indicator_bar.setFixedWidth(6)
        
        self.container_widget = QtWidgets.QFrame()
        self.container_widget.setObjectName("toastContainer")

        main_layout.addWidget(self.container_widget, 1)
        main_layout.addWidget(self.indicator_bar)

        # --- چیدمان اصلی داخلی ---
        container_main_layout = QtWidgets.QVBoxLayout(self.container_widget)
        container_main_layout.setContentsMargins(15, 10, 20, 15)
        container_main_layout.setSpacing(8)

        # --- چیدمان ردیف بالا (هدر) شامل عنوان و دکمه بستن ---
        header_layout = QtWidgets.QHBoxLayout()
        header_layout.setContentsMargins(0, 0, 0, 0)
        
        self.title_label = QtWidgets.QLabel()
        self.title_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        
        self.close_button = QtWidgets.QPushButton("×")
        self.close_button.setFixedSize(22, 22)
        self.close_button.setCursor(Qt.PointingHandCursor)
        self.close_button.clicked.connect(self.hide_animated)

        header_layout.addWidget(self.title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.close_button)
        
        # --- لیبل آیکون و متن اصلی ---
        body_layout = QtWidgets.QHBoxLayout(); body_layout.setSpacing(15)
        self.icon_label = QtWidgets.QLabel()
        self.icon_label.setFixedSize(28, 28)

        self.message_label = QtWidgets.QLabel()
        self.message_label.setFont(QFont(FONT_FAMILY, 10))
        self.message_label.setWordWrap(True)
        
        body_layout.addWidget(self.icon_label, 0, QtCore.Qt.AlignTop)
        body_layout.addWidget(self.message_label, 1)

        container_main_layout.addLayout(header_layout)
        container_main_layout.addLayout(body_layout)
        
        # --- انیمیشن‌ها و تایمر ---
        self.pos_animation = QtCore.QPropertyAnimation(self, b"pos")
        self.opacity_animation = QtCore.QPropertyAnimation(self, b"windowOpacity")
        
        self.show_animation = QtCore.QParallelAnimationGroup(self)
        self.show_animation.addAnimation(self.pos_animation)
        self.show_animation.addAnimation(self.opacity_animation)
        
        self.hide_timer = QtCore.QTimer(self)
        self.hide_timer.setSingleShot(True)
        self.hide_timer.timeout.connect(self.hide_animated)
        
        self.hide()

    def show_message(self, text: str, level: str = 'info', msec: int = 8000):
        if not self.parent(): return
        
        style_map = {
            'info':     ("اطلاع", "dialog-information", "#eaf2f8", "#3498db"),
            'success':  ("موفقیت", "emblem-ok", "#e8f8f5", "#27ae60"),
            'warning':  ("هشدار", "dialog-warning", "#fef9e7", "#f39c12"),
            'critical': ("خطا", "dialog-error", "#fdedec", "#c0392b"),
        }
        title, icon_name, bg_color, bar_color = style_map.get(level, style_map['info'])
        
        self.title_label.setText(title)
        self.message_label.setText(text)
        self.icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(28, 28))
        
        self.indicator_bar.setStyleSheet(f"background-color: {bar_color}; border-top-right-radius: 5px; border-bottom-right-radius: 5px;")
        self.container_widget.setStyleSheet(f"""
            #toastContainer {{ background-color: {bg_color}; border-top-left-radius: 5px; border-bottom-left-radius: 5px; }}
            QLabel {{ background: transparent; color: #2c3e50; }}
        """)
        self.close_button.setStyleSheet("""
            QPushButton {
                background-color: #0000001A; color: #555; border: none;
                border-radius: 11px; font-size: 14pt;
            }
            QPushButton:hover { background-color: #00000033; }
        """)

        # --- اصلاح نهایی ابعاد ---
        self.message_label.setMaximumWidth(550)
        self.adjustSize()

        parent_geo = self.parent().geometry()
        top_margin = 45
        final_pos = QtCore.QPoint(parent_geo.width() - self.width() - 25, top_margin)
        start_pos = QtCore.QPoint(final_pos.x(), top_margin - 20)
        
        self.move(final_pos.x(), 0)
        self.setWindowOpacity(0.0)
        self.show()

        pos_anim_show = QtCore.QPropertyAnimation(self, b"pos", self)
        pos_anim_show.setStartValue(start_pos); pos_anim_show.setEndValue(final_pos)
        pos_anim_show.setEasingCurve(QtCore.QEasingCurve.OutCubic); pos_anim_show.setDuration(350)

        opacity_anim_show = QtCore.QPropertyAnimation(self, b"windowOpacity", self)
        opacity_anim_show.setStartValue(0.0); opacity_anim_show.setEndValue(1.0)
        opacity_anim_show.setDuration(300)
        
        self.show_animation.clear()
        self.show_animation.addAnimation(pos_anim_show)
        self.show_animation.addAnimation(opacity_anim_show)
        self.show_animation.start()
        
        self.hide_timer.start(msec)

    def hide_animated(self):
        self.show_animation.stop()
        self.hide_timer.stop()
        
        anim = QtCore.QPropertyAnimation(self, b"windowOpacity", self)
        anim.setStartValue(self.windowOpacity()); anim.setEndValue(0.0)
        anim.setDuration(300)
        anim.finished.connect(self.hide)
        anim.start()        
                                                                                                                                        
class Splash(QtWidgets.QSplashScreen):
    def __init__(self):
        pix = QtGui.QPixmap(240, 160)
        pix.fill(Qt.transparent)

        p = QtGui.QPainter(pix); p.setRenderHint(p.Antialiasing)
        p.setBrush(QtGui.QColor('#283593'))
        p.drawRoundedRect(0, 0, 240, 160, 20, 20)
        p.setPen(Qt.white)
        p.setFont(QFont('B Titr', 28, QFont.Bold))      # ← فونت تیتر فارسی
        p.drawText(pix.rect(), Qt.AlignCenter, "MEGATITE")
        p.end()

        super().__init__(pix)
        self.show(); QtWidgets.qApp.processEvents()

# ────────────────── Toolbar ساز ────────────────────



# ────────────────── KPI Label ساز ──────────────────
def kpi_label(color: str, text: str) -> QtWidgets.QLabel:
    lbl = QtWidgets.QLabel(text, alignment=Qt.AlignCenter)
    lbl.setStyleSheet(f"background:{color};color:#fff;padding:8px;border-radius:6px;font-weight:bold;")
    return lbl

# این تابع را با نسخه جدید و هوشمند زیر جایگزین کنید

def set_empty_placeholder(widget: QtWidgets.QWidget, text: str):
    """
    نسخه نهایی و هوشمند:
    یک پیام جایگزین را برای ویجت‌های خالی (جدول یا درخت) نمایش می‌دهد.
    این تابع نوع ویجت را تشخیص داده و از متد صحیح برای شمارش آیتم‌ها استفاده می‌کند.
    """
    item_count = 0
    if isinstance(widget, QtWidgets.QTableWidget):
        item_count = widget.rowCount()
    elif isinstance(widget, QtWidgets.QTreeWidget):
        item_count = widget.topLevelItemCount()

    if item_count > 0:
        if hasattr(widget, '_empty_lbl'):
            widget._empty_lbl.hide()
        return

    if not hasattr(widget, '_empty_lbl'):
        lbl = QtWidgets.QLabel(text, widget)
        lbl.setAlignment(Qt.AlignCenter)
        lbl.setStyleSheet("color:#9e9e9e; font-style:italic; background-color: transparent;")
        widget._empty_lbl = lbl
        
    widget._empty_lbl.resize(widget.viewport().size())
    widget._empty_lbl.show()
    


# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید

class PinnedTable(QtWidgets.QTableWidget):
    """آخرین تراکنش‌ها با قابلیت نمایش موارد جدید پس از پاکسازی"""
    def __init__(self, db: DB, limit=15):
        super().__init__(0, 5)
        self.db, self.limit = db, limit
        
        self.setHorizontalHeaderLabels(['ID', 'کالا', 'نوع', 'مقدار', 'تاریخ'])
        self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.setAlternatingRowColors(True)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.verticalHeader().hide()
        self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers) # دابل کلیک غیرفعال است

    def refresh(self, since_id: int = 0):
        self.setRowCount(0)
        query = """
            SELECT t.id, i.name, t.t_type, t.qty, t.t_date
            FROM trans t JOIN items i ON t.item_id=i.id
            WHERE t.id > %s
            ORDER BY t.id DESC LIMIT %s
        """
        rows = self.db.execute_query(query, (since_id, self.limit))
        self.setRowCount(len(rows))
        
        for r, row_data in enumerate(rows):
            values = (
                row_data['id'], row_data['name'], row_data['t_type'],
                row_data['qty'], to_shamsi(row_data['t_date'])
            )
            for c, val in enumerate(values):
                item = QtWidgets.QTableWidgetItem(str(val))
                if c in [0, 3]: item.setTextAlignment(Qt.AlignCenter)
                else: item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                self.setItem(r, c, item)
        self.setColumnHidden(0, True)        
                
        
class ItemDialog(QtWidgets.QDialog):
    """
    نسخه 7.2 (یکپارچه‌سازی دسته‌بندی):
    - لیست دسته‌بندی‌ها در فرم با تب‌های صفحه اصلی هماهنگ شد.
    """
    # در کلاس ItemDialog، متد __init__ را جایگزین کنید

    def __init__(self, db: DB, user_id: int, role: str, item_id=None, parent_id=None, parent_name=None):
        super().__init__()
        self.db, self.user_id, self.role, self.item_id = db, user_id, role, item_id
        self.parent_id = parent_id

        # ── بارگذاری آیتم در حالت ویرایش
        self.item_data = self.db.get_item_details(self.item_id) if self.item_id else {}

        # ── عنوان پنجره بر اساس حالت
        if self.parent_id:
            # اگر نام مادر پاس داده نشده بود، از دیتابیس بیار
            if not parent_name:
                p = self.db.get_item_details(self.parent_id) or {}
                parent_name = p.get('name') or ''
            title = f"افزودن پک جدید برای: {parent_name}"
        else:
            title = ('افزودن کالا' if not self.item_id else f"ویرایش: {self.item_data.get('name')}")
        self.setWindowTitle(title)

        # ── اسکلت کلی UI
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 850)
        main_lay = QtWidgets.QVBoxLayout(self)
        self.tabs = QtWidgets.QTabWidget()
        main_lay.addWidget(self.tabs)

        # ── تب «مشخصات اصلی»
        props_page = QtWidgets.QWidget()
        self.form = QtWidgets.QFormLayout(props_page); self.form.setSpacing(10)
        self.tabs.addTab(props_page, "مشخصات اصلی کالا")

        self.e_name = QtWidgets.QLineEdit()
        self.e_sku  = QtWidgets.QLineEdit()

        self.c_cat = QtWidgets.QComboBox()
        # توجه: این مقادیر از قبل به‌صورت رشته‌های دسته‌ها تعریف شده‌اند
        self.c_cat.addItems([
            CATEGORY_RAW_MATERIAL, CATEGORY_FINAL_PRODUCT, CATEGORY_PACKAGING, CATEGORY_CONSUMABLES, 'محصول فله'
        ])

        self.c_unit = QtWidgets.QComboBox()
        self.populate_units_combo()

        self.e_net_weight = QtWidgets.QDoubleSpinBox()
        self.e_net_weight.setRange(0, 10000)
        self.e_net_weight.setDecimals(3)
        self.e_net_weight.setSuffix(" Kg")
        self.net_weight_label = QtWidgets.QLabel("وزن خالص (برای پک‌ها):")

        self.e_supp = QtWidgets.QLineEdit()
        self.e_note = QtWidgets.QTextEdit(); self.e_note.setFixedHeight(60)

        self.e_cost = QtWidgets.QDoubleSpinBox()
        self.e_cost.setRange(0, 1e12); self.e_cost.setDecimals(0); self.e_cost.setGroupSeparatorShown(True)

        self.e_min  = QtWidgets.QDoubleSpinBox(); self.e_min.setRange(0, 1e9); self.e_min.setDecimals(3)
        self.e_max  = QtWidgets.QDoubleSpinBox(); self.e_max.setRange(0, 1e9); self.e_max.setDecimals(3)

        self.is_parent_check = QtWidgets.QCheckBox("این یک محصول مادر است (برای تعریف بسته‌بندی‌های مختلف)")
        self.is_two_component_check = QtWidgets.QCheckBox("این محصول دوجزئی است (نیازمند پارت A و B)")
        self.is_two_component_check.setChecked(True)

        # QC
        self.requires_qc_check = QtWidgets.QCheckBox("این کالا هنگام ورود نیازمند بازرسی QC است")
        self.requires_qc_check.setChecked(True)

        # چیدمان فرم مشخصات
        self.form.addRow("نام کالا (*):", self.e_name)
        self.form.addRow("شناسه کالا (SKU):", self.e_sku)
        self.form.addRow("دسته:", self.c_cat)
        self.form.addRow("واحد شمارش (*):", self.c_unit)
        self.form.addRow(self.net_weight_label, self.e_net_weight)

        self.cost_label = QtWidgets.QLabel("ارزش واحد (ریال):")
        self.form.addRow(self.cost_label, self.e_cost)

        min_max_layout = QtWidgets.QHBoxLayout()
        min_max_layout.addWidget(QtWidgets.QLabel("حداقل موجودی:"));   min_max_layout.addWidget(self.e_min)
        min_max_layout.addSpacing(20)
        min_max_layout.addWidget(QtWidgets.QLabel("حداکثر موجودی:"));  min_max_layout.addWidget(self.e_max)
        self.form.addRow(min_max_layout)

        self.form.addRow("تأمین‌کننده:", self.e_supp)
        self.form.addRow("توضیحات:", self.e_note)

        self.form.addRow(self.is_parent_check)
        self.form.addRow(self.is_two_component_check)
        self.form.addRow(self.requires_qc_check)

        if self.role not in ['Admin', 'Finance']:
            self.cost_label.hide(); self.e_cost.hide()

        # ── تب «بسته‌بندی‌ها»
        self.packaging_page = QtWidgets.QWidget()
        packaging_layout = QtWidgets.QVBoxLayout(self.packaging_page)
        packaging_layout.addWidget(QtWidgets.QLabel("لیست پک‌های تعریف شده برای این محصول:"))

        self.tbl_child_items = QtWidgets.QTableWidget(0, 4)
        self.tbl_child_items.setHorizontalHeaderLabels(["ID", "SKU", "نام پک", "واحد"])
        self.tbl_child_items.setColumnHidden(0, True)
        self.tbl_child_items.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_child_items.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.tbl_child_items.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        packaging_layout.addWidget(self.tbl_child_items)

        pack_btn_layout = QtWidgets.QHBoxLayout()
        btn_add_pack  = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "تعریف پک جدید")
        btn_edit_pack = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), "ویرایش پک انتخابی")
        self.btn_manage_bom = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-properties"), "مدیریت لوازم این پک")
        self.btn_manage_bom.setEnabled(False)

        pack_btn_layout.addWidget(btn_add_pack); pack_btn_layout.addWidget(btn_edit_pack)
        pack_btn_layout.addStretch(); pack_btn_layout.addWidget(self.btn_manage_bom)
        packaging_layout.addLayout(pack_btn_layout)

        self.tabs.addTab(self.packaging_page, "بسته‌بندی‌ها (SKU)")

        # ── گروه «موجودی اولیه»
        self.stock_group = QtWidgets.QGroupBox("ثبت موجودی اولیه (فقط برای کالای جدید)")
        main_lay.addWidget(self.stock_group, 1)

        stock_layout = QtWidgets.QVBoxLayout(self.stock_group)
        self.stock_table = QtWidgets.QTableWidget(0, 4)
        self.stock_table.setHorizontalHeaderLabels(["لوکیشن", "شماره بچ", "تاریخ انقضا", "مقدار"])
        self.stock_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.stock_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        stock_layout.addWidget(self.stock_table)

        stock_btn_layout = QtWidgets.QHBoxLayout()
        btn_add_stock    = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن ردیف موجودی")
        btn_remove_stock = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف ردیف انتخاب شده")
        stock_btn_layout.addWidget(btn_add_stock); stock_btn_layout.addWidget(btn_remove_stock)
        stock_btn_layout.addStretch(); stock_layout.addLayout(stock_btn_layout)

        # ── دکمه‌های پایین
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Save | QtWidgets.QDialogButtonBox.Cancel)
        self.save_button = buttons.button(QtWidgets.QDialogButtonBox.Save)
        self.save_button.setText("ذخیره مشخصات کالا")
        buttons.accepted.connect(self._save_main_item)
        buttons.rejected.connect(self.reject)
        main_lay.addWidget(buttons)

        # ── اتصال‌ها
        self.e_name.textChanged.connect(self._update_save_button_state)
        self.c_unit.currentIndexChanged.connect(self._update_save_button_state)
        self.is_parent_check.toggled.connect(self._update_save_button_state)

        self.is_parent_check.toggled.connect(self._update_field_visibility)
        self.c_cat.currentIndexChanged.connect(self._update_field_visibility)

        self.tbl_child_items.itemSelectionChanged.connect(lambda: self.btn_manage_bom.setEnabled(True))
        self.btn_manage_bom.clicked.connect(self._open_packaging_bom_editor)
        btn_add_pack.clicked.connect(self._add_child_item)
        btn_edit_pack.clicked.connect(self._edit_child_item)
        btn_add_stock.clicked.connect(self._add_stock_row)
        btn_remove_stock.clicked.connect(self._remove_stock_row)

        # ─────────────────────────────────────────────────────────────
        # 🧠 قوانین حالت‌ها (کلیدِ رفع باگ A): یک تابع داخلی و رویدادها
        # این تابع را روی self می‌نشانیم تا جاهای دیگر هم در صورت نیاز بتوانند صدا بزنند.
        def _apply_item_type_rules():
            """
            حالت‌ها:
            - فرزند: parent_id موجود یا آیتم در حال ویرایش parent_item_id دارد.
            - مادر: تیک مادر خورده و فرزند نیست.
            - معمولی: نه فرزند، نه مادر.
            """
            # تشخیص فرزند حتی در حالت ویرایش
            is_child_mode = bool(self.parent_id) or bool(self.item_data.get('parent_item_id')) if self.item_id else bool(self.parent_id)
            is_parent_checked = self.is_parent_check.isChecked()

            # ارث دو‌جزئی از مادر در حالت فرزند
            parent_two_comp = False
            if is_child_mode:
                pid = self.parent_id or self.item_data.get('parent_item_id')
                p = self.db.get_item_details(pid) if pid else {}
                parent_two_comp = bool(p.get('is_two_component', False))
                # قفل تیک مادر و دو‌جزئی
                self.is_parent_check.blockSignals(True)
                self.is_parent_check.setChecked(False)
                self.is_parent_check.setEnabled(False)
                self.is_parent_check.blockSignals(False)

                self.is_two_component_check.blockSignals(True)
                self.is_two_component_check.setChecked(parent_two_comp)
                self.is_two_component_check.setEnabled(False)
                self.is_two_component_check.blockSignals(False)

                # دسته = محصول نهایی و قفل
                idx = self.c_cat.findText(CATEGORY_FINAL_PRODUCT)
                if idx >= 0:
                    self.c_cat.setCurrentIndex(idx)
                self.c_cat.setEnabled(False)

                # واحد و موجودی اولیه برای فرزند فعال
                self.c_unit.setEnabled(True)
                self.stock_group.setEnabled(True)

                # تب بسته‌بندی برای فرزند بی‌معناست
                i_tab = self.tabs.indexOf(self.packaging_page)
                if i_tab != -1:
                    self.tabs.setTabEnabled(i_tab, False)

                # وزن خالص برای پک نمایش داده شود
                self.net_weight_label.setVisible(True); self.e_net_weight.setVisible(True)

            else:
                # حالت مادر یا معمولی
                # وزن خالص: فقط اگر «محصول نهایی» و مادر نیست
                is_final_cat = (self.c_cat.currentText() == CATEGORY_FINAL_PRODUCT)

                if is_parent_checked:
                    # مادر
                    self.is_parent_check.setEnabled(True)
                    self.is_two_component_check.setEnabled(True)   # مادر مجاز است دو‌جزئی باشد
                    self.c_unit.setEnabled(False)                  # مادر واحد عملیاتی ندارد
                    # موجودی اولیه برای مادر بی‌معنا
                    self.stock_group.setEnabled(False)

                    # تب بسته‌بندی‌ها فقط وقتی فعال که آیتم قبلاً ذخیره شده (ویرایش)
                    i_tab = self.tabs.indexOf(self.packaging_page)
                    if i_tab != -1:
                        self.tabs.setTabEnabled(i_tab, bool(self.item_id))

                    # وزن خالص برای مادر پنهان
                    self.net_weight_label.setVisible(False); self.e_net_weight.setVisible(False)
                else:
                    # معمولی
                    self.is_parent_check.setEnabled(True)
                    # دو‌جزئی فقط برای مادر ⇒ اینجا قفل و خاموش
                    self.is_two_component_check.blockSignals(True)
                    self.is_two_component_check.setChecked(False)
                    self.is_two_component_check.setEnabled(False)
                    self.is_two_component_check.blockSignals(False)

                    self.c_unit.setEnabled(True)
                    # موجودی اولیه فقط در حالت «آیتم جدید» فعال
                    self.stock_group.setEnabled(self.item_id is None)

                    # تب بسته‌بندی‌ها بی‌معنا
                    i_tab = self.tabs.indexOf(self.packaging_page)
                    if i_tab != -1:
                        self.tabs.setTabEnabled(i_tab, False)

                    # وزن خالص: اگر خودش «محصول نهایی» است، نمایش بده
                    self.net_weight_label.setVisible(is_final_cat)
                    self.e_net_weight.setVisible(is_final_cat)

        # متد را روی self ست می‌کنیم تا بیرون از این اسکوپ هم قابل فراخوانی باشد
        self._apply_item_type_rules = _apply_item_type_rules

        # هر تغییری که روی حالت تأثیر دارد، این قوانین را دوباره اعمال کند
        self.is_parent_check.toggled.connect(self._apply_item_type_rules)
        self.c_cat.currentIndexChanged.connect(self._apply_item_type_rules)

        # ── بارگذاری اولیهٔ محتوا و سپس اعمال قوانین حالت‌ها
        if self.item_id:
            self._load_data_for_edit()
        elif self.parent_id:
            self._setup_for_new_child()
        else:
            self._update_field_visibility()

        # حتماً پس از بارگذاری اولیه، قوانین را اعمال کن
        self._apply_item_type_rules()
        self._update_save_button_state()
        
    # داخل کلاس ItemDialog
    def _apply_item_type_rules(self):
        """
        قوانین نمایش/قفل‌کردن فیلدها بر اساس حالت‌ها:
        - حالت فرزند (self.parent_item_id != None)
        - حالت مادر (self.chk_parent.isChecked())
        - حالت معمولی (بدون والد و بدون تیک مادر)
        """
        is_child  = getattr(self, 'parent_item_id', None) is not None
        is_parent = bool(self.chk_parent.isChecked())

        if is_child:
            # از مادر ارث بگیر
            parent = self.db.get_item_by_id(self.parent_item_id)
            parent_two_comp = bool(parent.get('is_two_component', False))

            # قفل‌های ضروری
            self.chk_parent.setChecked(False)
            self.chk_parent.setEnabled(False)

            self.chk_two_comp.setChecked(parent_two_comp)
            self.chk_two_comp.setEnabled(False)

            # دسته‌بندی = محصول نهایی (Final Product)
            idx = self.cmb_category.findData(CATEGORY_FINAL_PRODUCT)
            if idx >= 0:
                self.cmb_category.setCurrentIndex(idx)
            self.cmb_category.setEnabled(False)

            # موجودی اولیه/واحد برای فرزند فعال است
            self.grp_initial_stock.setEnabled(True)
            self.cmb_unit.setEnabled(True)

            # تبِ «بسته‌بندی‌ها» برای فرزند بی‌معنی است
            if hasattr(self, 'tab_packages'):
                self.tab_packages.setEnabled(False)

        elif is_parent:
            # مادر: واحد/موجودی اولیه معنی ندارد
            self.cmb_unit.setEnabled(False)
            self.grp_initial_stock.setEnabled(False)

            # مادر می‌تواند دو‌جزئی باشد؛ این گزینه فعال بماند
            self.chk_two_comp.setEnabled(True)

            # تب بسته‌بندی‌ها بعد از ذخیره فعال می‌شود (اینجا دست‌نزن)
            if hasattr(self, 'tab_packages'):
                self.tab_packages.setEnabled(True)

            # دسته‌بندی مادر معمولاً «محصول مادر/چتری» یا «بدون دسته نهایی» است
            # اگر سیاست شما دستهٔ خاصی برای مادر دارد، اینجا ست کنید (اختیاری)

        else:
            # حالت کالای معمولی (نه والد دارد نه تیک مادر)
            self.chk_parent.setEnabled(True)
            # دو‌جزئی فقط مخصوص مادر است؛ برای آیتم معمولی خاموش و قفل
            self.chk_two_comp.setChecked(False)
            self.chk_two_comp.setEnabled(False)

            # موجودی اولیه/واحد برای معمولی فعال است
            self.grp_initial_stock.setEnabled(True)
            self.cmb_unit.setEnabled(True)

            # تب بسته‌بندی‌ها بی‌معنی
            if hasattr(self, 'tab_packages'):
                self.tab_packages.setEnabled(False)

                        
    def _update_save_button_state(self):
        is_name_valid = bool(self.e_name.text().strip())
        is_parent = self.is_parent_check.isChecked()
        is_child = self.parent_id is not None
        is_unit_valid = self.c_unit.currentData() is not None or is_parent or is_child
        self.save_button.setEnabled(is_name_valid and is_unit_valid)

# در کلاس ItemDialog، متد _save_main_item را جایگزین کنید

# در کلاس ItemDialog
    def _save_main_item(self):
        name = self.e_name.text().strip()
        unit_id = self.c_unit.currentData()
        is_parent = self.is_parent_check.isChecked()
        is_two_comp = self.is_two_component_check.isChecked()
        category = self.c_cat.currentText(); is_packed_value = (category == CATEGORY_FINAL_PRODUCT)
        
        item_master_data = {
            'name': name, 'sku': self.e_sku.text().strip(), 'category': category, 'unit_id': unit_id, 
            'cost': self.e_cost.value(), 'min_qty': self.e_min.value(), 'max_qty': self.e_max.value(), 
            'supplier': self.e_supp.text().strip(), 'notes': self.e_note.toPlainText().strip(), 
            'is_parent_product': is_parent, 
            'is_two_component': is_two_comp,
            'is_packed': is_packed_value, 'default_loc': self.item_data.get('default_loc'), 
            'expiry_lead_days': self.item_data.get('expiry_lead_days', 30), 
            'reporting_group': self.item_data.get('reporting_group', ''), 
            'parent_item_id': self.parent_id, 'net_weight': self.e_net_weight.value(),
            # --- *** بخش جدید: ارسال وضعیت QC به بک‌اند *** ---
            'requires_qc': self.requires_qc_check.isChecked()
            # ---------------------------------------------
        }
        
        initial_stock_data = [self.stock_table.item(r, 0).data(Qt.UserRole) for r in range(self.stock_table.rowCount()) if self.stock_table.item(r, 0)] if not is_parent else []
        
        try:
            if self.item_id:
                self.db.update_item_with_locations(self.item_id, item_master_data, self.user_id)
            else:
                self.db.add_item_with_locations(item_master_data, initial_stock_data, self.user_id)
            self.accept()
        except Exception as e: 
            QtWidgets.QMessageBox.critical(self, 'خطا در ذخیره‌سازی', f"مشکلی در هنگام ذخیره پیش آمد:\n{e}"); 
            print(traceback.format_exc())
                        
    def _update_field_visibility(self):
        """
        قوانین UI:
        - فقط وقتی دسته = 'محصول نهایی' باشد، امکان 'محصول مادر' و 'دو جزئی' فعال است.
        - اگر این فرم برای 'پکِ فرزند' باز شده باشد (parent_id دارد)، همه چیز از مادر ارث می‌آید و قفل است.
        - تب 'بسته‌بندی‌ها' فقط وقتی آیتم مادر و ذخیره‌شده باشد فعال می‌شود.
        """
        final_cat = CATEGORY_FINAL_PRODUCT
        current_cat = self.c_cat.currentText()
        is_child_mode = bool(self.parent_id) or (bool(self.item_id) and bool(self.item_data.get('parent_item_id')))
        i_tab = self.tabs.indexOf(self.packaging_page)

        # پیش‌فرض‌ها: تب بسته‌بندی غیرفعال (اگر هست)
        if i_tab != -1:
            self.tabs.setTabEnabled(i_tab, False)

        # حالت فرزند: از مادر ارث و قفل
        if is_child_mode:
            # قفل 'مادر' و 'دو جزئی'
            self.is_parent_check.blockSignals(True)
            self.is_parent_check.setChecked(False)
            self.is_parent_check.setEnabled(False)
            self.is_parent_check.blockSignals(False)

            # ارث دو جزئی از مادر و قفل
            parent_two_comp = False
            pid = self.parent_id or (self.item_data.get('parent_item_id') if self.item_id else None)
            if pid:
                p = self.db.get_item_details(pid) or {}
                parent_two_comp = bool(p.get('is_two_component', False))
            self.is_two_component_check.blockSignals(True)
            self.is_two_component_check.setChecked(parent_two_comp)
            self.is_two_component_check.setEnabled(False)
            self.is_two_component_check.blockSignals(False)

            # دسته = محصول نهایی و قفل
            idx = self.c_cat.findText(final_cat)
            if idx >= 0:
                self.c_cat.setCurrentIndex(idx)
            self.c_cat.setEnabled(False)

            # واحد/موجودی اولیه برای فرزند
            self.c_unit.setEnabled(True)
            # ✅ فقط برای کالای جدید اجازه ثبت موجودی اولیه
            self.stock_group.setEnabled(self.item_id is None)

            # ✅ وزن خالص فقط برای پک‌ها (حالت فرزند)
            self.net_weight_label.setVisible(True)
            self.e_net_weight.setVisible(True)
            return  # حالت فرزند تمام

        # از اینجا به بعد: مادر/معمولی
        is_final_category = (current_cat == final_cat)

        # فقط در محصول نهایی اجازه‌ی مادر/دو‌جزئی بده
        if not is_final_category:
            # هر چی تیک خورده بود خاموش و قفل
            self.is_parent_check.blockSignals(True)
            self.is_parent_check.setChecked(False)
            self.is_parent_check.setEnabled(False)
            self.is_parent_check.blockSignals(False)

            self.is_two_component_check.blockSignals(True)
            self.is_two_component_check.setChecked(False)
            self.is_two_component_check.setEnabled(False)
            self.is_two_component_check.blockSignals(False)

            # تب بسته‌بندی بی‌معنا
            if i_tab != -1:
                self.tabs.setTabEnabled(i_tab, False)

            # واحد/موجودی اولیه فعال (غیرمادر)
            self.c_unit.setEnabled(True)
            self.stock_group.setEnabled(self.item_id is None)

            # ✅ وزن خالص برای پک‌هاست؛ اینجا پنهان
            self.net_weight_label.setVisible(False)
            self.e_net_weight.setVisible(False)
            return

        # دسته = محصول نهایی
        self.is_parent_check.setEnabled(True)

        if self.is_parent_check.isChecked():
            # مادر: دو‌جزئی فقط اینجا مجاز
            self.is_two_component_check.setEnabled(True)
            # مادر واحد عملیاتی و موجودی اولیه ندارد
            self.c_unit.setEnabled(False)
            self.stock_group.setEnabled(False)
            # تب بسته‌بندی‌ها فقط بعد از ذخیره‌بودن آیتم فعال شود
            if i_tab != -1:
                self.tabs.setTabEnabled(i_tab, bool(self.item_id))
            # ✅ وزن خالصِ مادر پنهان
            self.net_weight_label.setVisible(False)
            self.e_net_weight.setVisible(False)
        else:
            # کالای معمولیِ محصول نهایی (نه مادر، نه فرزند)
            self.is_two_component_check.blockSignals(True)
            self.is_two_component_check.setChecked(False)
            self.is_two_component_check.setEnabled(False)
            self.is_two_component_check.blockSignals(False)

            self.c_unit.setEnabled(True)
            self.stock_group.setEnabled(self.item_id is None)

            if i_tab != -1:
                self.tabs.setTabEnabled(i_tab, False)

            # ✅ وزن خالص فقط برای پک‌هاست؛ اینجا (نه مادر و نه فرزند) پنهان
            self.net_weight_label.setVisible(False)
            self.e_net_weight.setVisible(False)

# در کلاس ItemDialog، این متد را به طور کامل جایگزین کنید
    def _load_data_for_edit(self):
        rec = self.item_data
        if not rec: self.close(); return
        
        self.e_name.setText(rec.get('name', '')); self.e_sku.setText(rec.get('sku', '')); self.c_cat.setCurrentText(rec.get('category', ''))
        unit_id = rec.get('unit_id');
        if unit_id:
            index = self.c_unit.findData(unit_id)
            if index != -1: self.c_unit.setCurrentIndex(index)
        
        self.e_net_weight.setValue(rec.get('net_weight', 0))
        self.e_cost.setValue(rec.get('cost', 0)); self.e_min.setValue(rec.get('min_qty', 0)); self.e_max.setValue(rec.get('max_qty', 0)); self.e_supp.setText(rec.get('supplier', '')); self.e_note.setPlainText(rec.get('notes', ''))
        
        is_parent = rec.get('is_parent_product', False)
        self.is_parent_check.setChecked(is_parent)
        
        # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
        # این خط فراموش شده بود و باعث می‌شد وضعیت چک‌باکس از دیتابیس خوانده نشود.
        self.is_two_component_check.setChecked(rec.get('is_two_component', False))
        # --- ************************************* ---

        self.requires_qc_check.setChecked(rec.get('requires_qc', True))
        
        self._update_field_visibility() 
        self._update_save_button_state()
        
        if is_parent:
            self._load_child_items()
                        
    def _load_child_items(self):
        self.tbl_child_items.setRowCount(0)
        if not self.item_id: return
        children = self.db.get_child_items(self.item_id)
        self.tbl_child_items.setRowCount(len(children))
        for r, child in enumerate(children):
            self.tbl_child_items.setItem(r, 0, QtWidgets.QTableWidgetItem(str(child['id'])))
            self.tbl_child_items.setItem(r, 1, QtWidgets.QTableWidgetItem(child['sku']))
            self.tbl_child_items.setItem(r, 2, QtWidgets.QTableWidgetItem(child['name']))
            self.tbl_child_items.setItem(r, 3, QtWidgets.QTableWidgetItem(child.get('unit') or ''))

    def _add_child_item(self):
        if not self.item_id: return
        dlg = ItemDialog(self.db, self.user_id, self.role, parent_id=self.item_id, parent_name=self.item_data.get('name'))
        if dlg.exec_(): self._load_child_items()

    def _edit_child_item(self):
        selected = self.tbl_child_items.selectedItems();
        if not selected: QtWidgets.QMessageBox.warning(self, "انتخاب پک", "لطفاً یک پک را برای ویرایش از جدول انتخاب کنید."); return
        child_id = int(self.tbl_child_items.item(selected[0].row(), 0).text())
        dlg = ItemDialog(self.db, self.user_id, self.role, item_id=child_id, parent_id=self.item_id)
        if dlg.exec_(): self._load_child_items()

    def populate_units_combo(self):
        self.c_unit.clear(); units = self.db.get_all_units()
        for unit in units: self.c_unit.addItem(unit['name'], unit['id'])
        self.c_unit.insertItem(0, "--- انتخاب کنید ---", None); self.c_unit.setCurrentIndex(0)
    
    def _setup_for_new_child(self):
        self.is_parent_check.setChecked(False); self.is_parent_check.setDisabled(True)
        self.c_cat.setCurrentText("محصول نهایی"); self.c_cat.setEnabled(False)
        self.tabs.setTabVisible(1, False)
        unit_index = self.c_unit.findText("عدد")
        if unit_index != -1: self.c_unit.setCurrentIndex(unit_index)
        self.c_unit.setEnabled(False)

    def _add_stock_row(self):
        dlg = AddStockRowDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                row_pos = self.stock_table.rowCount(); self.stock_table.insertRow(row_pos); self.stock_table.setItem(row_pos, 0, QtWidgets.QTableWidgetItem(data['loc_label'])); self.stock_table.setItem(row_pos, 1, QtWidgets.QTableWidgetItem(data['batch_no'])); self.stock_table.setItem(row_pos, 2, QtWidgets.QTableWidgetItem(to_shamsi(data['expiry_date']))); self.stock_table.setItem(row_pos, 3, QtWidgets.QTableWidgetItem(str(data['qty']))); self.stock_table.item(row_pos, 0).setData(Qt.UserRole, data)
    
    def _remove_stock_row(self):
        current_row = self.stock_table.currentRow();
        if current_row >= 0: self.stock_table.removeRow(current_row)

    def _open_packaging_bom_editor(self):
        selected = self.tbl_child_items.selectedItems()
        if not selected: return
        pack_item_id = int(self.tbl_child_items.item(selected[0].row(), 0).text())
        pack_item_data = self.db.get_item_details(pack_item_id)
        if not pack_item_data: return
        dlg = PackagingBomDialog(self.db, dict(pack_item_data), self)
        dlg.exec_()
                
                                    
class TransferDialog(QtWidgets.QDialog):
    """
    نسخه نهایی (V3.0): این دیالوگ برای انتقال کالا بین لوکیشن‌های غیرتولیدی عمل می‌کند
    و حالا از انتخاب دقیق بچ/انقضا پشتیبانی می‌کند.
    """
    def __init__(self, db:DB, user_id:int, parent=None):
        super().__init__(parent)
        self.db, self.user_id = db, user_id
        
        self.setWindowTitle("انتقال داخلی بین انبارها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(550) # کمی عرض بیشتر برای نمایش اطلاعات بچ
        
        f = QtWidgets.QFormLayout(self)
        f.setSpacing(15)
        
        self.c_item = QtWidgets.QComboBox(); self.c_item.setEditable(True)
        self.c_item.setCompleter(QtWidgets.QCompleter(self.c_item.model()))
        
        self.c_src = QtWidgets.QComboBox()
        self.c_batch = QtWidgets.QComboBox() # <<< فیلد جدید برای انتخاب بچ
        self.c_dst = QtWidgets.QComboBox()
        self.e_qty = QtWidgets.QLineEdit()
        self.e_qty.setValidator(QtGui.QDoubleValidator(0.001, 1e9, 3))
        self.e_notes = QtWidgets.QLineEdit()

        f.addRow('کالا:', self.c_item)
        f.addRow('از لوکیشن:', self.c_src)
        f.addRow('انتخاب بچ/انقضا:', self.c_batch) # <<< فیلد جدید
        f.addRow('به لوکیشن:', self.c_dst)
        f.addRow('مقدار:', self.e_qty)
        f.addRow('یادداشت (اختیاری):', self.e_notes)
        
        btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " ثبت انتقال")
        btn.setProperty("class", "primary"); f.addRow(btn)
        
        self.c_item.currentIndexChanged.connect(self._refresh_source_locations)
        self.c_src.currentIndexChanged.connect(self._refresh_batches_and_destinations)
        btn.clicked.connect(self._do_transfer)
        
        self._populate_items()
        self._refresh_source_locations()

    def _g2j(self, greg_date: dt.date | None) -> str:
        if greg_date is None: return "نامشخص"
        return jd.fromgregorian(date=greg_date).strftime('%Y/%m/%d')

    def _populate_items(self):
        """فقط کالاهایی که در انبارهای غیرتولیدی موجودی دارند را لیست می‌کند."""
        self.c_item.clear()
        all_items = self.db.items_brief()
        for rec in all_items:
            non_prod_qty = rec.get('non_prod_qty', 0)
            if non_prod_qty > 0:
                # FIX: ستون batch از آیتم حذف شد چون در جدول items وجود ندارد.
                disp = f"{rec['name']} (موجودی غیرتولید: {non_prod_qty})"
                self.c_item.addItem(disp, dict(rec))

    def _refresh_source_locations(self):
        """لوکیشن‌های مبدا که کالا در آنها موجود است را بارگذاری می‌کند."""
        self.c_src.blockSignals(True)
        self.c_src.clear()
        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict): 
            self.c_src.blockSignals(False)
            self._refresh_batches_and_destinations()
            return
        
        item_id = item_data.get('id')
        if not item_id: 
            self.c_src.blockSignals(False)
            self._refresh_batches_and_destinations()
            return
        
        locations = self.db.get_item_locations_with_stock(item_id, exclude_warehouses=['Production'])
        
        if not locations:
            self.c_src.addItem("کالا در انبارهای غیرتولید موجودی ندارد!", -1)
        else:
            for loc in locations:
                self.c_src.addItem(f"{loc['loc_label']} (موجودی کل: {loc['qty']})", loc['id'])
        
        self.c_src.blockSignals(False)
        self._refresh_batches_and_destinations()

    def _refresh_batches_and_destinations(self):
        """بچ‌های موجود در لوکیشن مبدا و همچنین مقصدهای مجاز را رفرش می‌کند."""
        # رفرش کردن بچ‌ها
        self.c_batch.blockSignals(True)
        self.c_batch.clear()
        
        item_data = self.c_item.currentData()
        src_loc_id = self.c_src.currentData()
        
        if isinstance(item_data, dict) and src_loc_id not in [None, -1]:
            item_id = item_data.get('id')
            available_batches = self.db.get_batches_in_location(item_id, src_loc_id)
            if available_batches:
                for batch in available_batches:
                    display_text = (f"بچ: {batch['batch_no']} | "
                                    f"انقضا: {self._g2j(batch.get('expiry_date'))} | "
                                    f"موجودی: {batch['qty']}")
                    self.c_batch.addItem(display_text, batch)
        self.c_batch.blockSignals(False)

        # رفرش کردن مقصدها
        self.c_dst.clear()
        all_locations = self.db.list_locations_excluding_warehouse('Production')
        for loc in all_locations:
            if loc['id'] != src_loc_id:
                self.c_dst.addItem(loc['loc_label'], loc['id'])

    def _do_transfer(self):
        """عملیات انتقال را با اطلاعات کامل بچ و تاریخ انقضا انجام می‌دهد."""
        try:
            qty = float(self.e_qty.text())
            if qty <= 0: raise ValueError
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, 'خطا', 'مقدار وارد شده صحیح نیست.'); return

        item_data = self.c_item.currentData()
        src_id = self.c_src.currentData()
        dst_id = self.c_dst.currentData()
        batch_data = self.c_batch.currentData()

        if not isinstance(item_data, dict) or src_id in [None, -1] or dst_id is None or not isinstance(batch_data, dict):
            QtWidgets.QMessageBox.warning(self, 'خطا', 'لطفاً تمام فیلدها (کالا، مبدا، بچ و مقصد) را به درستی انتخاب کنید.'); return

        if src_id == dst_id:
            QtWidgets.QMessageBox.warning(self, 'خطا', 'مبدا و مقصد نمی‌توانند یکسان باشند.'); return

        if qty > batch_data.get('qty', 0):
            QtWidgets.QMessageBox.warning(self, 'خطای موجودی', f"مقدار درخواستی ({qty}) از موجودی این بچ ({batch_data.get('qty', 0)}) بیشتر است."); return
            
        try:
            # فراخوانی تابع transfer با تمام پارامترهای لازم
            self.db.transfer(
                item_id=item_data['id'], 
                qty=qty,
                src_loc_id=src_id, 
                dest_loc_id=dst_id, 
                user_id=self.user_id, 
                notes=self.e_notes.text().strip(), 
                batch_no=batch_data['batch_no'],
                expiry_date=batch_data.get('expiry_date')
            )
            
            toast = getattr(self.parent(), 'toast', None)
            if toast:
                toast.show_message("✔ انتقال داخلی با موفقیت ثبت شد.", "success")
            self.accept()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای پیش‌بینی نشده", f"خطا در هنگام ثبت انتقال:\n{e}")
            
                                                
# کل کلاس TransactionDialog را با این نسخه نهایی جایگزین کنید

class TransactionDialog(QtWidgets.QDialog):
    """
    نسخه نهایی و یکپارچه (V4.4)
    - در حالت ورود، به انباردار اجازه می‌دهد برای کالا وضعیت اولیه (تایید شده یا قرنطینه) را تعیین کند.
    """
    transaction_data_ready = QtCore.pyqtSignal(dict)

    def __init__(self, db: DB, user_id: int, t_type: str, parent=None, item_id=None):
        super().__init__(parent)
        self.db, self.user_id, self.t_type = db, user_id, t_type

        self.setWindowTitle(f'ثبت {self.t_type}')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(600)

        form = QtWidgets.QFormLayout(self); form.setSpacing(10)

        self.c_item = QtWidgets.QComboBox(); self.c_item.setEditable(True); self.c_item.setCompleter(QtWidgets.QCompleter(self.c_item.model()))
        form.addRow('کالا:', self.c_item)

        self.mode_stack = QtWidgets.QStackedWidget()
        form.addRow(self.mode_stack)

        # --- پنل خروج (بدون تغییر) ---
        exit_widget = QtWidgets.QWidget(); exit_layout = QtWidgets.QFormLayout(exit_widget); exit_layout.setContentsMargins(0,0,0,0)
        self.c_stock_record = QtWidgets.QComboBox()
        self.c_stock_record.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        exit_layout.addRow("انتخاب موجودی (انبار/بچ/انقضا):", self.c_stock_record)
        self.mode_stack.addWidget(exit_widget)

        # --- پنل ورود (با فیلد جدید) ---
        entry_widget = QtWidgets.QWidget(); entry_layout = QtWidgets.QFormLayout(entry_widget); entry_layout.setContentsMargins(0,0,0,0)
        self.c_loc_entry = QtWidgets.QComboBox()
        self.c_batch_entry = QtWidgets.QComboBox(); self.c_batch_entry.setEditable(True); self.c_batch_entry.setCompleter(None)
        self.expiry_date_edit = QtWidgets.QLineEdit(); self.expiry_date_edit.setInputMask("0000/00/00;_"); self.expiry_date_edit.setPlaceholderText("اختیاری")

        # --- ویجت جدید و کلیدی برای تصمیم‌گیری QC ---
        self.requires_qc_check = QtWidgets.QCheckBox("ارسال به کنترل کیفی (قرنطینه شود)")

        entry_layout.addRow("به لوکیشن:", self.c_loc_entry)
        entry_layout.addRow("شماره بچ:", self.c_batch_entry)
        entry_layout.addRow("تاریخ انقضا:", self.expiry_date_edit)
        entry_layout.addRow("", self.requires_qc_check) # <<-- اضافه شده به فرم
        self.mode_stack.addWidget(entry_widget)

        self.e_no = QtWidgets.QLineEdit(); self.e_qty = QtWidgets.QLineEdit(); self.e_qty.setValidator(QtGui.QDoubleValidator(0.001, 1e12, 3)); self.e_note = QtWidgets.QLineEdit()
        form.addRow('شماره سند:', self.e_no); form.addRow('مقدار:', self.e_qty); form.addRow('توضیحات:', self.e_note)

        self.btn_ok = QtWidgets.QPushButton(f'ثبت {self.t_type}'); self.btn_ok.setProperty("class", "primary")
        form.addRow(self.btn_ok)

        self.c_item.currentIndexChanged.connect(self._refresh_data_for_item)
        self.c_loc_entry.currentIndexChanged.connect(self._refresh_entry_batches)
        self.c_stock_record.currentIndexChanged.connect(self._on_stock_record_change)
        self.btn_ok.clicked.connect(self._save)

        self._populate_items()
        if item_id: self._select_preselected_item(item_id)

    def _refresh_data_for_item(self):
        is_entry = self.t_type.startswith('ورود') or self.t_type == 'برگشت'
        self.mode_stack.setCurrentIndex(1 if is_entry else 0)
        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict): self.btn_ok.setEnabled(False); return
        item_id = item_data.get('id');
        if not item_id: self.btn_ok.setEnabled(False); return

        # --- بخش جدید و کلیدی برای تنظیم پیش‌فرض چک‌باکس QC ---
        if is_entry:
            item_details = self.db.get_item_details(item_id)
            if item_details:
                self.requires_qc_check.setChecked(item_details.get('requires_qc', True))

        self.c_stock_record.blockSignals(True); self.c_stock_record.clear(); stock_records = self.db.stock_breakdown(item_id)
        if not stock_records: self.c_stock_record.addItem("این کالا در انبار موجودی ندارد!", None)
        else:
            for rec in stock_records:
                expiry_str = to_shamsi(rec['expiry_date']) if rec['expiry_date'] else 'ندارد'
                display_text = f"{rec['loc']} | بچ: {rec['batch_no']} | انقضا: {expiry_str} (موجودی: {rec['qty']})"; self.c_stock_record.addItem(display_text, rec)
        self.c_stock_record.blockSignals(False)

        self.c_loc_entry.blockSignals(True); self.c_loc_entry.clear(); locations = self.db.list_locations(exclude_warehouses=['Production'])
        for loc in locations: self.c_loc_entry.addItem(loc['loc_label'], loc['id'])
        self.c_loc_entry.blockSignals(False)

        if is_entry: self._refresh_entry_batches(); self.btn_ok.setEnabled(True)
        else: self._on_stock_record_change()

    def _save(self):
        doc_no = self.e_no.text().strip()
        if not doc_no: QtWidgets.QMessageBox.warning(self, 'اطلاعات ناقص', 'وارد کردن «شماره سند» اجباری است.'); return
        try:
            qty = float(self.e_qty.text().strip());
            if qty <= 0: raise ValueError
        except (ValueError, TypeError): QtWidgets.QMessageBox.warning(self, 'خطا', 'مقدار وارد شده صحیح نیست.'); return
        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict): QtWidgets.QMessageBox.warning(self, 'خطا', 'کالای انتخاب شده معتبر نیست.'); return
        is_entry = self.t_type.startswith('ورود') or self.t_type == 'برگشت'; expiry_date_obj = None
        if is_entry:
            loc_id = self.c_loc_entry.currentData(); batch_no = self.c_batch_entry.currentText().strip(); expiry_date_str = self.expiry_date_edit.text().strip()
            if expiry_date_str and '_' not in expiry_date_str:
                try: expiry_date_obj = jd.date(*map(int, expiry_date_str.split('/'))).togregorian()
                except: QtWidgets.QMessageBox.warning(self, 'خطا', 'فرمت تاریخ انقضا نامعتبر است.'); return
            is_consistent, existing_date = self.db.check_batch_expiry_consistency(item_data.get('id'), batch_no, expiry_date_obj)
            if not is_consistent: QtWidgets.QMessageBox.critical(self, "خطای یکپارچگی داده", f"<b>مغایرت در تاریخ انقضا!</b><br><br>بچ «{batch_no}» قبلاً با تاریخ <b>{to_shamsi(existing_date)}</b> ثبت شده است."); return
        else:
            stock_data = self.c_stock_record.currentData()
            if stock_data is None: QtWidgets.QMessageBox.warning(self, 'خطا', 'لطفاً یک ردیف موجودی معتبر برای خروج انتخاب کنید.'); return
            if qty > stock_data.get('qty', 0): QtWidgets.QMessageBox.warning(self, 'خطای موجودی', f"مقدار درخواستی ({qty}) از موجودی بچ انتخابی ({stock_data.get('qty', 0)}) بیشتر است."); return
            loc_id = stock_data['loc_id']; batch_no = stock_data['batch_no']; expiry_date_obj = stock_data.get('expiry_date')
        if not batch_no: QtWidgets.QMessageBox.warning(self, 'خطا', 'شماره بچ نمی‌تواند خالی باشد.'); return
        if not loc_id: QtWidgets.QMessageBox.warning(self, 'خطا', 'لوکیشن معتبر نیست.'); return

        data_to_emit = {
            't_type': self.t_type, 'item_id': item_data.get('id'), 'loc_id': loc_id,
            'qty': qty, 'batch_no': batch_no, 'expiry_date': expiry_date_obj,
            'doc_no': doc_no, 'notes': self.e_note.text().strip(),
            'requires_qc': self.requires_qc_check.isChecked() if is_entry else False
        }
        self.transaction_data_ready.emit(data_to_emit)
        self.accept()

    def _on_stock_record_change(self):
        """با تغییر انتخاب در لیست موجودی، دکمه ثبت را فعال/غیرفعال می‌کند."""
        # --- FIX: روش ساده و مطمئن برای فعال‌سازی دکمه ---
        # اگر متن آیتم انتخاب شده شامل عبارت "موجودی ندارد" باشد، یعنی آیتم نامعتبر است
        is_placeholder = "موجودی ندارد" in self.c_stock_record.currentText()
        self.btn_ok.setEnabled(not is_placeholder)

# در کلاس TransactionDialog، این متد را جایگزین کنید

    def _populate_items(self):
        self.c_item.blockSignals(True)
        self.c_item.clear()

        model = QtGui.QStandardItemModel()
        
        # --- اصلاح کلیدی: فراخوانی متد جدید و صحیح ---
        all_items = self.db.get_all_items_for_selection()

        items_by_id = {item['id']: dict(item) for item in all_items}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id:
                if parent_id not in child_map:
                    child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)

        root_node = model.invisibleRootItem()
        for item_data in top_level_items:
            parent_node = QtGui.QStandardItem(item_data.get('name', ''))
            parent_node.setData(item_data, Qt.UserRole)
            is_parent = item_data.get('is_parent_product')
            parent_node.setFlags(parent_node.flags() & ~Qt.ItemIsSelectable if is_parent else parent_node.flags())
            root_node.appendRow(parent_node)

            if item_data['id'] in child_map:
                for child_data in child_map[item_data['id']]:
                    child_node = QtGui.QStandardItem(f"  └ {child_data.get('name', '')}")
                    child_node.setData(child_data, Qt.UserRole)
                    parent_node.appendRow(child_node)

        self.c_item.setModel(model)
        self.c_item.setView(QtWidgets.QTreeView())
        
        self.c_item.blockSignals(False)
        self._refresh_data_for_item()
                
    def _select_preselected_item(self, item_id):
        for i in range(self.c_item.count()):
            if self.c_item.itemData(i).get('id') == item_id:
                self.c_item.setCurrentIndex(i); return

    def _refresh_data_for_item(self):
        is_entry = self.t_type.startswith('ورود') or self.t_type == 'برگشت'
        self.mode_stack.setCurrentIndex(1 if is_entry else 0)

        item_data = self.c_item.currentData()
        if not isinstance(item_data, dict): 
            self.btn_ok.setEnabled(False) # اگر آیتم معتبر نیست دکمه غیرفعال شود
            return
        item_id = item_data.get('id')
        if not item_id: 
            self.btn_ok.setEnabled(False)
            return

        # حالت خروج
        self.c_stock_record.blockSignals(True)
        self.c_stock_record.clear()
        stock_records = self.db.stock_breakdown(item_id)
        if not stock_records:
            self.c_stock_record.addItem("این کالا در انبار موجودی ندارد!", None)
        else:
            for rec in stock_records:
                expiry_str = to_shamsi(rec['expiry_date']) if rec['expiry_date'] else 'ندارد'
                display_text = f"{rec['loc']} | بچ: {rec['batch_no']} | انقضا: {expiry_str} (موجودی: {rec['qty']})"
                self.c_stock_record.addItem(display_text, rec)
        self.c_stock_record.blockSignals(False)
        
        # حالت ورود
        self.c_loc_entry.blockSignals(True)
        self.c_loc_entry.clear()
        locations = self.db.list_locations(exclude_warehouses=['Production'])
        for loc in locations: self.c_loc_entry.addItem(loc['loc_label'], loc['id'])
        self.c_loc_entry.blockSignals(False)
        
        # فراخوانی متدهای آپدیت ثانویه
        if is_entry:
            self._refresh_entry_batches()
            self.btn_ok.setEnabled(True) # در حالت ورود دکمه همیشه فعال است
        else:
            self._on_stock_record_change()

    def _refresh_entry_batches(self):
        self.c_batch_entry.clear()
        item_data = self.c_item.currentData()
        loc_id = self.c_loc_entry.currentData()
        if not isinstance(item_data, dict) or loc_id is None: return

        item_id = item_data.get('id')
        query = "SELECT DISTINCT batch_no FROM stock WHERE item_id = %s AND location_id = %s AND qty > 0"
        batches_in_loc = self.db.execute_query(query, (item_id, loc_id))
        for batch in batches_in_loc:
            self.c_batch_entry.addItem(batch['batch_no'])
            

                                        
# این کلاس کاملاً جدید را به فایل کد خود اضافه کنید

class AddStockRowDialog(QtWidgets.QDialog):
    """یک دیالوگ کمکی برای افزودن ردیف موجودی اولیه به پنجره تعریف کالا."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن ردیف موجودی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.loc_combo = QtWidgets.QComboBox()
        self.batch_edit = QtWidgets.QLineEdit()
        self.qty_edit = QtWidgets.QLineEdit()
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 1e9, 3))
        self.expiry_edit = QtWidgets.QLineEdit()
        self.expiry_edit.setInputMask("0000/00/00;_")
        self.expiry_edit.setPlaceholderText("اختیاری: 1404/01/20")

        layout.addRow("لوکیشن:", self.loc_combo)
        layout.addRow("شماره بچ:", self.batch_edit)
        layout.addRow("مقدار:", self.qty_edit)
        layout.addRow("تاریخ انقضا:", self.expiry_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

        # پر کردن لیست لوکیشن‌ها
        for loc in self.db.list_locations(exclude_warehouses=['Production']):
            self.loc_combo.addItem(loc['loc_label'], loc['id'])

    def get_data(self):
        """داده‌های وارد شده توسط کاربر را برمی‌گرداند."""
        if not all([self.loc_combo.currentData(), self.batch_edit.text().strip(), self.qty_edit.text()]):
            return None
            
        try:
            qty = float(self.qty_edit.text())
            if qty <= 0: return None

            expiry_date = None
            date_str = self.expiry_edit.text().strip()
            if date_str and '_' not in date_str:
                y, m, d = map(int, date_str.split('/'))
                expiry_date = jd.date(y, m, d).togregorian()

            return {
                "loc_id": self.loc_combo.currentData(),
                "loc_label": self.loc_combo.currentText(),
                "batch_no": self.batch_edit.text().strip(),
                "qty": qty,
                "expiry_date": expiry_date
            }
        except (ValueError, TypeError):
            return None
        
        
                                                

        
# ------------------------------------------------------------
# کلاس LocationDialog  (اصلاح شده)
# ------------------------------------------------------------
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QTableWidget, QTableWidgetItem,
    QPushButton, QHBoxLayout, QMessageBox, QHeaderView
)
from PyQt5.QtGui import QFont
from PyQt5.QtCore import Qt



import psycopg2.errors # این ایمپورت را در بالای فایل خود اضافه کنید

# کلاس LocationDialog را به طور کامل با این نسخه ساده جایگزین کنید
class LocationDialog(QtWidgets.QDialog):
    """
    مدیریت ساده لوکیشن‌های انبار.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle("مدیریت مکان‌ها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(600, 500)
        main = QtWidgets.QVBoxLayout(self)

        self.tbl = QtWidgets.QTableWidget(0, 5)
        self.tbl.setHorizontalHeaderLabels(["ID", "انبار", "راهرو (Rack)", "قفسه (Shelf)", "طبقه (Bin)"])
        self.tbl.setColumnHidden(0, True)
        self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl.setAlternatingRowColors(True)
        self.tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        main.addWidget(self.tbl, 1)

        form_group = QtWidgets.QGroupBox("افزودن لوکیشن جدید")
        f = QtWidgets.QFormLayout(form_group)
        self.e_wh   = QtWidgets.QLineEdit("Main")
        self.e_rack = QtWidgets.QLineEdit()
        self.e_shelf = QtWidgets.QLineEdit()
        self.e_bin  = QtWidgets.QLineEdit()
        f.addRow("انبار:",  self.e_wh)
        f.addRow("راهرو (Rack):",  self.e_rack)
        f.addRow("قفسه (Shelf):",   self.e_shelf)
        f.addRow("طبقه (Bin):",   self.e_bin)
        main.addWidget(form_group)

        h = QtWidgets.QHBoxLayout()
        btn_add   = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن")
        btn_del   = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف")
        btn_show  = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-information"), " نمایش اقلام")
        h.addWidget(btn_add); h.addWidget(btn_del); h.addWidget(btn_show); h.addStretch()
        main.addLayout(h)

        btn_add.clicked.connect(self._add_loc)
        btn_del.clicked.connect(self._del_loc)
        btn_show.clicked.connect(self._show_items)
        
        self._load()
        
    def _load(self):
        self.tbl.setRowCount(0)
        rows = self.db.list_locations()
        for rec in rows:
            r = self.tbl.rowCount()
            self.tbl.insertRow(r)
            self.tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(str(rec['id'])))
            self.tbl.setItem(r, 1, QtWidgets.QTableWidgetItem(str(rec['wh'])))
            self.tbl.setItem(r, 2, QtWidgets.QTableWidgetItem(str(rec['rack'])))
            self.tbl.setItem(r, 3, QtWidgets.QTableWidgetItem(str(rec['shelf'])))
            self.tbl.setItem(r, 4, QtWidgets.QTableWidgetItem(str(rec['bin'])))

    def _add_loc(self):
        wh    = self.e_wh.text().strip(); rack  = self.e_rack.text().strip()
        shelf = self.e_shelf.text().strip(); bin_  = self.e_bin.text().strip()
        if not all([wh, rack, shelf]):
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", "نام انبار، راهرو و قفسه اجباری است.")
            return
        try:
            wh_id = self.db.add_warehouse(wh)
            self.db.add_location(wh_id, rack, shelf, bin_)
            if self.toast: self.toast.show_message("✔ لوکیشن جدید با موفقیت ثبت شد.", "success")
            self._load()
            self.e_rack.clear(); self.e_shelf.clear(); self.e_bin.clear(); self.e_rack.setFocus()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت لوکیشن:\n{e}")

    def _del_loc(self):
        row = self.tbl.currentRow()
        if row < 0: return
        loc_id = int(self.tbl.item(row, 0).text())
        if len(self.db.items_in_location(loc_id)) > 0:
            QtWidgets.QMessageBox.warning(self, "خطا", "این مکان حاوی کالا است و قابل حذف نیست.")
            return
        if QtWidgets.QMessageBox.question(self, "تایید حذف", "آیا از حذف مطمئنید؟") == QtWidgets.QMessageBox.Yes:
             # self.db.delete_location(loc_id) # متد حذف هنوز پیاده‌سازی نشده
            self.toast.show_message("قابلیت حذف در دست ساخت است.", "info")
            self._load()

    def _show_items(self):
        row = self.tbl.currentRow()
        if row < 0: return
        loc_id = int(self.tbl.item(row, 0).text())
        StockAtLocationDialog(self.db, loc_id).exec_()
                



        
class HeatMapDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent); self.db = db
        self.setWindowTitle('Heat-Map ظرفیت رک‌ها')
        self.resize(420, 320)

        loads = db.rack_loads()
        if not loads:
            QtWidgets.QLabel('داده‌ای نیست', self).show(); return

        v = QtWidgets.QVBoxLayout(self)

        # ـــــــ آماده‌سازی داده ـــــــ
        labels = [fa(l['loc']) for l in loads]     # ← عبور از تابع rtl
        vals   = [l['load'] for l in loads]
        colors = ['#c62828' if v > 80 else '#f9a825' if v > 50 else '#2e7d32'
                  for v in vals]

        # ـــــــ نمودار ـــــــ
        fig, ax = plt.subplots(figsize=(4, 3), dpi=100)
        ax.barh(labels, vals, color=colors)
        ax.set_xlabel(fa('واحد'))
        ax.set_title(fa('بار رک‌ها (ظرفیت فرضی ۱۰۰)'))
        ax.tick_params(axis='y', labelsize=9)

        fig.tight_layout()
        v.addWidget(Canvas(fig))
        
# این کلاس جدید را به ابتدای فایل اضافه کنید
class ClickableFrame(QtWidgets.QFrame):
    """یک QFrame که سیگنال کلیک شدن دارد"""
    clicked = QtCore.pyqtSignal()
    def mouseReleaseEvent(self, event):
        if self.rect().contains(event.pos()):
            self.clicked.emit()
        super().mouseReleaseEvent(event)


    
# کل کلاس Pie را با این نسخه جایگزین کنید
class Pie(Canvas):
    """Pie chart فارسی‌شده با ظاهر بهبودیافته و خوانایی بالا"""
    def __init__(self, data, click_cb):
        fig, ax = plt.subplots(figsize=(5, 5), dpi=90, constrained_layout=True)

        labels = [fa(d[0]) for d in data]
        sizes  = [d[1] for d in data]
        colors = plt.cm.Pastel2(range(len(sizes)))

        wedges, texts, autotexts = ax.pie(
            sizes,
            labels=labels,
            autopct='%1.1f%%',
            startangle=90,
            pctdistance=0.85,
            colors=colors,
            wedgeprops=dict(width=0.4, edgecolor='w')
        )
        
        plt.setp(texts, size=10, weight="bold", color="#34495e")
        # اصلاح‌شده: تغییر رنگ و اندازه فونت درصدها
        plt.setp(autotexts, size=10, weight="bold", color="#2c3e50")

        ax.axis('equal')
        
        for w in wedges:
            w.set_picker(True)

        super().__init__(fig)
        self.mpl_connect('pick_event', lambda ev: click_cb(ev.artist.get_label()) if ev.artist else None)
        
class AttachMultipleFilesDialog(QtWidgets.QDialog):
    """دیالوگی برای مدیریت (افزودن/حذف/مشاهده) چندین فایل پیوست."""
    def __init__(self, initial_files: list, parent=None):
        super().__init__(parent)
        self.setWindowTitle("مدیریت پیوست‌ها")
        self.setMinimumSize(450, 300)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        self.file_list = initial_files.copy() if initial_files else []

        layout = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.itemDoubleClicked.connect(lambda item: QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(item.data(Qt.UserRole))))
        layout.addWidget(self.list_widget)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن فایل")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف فایل انتخاب شده")
        btn_layout.addWidget(btn_add)
        btn_layout.addWidget(btn_del)
        layout.addLayout(btn_layout)

        dialog_buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        dialog_buttons.accepted.connect(self.accept)
        dialog_buttons.rejected.connect(self.reject)
        layout.addWidget(dialog_buttons)

        btn_add.clicked.connect(self._add_files)
        btn_del.clicked.connect(self._remove_file)
        
        self._refresh_list()

    def _refresh_list(self):
        self.list_widget.clear()
        for f_path in self.file_list:
            item = QtWidgets.QListWidgetItem(QtGui.QIcon.fromTheme("document-properties"), Path(f_path).name)
            item.setData(Qt.UserRole, f_path)
            self.list_widget.addItem(item)
    
    def _add_files(self):
        paths, _ = QtWidgets.QFileDialog.getOpenFileNames(self, "انتخاب یک یا چند فایل")
        if paths:
            for path in paths:
                if path not in self.file_list:
                    self.file_list.append(path)
            self._refresh_list()

    def _remove_file(self):
        selected_items = self.list_widget.selectedItems()
        if not selected_items: return
        
        file_to_remove = selected_items[0].data(Qt.UserRole)
        if file_to_remove in self.file_list:
            self.file_list.remove(file_to_remove)
        self._refresh_list()

    def get_final_files(self):
        return self.file_list
                        
class FormsPage(QtWidgets.QWidget):
    """
    نسخه نهایی (V12.0): این صفحه حالا فقط فرم‌های عمومی (GENERAL) را مدیریت می‌کند.
    """
    def __init__(self, db: DB, usr: str, viewer: bool, main_window, parent=None):
        super().__init__(parent)
        self.db, self.usr, self.viewer, self.main_window = db, usr, viewer, main_window
        self.user_id = self.main_window.user_id
        self.user_role = self.main_window.role
        self._is_programmatically_changing = False
        self.last_edited_row = -1

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.addWidget(QtWidgets.QLabel("فرم‌های عمومی شما", objectName="subtitleLabel"))
        self.lst_defs = QtWidgets.QListWidget()
        self.lst_defs.itemSelectionChanged.connect(self._on_form_selected)
        right_layout.addWidget(self.lst_defs)
        form_actions_layout = QtWidgets.QHBoxLayout()
        btn_new_def = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " فرم جدید"); btn_new_def.setProperty("class", "primary")
        btn_del_def = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف فرم"); btn_del_def.setProperty("class", "danger")
        btn_new_def.clicked.connect(self._add_form_def)
        btn_del_def.clicked.connect(self._delete_form_def)
        form_actions_layout.addWidget(btn_new_def); form_actions_layout.addWidget(btn_del_def)
        right_layout.addLayout(form_actions_layout)
        splitter.addWidget(right_panel)

        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.entries_title = QtWidgets.QLabel("رکوردهای ثبت شده", objectName="subtitleLabel"); left_layout.addWidget(self.entries_title)
        action_bar = QtWidgets.QHBoxLayout()
        self.btn_new_entry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " ثبت رکورد جدید"); self.btn_new_entry.clicked.connect(self._new_entry)
        btn_del_entry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف رکوردهای انتخابی"); btn_del_entry.clicked.connect(self._delete_entry)
        action_bar.addWidget(self.btn_new_entry)
        action_bar.addStretch()
        action_bar.addWidget(btn_del_entry)
        left_layout.addLayout(action_bar)

        self.tbl_entries = QtWidgets.QTableWidget()
        self.tbl_entries.currentItemChanged.connect(self._on_current_item_changed)
        add_filter_export_tools(self.tbl_entries, left_layout)
        left_layout.addWidget(self.tbl_entries, 1)
        splitter.addWidget(left_panel)
        splitter.setSizes([250, 750])
        self._refresh_form_defs()

    def _refresh_form_defs(self):
        self.lst_defs.clear(); self.tbl_entries.setRowCount(0); self.btn_new_entry.setDisabled(False)
        forms = self.db.list_form_defs_by_type(form_type='GENERAL', user_id=self.user_id, is_admin=(self.user_role == 'Admin'))
        for fd in forms:
            item = QtWidgets.QListWidgetItem(fd['name'])
            item.setData(Qt.UserRole, fd['id'])
            self.lst_defs.addItem(item)
        if self.lst_defs.count() > 0:
            self.lst_defs.setCurrentRow(0)
        else:
            self.entries_title.setText("رکوردهای ثبت شده")
    
    # <<< FIX
    def _add_form_def(self):
        # دسترسی: ساخت فرم فقط برای کاربرانی که مجوز صفحهٔ فرم‌ها را دارند
        if not self.main_window.has_permission('page:view:forms'):
            self.main_window.toast.show_message("شما دسترسی لازم برای ایجاد فرم جدید را ندارید.", "error")
            return

        # نکته مهم: نوع پیش‌فرض باید GENERAL باشد
        dlg = AdvancedFormBuilderDialog(
            self.db,
            self.user_id,
            form_id=None,
            default_form_type='GENERAL',
            parent=self.main_window  # برای اینکه toast داخل دیالوگ هم کار کند
        )

        if dlg.exec_():
            # قبلاً self.toast بود که در این کلاس تعریف نشده و خطا می‌داد
            self.main_window.toast.show_message("✔ فرم عمومی جدید با موفقیت تعریف شد.", "success")
            self._refresh_form_defs()
                                        
    def _load_entries(self):
        # این متد از قبل اصلاح شده و صحیح است
        selected = self.lst_defs.selectedItems()
        self.tbl_entries.blockSignals(True)
        self.tbl_entries.clear(); self.tbl_entries.setRowCount(0)
        if not selected:
            self.entries_title.setText("رکوردهای ثبت شده"); self.tbl_entries.setColumnCount(0); self.tbl_entries.blockSignals(False); return
        form_id = selected[0].data(Qt.UserRole); form_name = selected[0].text()
        self.entries_title.setText(f"رکوردهای فرم: {form_name}")
        flds = self.db.get_form_fields(form_id)
        base_query = "SELECT e.*, u.username FROM form_entries e LEFT JOIN users u ON e.user_id = u.id WHERE e.form_id=%s"
        params = [form_id]
        if self.user_role != 'Admin':
            base_query += " AND e.user_id = %s"
            params.append(self.user_id)
        base_query += " ORDER BY e.id DESC"
        entries = self.db.execute_query(base_query, tuple(params))
        headers = [f['label'] for f in flds] + ['عملیات / کاربر', 'تاریخ ثبت', 'ID']
        self.tbl_entries.setColumnCount(len(headers)); self.tbl_entries.setHorizontalHeaderLabels(headers)
        self.tbl_entries.setColumnHidden(len(headers) - 1, True); self.tbl_entries.setRowCount(len(entries))
        for r, rec in enumerate(entries):
            raw_data = rec.get('data'); data_dict = json.loads(raw_data) if isinstance(raw_data, str) else (raw_data or {});
            data_dict['username'] = rec.get('username', 'نامشخص'); data_dict['timestamp'] = to_shamsi(rec['ts']); data_dict['entry_id'] = rec['id']
            self._populate_row(r, flds, data_dict, is_new_unsaved_row=False)
        header = self.tbl_entries.horizontalHeader();
        for i in range(len(headers)): header.setSectionResizeMode(i, QtWidgets.QHeaderView.Stretch if i < len(flds) else QtWidgets.QHeaderView.ResizeToContents)
        self.tbl_entries.resizeRowsToContents(); self.tbl_entries.blockSignals(False)


    def _populate_row(self, row_idx, flds, data_dict={}, is_new_unsaved_row=False):
            """
            نسخه نهایی: با استفاده از functools.partial مشکل اتصال دکمه پیوست را حل می‌کند.
            و سیگنال ذخیره‌سازی را برای فیلد تاریخ مجدداً فعال می‌کند.
            """
            from functools import partial

            self._is_programmatically_changing = True
            
            for c, fld in enumerate(flds):
                field_type, field_label = fld.get('type'), fld.get('label')
                value = data_dict.get(field_label, '')
                if field_type in ['date', 'file']:
                    container = QtWidgets.QWidget(); layout = QtWidgets.QHBoxLayout(container); layout.setContentsMargins(0,0,0,0)
                    if field_type == 'date':
                        widget = QtWidgets.QLineEdit(str(value)); widget.setInputMask("0000/00/00;_"); widget.setAlignment(Qt.AlignCenter)
                        # --- اصلاح کلیدی: اتصال مجدد سیگنال برای ذخیره تاریخ ---
                        widget.editingFinished.connect(partial(self._commit_row_data, row_idx))
                    elif field_type == 'file':
                        file_list = value if isinstance(value, list) else []; btn_text = f"پیوست‌ها ({len(file_list)})"
                        widget = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-attachment"), btn_text)
                        widget.setProperty("file_paths", file_list); widget.setProperty("class", "cell-button")
                        # --- اصلاح کلیدی: استفاده از partial برای اتصال ۱۰۰٪ صحیح ---
                        widget.clicked.connect(partial(self._open_multi_file_dialog, row_idx, c))
                    layout.addWidget(widget); self.tbl_entries.setCellWidget(row_idx, c, container)
                else:
                    self.tbl_entries.setItem(row_idx, c, QtWidgets.QTableWidgetItem(str(value)))
            
            user_col_idx = len(flds)
            if is_new_unsaved_row:
                container = QtWidgets.QWidget(); layout = QtWidgets.QHBoxLayout(container)
                layout.setContentsMargins(2, 2, 2, 2); layout.setAlignment(QtCore.Qt.AlignCenter)
                btn_commit = QtWidgets.QPushButton("✔ ثبت"); btn_commit.setProperty("class", "primary")
                btn_commit.setStyleSheet("font-size: 9pt; padding: 2px 6px;");
                btn_commit.clicked.connect(partial(self._commit_row_data, row_idx))
                layout.addWidget(btn_commit); self.tbl_entries.setCellWidget(row_idx, user_col_idx, container)
                self.tbl_entries.setItem(row_idx, user_col_idx + 1, QtWidgets.QTableWidgetItem("")); self.tbl_entries.setItem(row_idx, user_col_idx + 2, QtWidgets.QTableWidgetItem(""))
            else:
                self.tbl_entries.removeCellWidget(row_idx, user_col_idx)
                self.tbl_entries.setItem(row_idx, user_col_idx, QtWidgets.QTableWidgetItem(data_dict.get('username', '')))
                self.tbl_entries.setItem(row_idx, user_col_idx + 1, QtWidgets.QTableWidgetItem(data_dict.get('timestamp', '')))
                self.tbl_entries.setItem(row_idx, user_col_idx + 2, QtWidgets.QTableWidgetItem(str(data_dict.get('entry_id', ''))))

            self._is_programmatically_changing = False
        
    def _on_current_item_changed(self, current, previous):
        if self._is_programmatically_changing or not previous:
            return
        id_col_idx = self.tbl_entries.columnCount() - 1
        id_item = self.tbl_entries.item(previous.row(), id_col_idx)
        if id_item and id_item.text() == "":
             return
        if current is None or previous.row() != current.row():
            self._commit_row_data(previous.row())

    def _on_form_selected(self):
        if self.last_edited_row != -1:
            self._commit_row_data(self.last_edited_row)
            self.last_edited_row = -1
        self._load_entries()
        
    def _commit_row_data(self, row):
        if row < 0: return
        try:
            form_id_item = self.lst_defs.currentItem()
            if not form_id_item: return
            form_id = form_id_item.data(Qt.UserRole)
            
            flds = self.db.get_form_fields(form_id)
            if self.tbl_entries.columnCount() == 0: return

            id_col_idx = len(flds) + 2
            id_item = self.tbl_entries.item(row, id_col_idx)
            entry_id = int(id_item.text()) if id_item and id_item.text().isdigit() else None
            
            data_to_save = {}
            is_row_empty = True
            for c, fld in enumerate(flds):
                field_label, field_type, value = fld['label'], fld['type'], ""
                widget = self.tbl_entries.cellWidget(row, c)
                if widget:
                    inner_widget = widget.layout().itemAt(0).widget()
                    value = inner_widget.property("file_paths") or [] if field_type == 'file' else inner_widget.text()
                else:
                    item = self.tbl_entries.item(row, c)
                    value = item.text() if item else ""
                
                data_to_save[field_label] = value
                if value or value == 0:
                    if str(value).strip() and value != []:
                        is_row_empty = False
            
            if is_row_empty and not entry_id:
                return

            json_data = json.dumps(data_to_save, ensure_ascii=False)
            new_id = self.db.add_or_update_form_entry(form_id, self.user_id, json_data, entry_id)
            
            if not entry_id and new_id:
                rec = self.db.execute_query("SELECT e.*, u.username FROM form_entries e LEFT JOIN users u ON e.user_id = u.id WHERE e.id=%s", (new_id,), fetch_one=True)
                data_dict = rec.get('data') or {}
                data_dict['username'] = rec.get('username', 'نامشخص'); data_dict['timestamp'] = to_shamsi(rec['ts']); data_dict['entry_id'] = rec['id']
                self._populate_row(row, flds, data_dict, is_new_unsaved_row=False)
            
            self.btn_new_entry.setDisabled(False)

        except Exception as e:
            self.main_window.toast.show_message(f"خطا در هنگام ذخیره: {e}", "critical")
            print(f"ERROR during commit: {traceback.format_exc()}")
            self.btn_new_entry.setDisabled(False)
            
                
    def _new_entry(self):
            """یک ردیف جدید و خالی برای ورود اطلاعات با ارتفاع صحیح ایجاد می‌کند."""
            user_col_idx = self.tbl_entries.columnCount() - 3
            if self.tbl_entries.rowCount() > 0 and isinstance(self.tbl_entries.cellWidget(0, user_col_idx), QtWidgets.QWidget):
                self.main_window.toast.show_message("لطفاً ابتدا ردیف جدید فعلی را ثبت کنید.", "info"); return

            selected = self.lst_defs.selectedItems()
            if not selected: self.main_window.toast.show_message("ابتدا یک فرم را از لیست انتخاب کنید.", "warning"); return
            
            flds = self.db.get_form_fields(selected[0].data(Qt.UserRole))
            self.tbl_entries.blockSignals(True)
            self.tbl_entries.insertRow(0)
            
            self._populate_row(0, flds, is_new_unsaved_row=True)
            
            # --- اصلاح کلیدی: تنظیم خودکار ارتفاع برای ردیف جدید ---
            self.tbl_entries.resizeRowsToContents()
            
            self.tbl_entries.blockSignals(False)
            self.tbl_entries.setCurrentCell(0, 0)
            self.btn_new_entry.setDisabled(True)
        
    def _delete_entry(self):
        self._commit_row_data(self.tbl_entries.currentRow())
        selected_items = self.tbl_entries.selectedItems()
        if not selected_items: self.main_window.toast.show_message("لطفاً ابتدا یک یا چند رکورد را برای حذف انتخاب کنید.", "warning"); return
        
        rows_to_delete = sorted(list(set(item.row() for item in selected_items)), reverse=True)
        ids_to_delete = []
        id_col_idx = self.tbl_entries.columnCount() - 1
        
        for row in rows_to_delete:
            id_item = self.tbl_entries.item(row, id_col_idx)
            if not id_item or not id_item.text().isdigit():
                self.tbl_entries.removeRow(row)
                self.btn_new_entry.setDisabled(False) 
                continue
            ids_to_delete.append(int(id_item.text()))
        
        if not ids_to_delete: return

        if QtWidgets.QMessageBox.question(self, 'تایید حذف', f"آیا از حذف {len(ids_to_delete)} رکورد مطمئنید؟") == QtWidgets.QMessageBox.Yes:
            self.db.delete_form_entries_many(ids_to_delete)
            self._load_entries()
            self.main_window.toast.show_message(f"{len(ids_to_delete)} رکورد با موفقیت حذف شد.", "success")
            
    def _open_multi_file_dialog(self, row, col):
        container = self.tbl_entries.cellWidget(row, col)
        if not container: return
        button = container.layout().itemAt(0).widget()
        initial_files = button.property("file_paths") or []
        dlg = AttachMultipleFilesDialog(initial_files, self)
        if dlg.exec_():
            new_files = dlg.get_final_files(); button.setProperty("file_paths", new_files)
            button.setText(f"پیوست‌ها ({len(new_files)})")


    def _delete_form_def(self):
        # --- اصلاح کلیدی: چک کردن دسترسی صحیح ---
        if not self.main_window.has_permission('page:view:forms'): 
            self.main_window.toast.show_message("شما دسترسی لازم برای حذف فرم را ندارید.", "error"); return
        selected = self.lst_defs.selectedItems()
        if not selected: self.main_window.toast.show_message("ابتدا یک فرم را برای حذف انتخاب کنید.", "warning"); return
        fid = selected[0].data(Qt.UserRole)
        if QtWidgets.QMessageBox.question(self, 'تایید حذف', 'کل این فرم و تمام رکوردهای آن برای همیشه حذف شود؟ این عمل غیرقابل بازگشت است.', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No) == QtWidgets.QMessageBox.Yes:
            self.db.delete_form_def(fid); self._refresh_form_defs(); self.main_window.toast.show_message("✔ فرم با موفقیت حذف شد.", "info")

                                                
                        
            
class StockLocationsDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, item_id: int, parent=None):
        super().__init__(parent)
        self.setWindowTitle('مکان‌هاى نگهدارى کالا')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        v = QtWidgets.QVBoxLayout(self)
        tbl = QtWidgets.QTableWidget(); v.addWidget(tbl)
        tbl.setColumnCount(2)
        tbl.setHorizontalHeaderLabels(['لوکیشن', 'مقدار'])
        tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        tbl.horizontalHeader().setDefaultAlignment(Qt.AlignCenter)
        tbl.setStyleSheet("QTableWidget::item{ qproperty-alignment:AlignCenter; }")

        rows = db.stock_breakdown(item_id)
        tbl.setRowCount(len(rows))
        for r, rec in enumerate(rows):
            tbl.setItem(r, 0, QtWidgets.QTableWidgetItem(rec['loc']))
            tbl.setItem(r, 1, QtWidgets.QTableWidgetItem(str(rec['qty'])))
        tbl.resizeColumnsToContents()
        
        
            
class BOMAttachDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, bom_id: int, parent=None):
        super().__init__(parent)
        self.db, self.bom_id = db, bom_id
        self.setWindowTitle('پیوست‌های مصرف')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(380, 320)

        v = QtWidgets.QVBoxLayout(self)
        self.lst = QtWidgets.QListWidget(); v.addWidget(self.lst, 1)

        h = QtWidgets.QHBoxLayout(); v.addLayout(h)
        btn_scan = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("scanner"), " اسکن"); h.addWidget(btn_scan)
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("add"), " افزودن فایل"); h.addWidget(btn_add)
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("delete"), " حذف");   h.addWidget(btn_del)
        h.addStretch()
        btn_close = QtWidgets.QPushButton('بستن');  h.addWidget(btn_close)

        btn_scan.clicked.connect(self._scan_and_add)
        btn_add.clicked.connect(self._add)
        btn_del.clicked.connect(self._delete)
        btn_close.clicked.connect(self.accept)

        self.lst.itemDoubleClicked.connect(
            lambda itm: QtGui.QDesktopServices.openUrl(
                QtCore.QUrl.fromLocalFile(itm.data(Qt.UserRole))))

        self._load()

    def _load(self):
        self.lst.clear()
        for rec in self.db.list_bom_files(self.bom_id):
            itm = QtWidgets.QListWidgetItem(Path(rec['path']).name)
            itm.setData(Qt.UserRole,   rec['path'])
            itm.setData(Qt.UserRole+1, rec['id'])
            self.lst.addItem(itm)

    def _add(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if not path:
            return
        self.db.add_bom_file(self.bom_id, path)
        self._load()

    def _scan_and_add(self):
        scanned_file_path = scan_document(self)
        if scanned_file_path:
            self.db.add_bom_file(self.bom_id, scanned_file_path)
            self._load()

    def _delete(self):
        itm = self.lst.currentItem()
        if not itm: return
        if QtWidgets.QMessageBox.question(self, 'حذف', 'مطمئنید؟') != QtWidgets.QMessageBox.Yes:
            return
        fid = itm.data(Qt.UserRole+1)
        self.db.delete_bom_file(fid)
        self._load()        

# کلاس RecipeManagementDialog را به طور کامل با این نسخه نهایی و اصلاح شده جایگزین کنید

# کلاس RecipeManagementDialog (یا BomManagementDialog) را به طور کامل با این نسخه جایگزین کنید

class RecipeManagementDialog(QtWidgets.QDialog):
    """پنجره جامع مدیریت فرمول‌ها (نسخه نهایی با رفع خطاها)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.current_recipe_data = None
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle("مدیریت جامع فرمول‌های ساخت")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(850, 650)

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel); right_layout.addWidget(QtWidgets.QLabel("<b>لیست محصولات مادر و فرمول‌ها</b>")); self.recipe_search_edit = QtWidgets.QLineEdit(placeholderText="🔍 جستجو..."); right_layout.addWidget(self.recipe_search_edit); self.recipe_tree = QtWidgets.QTreeWidget(); self.recipe_tree.setHeaderHidden(True); right_layout.addWidget(self.recipe_tree); splitter.addWidget(right_panel)
        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel); mode_group = QtWidgets.QGroupBox("نوع تعریف"); mode_layout = QtWidgets.QHBoxLayout(mode_group); self.mode_master = QtWidgets.QRadioButton("دستور ساخت مادر (تعریف نسبت)"); self.mode_component = QtWidgets.QRadioButton("فرمول ساخت جزء (تعریف مواد اولیه)"); mode_layout.addWidget(self.mode_master); mode_layout.addWidget(self.mode_component); left_layout.addWidget(mode_group); self.details_stack = QtWidgets.QStackedWidget(); left_layout.addWidget(self.details_stack, 1);
        self.master_panel = self._create_master_recipe_panel(); self.component_panel = self._create_component_recipe_panel(); self.details_stack.addWidget(self.master_panel); self.details_stack.addWidget(self.component_panel)
        main_btn_layout = QtWidgets.QHBoxLayout(); new_btn = QtWidgets.QPushButton("فرم جدید"); save_btn = QtWidgets.QPushButton("ذخیره/ایجاد نسخه جدید"); save_btn.setProperty("class", "primary"); main_btn_layout.addWidget(new_btn); main_btn_layout.addStretch(); main_btn_layout.addWidget(save_btn); left_layout.addLayout(main_btn_layout); splitter.addWidget(left_panel); splitter.setSizes([300, 550])

        self.recipe_search_edit.textChanged.connect(self._filter_recipe_tree); self.recipe_tree.itemSelectionChanged.connect(self.load_selected_recipe_details); self.mode_master.toggled.connect(lambda checked: self.details_stack.setCurrentIndex(0) if checked else None); self.mode_component.toggled.connect(lambda checked: self.details_stack.setCurrentIndex(1) if checked else None); new_btn.clicked.connect(self.clear_form_for_new); save_btn.clicked.connect(self.save_recipe_version)
        self.comp_parent_product_combo.currentIndexChanged.connect(self._update_component_outputs)
        self.comp_part_type_combo.currentIndexChanged.connect(self._update_component_outputs)
        self._populate_all_parent_product_combos(); self.load_recipe_tree(); self.mode_component.setChecked(True)

    def _create_master_recipe_panel(self):
        panel = QtWidgets.QWidget(); layout = QtWidgets.QFormLayout(panel); layout.setSpacing(15); self.master_parent_product_combo = QtWidgets.QComboBox(); ratio_layout = QtWidgets.QHBoxLayout(); self.ratio_a_spin = QtWidgets.QSpinBox(); self.ratio_a_spin.setRange(0, 1000); self.ratio_b_spin = QtWidgets.QSpinBox(); self.ratio_b_spin.setRange(0, 1000); ratio_layout.addWidget(QtWidgets.QLabel("نسبت پارت A:")); ratio_layout.addWidget(self.ratio_a_spin); ratio_layout.addSpacing(20); ratio_layout.addWidget(QtWidgets.QLabel("به پارت B:")); ratio_layout.addWidget(self.ratio_b_spin); self.master_notes_edit = QtWidgets.QTextEdit(); self.master_product_name_label = QtWidgets.QLabel("<i>نام خودکار</i>"); self.master_product_name_label.setStyleSheet("font-weight:bold;"); self.active_part_a_label = QtWidgets.QLabel("<i>(یافت نشد)</i>"); self.active_part_a_label.setStyleSheet("color: #6c757d;"); self.active_part_b_label = QtWidgets.QLabel("<i>(یافت نشد)</i>"); self.active_part_b_label.setStyleSheet("color: #6c757d;"); layout.addRow("برای محصول مادر (*):", self.master_parent_product_combo); layout.addRow("نام دستور ساخت:", self.master_product_name_label); layout.addRow("نسبت اختلاط (*):", ratio_layout); layout.addRow("فرمول فعال پارت A:", self.active_part_a_label); layout.addRow("فرمول فعال پارت B:", self.active_part_b_label); layout.addRow("توضیحات:", self.master_notes_edit); self.master_parent_product_combo.currentIndexChanged.connect(self._on_master_parent_selected); return panel

    def _create_component_recipe_panel(self):
        panel = QtWidgets.QWidget(); layout = QtWidgets.QVBoxLayout(panel); form_layout = QtWidgets.QFormLayout();
        self.comp_name_edit = QtWidgets.QLineEdit(); self.comp_name_edit.setReadOnly(True); self.comp_name_edit.setStyleSheet("background-color: #e9ecef;")
        self.comp_parent_product_combo = QtWidgets.QComboBox()
        self.comp_part_type_combo = QtWidgets.QComboBox(); self.comp_part_type_combo.addItems(["---", "تک جزئی (پارت P)", "پارت A (رزین)", "پارت B (هاردنر)"])
        self.produces_item_combo = QtWidgets.QComboBox(); self.produces_item_combo.setEnabled(False)
        form_layout.addRow("برای محصول مادر (*):", self.comp_parent_product_combo); form_layout.addRow("نوع پارت (*):", self.comp_part_type_combo); form_layout.addRow("نام فرمول (خودکار):", self.comp_name_edit); form_layout.addRow("محصول خروجی (خودکار):", self.produces_item_combo); layout.addLayout(form_layout)
        layout.addWidget(QtWidgets.QLabel("<b>مواد اولیه تشکیل‌دهنده:</b>")); self.ingredients_table = QtWidgets.QTableWidget(0, 3); self.ingredients_table.setHorizontalHeaderLabels(['ID ماده', 'نام ماده اولیه', 'درصد (%)']); self.ingredients_table.setColumnHidden(0, True); self.ingredients_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch); self.ingredients_table.cellChanged.connect(self._update_sum_label); layout.addWidget(self.ingredients_table); ing_bottom_layout = QtWidgets.QHBoxLayout(); add_ing_btn = QtWidgets.QPushButton("افزودن مواد اولیه..."); remove_ing_btn = QtWidgets.QPushButton("حذف ماده اولیه"); self.sum_label = QtWidgets.QLabel("مجموع درصدها: 0.0%"); self.sum_label.setStyleSheet("font-weight: bold;"); ing_bottom_layout.addWidget(add_ing_btn); ing_bottom_layout.addWidget(remove_ing_btn); ing_bottom_layout.addStretch(); ing_bottom_layout.addWidget(self.sum_label); layout.addLayout(ing_bottom_layout);
        add_ing_btn.clicked.connect(self.add_ingredients); remove_ing_btn.clicked.connect(self.remove_ingredient)
        self.bulk_items_cache = self.db.get_items_by_category('محصول فله'); self.produces_item_combo.addItem("---", None)
        for item in self.bulk_items_cache: self.produces_item_combo.addItem(item['name'], item['id'])
        return panel

# در کلاس RecipeManagementDialog، این متد را به طور کامل جایگزین کنید

    def save_recipe_version(self):
        recipe_id_to_revise = self.current_recipe_data['id'] if self.current_recipe_data and self.current_recipe_data.get('status') == 'ACTIVE' else None
        recipe_data = {}
        
        if self.mode_master.isChecked():
            parent_id = self.master_parent_product_combo.currentData()
            if not parent_id:
                QtWidgets.QMessageBox.warning(self, "خطا", "انتخاب محصول مادر الزامی است."); return
            recipe_data = {
                "product_name": f"دستور ساخت اصلی - {self.master_parent_product_combo.currentText()}", "part_type": "MASTER",
                "parent_product_id": parent_id, "notes": self.master_notes_edit.toPlainText(),
                "properties": {"mix_ratio": {"A": self.ratio_a_spin.value(), "B": self.ratio_b_spin.value()}},
                "yield_percentage": 100.0, "produces_item_id": None, "version": 1
            }
            ingredients_for_db = []
        else:
            parent_data = self.comp_parent_product_combo.currentData(); part_type_index = self.comp_part_type_combo.currentIndex(); produces_item_id = self.produces_item_combo.currentData()
            if not isinstance(parent_data, dict) or not parent_data.get('id'):
                QtWidgets.QMessageBox.warning(self, "خطا", "فیلد ستاره‌دار «برای محصول مادر» باید پر شود."); return
            if part_type_index == 0:
                QtWidgets.QMessageBox.warning(self, "خطا", "فیلد ستاره‌دار «نوع پارت» باید انتخاب شود."); return
            if not produces_item_id:
                QtWidgets.QMessageBox.warning(self, "خطا", "فیلد «محصول خروجی» باید انتخاب شود."); return
            
            # --- *** گام ۱: خواندن اطلاعات کامل از جدول (شامل نام برای پیام خطا) *** ---
            ingredients_with_names = []
            for r in range(self.ingredients_table.rowCount()):
                try:
                    item_id = int(self.ingredients_table.item(r, 0).text())
                    item_name = self.ingredients_table.item(r, 1).text()
                    percentage = float(self.ingredients_table.item(r, 2).text())
                    ingredients_with_names.append({'item_id': item_id, 'name': item_name, 'percentage': percentage})
                except (ValueError, TypeError, AttributeError):
                    QtWidgets.QMessageBox.warning(self, "خطای داده", f"داده‌های نامعتبر در ردیف {r+1} جدول مواد اولیه وجود دارد."); return
            
            if not ingredients_with_names:
                QtWidgets.QMessageBox.warning(self, "خطا", "یک فرمول باید حداقل شامل یک ماده اولیه باشد."); return
            
            total = sum(ing['percentage'] for ing in ingredients_with_names)
            if abs(total - 100.0) > 0.01 and total != 0:
                QtWidgets.QMessageBox.warning(self, "خطا", "مجموع درصد مواد اولیه باید ۱۰۰ باشد."); return

            # --- *** گام ۲: اعتبارسنجی پیش از ذخیره‌سازی *** ---
            ingredient_ids_to_check = [ing['item_id'] for ing in ingredients_with_names]
            missing_ids = self.db.validate_item_ids(ingredient_ids_to_check)
            if missing_ids:
                missing_names = [ing['name'] for ing in ingredients_with_names if ing['item_id'] in missing_ids]
                error_msg = f"عملیات ذخیره متوقف شد زیرا یک یا چند ماده اولیه دیگر در سیستم موجود نیستند:\n\n - {', '.join(missing_names)}\n\n لطفاً این موارد را از لیست حذف کرده و دوباره تلاش کنید."
                QtWidgets.QMessageBox.critical(self, "خطای یکپارچگی داده", error_msg)
                return
            # --- *************************************** ---

            part_map = {1: 'P', 2: 'A', 3: 'B'}; part_type = part_map.get(part_type_index)
            recipe_data = {
                "product_name": self.comp_name_edit.text().strip(), "part_type": part_type, "parent_product_id": parent_data.get('id'),
                "produces_item_id": produces_item_id, "yield_percentage": 100.0, "notes": "", "properties": {}, "version": 1
            }
            ingredients_for_db = [{'item_id': ing['item_id'], 'percentage': ing['percentage']} for ing in ingredients_with_names]
        
        try:
            self.db.save_recipe(recipe_data, ingredients_for_db, recipe_id_to_revise)
            self.toast.show_message("✔ نسخه جدید فرمول با موفقیت ذخیره و فعال شد.", "success")
            self.load_recipe_tree(); self.clear_form_for_new()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ذخیره‌سازی", f"خطا: {e}\n\nممکن است نام این فرمول برای این نسخه تکراری باشد.")
            
                        
            
    def _populate_all_parent_product_combos(self):
        self.master_parent_product_combo.clear(); self.master_parent_product_combo.addItem("--- انتخاب کنید ---", None); self.comp_parent_product_combo.clear(); self.comp_parent_product_combo.addItem("--- انتخاب کنید ---", None); parents = self.db.execute_query("SELECT id, name FROM items WHERE is_parent_product = TRUE ORDER BY name")
        for p in parents:
            self.master_parent_product_combo.addItem(p['name'], p['id'])
            self.comp_parent_product_combo.addItem(p['name'], {'id': p['id'], 'name': p['name']})
            
# در کلاس RecipeManagementDialog، این متد را جایگزین کنید
    def _on_master_parent_selected(self):
        self.master_product_name_label.setText(f"دستور ساخت اصلی - {self.master_parent_product_combo.currentText()}")
        parent_id = self.master_parent_product_combo.currentData()
        self.active_part_a_label.setText("<i>(یافت نشد)</i>")
        self.active_part_b_label.setText("<i>(یافت نشد)</i>")
        
        # --- بخش جدید برای کنترل نمایش گزینه‌های دوجزئی ---
        parent_item_details = self.db.get_item_details(parent_id) if parent_id else None
        is_two_component = parent_item_details.get('is_two_component', False) if parent_item_details else False
        
        # تمام ویجت‌های مربوط به نسبت و پارت‌ها در یک لیست
        ratio_widgets = [self.ratio_a_spin, self.ratio_b_spin, self.active_part_a_label, self.active_part_b_label]
        # پیدا کردن لیبل‌های متناظر در فرم
        for widget in ratio_widgets:
            label = self.master_panel.layout().labelForField(widget)
            if label:
                label.setVisible(is_two_component)
            widget.setVisible(is_two_component)
        # --- پایان بخش جدید ---

        if not parent_id or not is_two_component:
            return

        part_a = self.db.execute_query("SELECT product_name, version FROM recipes WHERE parent_product_id = %s AND part_type = 'A' AND status = 'ACTIVE' LIMIT 1", (parent_id,), fetch_one=True)
        part_b = self.db.execute_query("SELECT product_name, version FROM recipes WHERE parent_product_id = %s AND part_type = 'B' AND status = 'ACTIVE' LIMIT 1", (parent_id,), fetch_one=True)
        if part_a: self.active_part_a_label.setText(f"{part_a['product_name']} (v{part_a['version']})")
        if part_b: self.active_part_b_label.setText(f"{part_b['product_name']} (v{part_b['version']})")
                
# در کلاس RecipeManagementDialog، این متد را به طور کامل جایگزین کنید

    def _update_component_outputs(self):
        """
        نسخه اصلاح شده و هوشمند:
        - تلاش می‌کند محصول خروجی را به صورت خودکار انتخاب کند.
        - اگر کاربر قبلاً به صورت دستی محصولی را انتخاب کرده باشد، انتخاب او را تغییر نمی‌دهد.
        """
        parent_data = self.comp_parent_product_combo.currentData()
        part_type_index = self.comp_part_type_combo.currentIndex()

        # اگر اطلاعات پایه (محصول مادر و نوع پارت) کامل نیست، نام فرمول را پاک کن
        if not isinstance(parent_data, dict) or part_type_index == 0:
            self.comp_name_edit.clear()
            return
            
        parent_name = parent_data.get('name', '')
        part_map = {1: 'P', 2: 'A', 3: 'B'}
        part_char = part_map.get(part_type_index)
        
        # نام فرمول همیشه بر اساس ورودی‌ها به‌روز می‌شود
        self.comp_name_edit.setText(f"فرمول پارت {part_char} برای {parent_name}")
        
        # --- *** منطق کلیدی و اصلاح شده اینجاست *** ---
        # فقط در صورتی که کاربر هنوز محصولی را انتخاب نکرده، تلاش برای انتخاب خودکار کن
        if self.produces_item_combo.currentIndex() <= 0:
            self.produces_item_combo.setCurrentIndex(0) # اطمینان از ریست بودن
            expected_bulk_name = f"{parent_name} - پارت {part_char}"
            
            # جستجو برای پیدا کردن محصول فله متناظر
            for item in self.bulk_items_cache:
                if item['name'] == expected_bulk_name:
                    index = self.produces_item_combo.findData(item['id'])
                    if index != -1:
                        self.produces_item_combo.setCurrentIndex(index)
                    break 
        # --- ************************************** ---
                        
# در کلاس RecipeManagementDialog، این متد را به طور کامل جایگزین کنید

    def load_recipe_tree(self):
        self.recipe_tree.clear()
        parent_products = self.db.execute_query("SELECT id, name FROM items WHERE is_parent_product = TRUE ORDER BY name")
        
        # --- *** اصلاح کلیدی: فیلتر کردن فقط فرمول‌های ساخت واقعی *** ---
        # ما دیگر تمام رکوردها را نمی‌خوانیم، بلکه فقط آنهایی که مربوط به بسته‌بندی نیستند
        all_recipes = self.db.execute_query(
            "SELECT * FROM recipes WHERE part_type IS NULL OR part_type != 'PACKAGING' ORDER BY product_name, version"
        )
        # --- ********************************************************** ---

        recipes_by_parent = {p['id']: [] for p in parent_products}
        for r in all_recipes:
            if r.get('parent_product_id') in recipes_by_parent:
                recipes_by_parent[r['parent_product_id']].append(r)
        
        for p in parent_products:
            parent_item = QtWidgets.QTreeWidgetItem(self.recipe_tree, [p['name']])
            parent_item.setFont(0, QFont(FONT_FAMILY, 10, QFont.Bold))
            parent_item.setData(0, Qt.UserRole, {'type': 'parent_product', 'id': p['id']})
            
            for r in recipes_by_parent.get(p['id'], []):
                status_icon = "✔" if r.get('status') == 'ACTIVE' else " (آرشیو)"
                name = r['product_name']
                child_item = QtWidgets.QTreeWidgetItem(parent_item, [f"{name} (v{r['version']}){status_icon}"])
                child_item.setData(0, Qt.UserRole, {'type': 'recipe', **r})
                if r.get('part_type') == 'MASTER':
                    font = child_item.font(0); font.setBold(True); child_item.setFont(0, font)
                    
        self.recipe_tree.expandAll()
                
    def _filter_recipe_tree(self, text):
        search_text = self.recipe_search_edit.text().lower().strip(); root = self.recipe_tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i); parent_name = parent_item.text(0).lower(); has_visible_child = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j); child_matches = search_text in child_item.text(0).lower(); child_item.setHidden(not child_matches)
                if not child_item.isHidden(): has_visible_child = True
            parent_item.setHidden(not (search_text in parent_name or has_visible_child))
            
    def load_selected_recipe_details(self):
        selected = self.recipe_tree.selectedItems(); self.clear_form_for_new(keep_selection=True)
        if not selected: return
        data = selected[0].data(0, Qt.UserRole);
        if not data or data.get('type') != 'recipe': return
        self.current_recipe_data = data; details = self.db.get_recipe_details(self.current_recipe_data['id'])
        if not details or not details.get('recipe'): return
        recipe_data = details['recipe']
        if recipe_data.get('part_type') == 'MASTER':
            self.mode_master.setChecked(True); parent_id = recipe_data.get('parent_product_id'); index = self.master_parent_product_combo.findData(parent_id) if parent_id else -1
            if index != -1: self.master_parent_product_combo.setCurrentIndex(index)
            props = recipe_data.get('properties', {}); props = json.loads(props) if isinstance(props, str) and props else props or {}; ratio = props.get('mix_ratio', {}); self.ratio_a_spin.setValue(ratio.get('A', 0)); self.ratio_b_spin.setValue(ratio.get('B', 0)); self.master_notes_edit.setPlainText(recipe_data.get('notes', ''))
        else:
            self.mode_component.setChecked(True); parent_id = recipe_data.get('parent_product_id')
            if parent_id:
                for i in range(self.comp_parent_product_combo.count()):
                    item_data = self.comp_parent_product_combo.itemData(i)
                    if isinstance(item_data, dict) and item_data.get('id') == parent_id: self.comp_parent_product_combo.setCurrentIndex(i); break
            part_map = {'P': 1, 'A': 2, 'B': 3}; self.comp_part_type_combo.setCurrentIndex(part_map.get(recipe_data.get('part_type'), 0))
            self._update_component_outputs()
            self.ingredients_table.setRowCount(0)
            for ing in details.get('ingredients', []): r = self.ingredients_table.rowCount(); self.ingredients_table.insertRow(r); self.ingredients_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(ing['raw_material_item_id']))); self.ingredients_table.setItem(r, 1, QtWidgets.QTableWidgetItem(ing['name'])); self.ingredients_table.setItem(r, 2, QtWidgets.QTableWidgetItem(str(ing['percentage'])))
            self._update_sum_label()
            
    def clear_form_for_new(self, keep_selection=False):
        if not keep_selection: self.recipe_tree.clearSelection()
        self.current_recipe_data = None; self.master_parent_product_combo.setCurrentIndex(0); self.ratio_a_spin.setValue(0); self.ratio_b_spin.setValue(0); self.master_notes_edit.clear(); self.comp_name_edit.clear(); self.comp_parent_product_combo.setCurrentIndex(0); self.comp_part_type_combo.setCurrentIndex(0); self.produces_item_combo.setCurrentIndex(0); self.ingredients_table.setRowCount(0); self._update_sum_label()
        
    def add_ingredients(self):
        dlg = IngredientSelectionDialog(self.db, self)
        if dlg.exec_() and dlg.selected_items:
            existing_ids = {self.ingredients_table.item(row, 0).text() for row in range(self.ingredients_table.rowCount()) if self.ingredients_table.item(row, 0)}; self.ingredients_table.blockSignals(True)
            for item in dlg.selected_items:
                if str(item['id']) not in existing_ids: row_pos = self.ingredients_table.rowCount(); self.ingredients_table.insertRow(row_pos); self.ingredients_table.setItem(row_pos, 0, QtWidgets.QTableWidgetItem(str(item['id']))); self.ingredients_table.setItem(row_pos, 1, QtWidgets.QTableWidgetItem(item['name'])); self.ingredients_table.setItem(row_pos, 2, QtWidgets.QTableWidgetItem("0.0"))
            self.ingredients_table.blockSignals(False); self._update_sum_label()
            
    def remove_ingredient(self):
        current_row = self.ingredients_table.currentRow();
        if current_row >= 0: self.ingredients_table.removeRow(current_row); self._update_sum_label()

    # --- **متد فراموش شده که باعث خطا شد، اکنون اضافه شده است** ---
    def _update_sum_label(self):
        total = 0.0
        for row in range(self.ingredients_table.rowCount()):
            item = self.ingredients_table.item(row, 2)
            if item and item.text():
                try: total += float(item.text())
                except (ValueError, TypeError): pass
        self.sum_label.setText(f"مجموع درصدها: {total:.2f}%")
        self.sum_label.setStyleSheet("font-weight: bold; color: red;" if abs(total - 100.0) > 0.01 and total != 0 else "font-weight: bold; color: green;")
                
                
        

# کلاس IngredientSelectionDialog را با این نسخه اصلاح‌شده جایگزین کنید
class IngredientSelectionDialog(QtWidgets.QDialog):
    """
    یک دیالوگ برای جستجو و انتخاب چندتایی مواد اولیه.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.selected_items = []

        self.setWindowTitle("انتخاب مواد اولیه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(400, 500)

        layout = QtWidgets.QVBoxLayout(self)

        self.search_edit = QtWidgets.QLineEdit(placeholderText="🔍 جستجوی نام ماده اولیه...")
        self.search_edit.textChanged.connect(self.filter_list)
        layout.addWidget(self.search_edit)

        self.items_list_widget = QtWidgets.QListWidget()
        self.items_list_widget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        layout.addWidget(self.items_list_widget)

        self.add_button = QtWidgets.QPushButton("افزودن موارد انتخاب شده")
        self.add_button.clicked.connect(self.accept_selection)
        layout.addWidget(self.add_button)

        self.populate_list()

    def populate_list(self):
        self.items_list_widget.clear()
        # --- *** اصلاح کلیدی اینجاست: فراخوانی تابع صحیح *** ---
        all_items = self.db.get_all_items_for_selection()

        for item in all_items:
            # فقط مواد اولیه را نمایش می‌دهیم
            if item['category'] == CATEGORY_RAW_MATERIAL: # استفاده از ثابت سراسری
                unit_name = item.get('unit', '')
                display_text = f"{item['name']} (واحد: {unit_name})" if unit_name else item['name']
                list_item = QtWidgets.QListWidgetItem(display_text)
                list_item.setData(Qt.UserRole, item)
                self.items_list_widget.addItem(list_item)

    def filter_list(self):
        search_text = self.search_edit.text().lower()
        for i in range(self.items_list_widget.count()):
            item = self.items_list_widget.item(i)
            item.setHidden(search_text not in item.text().lower())

    def accept_selection(self):
        for item in self.items_list_widget.selectedItems():
            self.selected_items.append(item.data(Qt.UserRole))
        self.accept()
        
# کل کلاس MenuActionWidget را با این نسخه کامل جایگزین کنید

class MenuActionWidget(QtWidgets.QFrame):
    """یک ویجت گرافیکی سفارشی برای نمایش اکشن در منو با قابلیت رنگ‌پذیری."""
    triggered = QtCore.pyqtSignal()

    def __init__(self, icon_path, title, subtitle, icon_bg_color, parent=None):
        super().__init__(parent)
        self.setCursor(Qt.PointingHandCursor)
        self.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.setContentsMargins(0,0,0,0)
        
        self.normal_style = "background-color: #ffffff; border-radius: 6px;"
        self.hover_style = "background-color: #f1f2f6; border: 1px solid #dcdcdc; border-radius: 6px;"
        
        self.setStyleSheet(self.normal_style)

        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(15)

        # --- بخش جدید: آیکون با پس‌زمینه دایره‌ای رنگی ---
        icon_container = QtWidgets.QLabel()
        icon_container.setFixedSize(36, 36)
        # استایل دایره رنگی
        icon_container.setStyleSheet(f"""
            background-color: {icon_bg_color};
            border-radius: 18px; /* نصف اندازه برای ایجاد دایره کامل */
        """)
        
        icon_layout = QtWidgets.QHBoxLayout(icon_container)
        icon_layout.setAlignment(Qt.AlignCenter)
        
        icon_label = QtWidgets.QLabel()
        # بهتر است آیکون شما 20x20 باشد تا در دایره 36x36 زیبا به نظر برسد
        pixmap = QtGui.QPixmap(icon_path).scaled(20, 20, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        icon_label.setPixmap(pixmap)
        icon_layout.addWidget(icon_label)
        # ---------------------------------------------

        text_layout = QtWidgets.QVBoxLayout()
        text_layout.setSpacing(1)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt; background: transparent;")
        
        subtitle_label = QtWidgets.QLabel(subtitle)
        subtitle_label.setStyleSheet("color: #636e72; background: transparent;")

        text_layout.addWidget(title_label)
        text_layout.addWidget(subtitle_label)
        
        layout.addWidget(icon_container) # کانتینر آیکون اضافه می‌شود
        layout.addLayout(text_layout)
        layout.addStretch()

    def enterEvent(self, event):
        self.setStyleSheet(self.hover_style)
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.setStyleSheet(self.normal_style)
        super().leaveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.triggered.emit()
        super().mouseReleaseEvent(event)
        
# این کلاس کاملاً جدید را به فایل اصلی برنامه اضافه کنید

class CountSheetDialog(QtWidgets.QDialog):
    """
    نسخه ۲.۰: بازطراحی کامل با استفاده از نمای درختی (QTreeWidget)
    - اقلام شمارش بر اساس لوکیشن دسته‌بندی می‌شوند تا فرآیند شمارش فیزیکی آسان‌تر شود.
    - رابط کاربری برای ورود داده بهینه‌سازی شده است.
    """
    def __init__(self, db: DB, user_id: int, count_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.count_id = db, user_id, count_id
        
        self.setWindowTitle(f"برگه شمارش سند شماره {self.count_id}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 700)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        
        # نوار جستجو
        search_layout = QtWidgets.QHBoxLayout()
        search_bar = QtWidgets.QLineEdit(placeholderText="جستجوی نام کالا، لوکیشن یا بچ نامبر...")
        search_bar.textChanged.connect(self._filter_tree)
        search_layout.addWidget(search_bar)
        layout.addLayout(search_layout)

        # ویجت درختی به جای جدول
        self.tree_items = QtWidgets.QTreeWidget()
        parent._style_tree(self.tree_items) # استفاده از استایل سراسری برنامه
        self.tree_items.setHeaderLabels(["کالا / بچ", "تاریخ انقضا", "موجودی سیستم", "مقدار شمارش شده"])
        self.tree_items.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, 4):
            self.tree_items.header().setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        
        layout.addWidget(self.tree_items, 1)

        # دکمه‌ها
        button_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره پیشرفت")
        btn_finalize = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " اتمام و ارسال برای بازبینی")
        btn_finalize.setProperty("class", "primary")
        
        btn_save.clicked.connect(self._save_progress)
        btn_finalize.clicked.connect(self._finalize_count)

        button_layout.addStretch()
        button_layout.addWidget(btn_save)
        button_layout.addWidget(btn_finalize)
        layout.addLayout(button_layout)
        
        self._load_and_build_tree()

    def _load_and_build_tree(self):
        """اطلاعات شمارش را خوانده و درخت را بر اساس لوکیشن می‌سازد."""
        items_to_count = self.db.get_items_for_count(self.count_id)
        
        grouped_by_loc = {}
        for item in items_to_count:
            loc_label = item['loc_label']
            if loc_label not in grouped_by_loc:
                grouped_by_loc[loc_label] = []
            grouped_by_loc[loc_label].append(item)

        for loc_label, items in grouped_by_loc.items():
            parent_item = QtWidgets.QTreeWidgetItem(self.tree_items, [loc_label])
            parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
            parent_item.setFlags(parent_item.flags() & ~Qt.ItemIsSelectable) # غیرقابل انتخاب کردن آیتم والد

            for item_data in items:
                child_item = QtWidgets.QTreeWidgetItem(parent_item)
                child_item.setText(0, f"  {item_data['item_name']} (بچ: {item_data['batch_no']})")
                child_item.setText(1, to_shamsi(item_data['expiry_date']))
                child_item.setText(2, str(item_data['system_qty']))
                
                # ذخیره ID اصلی برای آپدیت در دیتابیس
                child_item.setData(0, Qt.UserRole, item_data['count_item_id'])
                
                # ویجت QLineEdit برای ورود مقدار شمارش شده
                counted_edit = QtWidgets.QLineEdit()
                counted_edit.setValidator(QtGui.QDoubleValidator(0, 1e9, 3))
                counted_edit.setAlignment(Qt.AlignCenter)
                counted_edit.setText(str(item_data.get('counted_qty') or item_data['system_qty']))
                self.tree_items.setItemWidget(child_item, 3, counted_edit)
        
        self.tree_items.expandAll()

    def _filter_tree(self, text):
        """درخت را بر اساس متن ورودی فیلتر می‌کند."""
        text = text.lower()
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_items, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            # فیلتر فقط روی آیتم‌های فرزند (کالاها) اعمال می‌شود
            if item.parent(): 
                item_text = item.text(0).lower()
                parent_text = item.parent().text(0).lower()
                is_match = text in item_text or text in parent_text
                item.setHidden(not is_match)
            iterator += 1
        # نمایش/عدم نمایش آیتم‌های والد بر اساس فرزندانشان
        for i in range(self.tree_items.topLevelItemCount()):
            parent = self.tree_items.topLevelItem(i)
            has_visible_child = False
            for j in range(parent.childCount()):
                if not parent.child(j).isHidden():
                    has_visible_child = True
                    break
            parent.setHidden(not has_visible_child)

    def _save_progress(self, show_toast=True):
        """مقادیر وارد شده در درخت را در دیتابیس ذخیره می‌کند."""
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_items, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if item.parent(): # فقط آیتم‌های فرزند پردازش می‌شوند
                count_item_id = item.data(0, Qt.UserRole)
                counted_edit = self.tree_items.itemWidget(item, 3)
                if counted_edit and counted_edit.text().strip():
                    counted_qty = float(counted_edit.text())
                    self.db.update_counted_quantity(count_item_id, counted_qty)
            iterator += 1
            
        if show_toast and self.parent():
            self.parent().toast.show_message("✔ پیشرفت شمارش ذخیره شد.", "success")

    def _finalize_count(self):
        """شمارش را نهایی کرده و وضعیت سند را برای بازبینی ارسال می‌کند."""
        self._save_progress(show_toast=False)
        
        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی",
            "آیا از اتمام شمارش و ارسال نتایج برای بازبینی مطمئن هستید؟\nپس از این مرحله، دیگر قادر به ویرایش مقادیر نخواهید بود.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            
        if reply == QtWidgets.QMessageBox.Yes:
            self.db.change_count_status(self.count_id, 'REVIEW')
            if self.parent():
                self.parent().toast.show_message(f"شمارش سند {self.count_id} نهایی شد و برای بازبینی ارسال گردید.", "info")
            self.accept()
                        
class ReviewCountDialog(QtWidgets.QDialog):
    """
    نسخه ۲.۰: بازطراحی کامل برای بازبینی و تایید نهایی انبارگردانی.
    - نمایش دقیق مغایرت‌ها در سطح بچ/لوکیشن.
    - اصلاح موجودی به صورت دقیق و هدفمند بر اساس ردیف‌های دارای مغایرت.
    """
    def __init__(self, db: DB, user_id: int, count_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.count_id = db, user_id, count_id
        
        self.setWindowTitle(f"بازبینی و تایید سند شمارش شماره {self.count_id}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(1000, 700)

        self.layout = QtWidgets.QVBoxLayout(self)
        self.layout.setSpacing(10)
        
        # نوار ابزار بالا
        action_bar = QtWidgets.QHBoxLayout()
        self.filter_combo = QtWidgets.QComboBox()
        self.filter_combo.addItems(["نمایش همه", "فقط مغایرت‌ها"])
        self.filter_combo.currentTextChanged.connect(self._filter_table)
        action_bar.addWidget(QtWidgets.QLabel("نمایش:"))
        action_bar.addWidget(self.filter_combo)
        action_bar.addStretch()
        self.layout.addLayout(action_bar)

        # جدول اصلی آیتم‌های شمارش شده
        self.tbl_review = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'): parent._style_table(self.tbl_review)
        self.layout.addWidget(self.tbl_review, 1)

        # بخش شماره سند اصلاحی
        doc_no_layout = QtWidgets.QHBoxLayout()
        doc_no_label = QtWidgets.QLabel("شماره سند اصلاحی (اختیاری):")
        self.doc_no_edit = QtWidgets.QLineEdit()
        self.doc_no_edit.setPlaceholderText(f"پیش‌فرض اگر خالی بماند: COUNT-{self.count_id}")
        doc_no_layout.addWidget(doc_no_label); doc_no_layout.addWidget(self.doc_no_edit)
        self.layout.addLayout(doc_no_layout)

        # دکمه‌های عملیاتی مدیر
        button_layout = QtWidgets.QHBoxLayout()
        btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل از مغایرت‌ها")
        btn_finalize = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید نهایی و اصلاح موجودی انبار")
        btn_finalize.setProperty("class", "primary")
        
        btn_export.clicked.connect(lambda: export_table_to_excel(self.tbl_review, self))
        btn_finalize.clicked.connect(self._approve_and_finalize)
        
        button_layout.addStretch()
        button_layout.addWidget(btn_export)
        button_layout.addWidget(btn_finalize)
        self.layout.addLayout(button_layout)
        
        self._load_review_items()

    def _load_review_items(self):
        """جدول بازبینی را با اطلاعات دقیق در سطح بچ/لوکیشن پر می‌کند."""
        items_to_review = self.db.get_items_for_count(self.count_id)
        
        headers = ["کالا", "لوکیشن", "شماره بچ", "تاریخ انقضا", "موجودی سیستم", "مقدار شمارش شده", "مغایرت", "دلیل مغایرت (اجباری)"]
        self.tbl_review.setColumnCount(len(headers))
        self.tbl_review.setHorizontalHeaderLabels(headers)
        self.tbl_review.setRowCount(len(items_to_review))

        DISCREPANCY_COLOR = QtGui.QColor("#ffebee") # رنگ هایلایت برای مغایرت

        for r, item in enumerate(items_to_review):
            counted_qty = item.get('counted_qty') if item.get('counted_qty') is not None else item.get('system_qty', 0)
            system_qty = item.get('system_qty', 0)
            discrepancy = counted_qty - system_qty

            # ذخیره اطلاعات کلیدی در آیتم اول برای دسترسی بعدی
            item_name_cell = QtWidgets.QTableWidgetItem(item['item_name'])
            item_name_cell.setData(Qt.UserRole, item) # کل رکورد را در دیتا ذخیره می‌کنیم
            self.tbl_review.setItem(r, 0, item_name_cell)
            
            self.tbl_review.setItem(r, 1, QtWidgets.QTableWidgetItem(item['loc_label']))
            self.tbl_review.setItem(r, 2, QtWidgets.QTableWidgetItem(item['batch_no']))
            self.tbl_review.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(item['expiry_date'])))
            self.tbl_review.setItem(r, 4, NumericTableWidgetItem(str(system_qty)))
            self.tbl_review.setItem(r, 5, NumericTableWidgetItem(str(counted_qty)))
            self.tbl_review.setItem(r, 6, NumericTableWidgetItem(f"{discrepancy:+.2f}"))

            if abs(discrepancy) > 1e-9: # اگر مغایرت وجود داشت
                for col in range(7):
                    self.tbl_review.item(r, col).setBackground(DISCREPANCY_COLOR)
                
                reason_combo = QtWidgets.QComboBox()
                reason_combo.addItems(['- انتخاب کنید -', 'کسری (ضایعات)', 'کسری (شمارش غلط)', 'اضافی (یافت شده)', 'اصلاح خطای کاربری'])
                self.tbl_review.setCellWidget(r, 7, reason_combo)
        
        self.tbl_review.resizeColumnsToContents()
        self.tbl_review.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.tbl_review.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _filter_table(self, text):
        """جدول را برای نمایش همه یا فقط مغایرت‌ها فیلتر می‌کند."""
        show_only_discrepancies = (text == "فقط مغایرت‌ها")
        for r in range(self.tbl_review.rowCount()):
            discrepancy_text = self.tbl_review.item(r, 6).text()
            discrepancy_val = float(discrepancy_text)
            
            if show_only_discrepancies:
                self.tbl_review.setRowHidden(r, abs(discrepancy_val) < 1e-9)
            else:
                self.tbl_review.setRowHidden(r, False)

    def _approve_and_finalize(self):
        """مغایرت‌ها را در دیتابیس ثبت کرده و انبارگردانی را نهایی می‌کند."""
        custom_doc_no = self.doc_no_edit.text().strip() or f"COUNT-{self.count_id}"
        
        discrepancies_to_apply = []
        for r in range(self.tbl_review.rowCount()):
            if self.tbl_review.isRowHidden(r): continue
            
            discrepancy_val = float(self.tbl_review.item(r, 6).text())
            if abs(discrepancy_val) > 1e-9:
                reason_combo = self.tbl_review.cellWidget(r, 7)
                if not reason_combo or reason_combo.currentIndex() == 0:
                    QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", f"لطفاً برای کالای «{self.tbl_review.item(r, 0).text()}» در لوکیشن «{self.tbl_review.item(r, 1).text()}» دلیل مغایرت را انتخاب کنید.")
                    return
                
                item_data = self.tbl_review.item(r, 0).data(Qt.UserRole)
                discrepancies_to_apply.append({
                    'item_id': item_data['item_id'],
                    'location_id': item_data['location_id'],
                    'batch_no': item_data['batch_no'],
                    'expiry_date': item_data.get('expiry_date'),
                    'adjustment_qty': discrepancy_val,
                    'reason': reason_combo.currentText(),
                })

        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی عملیات",
            f"آیا برای صدور سند اصلاحی به شماره «{custom_doc_no}» و ثبت {len(discrepancies_to_apply)} مغایرت مطمئن هستید؟",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # فراخوانی تابع جدید و دقیق دیتابیس
                self.db.apply_inventory_adjustments(self.count_id, self.user_id, discrepancies_to_apply, custom_doc_no)
                
                self.parent().toast.show_message("✔ انبارگردانی با موفقیت نهایی و موجودی‌ها اصلاح شد.", "success")
                self.accept()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطای بحرانی", f"خطا در هنگام اصلاح موجودی انبار:\n{e}")
                print(traceback.format_exc())
                                                                
class StockCardDialog(QtWidgets.QDialog):
    """یک دیالوگ ساده برای نمایش اطلاعات و موجودی فعلی یک کالا."""
    def __init__(self, db: DB, item_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.item_id = item_id

        item_data = self.db.get_item_details(self.item_id)
        self.setWindowTitle(f"کارت کالا: {item_data.get('name', '')}")
        self.setMinimumWidth(450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        total_qty = item_data.get('qty', 0)
        total_qty_label = QtWidgets.QLabel(f"<b>{total_qty}</b> {item_data.get('unit', '')}")
        form_layout.addRow("موجودی کل فعلی:", total_qty_label)
        layout.addLayout(form_layout)
        
        layout.addWidget(QtWidgets.QLabel("موجودی به تفکیک لوکیشن:"))
        
        table = QtWidgets.QTableWidget()
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(['لوکیشن', 'مقدار'])
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        table.verticalHeader().hide()
        
        stock_details = self.db.stock_breakdown(self.item_id)
        table.setRowCount(len(stock_details))
        for r, detail in enumerate(stock_details):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(detail['loc']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(detail['qty'])))
        
        layout.addWidget(table)
        
# این کلاس جدید را به فایل خود اضافه کنید
class DocumentDetailsDialog(QtWidgets.QDialog):
    """خلاصه یک سند (شامل تمام کالاهای آن) را نمایش می‌دهد."""
    def __init__(self, db: DB, doc_no: str, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"جزئیات سند: {doc_no}")
        self.setMinimumWidth(600)
        # ... (این دیالوگ می‌تواند در آینده تکمیل شود) ...
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel(f"اینجا جزئیات کامل سند شماره {doc_no} نمایش داده خواهد شد."))
        
# این کلاس کاملاً جدید را به بالای فایل کد خود اضافه کنید
# (مثلاً بعد از قسمت import ها)

class NumericTableWidgetItem(QtWidgets.QTableWidgetItem):
    """یک سلول جدول سفارشی که اعداد را بر اساس مقدار واقعی آنها مرتب می‌کند، نه متن."""
    def __lt__(self, other):
        # تلاش برای تبدیل متن دو سلول به عدد (float)
        try:
            # کاماها را حذف می‌کنیم تا تبدیل به عدد به درستی انجام شود
            self_float = float(self.text().replace(',', ''))
            other_float = float(other.text().replace(',', ''))
            return self_float < other_float
        except (ValueError, TypeError):
            # اگر تبدیل به عدد ممکن نبود، بر اساس متن مقایسه کن (برای موارد غیر عددی)
            return super().__lt__(other)
        


# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید

class CustomColorDelegate(QtWidgets.QStyledItemDelegate):
    """
    نسخه نهایی و قطعی (با کنترل دستی پس‌زمینه):
    این نسخه با کنترل کامل و دستی پس‌زمینه، تضمین می‌کند که هم هایلایت انتخاب
    و هم رنگ وضعیت به درستی و بدون تداخل با یکدیگر کار می‌کنند.
    """
    def paint(self, painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex):
        # گام اول: کنترل کامل پس‌زمینه را به دست می‌گیریم
        
        # ابتدا چک می‌کنیم آیا ردیف انتخاب شده است یا خیر
        if option.state & QtWidgets.QStyle.State_Selected:
            # اگر انتخاب شده بود، آن را با رنگ هایلایت استاندارد سیستم پر می‌کنیم
            painter.fillRect(option.rect, option.palette.highlight())
        else:
            # اگر انتخاب نشده بود، رنگ وضعیت سفارشی خودمان را اعمال می‌کنیم
            background_data = index.data(QtCore.Qt.BackgroundRole)
            if background_data:
                painter.fillRect(option.rect, QtGui.QBrush(background_data))
            else:
                # اگر رنگ سفارشی هم نداشت، اجازه می‌دهیم خود استایل‌شیت
                # پس‌زمینه پیش‌فرض یا متناوب را ترسیم کند
                super().paint(painter, option, index)
                return # از ادامه کار جلوگیری می‌کنیم چون همه چیز کشیده شده است

        # گام دوم: حالا که پس‌زمینه را خودمان کشیده‌ایم، از متد اصلی می‌خواهیم
        # که فقط موارد رویی (foreground) مانند متن و آیکون را ترسیم کند.
        # برای این کار یک کپی از آپشن‌ها ساخته و به آن می‌گوییم پس‌زمینه ندارد.
        opt = QtWidgets.QStyleOptionViewItem(option)
        self.initStyleOption(opt, index)
        opt.state &= ~QtWidgets.QStyle.State_HasFocus # حذف فوکوس برای جلوگیری از ترسیم دوباره حاشیه
        opt.backgroundBrush = QtGui.QBrush(QtCore.Qt.transparent) # حذف پس‌زمینه از دستورالعمل
        
        # یک ویجت موقت برای دسترسی به استایل‌ها می‌سازیم
        widget = option.widget
        style = widget.style() if widget else QtWidgets.QApplication.style()
        
        # فقط محتوای آیتم (متن و آیکون) را ترسیم می‌کنیم
        style.drawControl(QtWidgets.QStyle.CE_ItemViewItem, opt, painter, widget)
                                                        
# ╔═════════════════════════════════════════════════════╗
# ║        دیالوگ گزارش‌گیری مالی هوشمند BOM           ║
# ╚═════════════════════════════════════════════════════╝
class FinancialBomReportDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ایجاد گزارش مالی BOM")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(600, 500)

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        self.pcode_combo = QtWidgets.QComboBox()
        self.pcode_combo.addItems(self.db.get_distinct_product_codes())
        form_layout.addRow("انتخاب بچ محصول نهایی برای گزارش:", self.pcode_combo)
        
        layout.addLayout(form_layout)
        
        self.materials_table = QtWidgets.QTableWidget()
        self.materials_table.setColumnCount(3)
        self.materials_table.setHorizontalHeaderLabels(['ماده اولیه مصرفی', 'نحوه گزارش', 'نام گروه (در صورت محرمانگی)'])
        self.materials_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.materials_table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.materials_table)

        btn_generate = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("x-office-spreadsheet"), " ایجاد فایل اکسل")
        btn_generate.setProperty("class", "primary")
        layout.addWidget(btn_generate)

        self.pcode_combo.currentTextChanged.connect(self._populate_materials)
        btn_generate.clicked.connect(self._generate_report)

        self._populate_materials() # فراخوانی اولیه

    def _populate_materials(self):
        self.materials_table.setRowCount(0)
        pcode = self.pcode_combo.currentText()
        if not pcode: return

        materials = self.db.get_bom_for_product_code(pcode)
        self.materials_table.setRowCount(len(materials))

        for r, material in enumerate(materials):
            self.materials_table.setItem(r, 0, QtWidgets.QTableWidgetItem(material['raw_item_name']))
            
            # --- ویجت‌های کنترلی برای هر ردیف ---
            # منوی کشویی
            combo = QtWidgets.QComboBox()
            combo.addItems(['شفاف (با نام اصلی)', 'محرمانه (در گروه)'])
            self.materials_table.setCellWidget(r, 1, combo)
            
            # کادر متن برای نام گروه
            line_edit = QtWidgets.QLineEdit()
            line_edit.setPlaceholderText("نام گروه را وارد کنید...")
            line_edit.setDisabled(True) # در ابتدا غیرفعال است
            self.materials_table.setCellWidget(r, 2, line_edit)
            
            # اتصال سیگنال برای فعال/غیرفعال کردن کادر متن
            combo.currentIndexChanged.connect(lambda state, le=line_edit: le.setEnabled(state == 1))

    def _generate_report(self):
        report_data = {}
        for r in range(self.materials_table.rowCount()):
            name = self.materials_table.item(r, 0).text()
            qty = float(self.db.get_bom_for_product_code(self.pcode_combo.currentText())[r]['qty'])
            
            combo = self.materials_table.cellWidget(r, 1)
            line_edit = self.materials_table.cellWidget(r, 2)

            if combo.currentIndex() == 1: # اگر محرمانه بود
                group_name = line_edit.text().strip()
                if not group_name:
                    QtWidgets.QMessageBox.warning(self, "خطا", f"لطفاً برای ماده محرمانه '{name}' یک نام گروه تعیین کنید.")
                    return
                # جمع‌آوری مقادیر در دیکشنری
                if group_name not in report_data: report_data[group_name] = 0
                report_data[group_name] += qty
            else: # اگر شفاف بود
                report_data[name] = qty
        
        # آماده‌سازی داده برای اکسل
        final_list = [{'ماده اولیه': name, 'مقدار مصرف': value} for name, value in report_data.items()]
        
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره گزارش مالی', f"BOM_{self.pcode_combo.currentText()}.xlsx", 'Excel (*.xlsx)')
        if not path: return
        
        try:
            import pandas as pd
            df = pd.DataFrame(final_list)
            df.to_excel(path, index=False)
            self.parent().toast.show_message("✔ گزارش مالی با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد فایل اکسل: {e}")
            
            
                    
                    
# ╔═════════════════════════════════════════════════════╗
# ║        مرکز کنترل محرمانگی (نسخه نهایی)             ║
# ╚═════════════════════════════════════════════════════╝
class ConfidentialityManagerDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_main = parent
        self.setWindowTitle("مرکز کنترل محرمانگی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 500)

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # پنل سمت راست: لیست گروه‌های تعریف شده توسط کاربر
        right_panel = QtWidgets.QWidget()
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.addWidget(QtWidgets.QLabel("<b>گروه‌های گزارش‌دهی</b>"))
        self.group_list = QtWidgets.QListWidget()
        self.group_list.itemSelectionChanged.connect(self.on_group_select)
        right_layout.addWidget(self.group_list)
        
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add_group = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " گروه جدید")
        btn_del_group = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف گروه")
        btn_layout.addWidget(btn_add_group); btn_layout.addWidget(btn_del_group)
        right_layout.addLayout(btn_layout)

        # پنل سمت چپ: لیست مواد اولیه برای اختصاص به گروه
        left_panel = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.materials_label = QtWidgets.QLabel("<b>مواد اولیه (برای گروه انتخاب شده تیک بزنید)</b>")
        left_layout.addWidget(self.materials_label)
        self.items_table = QtWidgets.QTableWidget()
        self.items_table.setColumnCount(2)
        self.items_table.setHorizontalHeaderLabels(['نام ماده اولیه', 'عضو این گروه است؟'])
        self.items_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.items_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        left_layout.addWidget(self.items_table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره تغییرات این گروه")
        btn_save.setProperty("class", "primary")
        left_layout.addWidget(btn_save)

        splitter.addWidget(left_panel); splitter.addWidget(right_panel)
        splitter.setSizes([450, 250])
        main_layout.addWidget(splitter)
        
        # اتصال سیگنال‌ها
        btn_add_group.clicked.connect(self._add_new_group)
        btn_del_group.clicked.connect(self._delete_group)
        btn_save.clicked.connect(self._save_group_changes)
        self.items_table.cellClicked.connect(self._toggle_checkbox)
        
        self._load_groups()
        self._load_all_raw_materials()

    def _load_groups(self):
        """لیست گروه‌هایی که کاربر تعریف کرده را بارگذاری می‌کند."""
        self.group_list.clear()
        self.group_list.addItems(self.db.get_all_reporting_groups())

    def _load_all_raw_materials(self):
        """جدول مواد اولیه را یک بار برای همیشه پر می‌کند."""
        self.items_table.setRowCount(0)
        materials = self.db.get_raw_materials_for_grouping()
        self.items_table.setRowCount(len(materials))
        for r, item in enumerate(materials):
            name_item = QtWidgets.QTableWidgetItem(item['name'])
            name_item.setData(Qt.UserRole, item['id'])
            name_item.setFlags(name_item.flags() & ~Qt.ItemIsEditable)
            self.items_table.setItem(r, 0, name_item)
            
            check_widget = QtWidgets.QWidget(); check_layout = QtWidgets.QHBoxLayout(check_widget)
            checkbox = QtWidgets.QCheckBox(); check_layout.addWidget(checkbox); check_layout.setAlignment(Qt.AlignCenter); check_layout.setContentsMargins(0,0,0,0)
            self.items_table.setCellWidget(r, 1, check_widget)

    def on_group_select(self):
        """با انتخاب یک گروه، چک‌باکس مواد اولیه مربوطه را در جدول سمت چپ فعال می‌کند."""
        selected_items = self.group_list.selectedItems()
        if not selected_items: 
            self.materials_label.setText("<b>برای اختصاص مواد، یک گروه را انتخاب کنید</b>")
            return
        
        group_name = selected_items[0].text()
        self.materials_label.setText(f"<b>مواد اولیه گروه: {group_name}</b>")
        
        all_materials = self.db.get_raw_materials_for_grouping()
        for r in range(self.items_table.rowCount()):
            item_id = self.items_table.item(r, 0).data(Qt.UserRole)
            checkbox = self.items_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            current_group = next((mat.get('reporting_group') for mat in all_materials if mat['id'] == item_id), "")
            checkbox.setChecked(current_group == group_name)

    def _add_new_group(self):
        """یک گروه گزارش‌دهی جدید با نام دلخواه کاربر ایجاد می‌کند."""
        text, ok = QtWidgets.QInputDialog.getText(self, 'گروه جدید', 'نام گروه محرمانه جدید را وارد کنید:')
        if ok and text:
            if text in [self.group_list.item(i).text() for i in range(self.group_list.count())]:
                QtWidgets.QMessageBox.warning(self, "خطا", "این نام گروه قبلاً استفاده شده است.")
            else:
                self.group_list.addItem(text)
                self.group_list.setCurrentRow(self.group_list.count() - 1)

    def _delete_group(self):
        """یک گروه و تمام تخصیص‌های آن را از سیستم حذف می‌کند."""
        selected_items = self.group_list.selectedItems()
        if not selected_items: return
        
        group_name = selected_items[0].text()
        reply = QtWidgets.QMessageBox.question(self, 'تایید حذف', f"آیا از حذف گروه '{group_name}' مطمئن هستید؟\n(تمام مواد اولیه عضو این گروه، از این پس به صورت شفاف گزارش خواهند شد)")
        
        if reply == QtWidgets.QMessageBox.Yes:
            self.db.clear_reporting_group(group_name)
            self._load_groups()
            self.on_group_select() # رفرش کردن چک‌باکس‌ها

    def _save_group_changes(self):
        """تغییرات عضویت مواد در گروه انتخاب شده را در دیتابیس ذخیره می‌کند."""
        selected_items = self.group_list.selectedItems()
        if not selected_items:
            QtWidgets.QMessageBox.warning(self, "خطا", "لطفاً ابتدا یک گروه را از لیست انتخاب کنید.")
            return
        group_name = selected_items[0].text()
        
        rules_to_save = []
        for r in range(self.items_table.rowCount()):
            item_id = self.items_table.item(r, 0).data(Qt.UserRole)
            is_checked = self.items_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox).isChecked()
            
            if is_checked:
                rules_to_save.append({'id': item_id, 'group_name': group_name})
            else:
                # اگر تیک برداشته شده، گروه آن را خالی می‌کنیم
                rules_to_save.append({'id': item_id, 'group_name': None})

        self.db.save_reporting_rules(rules_to_save)
        if hasattr(self.parent_main, 'toast'):
            self.parent_main.toast.show_message(f"✔ تغییرات برای گروه '{group_name}' ذخیره شد.", "success")

    def _toggle_checkbox(self, row, column):
        """با کلیک روی هر جای سلول ستون دوم، وضعیت چک‌باکس را تغییر می‌دهد."""
        if column == 1:
            widget = self.items_table.cellWidget(row, 1)
            if widget:
                checkbox = widget.findChild(QtWidgets.QCheckBox)
                if checkbox:
                    checkbox.setChecked(not checkbox.isChecked())        
        
# کلاس کمکی برای پنجره استثناها
class ExceptionsDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, group_prefix: str, is_group_confidential: bool, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"مدیریت استثناهای گروه {group_prefix}")
        self.setMinimumWidth(400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        
        # بر اساس وضعیت گروه، متن راهنما تغییر می‌کند
        info_text = "تیک مواردی را بزنید که می‌خواهند **برخلاف قانون گروه (محرمانه)، شفاف** باشند:" if is_group_confidential else "تیک مواردی را بزنید که می‌خواهند **برخلاف قانون گروه (شفاف)، محرمانه** باشند:"
        layout.addWidget(QtWidgets.QLabel(info_text))
        
        self.items_list = QtWidgets.QListWidget()
        layout.addWidget(self.items_list)
        
        items = self.db.get_items_for_main_group(group_prefix)
        for item in items:
            list_item = QtWidgets.QListWidgetItem(item['name'], self.items_list)
            list_item.setData(Qt.UserRole, item['id'])
            # بررسی اینکه آیا آیتم یک استثنا است یا نه
            is_confidential_item = bool(item.get('reporting_group'))
            is_exception = is_confidential_item != is_group_confidential
            list_item.setCheckState(Qt.Checked if is_exception else Qt.Unchecked)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def get_exception_ids(self):
        exceptions = []
        for i in range(self.items_list.count()):
            item = self.items_list.item(i)
            if item.checkState() == Qt.Checked:
                exceptions.append(item.data(Qt.UserRole))
        return exceptions

# کلاس اصلی و جدید مرکز کنترل محرمانگی
class AdvancedConfidentialityDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_main = parent
        self.rules = {} 
        self.setWindowTitle("مرکز کنترل هوشمند محرمانگی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(750, 400)

        layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # پنل راست: لیست گروه‌ها
        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.addWidget(QtWidgets.QLabel("<b>۱. گروه را انتخاب کنید:</b>"))
        self.group_list = QtWidgets.QListWidget()
        self.group_list.itemSelectionChanged.connect(self.on_group_select)
        right_layout.addWidget(self.group_list)
        btn_auto_detect = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), " شناسایی خودکار گروه‌ها")
        right_layout.addWidget(btn_auto_detect)
        
        # پنل چپ: تنظیمات
        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel)
        left_layout.addWidget(QtWidgets.QLabel("<b>۲. قوانین این گروه را تنظیم کنید:</b>"))
        
        self.confidential_check = QtWidgets.QCheckBox("این گروه به طور پیش‌فرض محرمانه است")
        self.report_name_edit = QtWidgets.QLineEdit(placeholderText="مثال: ترکیبات ویژه C")
        self.exceptions_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("preferences-system"), "مدیریت استثناها...")
        
        form_layout = QtWidgets.QFormLayout()
        form_layout.addRow(self.confidential_check)
        form_layout.addRow("نام گروه در گزارش:", self.report_name_edit)
        form_layout.addRow(self.exceptions_btn)
        left_layout.addLayout(form_layout)
        left_layout.addStretch()

        btn_save_rule = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره قانون برای این گروه")
        btn_save_rule.setProperty("class", "primary")
        left_layout.addWidget(btn_save_rule)

        splitter.addWidget(left_panel); splitter.addWidget(right_panel)
        splitter.setSizes([500, 250])
        layout.addWidget(splitter)
        
        # اتصالات
        self.confidential_check.toggled.connect(self.report_name_edit.setEnabled)
        self.exceptions_btn.clicked.connect(self.open_exceptions_dialog)
        btn_save_rule.clicked.connect(self.save_current_rule)
        btn_auto_detect.clicked.connect(self._load_main_groups)

        self.on_group_select() # برای غیرفعال کردن اولیه

    def _load_main_groups(self):
        self.group_list.clear()
        self.group_list.addItems(self.db.get_distinct_main_groups())

    def on_group_select(self):
        is_selected = bool(self.group_list.selectedItems())
        self.confidential_check.setEnabled(is_selected)
        self.report_name_edit.setEnabled(is_selected and self.confidential_check.isChecked())
        self.exceptions_btn.setEnabled(is_selected)
        
        if not is_selected: 
            self.confidential_check.setChecked(False)
            self.report_name_edit.clear()
            return

        group_prefix = self.group_list.currentItem().text()
        items_in_group = self.db.get_items_for_main_group(group_prefix)
        is_confidential = any(item.get('reporting_group') for item in items_in_group)
        self.confidential_check.setChecked(is_confidential)
        
        report_name = ""
        if is_confidential:
            for item in items_in_group:
                if item.get('reporting_group'):
                    report_name = item['reporting_group']; break
        self.report_name_edit.setText(report_name)

    def open_exceptions_dialog(self):
        selected = self.group_list.currentItem()
        if not selected: return
        group_prefix = selected.text()
        
        dlg = ExceptionsDialog(self.db, group_prefix, self.confidential_check.isChecked(), self)
        if dlg.exec_():
            exception_ids = dlg.get_exception_ids()
            self.rules[group_prefix] = self.rules.get(group_prefix, {})
            self.rules[group_prefix]['exceptions'] = exception_ids
            self.parent_main.toast.show_message(f"{len(exception_ids)} استثنا برای گروه {group_prefix} ثبت موقت شد.", "info")

    def save_current_rule(self):
        selected = self.group_list.currentItem()
        if not selected: return
        group_prefix = selected.text()
        
        is_confidential = self.confidential_check.isChecked()
        report_name = self.report_name_edit.text().strip()
        
        if is_confidential and not report_name:
            QtWidgets.QMessageBox.warning(self, "خطا", "برای گروه محرمانه، تعیین «نام در گزارش» الزامی است."); return
            
        report_name_to_save = report_name if is_confidential else ""
        exceptions = self.rules.get(group_prefix, {}).get('exceptions', [])
        
        self.db.save_confidentiality_rule(group_prefix, report_name_to_save, exceptions)
        self.parent_main.toast.show_message(f"✔ قانون برای گروه '{group_prefix}' با موفقیت در دیتابیس ذخیره شد.", "success")
        

# کل کلاس RoleManagerDialog را با این نسخه نهایی و کامل جایگزین کنید
class RoleManagerDialog(QtWidgets.QDialog):
    """پنجره مدیریت نقش‌ها با قابلیت تعیین دسترسی و تخصیص چندین داشبورد."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_role_id = None
        self.main_window = parent

        # --- *** اصلاح کلیدی و نهایی: تکمیل نقشه راهنمای سلسله مراتبی *** ---
        self.PERMISSION_HIERARCHY = {
            'page:view:dashboard': ("داشبورد", []),
            'page:view:items': ("کالاها و دارایی‌ها", ['items:', 'assets:create', 'assets:edit', 'assets:delete']),
            'page:view:transactions': ("تراکنش‌ها و رابط انبار", ['transactions:', 'assets:transact', 'warehouse:']),
            'page:view:purchasing': ("بازرگانی", ['purchasing:']),
            'page:view:qa': ("تضمین کیفیت (QA)", ['qa:']),
            'page:view:qc': ("کنترل کیفیت (QC)", ['qc:']),
            'page:view:sales': ("فروش", ['sales:']),
            'page:view:production': ("مدیریت تولید", ['production:']),
            'page:view:inventory': ("انبارگردانی", ['inventory:']),
            'page:view:forms': ("فرم‌های عمومی", []),
            'page:view:settings': ("تنظیمات", ['settings:']),
        }
        # --- ****************************************************** ---
        
        self.DASHBOARD_MAP = {
            "DEFAULT": "پنل کاربری استاندارد", "WAREHOUSE": "داشبورد انبار",
            "PURCHASING": "داشبورد بازرگانی", "CEO": "داشبورد مدیرعامل",
            "ADMIN": "داشبورد ویژه ادمین"
        }

        self.setWindowTitle("مدیریت نقش‌ها و دسترسی‌ها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(900, 700)
        main_layout = QtWidgets.QHBoxLayout(self); splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        roles_panel = QtWidgets.QWidget(); roles_layout = QtWidgets.QVBoxLayout(roles_panel)
        roles_layout.addWidget(QtWidgets.QLabel("<b>نقش‌های سیستم</b>")); self.roles_list = QtWidgets.QListWidget()
        roles_layout.addWidget(self.roles_list)
        roles_btn_layout = QtWidgets.QHBoxLayout()
        btn_add_role = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " نقش جدید"); btn_del_role = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف نقش")
        roles_btn_layout.addWidget(btn_add_role); roles_btn_layout.addWidget(btn_del_role)
        roles_layout.addLayout(roles_btn_layout); splitter.addWidget(roles_panel)

        details_panel = QtWidgets.QWidget(); details_layout = QtWidgets.QVBoxLayout(details_panel)
        self.details_title = QtWidgets.QLabel("<b>جزئیات (یک نقش را انتخاب کنید)</b>"); details_layout.addWidget(self.details_title)
        
        self.details_tabs = QtWidgets.QTabWidget()
        self.details_tabs.setStyleSheet("QTabBar::tab { min-width: 150px; padding: 10px; }")
        details_layout.addWidget(self.details_tabs)
        
        props_widget = QtWidgets.QWidget(); props_layout = QtWidgets.QFormLayout(props_widget)
        self.role_name_edit = QtWidgets.QLineEdit()
        props_layout.addRow("نام نقش:", self.role_name_edit)
        
        self.dashboard_table = QtWidgets.QTableWidget(len(self.DASHBOARD_MAP), 2)
        self.dashboard_table.verticalHeader().hide()
        self.dashboard_table.setHorizontalHeaderLabels(["نام داشبورد", "دسترسی دارد؟"])
        self.dashboard_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
        for r, (key, name) in enumerate(self.DASHBOARD_MAP.items()):
            name_item = QtWidgets.QTableWidgetItem(name); name_item.setData(Qt.UserRole, key)
            name_item.setFlags(name_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.dashboard_table.setItem(r, 0, name_item)
            
            checkbox_widget = QtWidgets.QWidget(); chk_layout = QtWidgets.QHBoxLayout(checkbox_widget)
            chk_box = QtWidgets.QCheckBox(); chk_layout.addWidget(chk_box); chk_layout.setAlignment(QtCore.Qt.AlignCenter)
            self.dashboard_table.setCellWidget(r, 1, checkbox_widget)
            self.dashboard_table.setRowHeight(r, 60)

        props_layout.addRow("داشبوردهای قابل دسترس:", self.dashboard_table)
        self.details_tabs.addTab(props_widget, "مشخصات و داشبوردها")

        perms_widget = QtWidgets.QWidget(); perms_widget_layout = QtWidgets.QVBoxLayout(perms_widget)
        self.permissions_tree = QtWidgets.QTreeWidget(); self.permissions_tree.setHeaderHidden(True)
        perms_widget_layout.addWidget(self.permissions_tree)
        self.details_tabs.addTab(perms_widget, "دسترسی‌ها")
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره تغییرات برای این نقش"); btn_save.setProperty("class", "primary")
        details_layout.addWidget(btn_save)
        splitter.addWidget(details_panel); splitter.setSizes([250, 650])

        self.roles_list.itemSelectionChanged.connect(self.on_role_selected)
        self.permissions_tree.itemChanged.connect(self.on_permission_toggled)
        btn_add_role.clicked.connect(self._add_role)
        btn_del_role.clicked.connect(self._delete_role)
        btn_save.clicked.connect(self._save_role_changes)

        self._populate_permissions_tree()
        self._load_roles()

    def _populate_permissions_tree(self):
        self.permissions_tree.clear()
        self.permissions_tree.blockSignals(True)
        all_perms_map = {p['code']: p for p in self.db.get_all_permissions()}
        
        parent_keys_ordered = list(self.PERMISSION_HIERARCHY.keys())

        for parent_code in parent_keys_ordered:
            if parent_code in self.PERMISSION_HIERARCHY and parent_code in all_perms_map:
                perm_data = all_perms_map.pop(parent_code)
                display_name, child_prefixes = self.PERMISSION_HIERARCHY[parent_code]
                
                parent_item = QtWidgets.QTreeWidgetItem(self.permissions_tree, [display_name])
                font = parent_item.font(0); font.setBold(True); font.setPointSize(11); parent_item.setFont(0, font)
                parent_item.setData(0, QtCore.Qt.UserRole, perm_data)
                parent_item.setToolTip(0, f"{perm_data['description']}\nکد: {perm_data['code']}")
                parent_item.setFlags(parent_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                parent_item.setCheckState(0, QtCore.Qt.Unchecked)

                children_to_add = []
                for prefix in child_prefixes:
                    matching_codes = [code for code in all_perms_map.keys() if code.startswith(prefix)]
                    for code in matching_codes:
                        children_to_add.append(all_perms_map[code])
                
                for perm in children_to_add:
                    if perm['code'] in all_perms_map:
                        del all_perms_map[perm['code']]

                for child_perm in sorted(children_to_add, key=lambda x: x['description']):
                    child_item = QtWidgets.QTreeWidgetItem(parent_item, [child_perm['description']])
                    child_item.setData(0, QtCore.Qt.UserRole, child_perm)
                    child_item.setToolTip(0, f"کد: {child_perm['code']}")
                    child_item.setFlags(child_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                    child_item.setCheckState(0, QtCore.Qt.Unchecked)
                    child_item.setDisabled(True)

        self.permissions_tree.expandAll()
        self.permissions_tree.blockSignals(False)

    def _load_roles(self):
        self.roles_list.blockSignals(True)
        self.roles_list.clear()
        roles = self.db.get_all_roles()
        for role in roles:
            item = QtWidgets.QListWidgetItem(role['name']); item.setData(Qt.UserRole, role)
            self.roles_list.addItem(item)
        self.roles_list.blockSignals(False)
        self._clear_fields()

    def on_role_selected(self):
        self.details_tabs.setEnabled(True)
        self.permissions_tree.blockSignals(True)
        selected_items = self.roles_list.selectedItems()
        if not selected_items: self._clear_fields(); return
            
        role_data = selected_items[0].data(Qt.UserRole)
        self.current_role_id = role_data['id']
        role_name = role_data['name']
        
        self.details_title.setText(f"<b>جزئیات نقش: {role_name}</b>")
        self.role_name_edit.setText(role_name)

        is_admin_role = (role_name == 'Admin')
        self.role_name_edit.setReadOnly(is_admin_role)
        self.dashboard_table.setEnabled(not is_admin_role)
        self.permissions_tree.setEnabled(not is_admin_role)
        
        current_dashboards = {d['dashboard_key'] for d in self.db.execute_query("SELECT dashboard_key FROM role_dashboards WHERE role_id = %s", (self.current_role_id,))}
        for r in range(self.dashboard_table.rowCount()):
            key = self.dashboard_table.item(r, 0).data(Qt.UserRole)
            chk_box = self.dashboard_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            chk_box.setChecked(key in current_dashboards)

        current_perm_ids = set(self.db.get_permissions_for_role(self.current_role_id))
        
        iterator = QtWidgets.QTreeWidgetItemIterator(self.permissions_tree)
        while iterator.value():
            item = iterator.value()
            perm_data = item.data(0, QtCore.Qt.UserRole)
            if perm_data:
                is_checked = perm_data['id'] in current_perm_ids
                item.setCheckState(0, QtCore.Qt.Checked if is_checked else QtCore.Qt.Unchecked)
                if item.parent():
                    is_parent_checked = item.parent().checkState(0) == QtCore.Qt.Checked
                    item.setDisabled(not is_parent_checked)
            iterator += 1
            
        self.permissions_tree.blockSignals(False)

    def on_permission_toggled(self, item, column):
        if column == 0:
            is_checked = item.checkState(0) == QtCore.Qt.Checked
            self.permissions_tree.blockSignals(True)
            for i in range(item.childCount()):
                child = item.child(i)
                child.setDisabled(not is_checked)
                if not is_checked: child.setCheckState(0, QtCore.Qt.Unchecked)
            parent = item.parent()
            if parent and is_checked: parent.setCheckState(0, QtCore.Qt.Checked)
            self.permissions_tree.blockSignals(False)
    
    def _add_role(self):
        self._clear_fields()
        self.details_tabs.setEnabled(True)
        self.role_name_edit.setFocus()
        if self.toast: self.toast.show_message("اطلاعات نقش جدید را وارد کرده و ذخیره کنید.", "info")

    def _delete_role(self):
        selected = self.roles_list.selectedItems()
        if not selected: return
        role_data = selected[0].data(Qt.UserRole)
        role_id, role_name = role_data['id'], role_data['name']

        if role_name == 'Admin':
            QtWidgets.QMessageBox.warning(self, "عملیات غیرمجاز", "نقش 'Admin' قابل حذف نیست.")
            return

        users_in_role = self.db.check_role_in_use(role_id)
        if users_in_role:
            user_list_str = "\n - ".join(users_in_role)
            QtWidgets.QMessageBox.warning(self, "عملیات ناموفق", f"این نقش به کاربران زیر تخصیص یافته و قابل حذف نیست:\n\n{user_list_str}")
            return

        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف نقش «{role_name}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes: self.db.delete_role(role_id); self._load_roles()

    def _save_role_changes(self):
        name = self.role_name_edit.text().strip()
        if not name:
            if self.toast: self.toast.show_message("نام نقش نمی‌تواند خالی باشد.", "error"); return
        
        role_id = self.current_role_id
        
        dashboard_keys = []
        for r in range(self.dashboard_table.rowCount()):
            chk_box = self.dashboard_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            if chk_box.isChecked():
                dashboard_keys.append(self.dashboard_table.item(r, 0).data(Qt.UserRole))
        
        permission_ids = []
        iterator = QtWidgets.QTreeWidgetItemIterator(self.permissions_tree)
        while iterator.value():
            item = iterator.value()
            if item.checkState(0) == QtCore.Qt.Checked:
                perm_data = item.data(0, QtCore.Qt.UserRole)
                if perm_data: permission_ids.append(perm_data['id'])
            iterator += 1
        
        try:
            self.db.save_role_details(role_id, name, permission_ids, dashboard_keys)
            if self.toast: self.toast.show_message(f"✔ نقش '{name}' با موفقیت ذخیره شد.", "success")
            self._load_roles()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی نقش: {e}")

    def _clear_fields(self):
        self.roles_list.clearSelection()
        self.current_role_id = None
        self.role_name_edit.setReadOnly(False); self.role_name_edit.clear()
        self.permissions_tree.setEnabled(False)
        self.details_tabs.setEnabled(False)
        self.details_title.setText("<b>جزئیات (یک نقش را انتخاب کنید)</b>")
        
        for r in range(self.dashboard_table.rowCount()):
            self.dashboard_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox).setChecked(False)
        
        iterator = QtWidgets.QTreeWidgetItemIterator(self.permissions_tree)
        while iterator.value():
            item = iterator.value()
            item.setCheckState(0, QtCore.Qt.Unchecked)
            if item.parent(): item.setDisabled(True)
            iterator += 1                        
                                                                                                                                    
# این کلاس کاملاً جدید را به فایل خود اضافه کنید
class ApproveVoidDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش و تایید ابطال تراکنش‌های خروج به تولید."""
    def __init__(self, db: DB, user: str, parent=None):
            super().__init__(parent)
            # user_id را از parent می‌گیریم
            self.db, self.user, self.user_id = db, user, getattr(parent, 'user_id', None)
            self.toast = getattr(parent, 'toast', None)

            self.setWindowTitle("تایید/رد ابطال تراکنش‌های تولید")
            self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(600, 400)
            layout = QtWidgets.QVBoxLayout(self)
            layout.addWidget(QtWidgets.QLabel("<b>لیست درخواست‌های ابطال که منتظر تایید یا رد شما هستند:</b>"))

            self.tbl_voids = QtWidgets.QTableWidget()
            if hasattr(parent, '_style_table'): parent._style_table(self.tbl_voids)
            layout.addWidget(self.tbl_voids)

            btn_layout = QtWidgets.QHBoxLayout()
            btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید ابطال")
            btn_approve.setProperty("class", "primary")
            btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), " رد کردن ابطال")

            btn_layout.addWidget(btn_approve); btn_layout.addWidget(btn_reject); btn_layout.addStretch()
            layout.addLayout(btn_layout)

            btn_approve.clicked.connect(self._approve_selected_void)
            btn_reject.clicked.connect(self._reject_selected_void)
            self._load_pending_voids()

    def _load_pending_voids(self):
        """لیست ابطال‌های در انتظار را از دیتابیس خوانده و در جدول نمایش می‌دهد."""
        try:
            pending_voids = self.db.get_pending_voids()
            self.tbl_voids.setRowCount(0)
            # --- اصلاح: تعداد ستون‌ها صحیح شد ---
            self.tbl_voids.setColumnCount(4)
            self.tbl_voids.setHorizontalHeaderLabels(['ID تراکنش', 'نام کالا', 'مقدار', 'نوع تراکنش اصلی'])
            self.tbl_voids.setRowCount(len(pending_voids))

            for r, trans in enumerate(pending_voids):
                self.tbl_voids.setItem(r, 0, QtWidgets.QTableWidgetItem(str(trans['id'])))
                self.tbl_voids.setItem(r, 1, QtWidgets.QTableWidgetItem(trans['item_name']))
                self.tbl_voids.setItem(r, 2, NumericTableWidgetItem(str(trans['qty'])))
                self.tbl_voids.setItem(r, 3, QtWidgets.QTableWidgetItem(str(trans['original_type'])))
            
            self.tbl_voids.resizeColumnsToContents()
            self.tbl_voids.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            self.tbl_voids.setColumnHidden(0, True)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست: {e}", "critical")

    def _approve_selected_void(self):
        """ابطال انتخاب شده را پس از تایید نهایی، در دیتابیس اعمال می‌کند."""
        selected_rows = self.tbl_voids.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً یک ردیف را برای تایید انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        trans_id = int(self.tbl_voids.item(row, 0).text())
        item_name = self.tbl_voids.item(row, 1).text()

        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی",
            f"آیا از تایید ابطال تراکنش برای کالای '{item_name}' و بازگرداندن موجودی آن به انبار اصلی مطمئنید؟",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)

        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # --- اصلاح کلیدی در این خط انجام شده است ---
                # به جای self.user (رشته متنی)، از self.user_id (عدد صحیح) استفاده می‌کنیم
                self.db.approve_void_transaction(trans_id, self.user_id)
                if self.toast: self.toast.show_message("✔ ابطال با موفقیت تایید و موجودی اصلاح شد.", "success")
                self._load_pending_voids()
                if hasattr(self.parent(), 'refresh_all'):
                    self.parent().refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند تایید با خطا مواجه شد:\n{e}")
                
    def _reject_selected_void(self):
            """درخواست ابطال انتخاب شده را رد می‌کند."""
            selected_rows = self.tbl_voids.selectionModel().selectedRows()
            if not selected_rows:
                if self.toast: self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
                return

            reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد درخواست ابطال", "چرا با ابطال این تراکنش موافق نیستید؟")
            if ok and reason:
                row = selected_rows[0].row()
                trans_id = int(self.tbl_voids.item(row, 0).text())
                try:
                    self.db.reject_void_transaction(trans_id, self.user_id, reason)
                    if self.toast: self.toast.show_message("✖ درخواست ابطال رد شد و تراکنش به حالت عادی بازگشت.", "info")
                    self._load_pending_voids()
                    if hasattr(self.parent(), 'refresh_all'): self.parent().refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")                
class ApproveMaterialTransferDialog(QtWidgets.QDialog):
    """
    نسخه 2.0:
    - بهبود یافته با قابلیت رد کردن درخواست تحویل.
    - استفاده از ساختار استاندارد برنامه.
    """
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.toast = db, user_id, getattr(parent, 'toast', None)

        self.setWindowTitle("تایید/رد دریافت مواد اولیه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(750, 500)
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("<b>موارد زیر از انبار ارسال شده و منتظر تایید دریافت شما هستند:</b>"))

        self.tbl_transfers = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'): parent._style_table(self.tbl_transfers)
        layout.addWidget(self.tbl_transfers)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید دریافت موارد انتخاب شده")
        btn_approve.setProperty("class", "primary")
        
        btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), " رد کردن درخواست")
        btn_reject.setProperty("class", "danger")

        btn_layout.addStretch()
        btn_layout.addWidget(btn_reject)
        btn_layout.addWidget(btn_approve)
        layout.addLayout(btn_layout)

        btn_approve.clicked.connect(self._approve_selected)
        btn_reject.clicked.connect(self._reject_selected)
        self._load_pending_transfers()

    def _load_pending_transfers(self):
        # این متد بدون تغییر باقی می‌ماند چون منطق درستی دارد
        try:
            transfers = self.db.get_pending_transfers_to_production()
            self.tbl_transfers.setRowCount(0)
            self.tbl_transfers.setColumnCount(6)
            self.tbl_transfers.setHorizontalHeaderLabels(['ID تراکنش', 'نام کالا', 'شماره بچ', 'مقدار', 'کاربر فرستنده', 'تاریخ ارسال'])
            
            self.tbl_transfers.setRowCount(len(transfers))
            for r, trans in enumerate(transfers):
                self.tbl_transfers.setItem(r, 0, QtWidgets.QTableWidgetItem(str(trans['id'])))
                self.tbl_transfers.setItem(r, 1, QtWidgets.QTableWidgetItem(trans['item_name']))
                self.tbl_transfers.setItem(r, 2, QtWidgets.QTableWidgetItem(trans.get('batch_no', '')))
                self.tbl_transfers.setItem(r, 3, NumericTableWidgetItem(str(trans['qty'])))
                self.tbl_transfers.setItem(r, 4, QtWidgets.QTableWidgetItem(trans['requester']))
                self.tbl_transfers.setItem(r, 5, QtWidgets.QTableWidgetItem(to_shamsi(trans['t_date'])))
            
            self.tbl_transfers.setColumnHidden(0, True)
            self.tbl_transfers.resizeColumnsToContents()
            self.tbl_transfers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست: {e}", "critical")

    # داخل کلاس ApproveMaterialTransferDialog

    def _gate(self, table_name: str, record_id: int, transition_status: str) -> bool:
        """گِیت QA مستقل برای دیالوگ (اگر MainWindow متدش را داشت، از همان استفاده می‌کند)."""
        parent_gate = getattr(self.parent(), '_qa_gate_or_block', None)
        if callable(parent_gate):
            return parent_gate(table_name, record_id, transition_status)

        # fallback محلی
        try:
            ok, errs = self.db.check_qa_gates(table_name, record_id, transition_status)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "گِیت کیفیت", f"بررسی گِیت با خطا مواجه شد:\n{e}")
            return False
        if ok: 
            return True
        msg = "برای انجام این عملیات، موارد زیر باید تکمیل شوند:\n\n- " + "\n- ".join(errs)
        QtWidgets.QMessageBox.warning(self, "گِیت کیفیت", msg)
        return False

    def _approve_selected(self):
        """تایید دریافت مواد اولیه (با گِیت QA قبل از هر مورد)."""
        selected_rows = self.tbl_transfers.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً یک یا چند ردیف را برای تایید انتخاب کنید.", "warning")
            return

        approved_count = 0
        for row in selected_rows:
            trans_id = int(self.tbl_transfers.item(row.row(), 0).text())

            # گِیت QA: قبل از APPROVED شدن رکورد trans
            if not self._gate('trans', trans_id, 'APPROVED'):
                continue  # این مورد خاص رد می‌شود ولی بقیه ادامه می‌یابد

            try:
                self.db.finalize_transfer_to_production(trans_id, self.user_id)
                approved_count += 1
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند تایید برای تراکنش #{trans_id} با خطا مواجه شد:\n{e}")

        if approved_count > 0:
            if self.toast: self.toast.show_message(f"✔ تعداد {approved_count} مورد با موفقیت دریافت و به موجودی تولید اضافه شد.", "success")
            self._load_pending_transfers()
            if hasattr(self.parent(), 'refresh_all'): self.parent().refresh_all()
    
# در کلاس ApproveMaterialTransferDialog
    def _reject_selected(self):
        """منطق جدید برای رد کردن درخواست تحویل"""
        selected_rows = self.tbl_transfers.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
            return
        
        # فقط اولین آیتم انتخاب شده را رد می‌کنیم تا از پیچیدگی جلوگیری شود
        row = selected_rows[0].row()
        trans_id = int(self.tbl_transfers.item(row, 0).text())
        item_name = self.tbl_transfers.item(row, 1).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کردن", f"چرا درخواست تحویل کالای «{item_name}» را رد می‌کنید؟")
        if not ok or not reason.strip():
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")
            return

        try:
            # --- اصلاح کلیدی اینجاست ---
            # حالا تابع صحیح دیتابیس را که قبلا اصلاح کردیم، فراخوانی می‌کنیم
            self.db.reject_raw_material_transfer(trans_id, self.user_id, reason)
            
            self.toast.show_message("درخواست با موفقیت رد و به انبار اطلاع داده شد.", "success")
            self._load_pending_transfers()
            if hasattr(self.parent(), 'refresh_all'): self.parent().refresh_all()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")                                            
                    
# کلاس RequestMaterialDialog را به طور کامل با این نسخه جایگزین کنید

class RequestMaterialDialog(QtWidgets.QDialog):
    """
    نسخه 2.0:
    - دارای فیلتر برای نمایش جداگانه مواد اولیه و لوازم بسته‌بندی.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("درخواست مواد/لوازم از انبار")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)
        
        layout = QtWidgets.QVBoxLayout(self) # استفاده از QVBoxLayout برای چیدمان بهتر
        form_layout = QtWidgets.QFormLayout()
        form_layout.setSpacing(15)

        # --- بخش جدید: دکمه‌های رادیویی برای فیلتر ---
        filter_group = QtWidgets.QGroupBox("نوع درخواست را مشخص کنید")
        filter_layout = QtWidgets.QHBoxLayout(filter_group)
        self.radio_raw = QtWidgets.QRadioButton("مواد اولیه")
        self.radio_packaging = QtWidgets.QRadioButton("لوازم بسته‌بندی")
        self.radio_raw.setChecked(True) # پیش‌فرض روی مواد اولیه
        filter_layout.addWidget(self.radio_raw)
        filter_layout.addWidget(self.radio_packaging)
        layout.addWidget(filter_group)
        
        self.item_combo = QtWidgets.QComboBox()
        self.item_combo.setEditable(True)
        self.item_combo.setCompleter(QtWidgets.QCompleter(self.item_combo.model()))
        
        self.qty_edit = QtWidgets.QLineEdit()
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, 1e9, 3))
        self.qty_edit.setPlaceholderText("مقدار مورد نیاز را وارد کنید...")
        
        form_layout.addRow("انتخاب کالا:", self.item_combo)
        form_layout.addRow("مقدار:", self.qty_edit)
        layout.addLayout(form_layout)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت درخواست")
        buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        # اتصال سیگنال دکمه‌های رادیویی به متد بارگذاری مجدد
        self.radio_raw.toggled.connect(self._populate_items)
        # اولین بار به صورت دستی فراخوانی می‌شود
        self._populate_items()

    def _populate_items(self):
        """لیست کالاها را بر اساس دسته‌بندی انتخاب شده، فیلتر و بارگذاری می‌کند."""
        self.item_combo.clear()
        
        category_filter = 'مواد اولیه' if self.radio_raw.isChecked() else 'لوازم بسته‌بندی'
        
        try:
            query = "SELECT id, name FROM items WHERE category = %s ORDER BY name"
            all_requestable_items = self.db.execute_query(query, (category_filter,))
            
            if not all_requestable_items:
                self.item_combo.addItem(f"هیچ کالایی در دسته «{category_filter}» یافت نشد.", -1)
                self.item_combo.setEnabled(False)
            else:
                self.item_combo.setEnabled(True)
                for item in all_requestable_items:
                    self.item_combo.addItem(item['name'], item['id'])
        except Exception as e:
            print(f"Error populating materials for request dialog: {e}")

    def get_request_data(self):
        """اطلاعات درخواست (ID کالا و مقدار) را برمی‌گرداند."""
        try:
            item_id = self.item_combo.currentData()
            quantity = float(self.qty_edit.text())
            if item_id != -1 and quantity > 0:
                return {'item_id': item_id, 'quantity': quantity, 'item_name': self.item_combo.currentText()}
        except (ValueError, TypeError):
            pass
        return None    
    
# این کلاس را به طور کامل جایگزین کنید
class AddAssetDialog(QtWidgets.QDialog):
    """دیالوگ کامل برای افزودن یا ویرایش یک دارایی جدید با فرمت‌بندی قیمت."""
    def __init__(self, db: DB, asset_data=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تعریف/ویرایش دارایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)
        
        layout = QtWidgets.QFormLayout(self)
        self.e_code = QtWidgets.QLineEdit()
        self.e_name = QtWidgets.QLineEdit()
        self.e_brand = QtWidgets.QLineEdit()
        self.e_model = QtWidgets.QLineEdit()
        self.e_cost = QtWidgets.QDoubleSpinBox()
        self.e_cost.setRange(0, 1e12)
        self.e_cost.setDecimals(0)
        self.e_cost.setGroupSeparatorShown(True) # <<< این خط فرمت‌بندی را اعمال می‌کند
        
        layout.addRow("کد دارایی (منحصر به فرد):", self.e_code)
        layout.addRow("نام دارایی:", self.e_name)
        layout.addRow("برند:", self.e_brand)
        layout.addRow("مدل:", self.e_model)
        layout.addRow("ارزش ریالی:", self.e_cost)

        if asset_data:
            self.e_code.setText(asset_data.get('code', ''))
            self.e_name.setText(asset_data.get('name', ''))
            self.e_brand.setText(asset_data.get('brand', ''))
            self.e_model.setText(asset_data.get('model', ''))
            self.e_cost.setValue(asset_data.get('cost', 0))
            self.e_code.setReadOnly(True)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        code = self.e_code.text().strip()
        name = self.e_name.text().strip()
        if code and name:
            return {'code': code, 'name': name, 'brand': self.e_brand.text().strip(), 'model': self.e_model.text().strip(), 'cost': self.e_cost.value()}
        return None
    
        
        
    
class AssetAttachDialog(QtWidgets.QDialog):
    """دیالوگ مدیریت پیوست‌ها برای تراکنش‌های دارایی."""
    def __init__(self, db: DB, asset_trans_id: int, parent=None):
        super().__init__(parent)
        self.db, self.tid = db, asset_trans_id
        self.setWindowTitle('پیوست‌های تراکنش دارایی')
        self.resize(380, 320)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        v = QtWidgets.QVBoxLayout(self)
        self.lst = QtWidgets.QListWidget(); v.addWidget(self.lst)

        btn_row = QtWidgets.QHBoxLayout(); v.addLayout(btn_row)
        btn_scan = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("scanner"), " اسکن"); btn_row.addWidget(btn_scan)
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("add"), " افزودن فایل"); btn_row.addWidget(btn_add)
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("delete"), " حذف"); btn_row.addWidget(btn_del)
        btn_row.addStretch(); btn_close = QtWidgets.QPushButton('بستن'); btn_row.addWidget(btn_close)

        self.lst.itemDoubleClicked.connect(lambda itm: QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(itm.data(Qt.UserRole))))
        
        btn_scan.clicked.connect(self._scan_and_add)
        btn_add.clicked.connect(self._add)
        btn_del.clicked.connect(self._delete)
        btn_close.clicked.connect(self.accept)

        self._load()

    def _load(self):
        self.lst.clear()
        for rec in self.db.list_asset_files(self.tid):
            itm = QtWidgets.QListWidgetItem(Path(rec['path']).name)
            itm.setData(Qt.UserRole, rec['path'])
            itm.setData(Qt.UserRole+1, rec['id'])
            self.lst.addItem(itm)

    def _add(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if path:
            self.db.add_asset_file(self.tid, path); self._load()
    
    def _scan_and_add(self):
        scanned_file_path = scan_document(self)
        if scanned_file_path:
            self.db.add_asset_file(self.tid, scanned_file_path); self._load()

    def _delete(self):
        itm = self.lst.currentItem()
        if not itm: return
        fid = itm.data(Qt.UserRole+1)
        if QtWidgets.QMessageBox.question(self, 'حذف', 'مطمئن؟') != QtWidgets.QMessageBox.Yes: return
        self.db.delete_asset_file(fid); self._load()

class AssetExitDialog(QtWidgets.QDialog):
    """نسخه نهایی و کامل دیالوگ خروج دارایی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent 
        self.setWindowTitle("ثبت خروج دارایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        main_layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        form_layout.setSpacing(15)
        main_layout.addLayout(form_layout)

        self.asset_combo = QtWidgets.QComboBox()
        self.doc_no_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QLineEdit()
        
        form_layout.addRow("انتخاب دارایی:", self.asset_combo)
        form_layout.addRow("شماره سند/حواله:", self.doc_no_edit)
        form_layout.addRow("توضیحات:", self.notes_edit)

        mgmt_layout = QtWidgets.QHBoxLayout()
        btn_add_asset = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " تعریف دارایی جدید")
        btn_add_asset.clicked.connect(self._add_new_asset)
        mgmt_layout.addWidget(btn_add_asset)
        mgmt_layout.addStretch()
        main_layout.addLayout(mgmt_layout)

        self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ادامه و افزودن پیوست")
        self.buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        main_layout.addWidget(self.buttons)

        self._load_assets()

    def _load_assets(self):
        current_selection = self.asset_combo.currentData()
        self.asset_combo.clear()
        assets = self.db.list_assets_in_stock()
        ok_button = self.buttons.button(QtWidgets.QDialogButtonBox.Ok)
        if not assets:
            self.asset_combo.addItem("هیچ دارایی در انبار برای خروج وجود ندارد.", -1)
            if ok_button: ok_button.setEnabled(False)
        else:
            if ok_button: ok_button.setEnabled(True)
            for asset in assets:
                self.asset_combo.addItem(f"{asset['code']} - {asset['name']}", asset['id'])
            if current_selection:
                index = self.asset_combo.findData(current_selection)
                if index != -1: self.asset_combo.setCurrentIndex(index)

    def _add_new_asset(self):
        dlg = AddAssetDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data and self.parent_window and hasattr(self.parent_window, 'user_id'):
                try:
                    self.db.add_asset(data['code'], data['name'], user_id=self.parent_window.user_id)
                    self._load_assets()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"دارایی با این کد از قبل موجود است یا خطای دیگری رخ داد.\n{e}")

    def get_data(self):
        doc_no = self.doc_no_edit.text().strip()
        if not doc_no:
            QtWidgets.QMessageBox.warning(self, "خطای ورودی", "وارد کردن شماره سند الزامی است.")
            return None
        if self.asset_combo.currentData() == -1: return None
        return {
            "asset_id": self.asset_combo.currentData(),
            "doc_no": doc_no,
            "notes": self.notes_edit.text(),
        }


# کلاس SelectAssetDialog را به طور کامل با این نسخه جایگزین کنید

class SelectAssetDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب یک دارایی از لیست فیلتر شده بر اساس وضعیت."""
    def __init__(self, db: DB, title: str, status_filter: list, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(title)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400) # عرض بیشتر برای نمایش پیام
        
        layout = QtWidgets.QFormLayout(self)
        self.asset_combo = QtWidgets.QComboBox()
        self.asset_combo.setEditable(True) # قابلیت جستجو
        self.asset_combo.setCompleter(QtWidgets.QCompleter(self.asset_combo.model()))
        layout.addRow("انتخاب دارایی:", self.asset_combo)
        
        placeholders = ','.join(['%s'] * len(status_filter))
        query = f"SELECT id, code, name FROM assets WHERE status IN ({placeholders}) ORDER BY name"
        assets = self.db.execute_query(query, tuple(status_filter))
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)
        
        # --- اصلاح کلیدی: منطق هوشمند برای نمایش پیام ---
        if not assets:
            # اگر هیچ دارایی یافت نشد، یک پیام راهنما نمایش داده و دکمه OK را غیرفعال کن
            status_text = ' یا '.join(status_filter)
            self.asset_combo.addItem(f"هیچ دارایی با وضعیت '{status_text}' یافت نشد.", -1)
            self.asset_combo.setEnabled(False)
            buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
        else:
            # در غیر این صورت، لیست دارایی‌ها را پر کن
            for asset in assets:
                self.asset_combo.addItem(f"{asset['code']} - {asset['name']}", asset['id'])

    def get_selected_asset_id(self):
        return self.asset_combo.currentData()    
    
# این کلاس جدید را به فایل کد خود اضافه کنید

class TemporaryExitDialog(QtWidgets.QDialog):
    """دیالوگ برای ثبت خروج موقت یک دارایی."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ثبت خروج موقت دارایی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        layout = QtWidgets.QFormLayout(self)
        self.reason_combo = QtWidgets.QComboBox()
        self.reason_combo.addItems(["خروج (تعمیرات)", "خروج (پروژه)"])
        self.doc_no_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QLineEdit()
        layout.addRow("دلیل خروج:", self.reason_combo)
        layout.addRow("شماره سند/مجوز:", self.doc_no_edit)
        layout.addRow("توضیحات:", self.notes_edit)
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        return {
            "t_type": self.reason_combo.currentText(),
            "t_no": self.doc_no_edit.text(),
            "notes": self.notes_edit.text()
        }
        
        
# این کلاس کاملاً جدید را به فایل کد خود اضافه کنید
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class BarcodeLabelDialog(QtWidgets.QDialog):
    """
    نسخه نهایی: دیالوگی برای تولید و نمایش لیبل بارکد خوانا و کامل.
    - نام کالا (فارسی/انگلیسی) را به درستی در بالا نمایش می‌دهد.
    - کد عددی را همیشه در پایین بارکد نمایش می‌دهد.
    - نیازمند وجود فایل فونت در کنار اسکریپت است.
    """
    def __init__(self, item_name: str, item_id: str, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"لیبل بارکد برای: {item_name}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(350)

        layout = QtWidgets.QVBoxLayout(self)
        
        self.label_widget = QtWidgets.QLabel("در حال تولید بارکد...")
        self.label_widget.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.label_widget)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " ذخیره لیبل (جهت چاپ)")
        btn_save.clicked.connect(self.save_label)
        layout.addWidget(btn_save)

        self.barcode_image_bytes = self._generate_barcode(item_id, item_name)
        
        if self.barcode_image_bytes:
            pixmap = QPixmap()
            pixmap.loadFromData(self.barcode_image_bytes)
            self.label_widget.setPixmap(pixmap.scaledToWidth(300, Qt.SmoothTransformation))
        else:
            btn_save.setEnabled(False)

    def _prepare_text(self, text: str):
        """متن را برای نمایش صحیح (فارسی/انگلیسی) آماده می‌کند."""
        import re
        # اگر حتی یک کاراکتر فارسی در متن وجود داشت، عملیات فارسی‌سازی را انجام بده
        if re.search(r'[\u0600-\u06FF]', text):
            from bidi.algorithm import get_display
            from arabic_reshaper import reshape
            reshaped_text = reshape(text)
            return get_display(reshaped_text, base_dir='R')
        # در غیر این صورت، متن اصلی (انگلیسی) را برگردان
        return text

# در کلاس BarcodeLabelDialog، این متد را با نسخه جدید جایگزین کنید
    def _generate_barcode(self, item_id: str, item_name: str):
        """بارکد Code128 را با استفاده از فونت‌های استاندارد ویندوز تولید می‌کند."""
        try:
            import barcode
            from barcode.writer import ImageWriter
            from io import BytesIO
            from PIL import Image, ImageDraw, ImageFont
            from bidi.algorithm import get_display
            from arabic_reshaper import reshape

            code128 = barcode.get_barcode_class('code128')
            
            # ۱. تولید بارکد با نمایش اجباری متن (کد عددی)
            writer_options = {'write_text': True, 'module_height': 12.0, 'font_size': 14, 'text_distance': 5.0}
            buffer = BytesIO()
            code128(item_id, writer=ImageWriter()).write(buffer, writer_options)
            buffer.seek(0)
            barcode_img = Image.open(buffer)

            # ۲. ایجاد بوم (canvas) جدید برای لیبل نهایی
            text_height = 45
            padding = 15
            final_width = max(300, barcode_img.width + 40)
            final_height = barcode_img.height + text_height + padding
            final_img = Image.new('RGB', (final_width, final_height), 'white')
            draw = ImageDraw.Draw(final_img)

            # ۳. نوشتن نام محصول در بالای لیبل با فونت Tahoma
            try:
                # --- اصلاح کلیدی: استفاده مستقیم از فونت ویندوز ---
                font = ImageFont.truetype("tahoma.ttf", 22)
            except IOError:
                # جایگزین در صورت نبود فونت Tahoma (بسیار نادر)
                font = ImageFont.load_default()
            
            bidi_text = self._prepare_text(item_name)
            text_bbox = draw.textbbox((0, 0), bidi_text, font=font)
            text_width = text_bbox[2] - text_bbox[0]
            text_x = (final_img.width - text_width) / 2
            draw.text((text_x, 10), bidi_text, fill='black', font=font)
            
            # ۴. چسباندن بارکد زیر متن
            barcode_x = (final_img.width - barcode_img.width) // 2
            final_img.paste(barcode_img, (barcode_x, text_height))
            
            # ۵. ذخیره تصویر نهایی در حافظه
            final_buffer = BytesIO()
            final_img.save(final_buffer, 'PNG')
            final_buffer.seek(0)
            return final_buffer.getvalue()

        except ImportError as e:
            self.label_widget.setText(f"خطا: کتابخانه‌های لازم نصب نیستند: {e}")
            return None
        except Exception as e:
            print(f"Error generating barcode label: {e}")
            self.label_widget.setText(f"خطا در تولید لیبل: {e}")
            return None
        
        
    def save_label(self):
        """دیالوگ ذخیره فایل را باز کرده و تصویر بارکد را ذخیره می‌کند."""
        if not self.barcode_image_bytes:
            QMessageBox.warning(self, "خطا", "تصویر بارکدی برای ذخیره وجود ندارد.")
            return

        default_filename = f"Label_{self.windowTitle().split(': ')[-1]}.png"
        path, _ = QFileDialog.getSaveFileName(self, "ذخیره فایل لیبل", default_filename, "PNG Image (*.png)")
        
        if path:
            try:
                with open(path, 'wb') as f:
                    f.write(self.barcode_image_bytes)
                if hasattr(self.parent(), 'toast'):
                    self.parent().toast.show_message("✔ لیبل با موفقیت ذخیره شد.", "success")
            except Exception as e:
                QMessageBox.critical(self, "خطا در ذخیره فایل", f"خطا: {e}")
                                

# این کلاس کاملاً جدید را به فایل خود اضافه کنید
class InventoryAdjustmentDialog(QtWidgets.QDialog):
    """پنجره‌ای برای ثبت اصلاحیه‌های انبارگردانی با استفاده از PyQt5."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت سند اصلاحی موجودی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_combo = QtWidgets.QComboBox()
        self.item_combo.setEditable(True)
        self.item_combo.setCompleter(QtWidgets.QCompleter(self.item_combo.model()))

        self.location_combo = QtWidgets.QComboBox()
        
        self.counted_qty_edit = QtWidgets.QLineEdit()
        self.counted_qty_edit.setValidator(QtGui.QDoubleValidator(-1e9, 1e9, 3))

        self.reason_combo = QtWidgets.QComboBox()
        self.reason_combo.addItems(['کسری (ضایعات)', 'کسری (شمارش غلط)', 'اضافی (یافت شده)', 'اصلاح خطای کاربری', 'سایر'])

        layout.addRow("انتخاب کالا:", self.item_combo)
        layout.addRow("محل انبار:", self.location_combo)
        layout.addRow("مقدار شمارش شده (جدید):", self.counted_qty_edit)
        layout.addRow("دلیل اصلاح:", self.reason_combo)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت اصلاحیه")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)
        
        self.item_combo.currentIndexChanged.connect(self._load_locations_for_item)
        self._load_all_items()

    def _load_all_items(self):
        items = self.db.items_brief()
        for item in items:
            self.item_combo.addItem(item['name'], item)

    def _load_locations_for_item(self):
        self.location_combo.clear()
        item_data = self.item_combo.currentData()
        if not isinstance(item_data, dict): return
        
        item_id = item_data.get('id')
        locations = self.db.get_item_locations_with_stock(item_id)
        if not locations:
            self.location_combo.addItem("کالا در هیچ لوکیشنی موجودی ندارد", -1)
        else:
            for loc in locations:
                display_text = f"{loc['loc_label']} (بچ: {loc.get('batch_no', 'N/A')})"
                self.location_combo.addItem(display_text, loc)

    def get_data(self):
        try:
            item_data = self.item_combo.currentData()
            loc_data = self.location_combo.currentData()
            counted_qty_text = self.counted_qty_edit.text()
            reason = self.reason_combo.currentText()

            if not all([isinstance(item_data, dict), isinstance(loc_data, dict), reason, counted_qty_text]):
                return None
            
            return {
                'item_id': item_data['id'],
                'location_id': loc_data['id'],
                'batch_no': loc_data.get('batch_no', 'default_adj_batch'),
                'counted_qty': float(counted_qty_text),
                'reason': reason
            }
        except (ValueError, TypeError):
            return None
        
# این کلاس را به طور کامل با نسخه زیر جایگزین کنید

# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class DetailedStockViewDialog(QtWidgets.QDialog):
    """
    نسخه نهایی (V4.0) پنجره جزئیات کامل موجودی
    ***اصلاح کلیدی: ستون "وضعیت" به جدول اضافه شد.***
    """
    def __init__(self, db: DB, item_data: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.item_data = item_data
        self.parent_window = parent

        self.setWindowTitle(f"جزئیات کامل موجودی: {self.item_data.get('name')}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(800, 600)

        layout = QtWidgets.QVBoxLayout(self)

        # ... (بخش نوار ابزار بدون تغییر باقی می‌ماند) ...
        tools_layout = QtWidgets.QHBoxLayout()
        filter_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), "فیلتر پیشرفته")
        reset_filter_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "ریست فیلتر")
        export_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "خروجی اکسل")
        tools_layout.addStretch(); tools_layout.addWidget(filter_btn); tools_layout.addWidget(reset_filter_btn); tools_layout.addWidget(export_btn)
        layout.addLayout(tools_layout)

        self.tree = QtWidgets.QTreeWidget()
        self.tree.setObjectName("details_tree")
        # --- *** هدر جدید با ستون وضعیت *** ---
        self.tree.setHeaderLabels(['انبار / بچ', 'تاریخ انقضا', 'وضعیت', 'موجودی', 'واحد'])
        header = self.tree.header()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, 5):
            header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)

        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self._show_context_menu)

        layout.addWidget(self.tree)

        filter_btn.clicked.connect(lambda: FilterDialog(self.tree, self).exec_())
        reset_filter_btn.clicked.connect(self._reset_tree_filter)
        export_btn.clicked.connect(lambda: export_table_to_excel(self.tree, self))

        self._populate_stock_details()

    def _populate_stock_details(self):
        self.tree.clear()
        stock_details = self.db.stock_breakdown(self.item_data['id'])

        if not stock_details:
            QtWidgets.QTreeWidgetItem(self.tree, ["این کالا در انبارهای اصلی موجودی ندارد."])
            return

        locations = {}
        for row in stock_details:
            loc_label = row['loc']
            if loc_label not in locations: locations[loc_label] = []
            locations[loc_label].append(row)

        for loc_label, batches in locations.items():
            total_in_loc = sum(b['qty'] for b in batches)
            loc_item = QtWidgets.QTreeWidgetItem(self.tree)
            loc_item.setText(0, f"{loc_label}")
            loc_item.setFont(0, QFont(FONT_FAMILY, FONT_SIZE, QFont.Bold))
            loc_item.setText(3, str(total_in_loc))
            loc_item.setText(4, batches[0]['unit'])

            for batch in batches:
                expiry_text = to_shamsi(batch.get('expiry_date'))
                child_text = f"    بچ: {batch['batch_no']}"

                status_text = batch.get('status', 'نامشخص')
                child_item = QtWidgets.QTreeWidgetItem(loc_item, [child_text, expiry_text, status_text, str(batch['qty']), batch['unit']])
                child_item.setData(0, Qt.UserRole, batch)
                child_item.setToolTip(0, "برای انتقال، روی این ردیف راست‌کلیک کنید")

                # رنگ‌آمیزی بر اساس وضعیت
                if status_text == 'قرنطینه':
                    child_item.setForeground(2, QtGui.QColor("#fd7e14")) # Orange
                elif status_text == 'رد شده':
                    child_item.setForeground(2, QtGui.QColor("#dc3545")) # Red

        self.tree.expandAll()

    # (متدهای _show_context_menu, _initiate_transfer, _reset_tree_filter بدون تغییر باقی می‌مانند)
    def _show_context_menu(self, pos):
        item = self.tree.itemAt(pos)
        if not item or not item.parent(): return
        batch_data = item.data(0, Qt.UserRole)
        if not batch_data: return
        menu = QtWidgets.QMenu(self)
        transfer_action = menu.addAction(QtGui.QIcon.fromTheme("go-next"), "انتقال این بچ...")
        action = menu.exec_(self.tree.mapToGlobal(pos))
        if action == transfer_action: self._initiate_transfer(batch_data)
    def _initiate_transfer(self, batch_data: dict):
        all_locations = self.db.list_locations(exclude_warehouses=['Production'])
        dest_map = {loc['loc_label']: loc['id'] for loc in all_locations if loc['id'] != batch_data['loc_id']}
        if not dest_map: QtWidgets.QMessageBox.warning(self, "خطا", "هیچ لوکیشن مقصد معتبری یافت نشد."); return
        dest_name, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب مقصد", "این بچ را به کدام لوکیشن منتقل می‌کنید؟", dest_map.keys(), 0, False)
        if not ok or not dest_name: return
        dest_loc_id = dest_map[dest_name]
        qty, ok = QtWidgets.QInputDialog.getDouble(self, "مقدار انتقال", f"چه مقداری از موجودی ({batch_data['qty']}) را منتقل می‌کنید؟", batch_data['qty'], 0.001, batch_data['qty'], 3)
        if not ok: return
        try:
            self.db.transfer(item_id=self.item_data['id'], qty=qty, src_loc_id=batch_data['loc_id'], dest_loc_id=dest_loc_id, user_id=self.parent_window.user_id, notes=f"انتقال از پنجره جزئیات موجودی", batch_no=batch_data['batch_no'], expiry_date=batch_data.get('expiry_date'))
            self.parent_window.toast.show_message("✔ انتقال با موفقیت انجام شد.", "success"); self._populate_stock_details(); self.parent_window.refresh_all()
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"انتقال با خطا مواجه شد:\n{e}")
    def _reset_tree_filter(self):
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value(): iterator.value().setHidden(False); iterator += 1
        
                            
class MultiBatchSelectionDialog(QtWidgets.QDialog):
    """
    نسخه 2.0:
    - امکان ورود دستی مقدار برداشت برای هر بچ فراهم شده است.
    - اعتبارسنجی برای جلوگیری از برداشت بیش از موجودی اضافه شده است.
    """
    def __init__(self, item_name, needed_qty, available_batches, parent=None):
            super().__init__(parent)
            self.item_name = item_name
            self.needed_qty = needed_qty
            self.available_batches = available_batches
            self.pick_plan = []

            self.setWindowTitle(f"تخصیص بچ برای: {item_name}")
            self.setMinimumSize(600, 400)
            self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

            layout = QtWidgets.QVBoxLayout(self)
            
            info_layout = QtWidgets.QHBoxLayout()
            self.needed_label = QtWidgets.QLabel(f"مقدار مورد نیاز: <b>{self.needed_qty:.3f}</b>")
            self.selected_label = QtWidgets.QLabel("مقدار انتخاب شده: <b>0.000</b>")
            info_layout.addWidget(self.needed_label); info_layout.addStretch(); info_layout.addWidget(self.selected_label)
            layout.addLayout(info_layout)

            self.table = QtWidgets.QTableWidget()
            
            # --- اصلاح کلیدی اینجاست ---
            self.table.verticalHeader().setDefaultSectionSize(60) # ارتفاع مناسب برای ردیف‌ها
            # --- پایان اصلاح ---

            self.table.setColumnCount(4)
            self.table.setHorizontalHeaderLabels(['بچ نامبر', 'تاریخ انقضا', 'موجودی در دسترس', 'مقدار برداشت'])
            self.table.setRowCount(len(self.available_batches))

            for row, batch in enumerate(self.available_batches):
                for c, key in enumerate(['batch_no', 'expiry_date', 'qty']):
                    val = batch.get(key)
                    text = to_shamsi(val) if isinstance(val, dt.date) else str(val)
                    item = QtWidgets.QTableWidgetItem(text)
                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                    self.table.setItem(row, c, item)
                
                available_qty = batch.get('qty', 0)
                pick_edit = QtWidgets.QLineEdit("0.0")
                pick_edit.setAlignment(Qt.AlignRight)
                pick_edit.setValidator(QtGui.QDoubleValidator(0.0, available_qty, 3))
                pick_edit.textChanged.connect(self._update_totals)
                self.table.setCellWidget(row, 3, pick_edit)

            self.table.resizeColumnsToContents()
            self.table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            layout.addWidget(self.table)

            self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
            self.ok_button = self.buttons.button(QtWidgets.QDialogButtonBox.Ok)
            self.ok_button.setText("تایید تخصیص")
            self.ok_button.setEnabled(False)
            layout.addWidget(self.buttons)

            self.buttons.accepted.connect(self.accept)
            self.buttons.rejected.connect(self.reject)
            self._update_totals()
                
    def _update_totals(self):
        total_selected = 0.0
        for row in range(self.table.rowCount()):
            pick_edit = self.table.cellWidget(row, 3)
            if pick_edit:
                try:
                    total_selected += float(pick_edit.text())
                except (ValueError, TypeError):
                    pass
        
        self.selected_label.setText(f"مقدار انتخاب شده: <b>{total_selected:.3f}</b>")
        
        if abs(total_selected - self.needed_qty) < 0.001:
            self.selected_label.setStyleSheet("color: green; font-weight: bold;")
            self.ok_button.setEnabled(True)
        else:
            self.selected_label.setStyleSheet("color: red;")
            self.ok_button.setEnabled(False)

    def accept(self):
        for row in range(self.table.rowCount()):
            pick_edit = self.table.cellWidget(row, 3)
            if not pick_edit: continue
            
            try:
                pick_qty = float(pick_edit.text())
                if pick_qty > 0:
                    batch_info = self.available_batches[row]
                    # این چک اضافی لازم نیست چون Validator کارش را انجام می‌دهد، اما برای اطمینان خوب است
                    if pick_qty > batch_info['qty']:
                        QtWidgets.QMessageBox.warning(self, "خطای مقدار", f"مقدار برداشت برای بچ {batch_info['batch_no']} از موجودی آن بیشتر است.")
                        return 
                    
                    self.pick_plan.append({
                        'item_id': batch_info['item_id'],
                        'batch_no': batch_info['batch_no'],
                        'qty_to_consume': pick_qty,
                        'expiry_date': batch_info.get('expiry_date')
                    })
            except (ValueError, TypeError):
                continue
        
        super().accept()
        
        
# این کلاس را به طور کامل با نسخه هوشمند زیر جایگزین کنید
class DeliverFinishedGoodDialog(QtWidgets.QDialog):
    """
    نسخه نهایی:
    - پس از انتخاب بچ، به صورت خودکار سفارش تولید مرتبط را پیدا می‌کند.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("اعلام آمادگی تحویل محصول به انبار")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(800, 500)

        self.prod_loc_id = self.db.get_production_floor_location()
        if not self.prod_loc_id:
            QtWidgets.QMessageBox.critical(self, "خطا", "انبار تولید در سیستم تعریف نشده است.")
            QtCore.QTimer.singleShot(0, self.reject)
            return

        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("یک بچ را از لیست زیر انتخاب کرده و مقدار تحویلی را مشخص کنید:"))
        self.products_table = QtWidgets.QTableWidget(); self._style_table(self.products_table); layout.addWidget(self.products_table)
        form_layout = QtWidgets.QFormLayout(); self.qty_edit = QtWidgets.QLineEdit("0.0"); form_layout.addRow("مقدار تحویلی:", self.qty_edit); layout.addLayout(form_layout)
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel); buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت درخواست تحویل"); buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject); layout.addWidget(buttons)
        self.products_table.itemSelectionChanged.connect(self._on_item_selected)
        self._populate_deliverable_items()

    def _style_table(self, table):
        table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows); table.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection); table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers); table.setAlternatingRowColors(True)

    def _populate_deliverable_items(self):
        self.products_table.setRowCount(0)
        items = self.db.get_finished_goods_at_location(self.prod_loc_id, packed_only=True)
        
        headers = ["محصول مادر", "مشخصات پک", "شماره بچ", "موجودی در کارگاه", "تاریخ انقضا"]
        self.products_table.setColumnCount(len(headers)); self.products_table.setHorizontalHeaderLabels(headers)
        
        self.products_table.setRowCount(len(items))
        for r, item in enumerate(items):
            item_data = dict(item)
            parent_name = "نامشخص"
            if item_data.get('parent_item_id'):
                parent_info = self.db.get_item_details(item_data['parent_item_id'])
                if parent_info: parent_name = parent_info.get('name', 'نامشخص')
            
            parent_name_item = QtWidgets.QTableWidgetItem(parent_name)
            parent_name_item.setData(Qt.UserRole, item_data)
            
            self.products_table.setItem(r, 0, parent_name_item)
            self.products_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item_data['name']))
            self.products_table.setItem(r, 2, QtWidgets.QTableWidgetItem(item_data['batch_no']))
            self.products_table.setItem(r, 3, NumericTableWidgetItem(str(item_data['qty'])))
            self.products_table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(item_data.get('expiry_date'))))
        
        self.products_table.resizeColumnsToContents()
        self.products_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.products_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(self.products_table, "هیچ محصول بسته‌بندی شده‌ای برای تحویل یافت نشد.")

    def _on_item_selected(self):
        selected_items = self.products_table.selectedItems()
        if not selected_items: return
        data = self.products_table.item(selected_items[0].row(), 0).data(Qt.UserRole)
        if data:
            max_qty = data.get('qty', 0.0)
            self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, max_qty, 3))
            self.qty_edit.setText(str(max_qty))

    def get_data(self):
        current_row = self.products_table.currentRow()
        if current_row < 0: return None
        try:
            item_with_data = self.products_table.item(current_row, 0)
            if not item_with_data: return None
            item_data = item_with_data.data(Qt.UserRole)
            qty_to_transfer = float(self.qty_edit.text())
            if not all([item_data, qty_to_transfer > 0]): return None
            if qty_to_transfer > item_data.get('qty', 0):
                QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "مقدار تحویلی نمی‌تواند از موجودی بچ بیشتر باشد."); return None

            # --- *** بخش جدید و کلیدی: پیدا کردن سفارش تولید مرتبط *** ---
            production_order_id = None
            prod_order_info = self.db.execute_query("SELECT id FROM production_orders WHERE production_batch_no = %s", (item_data['batch_no'],), fetch_one=True)
            if prod_order_info:
                production_order_id = prod_order_info['id']
            # --- ****************************************************** ---

            return { 
                "item_id": item_data['item_id'], 
                "qty": qty_to_transfer, 
                "batch_no": item_data['batch_no'], 
                "expiry_date": item_data.get('expiry_date'),
                "production_order_id": production_order_id # ارسال شناسه پیدا شده
            }
        except (ValueError, TypeError, AttributeError):
            return None
        
        # این کلاس را به طور کامل با نسخه جدید جایگزین کنید
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class ComponentSelectionDialog(QtWidgets.QDialog):
    """
    دیالوگ کمکی برای انتخاب یک بچ از یک کالا (شامل محصولات فله).
    """
    def __init__(self, db: DB, title: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(title)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(500, 400)

        layout = QtWidgets.QVBoxLayout(self)
        self.search_edit = QtWidgets.QLineEdit(placeholderText="🔍 جستجوی نام یا بچ...")
        self.search_edit.textChanged.connect(self.filter_list)
        layout.addWidget(self.search_edit)

        self.items_list = QtWidgets.QListWidget()
        layout.addWidget(self.items_list)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        self._load_components()

    def _load_components(self):
        items = self.db.get_available_bulk_products()
        for item in items:
            display_text = f"{item['product_name']} (بچ: {item['production_batch_no']}, موجودی: {item['quantity']})"
            list_item = QtWidgets.QListWidgetItem(display_text, self.items_list)
            list_item.setData(Qt.UserRole, item)
            self.items_list.addItem(list_item)

    def filter_list(self, text):
        for i in range(self.items_list.count()):
            item = self.items_list.item(i)
            item.setHidden(text.lower() not in item.text().lower())

    def get_selected_component(self):
        selected = self.items_list.selectedItems()
        if not selected: return None
        return selected[0].data(Qt.UserRole)
    
                        


# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class PackingPreviewDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نمایش پلن برداشت به کاربر و دریافت تایید نهایی."""
    def __init__(self, pick_plan_tree: QtWidgets.QTreeWidget, parent=None):
        super().__init__(parent)
        self.setWindowTitle("پیش‌نمایش و تایید نهایی مصرف")
        self.setMinimumSize(700, 450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        info_label = QtWidgets.QLabel("<b>سیستم پیشنهاد می‌کند موارد زیر از موجودی کسر شوند. لطفاً بررسی و تایید کنید:</b>")
        layout.addWidget(info_label)
        
        pick_plan_tree.setParent(self)
        layout.addWidget(pick_plan_tree, 1)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("✔ تایید و ثبت نهایی بسته‌بندی")
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setProperty("class", "primary")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
                
                                                                            
# این کلاس را به طور کامل جایگزین کنید
class CreateDeliveryRequestDialog(QtWidgets.QDialog):
    """پنجره‌ای برای انتخاب یک محصول پک شده از کف کارگاه و ایجاد درخواست تحویل."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ایجاد درخواست تحویل به انبار")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.items_combo = QtWidgets.QComboBox()
        layout.addRow("انتخاب محصول بسته‌بندی شده:", self.items_combo)

        # --- اصلاح کلیدی: متغیر محلی به متغیر کلاس تبدیل شد ---
        self.buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        layout.addRow(self.buttons)

        self._load_packable_items()

    def _load_packable_items(self):
        # فقط محصولات پک شده موجود در انبار تولید را می‌خوانیم
        items = self.db.get_finished_goods_at_location(self.db.get_production_floor_location(), packed_only=True)
        if not items:
            self.items_combo.addItem("هیچ محصول بسته‌بندی شده‌ای برای تحویل یافت نشد.", None)
            self.items_combo.setEnabled(False)
            # حالا این خط به درستی کار می‌کند
            self.buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
            return
            
        for item in items:
            display_text = f"{item['name']} (بچ: {item['batch_no']}, موجودی: {item['qty']})"
            self.items_combo.addItem(display_text, item)

    def get_selected_data(self):
        return self.items_combo.currentData()
    
class UomManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت واحدهای اندازه‌گیری (UoM)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle("مدیریت واحدهای اندازه‌گیری")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(500, 400)
        
        layout = QtWidgets.QVBoxLayout(self)
        
        self.tbl_units = QtWidgets.QTableWidget()
        self.tbl_units.setColumnCount(3)
        self.tbl_units.setHorizontalHeaderLabels(['ID', 'نام کامل واحد', 'مخفف (اختیاری)'])
        self.tbl_units.setColumnHidden(0, True)
        self.tbl_units.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_units.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_units.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl_units.itemClicked.connect(self._populate_fields_for_edit)
        layout.addWidget(self.tbl_units)
        
        # بخش ورود داده
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش واحد")
        form_layout = QtWidgets.QFormLayout(form_group)
        self.name_edit = QtWidgets.QLineEdit()
        self.abbr_edit = QtWidgets.QLineEdit()
        form_layout.addRow("نام کامل:", self.name_edit)
        form_layout.addRow("مخفف:", self.abbr_edit)
        layout.addWidget(form_group)

        # دکمه‌ها
        btn_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_save.setProperty("class", "primary")
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن فرم")
        
        btn_layout.addWidget(btn_save)
        btn_layout.addWidget(btn_delete)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_clear)
        layout.addLayout(btn_layout)

        btn_save.clicked.connect(self._add_or_update_unit)
        btn_delete.clicked.connect(self._delete_unit)
        btn_clear.clicked.connect(self._clear_fields)
        
        self._load_units()

    def _load_units(self):
        self.tbl_units.setRowCount(0)
        units = self.db.get_all_units()
        self.tbl_units.setRowCount(len(units))
        for r, unit in enumerate(units):
            self.tbl_units.setItem(r, 0, QtWidgets.QTableWidgetItem(str(unit['id'])))
            self.tbl_units.setItem(r, 1, QtWidgets.QTableWidgetItem(unit['name']))
            self.tbl_units.setItem(r, 2, QtWidgets.QTableWidgetItem(unit.get('abbreviation', '')))

    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.name_edit.setText(self.tbl_units.item(row, 1).text())
        self.abbr_edit.setText(self.tbl_units.item(row, 2).text())
        
    def _clear_fields(self):
        self.tbl_units.clearSelection()
        self.name_edit.clear()
        self.abbr_edit.clear()
        self.name_edit.setFocus()

    def _add_or_update_unit(self):
        name = self.name_edit.text().strip()
        abbr = self.abbr_edit.text().strip()
        
        selected_items = self.tbl_units.selectedItems()
        unit_id = int(self.tbl_units.item(selected_items[0].row(), 0).text()) if selected_items else None
        
        try:
            self.db.add_or_update_unit(name, abbr, unit_id)
            self._load_units()
            self._clear_fields()
            if self.toast:
                self.toast.show_message("✔ واحد با موفقیت ذخیره شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", str(e))

# در کلاس UomManagerDialog
    def _delete_unit(self):
        selected_items = self.tbl_units.selectedItems()
        if not selected_items:
            self.toast.show_message("لطفاً یک واحد را برای حذف انتخاب کنید.", "warning")
            return
            
        unit_id = int(self.tbl_units.item(selected_items[0].row(), 0).text())
        unit_name = self.tbl_units.item(selected_items[0].row(), 1).text()
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف واحد «{unit_name}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # فراخوانی متد دیتابیس که خودش چک‌های لازم را انجام می‌دهد
                self.db.delete_unit(unit_id)
                self._load_units()
                self._clear_fields()
                if self.toast:
                    self.toast.show_message("✔ واحد با موفقیت حذف شد.", "info")
            
            # --- اصلاح کلیدی اینجاست ---
            except ValueError as e:
                # اگر خطا از نوع ValueError بود (یعنی واحد در حال استفاده است)، پیغام مشخص نمایش بده
                QtWidgets.QMessageBox.critical(self, "عملیات ناموفق", f"<b>امکان حذف واحد «{unit_name}» وجود ندارد.</b><br><br>دلیل: {e}")
            except Exception as e:
                # برای خطاهای پیش‌بینی نشده دیگر
                QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام حذف واحد:\n{e}")
                
                                
# کل کلاس AppSettingsDialog را با این نسخه نهایی جایگزین کنید
class AppSettingsDialog(QtWidgets.QDialog):
    """نسخه نهایی با قابلیت تنظیم دوره پشتیبان‌گیری."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.setWindowTitle("تنظیمات برنامه"); self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumWidth(550)
        layout = QtWidgets.QVBoxLayout(self); layout.setSpacing(15); layout.setContentsMargins(15, 15, 15, 15)

        # --- بخش تنظیمات بکاپ خودکار ---
        backup_group = QtWidgets.QGroupBox()
        backup_layout = QtWidgets.QVBoxLayout(backup_group)
        header_layout_1 = QtWidgets.QHBoxLayout(); icon_label_1 = QtWidgets.QLabel(); icon_label_1.setPixmap(QtGui.QIcon.fromTheme("document-save").pixmap(24, 24)); title_label_1 = QtWidgets.QLabel("پشتیبان‌گیری خودکار"); title_label_1.setFont(QFont(FONT_FAMILY, 11, QFont.Bold)); header_layout_1.addWidget(icon_label_1); header_layout_1.addWidget(title_label_1); header_layout_1.addStretch(); backup_layout.addLayout(header_layout_1)
        form_layout_1 = QtWidgets.QFormLayout(); form_layout_1.setContentsMargins(10, 15, 10, 0); form_layout_1.setSpacing(10)
        self.autobackup_check = QtWidgets.QCheckBox("پشتیبان‌گیری خودکار فعال باشد")
        
        # --- فیلد جدید: دوره پشتیبان‌گیری ---
        self.backup_freq_spinbox = QtWidgets.QSpinBox(); self.backup_freq_spinbox.setRange(1, 30); self.backup_freq_spinbox.setSuffix(" روز یکبار")

        time_container_widget = QtWidgets.QWidget(); time_container_widget.setLayoutDirection(QtCore.Qt.LeftToRight); time_layout = QtWidgets.QHBoxLayout(time_container_widget); time_layout.setContentsMargins(0,0,0,0); self.hour_spinbox = QtWidgets.QSpinBox(); self.hour_spinbox.setRange(0, 23); self.minute_spinbox = QtWidgets.QSpinBox(); self.minute_spinbox.setRange(0, 59); self.hour_spinbox.setDisplayIntegerBase(10); self.hour_spinbox.setStyleSheet("padding: 4px;"); self.minute_spinbox.setDisplayIntegerBase(10); self.minute_spinbox.setStyleSheet("padding: 4px;"); time_layout.addWidget(self.hour_spinbox); time_layout.addWidget(QtWidgets.QLabel(":")); time_layout.addWidget(self.minute_spinbox); time_layout.addStretch()
        path_layout = QtWidgets.QHBoxLayout(); self.backup_path_edit = QtWidgets.QLineEdit(); self.backup_path_edit.setPlaceholderText("یک پوشه انتخاب کنید..."); btn_browse = QtWidgets.QPushButton("..."); btn_browse.setFixedSize(30,30); btn_browse.clicked.connect(self._browse_backup_path); path_layout.addWidget(self.backup_path_edit, 1); path_layout.addWidget(btn_browse)
        backup_desc = QtWidgets.QLabel("پشتیبان‌گیری در ساعت مشخص شده انجام می‌شود (برنامه باید باز و کاربر ادمین آنلاین باشد)."); backup_desc.setStyleSheet("color: #6c757d; font-size: 9pt;")
        form_layout_1.addRow(self.autobackup_check); form_layout_1.addRow("دوره پشتیبان‌گیری:", self.backup_freq_spinbox); form_layout_1.addRow("ساعت پشتیبان‌گیری:", time_container_widget); form_layout_1.addRow("محل ذخیره بکاپ‌ها:", path_layout); form_layout_1.addRow(backup_desc)
        backup_layout.addLayout(form_layout_1); layout.addWidget(backup_group)

        # ... (بقیه کد بدون تغییر) ...
        analysis_group = QtWidgets.QGroupBox(); analysis_layout = QtWidgets.QVBoxLayout(analysis_group); header_layout_2 = QtWidgets.QHBoxLayout(); icon_label_2 = QtWidgets.QLabel(); icon_label_2.setPixmap(QtGui.QIcon.fromTheme("view-sort-ascending").pixmap(24, 24)); title_label_2 = QtWidgets.QLabel("تنظیمات تحلیل و هشدارها"); title_label_2.setFont(QFont(FONT_FAMILY, 11, QFont.Bold)); header_layout_2.addWidget(icon_label_2); header_layout_2.addWidget(title_label_2); header_layout_2.addStretch(); analysis_layout.addLayout(header_layout_2); form_layout_2 = QtWidgets.QFormLayout(); form_layout_2.setContentsMargins(10, 15, 10, 0); form_layout_2.setSpacing(10); self.expiry_spinbox = QtWidgets.QSpinBox(); self.expiry_spinbox.setRange(1, 365); self.expiry_spinbox.setSuffix(" روز"); expiry_desc = QtWidgets.QLabel("تعداد روز باقی‌مانده به انقضا که باعث نمایش هشدار می‌شود."); expiry_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("بازه هشدار انقضا:", self.expiry_spinbox); form_layout_2.addRow(expiry_desc); separator = QtWidgets.QFrame(); separator.setFrameShape(QtWidgets.QFrame.HLine); separator.setFrameShadow(QtWidgets.QFrame.Sunken); form_layout_2.addRow(separator); self.service_level_spinbox = QtWidgets.QDoubleSpinBox(); self.service_level_spinbox.setRange(0.50, 0.99); self.service_level_spinbox.setDecimals(2); self.service_level_spinbox.setSingleStep(0.01); service_level_desc = QtWidgets.QLabel("سطح اطمینان برای محاسبه موجودی اطمینان (Safety Stock). پیشنهادی: 0.95"); service_level_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("سطح خدمت (Service Level):", self.service_level_spinbox); form_layout_2.addRow(service_level_desc); self.max_multiplier_spinbox = QtWidgets.QDoubleSpinBox(); self.max_multiplier_spinbox.setRange(1.1, 3.0); self.max_multiplier_spinbox.setDecimals(2); self.max_multiplier_spinbox.setSingleStep(0.1); max_multiplier_desc = QtWidgets.QLabel("ضریب محاسبه حداکثر موجودی (حداکثر = حداقل × ضریب). پیشنهادی: 1.5"); max_multiplier_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("ضریب حداکثر موجودی:", self.max_multiplier_spinbox); form_layout_2.addRow(max_multiplier_desc); self.analysis_days_spinbox = QtWidgets.QSpinBox(); self.analysis_days_spinbox.setRange(1, 730); self.analysis_days_spinbox.setSuffix(" روز"); analysis_days_desc = QtWidgets.QLabel("تعداد روزهای گذشته برای تحلیل مصرف کالا. پیشنهادی: 90"); analysis_days_desc.setStyleSheet("color: #6c757d; font-size: 9pt;"); form_layout_2.addRow("بازه زمانی تحلیل مصرف:", self.analysis_days_spinbox); form_layout_2.addRow(analysis_days_desc); analysis_layout.addLayout(form_layout_2); layout.addWidget(analysis_group); layout.addStretch();
        btn_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Save | QtWidgets.QDialogButtonBox.Cancel); btn_box.button(QtWidgets.QDialogButtonBox.Save).clicked.connect(self._save_settings); btn_box.rejected.connect(self.reject); layout.addWidget(btn_box)
        self._load_settings()

    def _browse_backup_path(self):
        directory = QtWidgets.QFileDialog.getExistingDirectory(self, "انتخاب پوشه برای پشتیبان‌گیری")
        if directory: self.backup_path_edit.setText(directory)

    def _load_settings(self):
        def safe_int_cast(value_str, default):
            try: return int("".join(filter(str.isdigit, str(value_str))))
            except: return default
        def safe_float_cast(value_str, default):
            try: return float(str(value_str).replace(',', '.'))
            except: return default
        
        self.autobackup_check.setChecked(self.db.get_setting('autobackup_enabled', 'false') == 'true')
        self.backup_freq_spinbox.setValue(safe_int_cast(self.db.get_setting('autobackup_frequency_days', '1'), 1))
        time_str = self.db.get_setting('autobackup_time', '02:00'); parts = time_str.split(':')
        if len(parts) == 2: self.hour_spinbox.setValue(int(parts[0])); self.minute_spinbox.setValue(int(parts[1]))
        default_path = str(BASE_DIR / 'Auto_Backups'); self.backup_path_edit.setText(self.db.get_setting('autobackup_path', default_path))
        self.expiry_spinbox.setValue(safe_int_cast(self.db.get_setting('expiry_alert_days', '30'), 30))
        self.service_level_spinbox.setValue(safe_float_cast(self.db.get_setting('reorder_service_level', '0.95'), 0.95))
        self.max_multiplier_spinbox.setValue(safe_float_cast(self.db.get_setting('reorder_max_multiplier', '1.5'), 1.5))
        self.analysis_days_spinbox.setValue(safe_int_cast(self.db.get_setting('reorder_analysis_days', '90'), 90))
    
    def _save_settings(self):
        try:
            hour = self.hour_spinbox.value(); minute = self.minute_spinbox.value(); time_str = f"{hour:02d}:{minute:02d}"
            settings_to_save = {
                'autobackup_enabled': 'true' if self.autobackup_check.isChecked() else 'false',
                'autobackup_frequency_days': self.backup_freq_spinbox.value(),
                'autobackup_time': time_str,
                'autobackup_path': self.backup_path_edit.text(),
                'expiry_alert_days': self.expiry_spinbox.value(),
                'reorder_service_level': self.service_level_spinbox.value(),
                'reorder_max_multiplier': self.max_multiplier_spinbox.value(),
                'reorder_analysis_days': self.analysis_days_spinbox.value()
            }
            for key, value in settings_to_save.items():
                self.db.set_setting(key, str(value))
            if self.toast: self.toast.show_message("✔ تنظیمات با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"مشکلی در ذخیره تنظیمات پیش آمد:\n{e}")
                                                                                
class DebugReportDialog(QtWidgets.QDialog):
    """یک پنجره برای نمایش گزارش‌های متنی طولانی و قابل کپی."""
    def __init__(self, report_text, parent=None):
        super().__init__(parent)
        self.setWindowTitle("گزارش تست مصرف")
        self.setFont(QFont("Tahoma", 10))
        self.setMinimumSize(700, 500)

        layout = QtWidgets.QVBoxLayout(self)

        self.report_display = QtWidgets.QTextEdit()
        self.report_display.setReadOnly(True)
        # استفاده از فونت مونواسپیس برای نمایش ستونی و مرتب
        self.report_display.setFont(QFont("Consolas", 10))
        self.report_display.setText(report_text)
        
        layout.addWidget(self.report_display)

        button_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Close)
        button_box.button(QtWidgets.QDialogButtonBox.Close).setText("بستن")
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        
class SettingsActionCard(QtWidgets.QFrame):
    """یک ویجت سفارشی و زیبا برای نمایش یک گزینه در صفحه تنظیمات (نسخه حرفه‌ای)."""
    clicked = QtCore.pyqtSignal()

    def __init__(self, icon_theme_name: str, icon_bg_color: str, title: str, subtitle: str, parent=None):
        super().__init__(parent)
        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.setObjectName("actionCard")
        
        # --- استایل جدید با سایه ---
        self.setStyleSheet("""
            QFrame#actionCard {
                background-color: #ffffff;
                border-radius: 8px;
            }
        """)
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(25)
        shadow.setOffset(0, 5)
        shadow.setColor(QColor(0, 0, 0, 30))
        self.setGraphicsEffect(shadow)

        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)

        icon_bg = QtWidgets.QLabel()
        icon_bg.setFixedSize(48, 48)
        icon_bg.setStyleSheet(f"background-color: {icon_bg_color}; border-radius: 24px;")
        icon_layout = QVBoxLayout(icon_bg)
        icon_layout.setAlignment(QtCore.Qt.AlignCenter)
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_theme_name).pixmap(24, 24))
        icon_layout.addWidget(icon_label)

        text_layout = QVBoxLayout()
        text_layout.setSpacing(2)
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt; background: transparent;")
        subtitle_label = QtWidgets.QLabel(subtitle)
        subtitle_label.setStyleSheet("color: #6c757d; background: transparent;")
        text_layout.addWidget(title_label)
        text_layout.addWidget(subtitle_label)
        text_layout.addStretch()

        arrow_label = QtWidgets.QLabel("›")
        arrow_label.setStyleSheet("font-size: 24pt; color: #b0bec5; background: transparent;")

        layout.addWidget(icon_bg)
        layout.addLayout(text_layout, 1)
        layout.addWidget(arrow_label)

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.clicked.emit()
        super().mouseReleaseEvent(event)
        
# این کلاس کاملا جدید را به انتهای فایل کد خود اضافه کنید
class DeliverToLabDialog(QtWidgets.QDialog):
    """پنجره‌ای برای ثبت ارسال محصول از کف کارگاه به آزمایشگاه."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت خروج کالا به آزمایشگاه")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)

        self.prod_loc_id = self.db.get_production_floor_location()
        if not self.prod_loc_id:
            QtWidgets.QMessageBox.critical(self, "خطا", "انبار تولید در سیستم تعریف نشده است.")
            QtCore.QTimer.singleShot(0, self.reject)
            return

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_combo = QtWidgets.QComboBox()
        self.batch_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("0.0")
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="مثال: نمونه بچ برای تست فشار")

        layout.addRow("انتخاب محصول موجود در تولید:", self.item_combo)
        layout.addRow("انتخاب بچ محصول:", self.batch_combo)
        layout.addRow("مقدار ارسالی به آزمایشگاه:", self.qty_edit)
        layout.addRow("یادداشت (اختیاری):", self.notes_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت خروج")
        layout.addRow(buttons)

        self.item_combo.currentIndexChanged.connect(self._on_item_selected)
        self.batch_combo.currentIndexChanged.connect(self._on_batch_selected)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        self._populate_finished_goods()

    def _populate_finished_goods(self):
        # فقط محصولات نهایی را لیست می‌کنیم
        items = self.db.get_finished_goods_at_location(self.prod_loc_id, packed_only=False) 
        grouped_items = {}
        for item in items:
            name = item['name']
            if name not in grouped_items: grouped_items[name] = []
            grouped_items[name].append(item)
        
        for name, batches in grouped_items.items():
            self.item_combo.addItem(name, batches)
    
    def _on_item_selected(self):
        self.batch_combo.clear()
        batches = self.item_combo.currentData()
        if not batches: return
        for batch_info in batches:
            display_text = f"بچ: {batch_info['batch_no']} (موجودی: {batch_info['qty']})"
            self.batch_combo.addItem(display_text, batch_info)
    
    def _on_batch_selected(self):
        batch_info = self.batch_combo.currentData()
        if batch_info:
            self.qty_edit.setText(str(batch_info.get('qty', 0.0)))
            self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, batch_info.get('qty', 0.0), 3))

    def get_data(self):
        try:
            batch_info = self.batch_combo.currentData()
            qty_to_send = float(self.qty_edit.text())
            notes = self.notes_edit.text().strip()

            if not all([batch_info, qty_to_send > 0]):
                return None

            available_qty = batch_info.get('qty', 0)
            if qty_to_send > available_qty:
                QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر",
                                              f"مقدار درخواستی ({qty_to_send}) از موجودی بچ ({available_qty}) بیشتر است.")
                return None
            
            return {
                "item_id": batch_info['item_id'],
                "qty": qty_to_send,
                "batch_no": batch_info['batch_no'],
                "expiry_date": batch_info.get('expiry_date'),
                "notes": notes
            }
        except (ValueError, TypeError, AttributeError):
            return None
        
# این کلاس کاملا جدید را به انتهای فایل کد خود اضافه کنید
class PackagingOptionDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک نوع بسته‌بندی (SKU)."""
    def __init__(self, pack_data=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("افزودن/ویرایش نوع بسته‌بندی" if not pack_data else "ویرایش بسته‌بندی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.sku_edit = QtWidgets.QLineEdit()
        self.name_edit = QtWidgets.QLineEdit()
        self.weight_edit = QtWidgets.QLineEdit()
        self.weight_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 3))
        self.notes_edit = QtWidgets.QLineEdit()

        layout.addRow("کد SKU (*):", self.sku_edit)
        layout.addRow("نام پک (*):", self.name_edit)
        layout.addRow("وزن خالص (Kg) (*):", self.weight_edit)
        layout.addRow("توضیحات:", self.notes_edit)

        if pack_data:
            self.sku_edit.setText(pack_data.get('sku', ''))
            self.name_edit.setText(pack_data.get('pack_name', ''))
            self.weight_edit.setText(str(pack_data.get('pack_weight', '')))
            self.notes_edit.setText(pack_data.get('notes', ''))

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        sku = self.sku_edit.text().strip()
        name = self.name_edit.text().strip()
        weight_str = self.weight_edit.text().strip()
        if not all([sku, name, weight_str]):
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", "پر کردن فیلدهای ستاره‌دار الزامی است.")
            return None
        
        try:
            return {
                "sku": sku,
                "pack_name": name,
                "pack_weight": float(weight_str),
                "notes": self.notes_edit.text().strip()
            }
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "لطفاً وزن را به صورت عددی صحیح وارد کنید.")
            return None
        
# این دو کلاس جدید را به انتهای فایل کد خود اضافه کنید

class AddOrEditBomItemDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک جزء به BOM بسته‌بندی."""
    def __init__(self, db: DB, existing_components: list, bom_item_data=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن/ویرایش جزء به BOM")
        self.setMinimumWidth(400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.component_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("1")
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        layout.addRow("جزء بسته‌بندی:", self.component_combo)
        layout.addRow("تعداد/مقدار برای هر پک:", self.qty_edit)

        all_packaging_items = self.db.execute_query("SELECT id, name FROM items WHERE category='لوازم بسته‌بندی' ORDER BY name")
        for item in all_packaging_items:
            if item['id'] not in existing_components or (bom_item_data and item['id'] == bom_item_data.get('component_item_id')):
                self.component_combo.addItem(item['name'], item['id'])

        if bom_item_data:
            index = self.component_combo.findData(bom_item_data.get('component_item_id'))
            if index != -1: self.component_combo.setCurrentIndex(index)
            self.qty_edit.setText(str(bom_item_data.get('quantity', 1)))

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if self.component_combo.currentIndex() == -1: return None
        try:
            return {
                "component_item_id": self.component_combo.currentData(),
                "quantity": float(self.qty_edit.text())
            }
        except (ValueError, TypeError): return None

# کلاس ManagePackagingBomDialog را با این نسخه تعاملی و کامل جایگزین کنید

class ManagePackagingBomDialog(QtWidgets.QDialog):
    """پنجره تعاملی برای مدیریت BOM یک پک خاص به صورت شبیه به اکسل."""
    def __init__(self, db: DB, pack_option_id: int, pack_name: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.pack_option_id = pack_option_id
        self.toast = getattr(parent, 'toast', None)

        self.setWindowTitle(f"مدیریت BOM برای: {pack_name}")
        self.setMinimumSize(600, 450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر واحد از این پک، لوازم مورد نیاز را تعریف کنید:"))
        
        self.bom_table = QtWidgets.QTableWidget(0, 3)
        self.bom_table.setHorizontalHeaderLabels(["جزء بسته‌بندی (انتخابی)", "مقدار/تعداد", "واحد"])
        self.bom_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.bom_table.verticalHeader().setDefaultSectionSize(50)

        
        layout.addWidget(self.bom_table, 1)
        
        # --- دکمه‌های عملیاتی جدید ---
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن ردیف جدید")
        btn_del_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف ردیف انتخابی")
        btn_layout.addWidget(btn_add_row); btn_layout.addWidget(btn_del_row); btn_layout.addStretch()
        layout.addLayout(btn_layout)

        # --- دکمه ذخیره نهایی ---
        save_button = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره BOM")
        save_button.setProperty("class", "primary")
        layout.addWidget(save_button)

        btn_add_row.clicked.connect(self._add_row)
        btn_del_row.clicked.connect(self._delete_row)
        save_button.clicked.connect(self._save_bom)

        # خواندن لیست لوازم بسته‌بندی یک بار برای استفاده مکرر
        self.packaging_supplies = self.db.get_all_packaging_supplies()
        self._load_bom()

    def _load_bom(self):
        """BOM موجود را خوانده و جدول را با ردیف‌های قابل ویرایش پر می‌کند."""
        self.bom_table.setRowCount(0)
        bom_items = self.db.get_packaging_bom(self.pack_option_id)
        for item in bom_items:
            self._add_row(component_id=item['component_item_id'], quantity=item['quantity'])

    def _add_row(self, component_id=None, quantity=1.0):
        """یک ردیف جدید به جدول اضافه کرده و ویجت‌های لازم را در آن قرار می‌دهد."""
        row_pos = self.bom_table.rowCount()
        self.bom_table.insertRow(row_pos)

        # ستون ۰: انتخاب جزء
        combo = QtWidgets.QComboBox()
        for supply in self.packaging_supplies:
            combo.addItem(supply['name'], supply['id'])
        if component_id:
            index = combo.findData(component_id)
            if index != -1: combo.setCurrentIndex(index)
        combo.currentIndexChanged.connect(lambda _, r=row_pos: self._update_unit(r))
        self.bom_table.setCellWidget(row_pos, 0, combo)

        # ستون ۱: مقدار
        qty_edit = QtWidgets.QLineEdit(str(quantity))
        qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        self.bom_table.setCellWidget(row_pos, 1, qty_edit)

        # ستون ۲: واحد (غیرقابل ویرایش)
        unit_item = QtWidgets.QTableWidgetItem()
        unit_item.setFlags(unit_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.bom_table.setItem(row_pos, 2, unit_item)
        self._update_unit(row_pos)

    def _update_unit(self, row):
        """واحد شمارش را بر اساس جزء انتخاب شده در کمبوباکس، آپدیت می‌کند."""
        combo = self.bom_table.cellWidget(row, 0)
        if not combo: return
        
        selected_id = combo.currentData()
        unit = next((s.get('unit', '') for s in self.packaging_supplies if s['id'] == selected_id), '')
        self.bom_table.item(row, 2).setText(unit)

    def _delete_row(self):
        current_row = self.bom_table.currentRow()
        if current_row >= 0:
            self.bom_table.removeRow(current_row)

    def _save_bom(self):
        """تمام محتویات جدول را به عنوان BOM جدید ذخیره می‌کند."""
        bom_to_save = []
        for r in range(self.bom_table.rowCount()):
            try:
                combo = self.bom_table.cellWidget(r, 0)
                qty_widget = self.bom_table.cellWidget(r, 1)
                
                component_id = combo.currentData()
                quantity = float(qty_widget.text())
                
                if component_id and quantity > 0:
                    bom_to_save.append({
                        "component_item_id": component_id,
                        "quantity": quantity
                    })
            except (ValueError, TypeError, AttributeError):
                QtWidgets.QMessageBox.warning(self, "خطای داده", f"لطفاً اطلاعات ردیف {r+1} را به درستی وارد کنید.")
                return

        try:
            self.db.save_packaging_bom(self.pack_option_id, bom_to_save)
            if self.toast:
                self.toast.show_message("✔ لیست BOM با موفقیت ذخیره شد.", "success")
            self.accept() # بستن دیالوگ پس از ذخیره موفق
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام ذخیره BOM:\n{e}")
            
# این دو کلاس جدید را به انتهای فایل کد خود اضافه کنید

class AddPackagingSupplyDialog(QtWidgets.QDialog):
    """یک دیالوگ کمکی برای انتخاب یک قلم از لوازم بسته‌بندی و تعیین تعداد آن."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن جزء بسته‌بندی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.supply_combo = QtWidgets.QComboBox()
        self.qty_edit = QtWidgets.QLineEdit("1.0")
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        
        layout.addRow("انتخاب قلم:", self.supply_combo)
        layout.addRow("تعداد/مقدار:", self.qty_edit)
        
        # فقط کالاهای دسته "لوازم بسته‌بندی" را لود می‌کنیم
        supplies = self.db.get_items_by_category('لوازم بسته‌بندی')
        for supply in supplies:
            self.supply_combo.addItem(f"{supply['name']} ({supply['unit']})", supply)
            
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if self.supply_combo.currentIndex() == -1: return None
        try:
            return {
                "item_data": self.supply_combo.currentData(),
                "quantity": float(self.qty_edit.text())
            }
        except (ValueError, TypeError):
            return None


# کلاس PackagingBomDialog را به طور کامل با این نسخه نهایی و اصلاح شده جایگزین کنید

class PackagingBomDialog(QtWidgets.QDialog):
    """
    نسخه نهایی: پنجره مدیریت BOM برای یک پک خاص.
    - بخش نسبت اختلاط از این فرم حذف شده و منطق آن به فرمول مادر منتقل می‌شود.
    - خطای TypeError هنگام ذخیره‌سازی برطرف شده است.
    """
    def __init__(self, db: DB, pack_item_data: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.pack_item_data = pack_item_data
        self.toast = getattr(parent, 'toast', None)
        # recipe_id_to_revise برای ارسال به متد save_bom استفاده خواهد شد
        self.recipe_id_to_revise = None

        self.setWindowTitle(f"مدیریت BOM بسته‌بندی برای: {self.pack_item_data.get('name')}")
        self.setMinimumSize(600, 450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر واحد از این پک، لوازم بسته‌بندی مورد نیاز را تعریف کنید:"))
        
        self.bom_table = QtWidgets.QTableWidget(0, 4)
        self.bom_table.setHorizontalHeaderLabels(["ID جزء", "نام جزء", "مقدار/تعداد", "واحد"])
        self.bom_table.setColumnHidden(0, True)
        self.bom_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.bom_table, 1)
        
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن جزء")
        btn_del_row = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف جزء")
        btn_layout.addWidget(btn_add_row); btn_layout.addWidget(btn_del_row); btn_layout.addStretch()
        layout.addLayout(btn_layout)

        save_button = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره نهایی BOM بسته‌بندی")
        save_button.setProperty("class", "primary")
        layout.addWidget(save_button)

        btn_add_row.clicked.connect(self._add_row)
        btn_del_row.clicked.connect(self._delete_row)
        save_button.clicked.connect(self._save_bom)

        self.packaging_supplies = self.db.get_all_packaging_supplies()
        self._load_bom()

    def _load_bom(self):
        """
        BOM بسته‌بندی برای پک فعلی را لود می‌کند.
        - اگر ستون part_type در recipes باشد: دنبال آخرین نسخه ACTIVE با part_type='PACKAGING' می‌گردد.
        - اگر نباشد: آخرین نسخه ACTIVE که اجزای بسته‌بندی دارد را پیدا می‌کند.
        سپس اقلام را از DB.get_bom_for_product لود می‌کند.
        """
        self.bom_table.setRowCount(0)

        # اطمینان از وجود ستون (اگر قبلاً در استارتاپ صدا نشده)
        try:
            if hasattr(self.db, 'ensure_recipes_part_type'):
                self.db.ensure_recipes_part_type()
        except Exception:
            pass  # اگر مجوز ALTER نداشتیم، مسیر بدون part_type کار خواهد کرد

        # تشخیص وجود ستون
        has_part_type = self.db.execute_query(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = current_schema()
            AND table_name = 'recipes'
            AND column_name = 'part_type'
            LIMIT 1
            """, fetch_one=True
        )

        recipe_row = None
        if has_part_type:
            recipe_row = self.db.execute_query(
                """
                SELECT id
                FROM recipes
                WHERE product_name = %s
                AND status = 'ACTIVE'
                AND part_type = 'PACKAGING'
                ORDER BY version DESC
                LIMIT 1
                """,
                (self.pack_item_data['name'],),
                fetch_one=True
            )
        else:
            # بدون part_type، بر اساس وجود جزء بسته‌بندی تشخیص می‌دهیم
            recipe_row = self.db.execute_query(
                """
                SELECT r.id
                FROM recipes r
                WHERE r.product_name = %s
                AND r.status = 'ACTIVE'
                AND EXISTS (
                        SELECT 1
                        FROM recipe_ingredients ri
                        JOIN items i ON i.id = ri.raw_material_item_id
                        WHERE ri.recipe_id = r.id
                        AND i.category = %s
                )
                ORDER BY r.version DESC
                LIMIT 1
                """,
                (self.pack_item_data['name'], CATEGORY_PACKAGING),
                fetch_one=True
            )

        if recipe_row:
            self.recipe_id_to_revise = recipe_row['id']
            bom_items = self.db.get_bom_for_product(self.pack_item_data['name'])
            for item in (bom_items or []):
                self._add_row(
                    component_id=item['component_item_id'],
                    quantity=item['quantity'],
                    unit=item.get('unit', '')
                )

    def _add_row(self, component_id=None, quantity=1.0, unit=''):
        row_pos = self.bom_table.rowCount()
        self.bom_table.insertRow(row_pos)
        
        combo = QtWidgets.QComboBox()
        for supply in self.packaging_supplies:
            combo.addItem(supply['name'], supply['id'])
        if component_id:
            index = combo.findData(component_id)
            if index != -1: combo.setCurrentIndex(index)
        combo.currentIndexChanged.connect(lambda _, r=row_pos: self._update_unit(r))
        self.bom_table.setCellWidget(row_pos, 1, combo)

        qty_edit = QtWidgets.QLineEdit(str(quantity))
        qty_edit.setValidator(QtGui.QDoubleValidator(0.001, 10000, 4))
        self.bom_table.setCellWidget(row_pos, 2, qty_edit)

        unit_item = QtWidgets.QTableWidgetItem(unit)
        unit_item.setFlags(unit_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.bom_table.setItem(row_pos, 3, unit_item)
        if not unit: self._update_unit(row_pos)
        
    def _update_unit(self, row):
        combo = self.bom_table.cellWidget(row, 1)
        if not combo: return
        selected_id = combo.currentData()
        unit = next((s.get('unit', '') for s in self.packaging_supplies if s['id'] == selected_id), '')
        self.bom_table.item(row, 3).setText(unit)

    def _delete_row(self):
        current_row = self.bom_table.currentRow()
        if current_row >= 0:
            self.bom_table.removeRow(current_row)

    def _save_bom(self):
        ingredients = []
        for r in range(self.bom_table.rowCount()):
            try:
                combo = self.bom_table.cellWidget(r, 1)
                qty_widget = self.bom_table.cellWidget(r, 2)
                component_id = combo.currentData()
                quantity = float(qty_widget.text())
                if component_id and quantity > 0:
                    ingredients.append({"item_id": component_id, "percentage": quantity})
            except (ValueError, TypeError, AttributeError):
                QtWidgets.QMessageBox.warning(self, "خطای داده", f"لطفاً اطلاعات ردیف {r+1} را به درستی وارد کنید.")
                return

        # --- *** اصلاح کلیدی: ساخت دیکشنری صحیح برای ارسال به دیتابیس *** ---
        recipe_data_to_save = {
            "product_name": self.pack_item_data['name'],
            "part_type": "PACKAGING",
            "parent_product_id": self.pack_item_data.get('parent_item_id'),
            "produces_item_id": self.pack_item_data['id'],
            "notes": f"BOM بسته‌بندی برای {self.pack_item_data['name']}",
            "yield_percentage": 100.0,
            "properties": {} # بدون نسبت اختلاط
        }

        try:
            # ارسال دیکشنری به متد save_recipe (که اکنون باید به save_bom تغییر نام داده باشد)
            self.db.save_recipe(recipe_data_to_save, ingredients, recipe_id_to_revise=self.recipe_id_to_revise)
            if self.toast:
                self.toast.show_message("✔ لیست BOM بسته‌بندی با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام ذخیره BOM:\n{e}")
            print(traceback.format_exc())
            
                                    
# این کلاس جدید را به انتهای فایل کد خود اضافه کنید
class AssignAssetDialog(QtWidgets.QDialog):
    """دیالوگی برای تخصیص یک دارایی به یک کارمند."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تحویل دارایی به پرسنل")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(450)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.asset_combo = QtWidgets.QComboBox()
        self.employee_name_edit = QtWidgets.QLineEdit()
        self.doc_no_edit = QtWidgets.QLineEdit()
        
        layout.addRow("انتخاب دارایی (از انبار):", self.asset_combo)
        layout.addRow("نام تحویل گیرنده:", self.employee_name_edit)
        layout.addRow("شماره/نوع مدرک تحویل:", self.doc_no_edit)

        assets_in_stock = self.db.list_assets_in_stock()
        if not assets_in_stock:
            self.asset_combo.addItem("هیچ دارایی در انبار موجود نیست!", -1)
            self.asset_combo.setEnabled(False)
        else:
            for asset in assets_in_stock:
                self.asset_combo.addItem(f"{asset['code']} - {asset['name']}", asset['id'])

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت تحویل")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if self.asset_combo.currentIndex() == -1 or not self.employee_name_edit.text().strip():
            return None
        return {
            "asset_id": self.asset_combo.currentData(),
            "employee_name": self.employee_name_edit.text().strip(),
            "doc_no": self.doc_no_edit.text().strip()
        }
        
        
# این کلاس جدید را به انتهای فایل کد خود اضافه کنید
class ReasonDialog(QtWidgets.QDialog):
    """یک دیالوگ سفارشی برای دریافت اجباری دلیل از کاربر."""
    def __init__(self, title, label, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)
        self.reason = ""

        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel(label))
        
        self.text_edit = QtWidgets.QLineEdit()
        self.text_edit.setPlaceholderText("وارد کردن دلیل الزامی است...")
        layout.addWidget(self.text_edit)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("تایید")
        buttons.button(QtWidgets.QDialogButtonBox.Cancel).setText("انصراف")
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def validate_and_accept(self):
        """قبل از بستن پنجره، ورودی را چک می‌کند."""
        reason_text = self.text_edit.text().strip()
        if not reason_text:
            QtWidgets.QMessageBox.warning(self, "ورودی ناقص", "وارد کردن دلیل الزامی است.")
            return # از بسته شدن دیالوگ جلوگیری می‌کند
        
        self.reason = reason_text
        self.accept() # حالا که ورودی معتبر است، دیالوگ را می‌بندیم 
                                       
# این کلاس کاملاً جدید را به فایل کد خود اضافه کنید
class AssetHistoryDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش تاریخچه کامل تراکنش‌های یک دارایی."""
    def __init__(self, db: DB, asset_id: int, asset_name: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"تاریخچه دارایی: {asset_name}")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 400)

        layout = QtWidgets.QVBoxLayout(self)
        
        self.tbl_history = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(self.tbl_history)
        
        layout.addWidget(self.tbl_history)
        self._load_history(asset_id)

    def _load_history(self, asset_id):
        history = self.db.get_transactions_for_asset(asset_id)
        
        headers = ['نوع تراکنش', 'شماره سند', 'تاریخ', 'کاربر', 'توضیحات']
        self.tbl_history.setColumnCount(len(headers))
        self.tbl_history.setHorizontalHeaderLabels(headers)
        self.tbl_history.setRowCount(len(history))

        for r, trans in enumerate(history):
            self.tbl_history.setItem(r, 0, QtWidgets.QTableWidgetItem(trans.get('t_type', '')))
            self.tbl_history.setItem(r, 1, QtWidgets.QTableWidgetItem(trans.get('t_no', '')))
            self.tbl_history.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(trans.get('t_date'))))
            self.tbl_history.setItem(r, 3, QtWidgets.QTableWidgetItem(trans.get('username', '')))
            self.tbl_history.setItem(r, 4, QtWidgets.QTableWidgetItem(trans.get('notes', '')))

        self.tbl_history.resizeColumnsToContents()
        self.tbl_history.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.Stretch)
        
        
        
# این کلاس جدید را به بالای فایل، کنار بقیه کلاس‌های کمکی اضافه کنید
class NumericTreeWidgetItem(QtWidgets.QTreeWidgetItem):
    """یک آیتم درختی که ستون‌های عددی را به درستی مرتب می‌کند."""
    def __lt__(self, other_item):
        column = self.treeWidget().sortColumn()
        
        # ستون‌هایی که باید به صورت عددی مرتب شوند
        numeric_columns = [2, 4] # ستون 2 (مقدار موجودی) و 4 (حد سفارش)
        
        if column in numeric_columns:
            try:
                self_val = float(self.text(column).replace(',', ''))
                other_val = float(other_item.text(column).replace(',', ''))
                return self_val < other_val
            except (ValueError, TypeError):
                # اگر تبدیل به عدد ممکن نبود، بر اساس متن مقایسه کن
                return super().__lt__(other_item)
        
        # برای بقیه ستون‌ها، از مرتب‌سازی پیش‌فرض استفاده کن
        return super().__lt__(other_item)
    
    
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class BomFilterDialog(QtWidgets.QDialog):
    """یک دیالوگ فیلتر سفارشی برای نمای درختی تاریخچه مصرف (BOM)."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("فیلتر پیشرفته تاریخچه مصرف")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.product_filter = QtWidgets.QLineEdit(placeholderText="مثال: P-2401-001")
        self.material_filter = QtWidgets.QLineEdit(placeholderText="مثال: رزین اپوکسی")
        self.batch_filter = QtWidgets.QLineEdit(placeholderText="مثال: BATCH-XYZ")

        layout.addRow("کد/نام محصول نهایی شامل:", self.product_filter)
        layout.addRow("نام ماده اولیه شامل:", self.material_filter)
        layout.addRow("بچ ماده اولیه شامل:", self.batch_filter)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("اعمال فیلتر")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_filters(self):
        """دیکشنری از فیلترهای وارد شده توسط کاربر را برمی‌گرداند."""
        return {
            "product": self.product_filter.text().lower().strip(),
            "material": self.material_filter.text().lower().strip(),
            "batch": self.batch_filter.text().lower().strip()
        }
        
# کل کلاس NotificationPanel را با این نسخه نهایی و کامل جایگزین کنید
class NotificationPanel(QtWidgets.QFrame):
    """یک پنل اعلان کشویی و مدرن که از زیر دکمه اصلی باز می‌شود."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent
        
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.Popup)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        self.setMinimumSize(500, 600)

        shadow = QtWidgets.QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(30); shadow.setColor(QtGui.QColor(0, 0, 0, 100)); shadow.setOffset(0, 4)
        self.setGraphicsEffect(shadow)
        
        self.main_widget = QtWidgets.QFrame(self)
        self.main_widget.setObjectName("notificationPanel")
        # --- اصلاح استایل: تم سرمه‌ای ---
        self.main_widget.setStyleSheet("""
            #notificationPanel { 
                background-color: #2c3e50; 
                border-radius: 8px; 
            }
        """)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(15, 10, 15, 15)
        layout.addWidget(self.main_widget)

        panel_layout = QtWidgets.QVBoxLayout(self.main_widget)
        panel_layout.setContentsMargins(0, 0, 0, 0)
        panel_layout.setSpacing(0)

        header_frame = QtWidgets.QFrame()
        header_frame.setStyleSheet("background-color: #34495e; border-bottom: 1px solid #4a6572; border-top-left-radius: 8px; border-top-right-radius: 8px;")
        header_layout = QtWidgets.QHBoxLayout(header_frame)
        header_layout.setContentsMargins(15, 10, 10, 10)
        
        title_label = QtWidgets.QLabel("کارتابل اعلانات")
        title_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        title_label.setStyleSheet("background: transparent; border: none; color: #ecf0f1;")

        close_button = QtWidgets.QPushButton("×")
        close_button.setFixedSize(24, 24)
        close_button.setCursor(Qt.PointingHandCursor)
        # --- اصلاح استایل: قرمز شدن دکمه بستن ---
        close_button.setStyleSheet("""
            QPushButton { background-color: #7f8c8d; color: white; border: none; border-radius: 12px; font-size: 16pt; }
            QPushButton:hover { background-color: #e74c3c; }
        """)
        close_button.clicked.connect(self.hide)

        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addWidget(close_button)
        panel_layout.addWidget(header_frame)
        
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setStyleSheet("QListWidget { border: none; background-color: transparent; }")
        self.list_widget.setSpacing(8)
        self.list_widget.itemClicked.connect(self._on_item_clicked)
        panel_layout.addWidget(self.list_widget)

        self.animation = QtCore.QPropertyAnimation(self, b"windowOpacity")
        self.animation.setDuration(200)

    def _load_notifications(self):
        # ... (این متد بدون تغییر باقی می‌ماند) ...
        self.list_widget.clear()
        notifications = self.parent_window.notifications_cache
        if not notifications:
            placeholder_label = QtWidgets.QLabel("هیچ اعلان یا کار جدیدی برای شما وجود ندارد.")
            placeholder_label.setAlignment(Qt.AlignCenter)
            placeholder_label.setStyleSheet("color: #95a5a6; font-style: italic; padding: 50px; background:transparent;")
            item = QtWidgets.QListWidgetItem(self.list_widget)
            item.setSizeHint(placeholder_label.sizeHint())
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, placeholder_label)
            return
        for notif in notifications:
            card = NotificationCard(notif)
            item = QtWidgets.QListWidgetItem(self.list_widget)
            item.setSizeHint(card.sizeHint())
            item.setData(Qt.UserRole, notif)
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, card)
            
    def _on_item_clicked(self, item):
        # ... (این متد بدون تغییر باقی می‌ماند) ...
        notification_data = item.data(Qt.UserRole)
        if notification_data:
            self.parent_window._handle_notification_action(
                notification_data['action_key'],
                notification_data['action_data']
            )
            self.hide()

    def show_panel(self, button_widget):
        # ... (این متد بدون تغییر باقی می‌ماند) ...
        self._load_notifications()
        button_pos = button_widget.mapToGlobal(QtCore.QPoint(0, 0))
        ideal_x = button_pos.x() + button_widget.width() - self.width()
        final_x = max(5, ideal_x)
        target_pos = QtCore.QPoint(final_x, button_pos.y() + button_widget.height() + 5)
        self.move(target_pos)
        self.setWindowOpacity(0.0)
        self.show()
        self.animation.setStartValue(0.0)
        self.animation.setEndValue(1.0)
        self.animation.start()
                
# کل کلاس NotificationsDialog را با این نسخه جایگزین کنید
class NotificationsDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نمایش تمام موارد نیازمند اقدام کاربر با استفاده از کارت‌های اعلان."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent
        self.setWindowTitle("کارتابل اعلانات")
        self.setMinimumSize(500, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        
        # استفاده از QListWidget به جای QTableWidget
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setStyleSheet("QListWidget { border: none; background-color: #f4f6f9; }")
        self.list_widget.setSpacing(8)
        self.list_widget.itemClicked.connect(self._on_item_clicked)
        
        layout.addWidget(self.list_widget)
        self._load_notifications()

    def _load_notifications(self):
        self.list_widget.clear()
        notifications = self.parent_window.notifications_cache
        
        if not notifications:
            # نمایش پیام در صورت خالی بودن
            placeholder_label = QtWidgets.QLabel("هیچ اعلان یا کار جدیدی برای شما وجود ندارد.")
            placeholder_label.setAlignment(Qt.AlignCenter)
            placeholder_label.setStyleSheet("color: #95a5a6; font-style: italic; padding: 50px;")
            item = QtWidgets.QListWidgetItem(self.list_widget)
            item.setSizeHint(placeholder_label.sizeHint())
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, placeholder_label)
            return

        for notif in notifications:
            card = NotificationCard(notif)
            item = QtWidgets.QListWidgetItem(self.list_widget)
            item.setSizeHint(card.sizeHint())
            # ذخیره اطلاعات برای کلیک
            item.setData(Qt.UserRole, notif)
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, card)

    def _on_item_clicked(self, item):
        """با کلیک روی یک کارت، عملیات مربوطه را اجرا می‌کند."""
        notification_data = item.data(Qt.UserRole)
        if notification_data:
            self.parent_window._handle_notification_action(
                notification_data['action_key'],
                notification_data['action_data']
            )
            self.close()
                    
# این کلاس کاملاً جدید را به کد خود اضافه کنید
class NotificationCard(QtWidgets.QFrame):
    """یک ویجت سفارشی برای نمایش یک اعلان به صورت گرافیکی."""
    def __init__(self, notification_data, parent=None):
        super().__init__(parent)
        self.setObjectName("notificationCard")
        self.setCursor(Qt.PointingHandCursor)
        
        # استایل‌دهی بر اساس اولویت
        priority_styles = {
            1: "border-left: 5px solid #e74c3c;", # High
            2: "border-left: 5px solid #3498db;", # Normal
            3: "border-left: 5px solid #95a5a6;"  # Low
        }
        base_style = """
            QFrame#notificationCard {
                background-color: white;
                border-radius: 5px;
                padding: 12px;
            }
            QFrame#notificationCard:hover {
                background-color: #f8f9fa;
            }
        """
        self.setStyleSheet(base_style + priority_styles.get(notification_data.get('priority', 2)))

        layout = QtWidgets.QHBoxLayout(self)
        layout.setSpacing(12)

        # آیکون بر اساس نوع
        icon_map = {
            "درخواست مواد": "go-down",
            "تحویل از تولید": "go-up",
            "برگشت از تولید": "go-previous",
            "انتقال به تولید": "go-jump"
        }
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_map.get(notification_data['type'], "dialog-information")).pixmap(32, 32))
        layout.addWidget(icon_label)

        text_layout = QtWidgets.QVBoxLayout()
        text_layout.setSpacing(2)
        type_label = QtWidgets.QLabel(f"<b>{notification_data['type']}</b>")
        details_label = QtWidgets.QLabel(notification_data['details'])
        details_label.setWordWrap(True)
        date_label = QtWidgets.QLabel(to_shamsi(notification_data['date']))
        date_label.setStyleSheet("color: #7f8c8d; font-size: 9pt;")
        text_layout.addWidget(type_label)
        text_layout.addWidget(details_label)
        text_layout.addWidget(date_label)
        layout.addLayout(text_layout, 1)
        
# این کلاس جدید را به انتهای فایل، قبل از MainWindow اضافه کنید
class SupplierManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت کامل تامین‌کنندگان."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_supplier_id = None

        self.setWindowTitle("مدیریت تامین‌کنندگان")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 600)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        # پنل راست: لیست تامین‌کنندگان
        list_panel = QtWidgets.QWidget()
        list_layout = QtWidgets.QVBoxLayout(list_panel)
        list_layout.addWidget(QtWidgets.QLabel("<b>لیست تامین‌کنندگان</b>"))
        self.tbl_suppliers = QtWidgets.QTableWidget()
        self._style_table(self.tbl_suppliers)
        self.tbl_suppliers.itemClicked.connect(self._populate_fields_for_edit)
        list_layout.addWidget(self.tbl_suppliers)
        splitter.addWidget(list_panel)

        # پنل چپ: فرم ورود و ویرایش اطلاعات
        form_panel = QtWidgets.QWidget()
        form_layout = QtWidgets.QVBoxLayout(form_panel)
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش تامین‌کننده")
        self.form = QtWidgets.QFormLayout(form_group)
        self.form.setSpacing(10)
        
        self.name_edit = QtWidgets.QLineEdit()
        self.contact_edit = QtWidgets.QLineEdit()
        self.phone_edit = QtWidgets.QLineEdit()
        self.email_edit = QtWidgets.QLineEdit()
        self.address_edit = QtWidgets.QTextEdit(); self.address_edit.setFixedHeight(60)
        self.ecode_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QTextEdit(); self.notes_edit.setFixedHeight(60)
        self.is_active_check = QtWidgets.QCheckBox("فعال")
        self.is_active_check.setChecked(True)

        self.form.addRow("نام شرکت (*):", self.name_edit)
        self.form.addRow("فرد رابط:", self.contact_edit)
        self.form.addRow("تلفن:", self.phone_edit)
        self.form.addRow("ایمیل:", self.email_edit)
        self.form.addRow("آدرس:", self.address_edit)
        self.form.addRow("کد اقتصادی:", self.ecode_edit)
        self.form.addRow("یادداشت:", self.notes_edit)
        self.form.addRow("وضعیت:", self.is_active_check)
        form_layout.addWidget(form_group)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_save.setProperty("class", "primary")
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف")
        btn_delete.setProperty("class", "danger")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن فرم")
        btn_layout.addWidget(btn_save); btn_layout.addWidget(btn_delete); btn_layout.addStretch(); btn_layout.addWidget(btn_clear)
        form_layout.addLayout(btn_layout)
        
        splitter.addWidget(form_panel)
        splitter.setSizes([550, 350])

        btn_save.clicked.connect(self._save_supplier)
        btn_delete.clicked.connect(self._delete_supplier)
        btn_clear.clicked.connect(self._clear_fields)
        
        self._load_suppliers()

    def _style_table(self, tbl):
        tbl.setAlternatingRowColors(True)
        tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tbl.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)

    def _load_suppliers(self):
        self.tbl_suppliers.setRowCount(0)
        suppliers = self.db.get_all_suppliers()
        headers = ['ID', 'نام شرکت', 'فرد رابط', 'تلفن', 'وضعیت']
        self.tbl_suppliers.setColumnCount(len(headers))
        self.tbl_suppliers.setHorizontalHeaderLabels(headers)
        self.tbl_suppliers.setColumnHidden(0, True)
        self.tbl_suppliers.setRowCount(len(suppliers))
        for r, sup in enumerate(suppliers):
            self.tbl_suppliers.setItem(r, 0, QtWidgets.QTableWidgetItem(str(sup['id'])))
            self.tbl_suppliers.setItem(r, 1, QtWidgets.QTableWidgetItem(sup['name']))
            self.tbl_suppliers.setItem(r, 2, QtWidgets.QTableWidgetItem(sup.get('contact_person', '')))
            self.tbl_suppliers.setItem(r, 3, QtWidgets.QTableWidgetItem(sup.get('phone', '')))
            status_item = QtWidgets.QTableWidgetItem("فعال" if sup.get('is_active') else "غیرفعال")
            status_item.setForeground(QtGui.QColor("green") if sup.get('is_active') else QtGui.QColor("red"))
            self.tbl_suppliers.setItem(r, 4, status_item)
        self.tbl_suppliers.resizeColumnsToContents()
        self.tbl_suppliers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.current_supplier_id = int(self.tbl_suppliers.item(row, 0).text())
        # برای خواندن اطلاعات کامل، یکبار دیگر از دیتابیس استعلام می‌کنیم
        supplier_details = self.db.execute_query("SELECT * FROM suppliers WHERE id = %s", (self.current_supplier_id,), fetch_one=True)
        if not supplier_details: return

        self.name_edit.setText(supplier_details.get('name', ''))
        self.contact_edit.setText(supplier_details.get('contact_person', ''))
        self.phone_edit.setText(supplier_details.get('phone', ''))
        self.email_edit.setText(supplier_details.get('email', ''))
        self.address_edit.setPlainText(supplier_details.get('address', ''))
        self.ecode_edit.setText(supplier_details.get('economic_code', ''))
        self.notes_edit.setPlainText(supplier_details.get('notes', ''))
        self.is_active_check.setChecked(supplier_details.get('is_active', True))

    def _clear_fields(self):
        self.current_supplier_id = None
        self.tbl_suppliers.clearSelection()
        for widget in [self.name_edit, self.contact_edit, self.phone_edit, self.email_edit, self.ecode_edit]:
            widget.clear()
        for widget in [self.address_edit, self.notes_edit]:
            widget.clear()
        self.is_active_check.setChecked(True)
        self.name_edit.setFocus()

    def _save_supplier(self):
        supplier_data = {
            "name": self.name_edit.text().strip(),
            "contact_person": self.contact_edit.text().strip(),
            "phone": self.phone_edit.text().strip(),
            "email": self.email_edit.text().strip(),
            "address": self.address_edit.toPlainText().strip(),
            "economic_code": self.ecode_edit.text().strip(),
            "notes": self.notes_edit.toPlainText().strip(),
            "is_active": self.is_active_check.isChecked()
        }
        try:
            self.db.add_or_update_supplier(supplier_data, self.current_supplier_id)
            if self.toast: self.toast.show_message("✔ اطلاعات تامین‌کننده با موفقیت ذخیره شد.", "success")
            self._load_suppliers()
            self._clear_fields()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ذخیره‌سازی", str(e))

    def _delete_supplier(self):
        if self.current_supplier_id is None:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک تامین‌کننده را از لیست انتخاب کنید.", "warning")
            return
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف تامین‌کننده «{self.name_edit.text()}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_supplier(self.current_supplier_id)
                if self.toast: self.toast.show_message("✔ تامین‌کننده با موفقیت حذف شد.", "info")
                self._load_suppliers()
                self._clear_fields()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در حذف", f"این تامین‌کننده احتمالاً در سوابق خرید استفاده شده و قابل حذف نیست.\nبه جای حذف، آن را غیرفعال کنید.\n\n{e}")


# این کلاس جدید را به انتهای فایل، قبل از MainWindow اضافه کنید
class CreatePurchaseRequestDialog(QtWidgets.QDialog):
    """دیالوگی برای ایجاد یک درخواست خرید جدید."""
    def __init__(self, item_name, suggested_qty, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ایجاد درخواست خرید جدید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(400)

        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.item_label = QtWidgets.QLabel(f"<b>{item_name}</b>")
        self.qty_edit = QtWidgets.QLineEdit(str(suggested_qty))
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, 1e9, 3))
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری: توضیحات لازم برای واحد بازرگانی")

        layout.addRow("برای کالای:", self.item_label)
        layout.addRow("مقدار مورد نیاز:", self.qty_edit)
        layout.addRow("یادداشت:", self.notes_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت و ارسال درخواست")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        """داده‌های وارد شده توسط کاربر را برمی‌گرداند."""
        try:
            qty = float(self.qty_edit.text())
            if qty > 0:
                return {
                    "quantity": qty,
                    "notes": self.notes_edit.text().strip()
                }
        except (ValueError, TypeError):
            pass
        return None
                
# این کلاس را به طور کامل جایگزین کنید
class WorkflowStepDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک مرحله از فرآیند (با قابلیت تعریف قانون)."""
    def __init__(self, db: DB, workflow_id: int, workflow_form_id: int, step_data=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.workflow_id = workflow_id # <<-- اصلاح ۱: شناسه فرآیند اینجا ذخیره می‌شود
        self.workflow_form_id = workflow_form_id
        self.current_rules = step_data.get('rules') if step_data and isinstance(step_data.get('rules'), dict) else None
        
        self.setWindowTitle("افزودن / ویرایش مرحله فرآیند")
        self.setMinimumWidth(500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.step_name_edit = QtWidgets.QLineEdit()
        self.step_order_spin = QtWidgets.QSpinBox(); self.step_order_spin.setRange(10, 1000); self.step_order_spin.setSingleStep(10)
        self.approver_type_combo = QtWidgets.QComboBox(); self.approver_type_combo.addItems(["نقش مشخص (Role)", "مدیر واحد درخواست دهنده", "مدیر عامل (CEO)"])
        self.approver_role_combo = QtWidgets.QComboBox()
        self.success_status_edit = QtWidgets.QLineEdit(placeholderText="مثال: تایید مدیر واحد")
        self.failure_status_edit = QtWidgets.QLineEdit(placeholderText="مثال: رد شده توسط مدیر واحد")
        
        layout.addRow("نام مرحله (*):", self.step_name_edit)
        layout.addRow("ترتیب اجرا (*):", self.step_order_spin)
        layout.addRow("نوع تایید کننده (*):", self.approver_type_combo)
        self.approver_role_row = layout.addRow("نقش تایید کننده:", self.approver_role_combo)
        layout.addRow("متن وضعیت در صورت تایید:", self.success_status_edit)
        layout.addRow("متن وضعیت در صورت رد:", self.failure_status_edit)

        self.btn_manage_rules = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("preferences-system"), " مدیریت قوانین شرطی")
        layout.addRow(self.btn_manage_rules)
        self.btn_manage_rules.clicked.connect(self._open_rule_editor)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addRow(buttons)
        
        self.approver_type_combo.currentIndexChanged.connect(self._toggle_role_selector)
        self._load_roles()
        
        if step_data:
            self.step_name_edit.setText(step_data.get('step_name', ''))
            self.step_order_spin.setValue(step_data.get('step_order', 10))
            type_map = {'ROLE': 0, 'REQUESTER_MANAGER': 1, 'CEO': 2}
            self.approver_type_combo.setCurrentIndex(type_map.get(step_data.get('approver_type'), 0))
            if step_data.get('approver_role_id'):
                index = self.approver_role_combo.findData(step_data['approver_role_id'])
                if index != -1: self.approver_role_combo.setCurrentIndex(index)
            self.success_status_edit.setText(step_data.get('success_status_text', ''))
            self.failure_status_edit.setText(step_data.get('failure_status_text', ''))
        
        self._toggle_role_selector()

    def _load_roles(self):
        roles = self.db.get_all_roles()
        for role in roles:
            self.approver_role_combo.addItem(role['name'], role['id'])
            
    def _toggle_role_selector(self):
        is_role_type = self.approver_type_combo.currentIndex() == 0
        self.approver_role_combo.setVisible(is_role_type)
        self.layout().labelForField(self.approver_role_combo).setVisible(is_role_type)
        
    def _open_rule_editor(self):
        if not self.workflow_form_id:
            QtWidgets.QMessageBox.warning(self, "خطا", "ابتدا باید برای این فرآیند یک فرم مشخص کرده و آن را ذخیره کنید.")
            return
            
        form_fields = self.db.get_form_fields(self.workflow_form_id)
        if not form_fields:
            QtWidgets.QMessageBox.warning(self, "خطا", "فرم انتخاب شده هیچ فیلدی برای تعریف قانون ندارد.")
            return

        # <<-- اصلاح ۲: ارسال تمام آرگومان‌های لازم به RuleEditorDialog -->>
        dlg = RuleEditorDialog(
            db=self.db,
            workflow_id=self.workflow_id,
            current_step_order=self.step_order_spin.value(),
            form_fields=form_fields,
            current_rules=self.current_rules,
            parent=self
        )
        if dlg.exec_():
            self.current_rules = dlg.get_rules()
            # نمایش خلاصه‌ای از قانون برای کاربر
            if self.current_rules:
                self.btn_manage_rules.setText("✔ یک قانون شرطی تعریف شده است")
            else:
                self.btn_manage_rules.setText("مدیریت قوانین شرطی")


    def get_data(self):
        if not self.step_name_edit.text().strip(): return None
        type_map = {0: 'ROLE', 1: 'REQUESTER_MANAGER', 2: 'CEO'}
        return {
            "step_name": self.step_name_edit.text().strip(),
            "step_order": self.step_order_spin.value(),
            "approver_type": type_map[self.approver_type_combo.currentIndex()],
            "approver_role_id": self.approver_role_combo.currentData() if self.approver_type_combo.currentIndex() == 0 else None,
            "success_status_text": self.success_status_edit.text().strip(),
            "failure_status_text": self.failure_status_edit.text().strip(),
            "rules": self.current_rules
        }
        
class StartConditionDialog(QtWidgets.QDialog):
    """دیالوگ پیشرفته برای تعریف محرک‌های شروع یک فرآیند (رویداد سیستمی یا فرآیند دیگر)."""
    def __init__(self, db, current_conditions: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تنظیم قوانین شروع خودکار فرآیند")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(600)

        # --- کاتالوگ رویدادهای سیستمی ---
        self.SYSTEM_EVENTS = {
            'stock.level.below_minimum': "موجودی کالا به حد سفارش رسید",
            'stock.receipt.confirmed': "ورود کالا از تامین‌کننده تایید شد",
            'production.batch.completed': "تولید بچ محصول فله تکمیل شد",
            'qc.inspection.passed': "نتیجه کنترل کیفیت ورودی 'موفق' بود",
            'qc.inspection.failed': "نتیجه کنترل کیفیت ورودی 'ناموفق' بود",
        }

        layout = QtWidgets.QVBoxLayout(self)
        
        self.trigger_type_combo = QtWidgets.QComboBox()
        self.trigger_type_combo.addItems(["این فرآیند به صورت خودکار شروع نمی‌شود", "وقتی یک رویداد سیستمی رخ می‌دهد", "وقتی یک فرآیند دیگر به نتیجه می‌رسد"])
        layout.addWidget(self.trigger_type_combo)

        self.stack = QtWidgets.QStackedWidget()
        layout.addWidget(self.stack)

        # پنل خالی
        self.stack.addWidget(QtWidgets.QWidget())

        # پنل رویدادهای سیستمی
        event_panel = QtWidgets.QWidget(); event_layout = QtWidgets.QFormLayout(event_panel)
        self.system_event_combo = QtWidgets.QComboBox()
        for code, desc in self.SYSTEM_EVENTS.items():
            self.system_event_combo.addItem(desc, code)
        event_layout.addRow("نام رویداد:", self.system_event_combo)
        self.stack.addWidget(event_panel)

        # پنل فرآیندهای دیگر
        process_panel = QtWidgets.QWidget(); process_layout = QtWidgets.QFormLayout(process_panel)
        self.parent_process_combo = QtWidgets.QComboBox()
        self.process_outcome_combo = QtWidgets.QComboBox()
        self.process_outcome_combo.addItems(["با موفقیت تمام شود", "رد (ناموفق) شود"])
        process_layout.addRow("فرآیند والد:", self.parent_process_combo)
        process_layout.addRow("اگر آن فرآیند:", self.process_outcome_combo)
        self.stack.addWidget(process_panel)
        
        active_workflows = self.db.get_active_workflows()
        for wf in active_workflows:
            self.parent_process_combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])

        self.trigger_type_combo.currentIndexChanged.connect(self.stack.setCurrentIndex)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        if current_conditions:
            self._load_existing_conditions(current_conditions)

    def _load_existing_conditions(self, conditions):
        cond_type = conditions.get('type')
        if cond_type == 'system_event':
            self.trigger_type_combo.setCurrentIndex(1)
            index = self.system_event_combo.findData(conditions.get('event_code'))
            if index != -1: self.system_event_combo.setCurrentIndex(index)
        elif cond_type == 'process_outcome':
            self.trigger_type_combo.setCurrentIndex(2)
            index = self.parent_process_combo.findData(conditions.get('parent_process_id'))
            if index != -1: self.parent_process_combo.setCurrentIndex(index)
            self.process_outcome_combo.setCurrentIndex(1 if conditions.get('outcome') == 'REJECTED' else 0)
        else:
            self.trigger_type_combo.setCurrentIndex(0)

    def get_data(self):
        idx = self.trigger_type_combo.currentIndex()
        if idx == 0:
            return None
        elif idx == 1:
            return {
                "type": "system_event",
                "event_code": self.system_event_combo.currentData()
            }
        elif idx == 2:
            return {
                "type": "process_outcome",
                "parent_process_id": self.parent_process_combo.currentData(),
                "outcome": "COMPLETED" if self.process_outcome_combo.currentIndex() == 0 else "REJECTED"
            }
        return None
        
        
# کل کلاس WorkflowManagerDialog را با این نسخه نهایی و کامل جایگزین کنید
class WorkflowManagerDialog(QtWidgets.QDialog):
    """طراح فرآیند هوشمند با قابلیت تعریف محرک‌ها و اقدامات نهایی پویا و هوشمند (نسخه نهایی و کامل)."""
    def __init__(self, db: DB, user_id: int, parent=None, workflow_id=None):
            super().__init__(parent)
            self.db = db; self.user_id = user_id; self.toast = getattr(parent, 'toast', None)
            self.current_workflow_id = workflow_id
            
            self.FINAL_ACTIONS_CATALOG = {
                "UPDATE_STATUS": {"name": "تغییر وضعیت سند", "value_type": "dropdown"},
                "CREATE_PROD_ORDER_FROM_SO": {"name": "ایجاد سفارش تولید از روی سفارش فروش", "value_type": "none"}
            }
            self.PROCESS_TYPE_STATUSES = {
                "PURCHASING": ["تایید نهایی شد - آماده اقدام بازرگانی", "ارسال شده برای استعلام"],
                "SALES": ["آماده ارسال", "در حال پردازش مالی"]
            }

            self.setWindowTitle("طراح و مدیر فرآیندهای سازمانی (QA)")
            self.setFont(QFont(FONT_FAMILY, FONT_SIZE)); self.setMinimumSize(1100, 750)
            
            main_layout = QtWidgets.QHBoxLayout(self); splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal); main_layout.addWidget(splitter)
            
            self.workflows_list = QtWidgets.QListWidget()
            self.wf_name_edit = QtWidgets.QLineEdit()
            self.wf_desc_edit = QtWidgets.QLineEdit(placeholderText="توضیحی کوتاه درباره کاربرد این فرآیند")
            self.wf_type_combo = QtWidgets.QComboBox()
            self.wf_form_combo = QtWidgets.QComboBox()
            self.final_action_type_combo = QtWidgets.QComboBox()
            self.final_action_value_widget = QtWidgets.QComboBox()
            self.final_action_value_row_widget = QtWidgets.QWidget()
            self.dept_access_tree = QtWidgets.QTreeWidget()
            self.dept_access_tree.setHeaderHidden(True)
            self.wf_is_manual_check = QtWidgets.QCheckBox("این فرآیند به صورت دستی توسط کاربران قابل شروع است")
            self.status_label = QtWidgets.QLabel()
            self.steps_table = QtWidgets.QTableWidget()
            self.btn_save_details = QtWidgets.QPushButton("ذخیره مشخصات")
            self.btn_submit_approval = QtWidgets.QPushButton("ارسال برای تایید نهایی")
            self.steps_group = QtWidgets.QGroupBox("مراحل فرآیند (به ترتیب اجرا)")
            
            workflows_panel = QtWidgets.QWidget(); workflows_layout = QtWidgets.QVBoxLayout(workflows_panel)
            workflows_layout.addWidget(QtWidgets.QLabel("<b>فرآیندهای تعریف شده</b>"));
            workflows_layout.addWidget(self.workflows_list)
            wf_btn_layout = QtWidgets.QHBoxLayout(); btn_add_wf = QtWidgets.QPushButton("فرآیند جدید"); btn_del_wf = QtWidgets.QPushButton("حذف/آرشیو"); wf_btn_layout.addWidget(btn_add_wf); wf_btn_layout.addWidget(btn_del_wf); workflows_layout.addLayout(wf_btn_layout); splitter.addWidget(workflows_panel)

            details_panel = QtWidgets.QWidget(); details_layout = QtWidgets.QVBoxLayout(details_panel)
            details_group = QtWidgets.QGroupBox("مشخصات فرآیند")
            group_main_layout = QtWidgets.QVBoxLayout(details_group)
            top_form_layout = QtWidgets.QFormLayout()
            top_form_layout.addRow("نام فرآیند:", self.wf_name_edit); top_form_layout.addRow("توضیحات:", self.wf_desc_edit)
            top_form_layout.addRow("نوع فرآیند (جهت دسته‌بندی):", self.wf_type_combo)
            top_form_layout.addRow("فرم مرتبط (*):", self.wf_form_combo)
            
            self.final_action_type_combo.addItem("--- هیچکدام ---", None)
            for key, data in self.FINAL_ACTIONS_CATALOG.items(): self.final_action_type_combo.addItem(data['name'], key)
            
            top_form_layout.addRow("اقدام نهایی پس از تکمیل موفق:", self.final_action_type_combo)
            final_action_value_row_layout = QtWidgets.QFormLayout(self.final_action_value_row_widget)
            final_action_value_row_layout.setContentsMargins(0,0,0,0)
            final_action_value_row_layout.addRow("مقدار/وضعیت:", self.final_action_value_widget)
            top_form_layout.addRow(self.final_action_value_row_widget)

            group_main_layout.addLayout(top_form_layout)
            self.wf_is_manual_check.setChecked(True)
            group_main_layout.addWidget(self.wf_is_manual_check)
            
            self.dept_access_group = QtWidgets.QGroupBox("واحدهای مجاز برای شروع (برای فرآیندهای دستی):")
            dept_access_layout = QtWidgets.QVBoxLayout(self.dept_access_group)
            self.dept_access_tree.setStyleSheet("border: 1px solid #ced4da; border-radius: 5px;")
            dept_access_layout.addWidget(self.dept_access_tree)
            group_main_layout.addWidget(self.dept_access_group)
            
            self.status_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
            group_main_layout.addWidget(self.status_label, 0, QtCore.Qt.AlignCenter)
            details_layout.addWidget(details_group)
            
            self.workflow_actions_layout = QtWidgets.QHBoxLayout()
            self.btn_submit_approval.setProperty("class", "primary")
            self.workflow_actions_layout.addStretch(); self.workflow_actions_layout.addWidget(self.btn_save_details); self.workflow_actions_layout.addWidget(self.btn_submit_approval)
            details_layout.addLayout(self.workflow_actions_layout)
            
            self.steps_layout = QtWidgets.QVBoxLayout(self.steps_group)
            self.steps_table.setColumnCount(5); self.steps_table.setHorizontalHeaderLabels(['ID', 'ترتیب', 'نام مرحله', 'تایید کننده', 'نقش']); self.steps_table.setColumnHidden(0, True); self.steps_table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
            self.steps_layout.addWidget(self.steps_table)
            self.steps_btn_layout = QtWidgets.QHBoxLayout(); btn_add_step = QtWidgets.QPushButton("افزودن"); btn_edit_step = QtWidgets.QPushButton("ویرایش"); btn_del_step = QtWidgets.QPushButton("حذف"); self.steps_btn_layout.addStretch(); self.steps_btn_layout.addWidget(btn_add_step); self.steps_btn_layout.addWidget(btn_edit_step); self.steps_btn_layout.addWidget(btn_del_step); self.steps_layout.addLayout(self.steps_btn_layout); details_layout.addWidget(self.steps_group, 1)
            splitter.addWidget(details_panel); splitter.setSizes([300, 800])
            
            self.workflows_list.itemSelectionChanged.connect(self.on_workflow_selected); self.workflows_list.itemDoubleClicked.connect(self._edit_workflow_from_list)
            btn_add_wf.clicked.connect(self._add_workflow); btn_del_wf.clicked.connect(self._delete_workflow)
            self.btn_save_details.clicked.connect(self._save_workflow_details); self.btn_submit_approval.clicked.connect(self._submit_for_approval)
            btn_add_step.clicked.connect(self._add_step); btn_edit_step.clicked.connect(self._edit_step); btn_del_step.clicked.connect(self._delete_step)
            self.final_action_type_combo.currentIndexChanged.connect(self._on_final_action_type_changed)
            self.wf_type_combo.currentIndexChanged.connect(self._on_final_action_type_changed)
            self.wf_is_manual_check.toggled.connect(self.dept_access_group.setVisible)
            self.dept_access_tree.itemChanged.connect(self._on_dept_access_item_changed)
            
            self._populate_process_types_combo(); self._populate_qa_forms_combo(); self._load_workflows()
            
            # --- *** اصلاح کلیدی: فراخوانی متد فراموش شده در اینجا اضافه شد *** ---
            self._populate_department_tree()
            
            if self.current_workflow_id:
                for i in range(self.workflows_list.count()):
                    if self.workflows_list.item(i).data(Qt.UserRole)['id'] == self.current_workflow_id: self.workflows_list.setCurrentRow(i); break
            else: self._clear_details()

    def _populate_department_tree(self):
        """درخت دپارتمان‌ها را با ساختار سلسله‌مراتبی بارگذاری می‌کند."""
        self.dept_access_tree.clear()
        departments = self.db.get_departments_tree()
        dept_map = {d['id']: d for d in departments}
        item_map = {}

        for dept in departments:
            item = QtWidgets.QTreeWidgetItem([dept['name']])
            item.setData(0, Qt.UserRole, dept['id'])
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(0, QtCore.Qt.Unchecked)
            item_map[dept['id']] = item
        
        for dept_id, item in item_map.items():
            parent_id = dept_map.get(dept_id, {}).get('parent_id')
            if parent_id and parent_id in item_map:
                item_map[parent_id].addChild(item)
            else:
                self.dept_access_tree.addTopLevelItem(item)
        self.dept_access_tree.expandAll()
        
    # (بقیه متدهای این کلاس تا on_workflow_selected بدون تغییر باقی می‌مانند)
    def _on_final_action_type_changed(self):
        action_key = self.final_action_type_combo.currentData()
        action_config = self.FINAL_ACTIONS_CATALOG.get(action_key)
        
        is_visible = bool(action_config and action_config['value_type'] != 'none')
        self.final_action_value_row_widget.setVisible(is_visible)
        
        if is_visible and action_config['value_type'] == 'dropdown':
            self.final_action_value_widget.clear()
            process_type_key = self.wf_type_combo.itemData(self.wf_type_combo.currentIndex())
            allowed_statuses = self.PROCESS_TYPE_STATUSES.get(process_type_key, [])
            if allowed_statuses:
                self.final_action_value_widget.addItems(allowed_statuses)
                self.final_action_value_widget.setEnabled(True)
            else:
                self.final_action_value_widget.addItem("ابتدا نوع فرآیند را مشخص کنید")
                self.final_action_value_widget.setEnabled(False)

    def _clear_details(self):
        self.current_workflow_id = None; self.workflows_list.clearSelection()
        self.wf_name_edit.clear(); self.wf_desc_edit.clear(); self.wf_form_combo.setCurrentIndex(0)
        self.wf_type_combo.setCurrentIndex(0); self.steps_table.setRowCount(0); self.final_action_type_combo.setCurrentIndex(0)
        self.wf_is_manual_check.setChecked(True)
        # پاک کردن تیک‌های درخت
        iterator = QtWidgets.QTreeWidgetItemIterator(self.dept_access_tree)
        while iterator.value():
            iterator.value().setCheckState(0, QtCore.Qt.Unchecked)
            iterator += 1
        self._update_status_and_controls('NONE')

    # --- *** اصلاح ۴: متد on_workflow_selected برای کار با درخت بازنویسی می‌شود *** ---
    def on_workflow_selected(self):
        selected = self.workflows_list.selectedItems()
        if not selected: self._clear_details(); return
        
        wf_data = selected[0].data(Qt.UserRole)
        self.current_workflow_id = wf_data['id']
        accessible_dept_ids = {d['department_id'] for d in self.db.execute_query("SELECT department_id FROM manual_workflow_access WHERE workflow_id = %s", (self.current_workflow_id,))}

        self.wf_name_edit.setText(wf_data.get('name', ''))
        self.wf_desc_edit.setText(wf_data.get('description', ''))
        
        process_type_key = wf_data.get('process_type_key'); 
        index = self.wf_type_combo.findData(process_type_key) if process_type_key else 0
        self.wf_type_combo.setCurrentIndex(index if index != -1 else 0)
        
        final_action_json = wf_data.get('final_action_key')
        self.final_action_type_combo.blockSignals(True)
        self.final_action_value_widget.blockSignals(True)
        self._on_final_action_type_changed() 
        if final_action_json and isinstance(final_action_json, str):
            try:
                final_action = json.loads(final_action_json)
                action_type = final_action.get('type'); action_value = final_action.get('value')
                index_type = self.final_action_type_combo.findData(action_type)
                if index_type != -1: self.final_action_type_combo.setCurrentIndex(index_type)
                
                self._on_final_action_type_changed() 
                self.final_action_value_widget.setCurrentText(str(action_value or ''))
            except (json.JSONDecodeError, TypeError): self.final_action_type_combo.setCurrentIndex(0)
        else: self.final_action_type_combo.setCurrentIndex(0)
        self.final_action_type_combo.blockSignals(False)
        self.final_action_value_widget.blockSignals(False)
        self._on_final_action_type_changed()
            
        self.wf_is_manual_check.setChecked(wf_data.get('is_manual_start', True))
        form_id = wf_data.get('form_def_id'); index = self.wf_form_combo.findData(form_id) if form_id else 0; self.wf_form_combo.setCurrentIndex(index if index != -1 else 0)
        
        # پر کردن و تیک زدن درخت دپارتمان‌ها
        self.dept_access_tree.blockSignals(True)
        iterator = QtWidgets.QTreeWidgetItemIterator(self.dept_access_tree)
        while iterator.value():
            item = iterator.value()
            dept_id = item.data(0, Qt.UserRole)
            item.setCheckState(0, QtCore.Qt.Checked if dept_id in accessible_dept_ids else QtCore.Qt.Unchecked)
            iterator += 1
        self.dept_access_tree.blockSignals(False)
        
        self._update_status_and_controls(wf_data.get('status', 'DRAFT')); self._load_steps()

    # --- *** اصلاح ۵: متد _save_workflow_details برای خواندن از درخت بازنویسی می‌شود *** ---
    def _save_workflow_details(self):
        name = self.wf_name_edit.text().strip();
        if not name: QtWidgets.QMessageBox.warning(self, "خطا", "نام فرآیند باید مشخص شود."); return
        
        action_type = self.final_action_type_combo.currentData()
        final_action_json = None
        if action_type:
            final_action = {"type": action_type}
            if self.FINAL_ACTIONS_CATALOG[action_type]['value_type'] != 'none':
                final_action['value'] = self.final_action_value_widget.currentText()
            final_action_json = json.dumps(final_action, ensure_ascii=False)
        
        # خواندن ID های تیک خورده از درخت
        selected_dept_ids = []
        if self.wf_is_manual_check.isChecked():
            iterator = QtWidgets.QTreeWidgetItemIterator(self.dept_access_tree)
            while iterator.value():
                item = iterator.value()
                if item.checkState(0) == QtCore.Qt.Checked:
                    selected_dept_ids.append(item.data(0, Qt.UserRole))
                iterator += 1

        data_to_save = { "name": name, "description": self.wf_desc_edit.text().strip(), "process_type_key": self.wf_type_combo.currentData(), "form_def_id": self.wf_form_combo.currentData(), "final_action_key": final_action_json, "is_manual_start": self.wf_is_manual_check.isChecked() }
        
        status = 'DRAFT'
        if self.current_workflow_id:
            wf_data = self.db.execute_query("SELECT status FROM workflows WHERE id=%s", (self.current_workflow_id,), fetch_one=True)
            status = wf_data.get('status', 'DRAFT')

        if status in ['ACTIVE', 'PENDING_APPROVAL']:
            if QtWidgets.QMessageBox.question(self, "تایید نسخه‌برداری", "این فرآیند فعال است. برای ویرایش، یک نسخه جدید ایجاد خواهد شد.\nادامه می‌دهید؟") == QtWidgets.QMessageBox.Yes:
                try: 
                    new_wf_id = self.db.create_new_version_of_workflow(self.current_workflow_id, self.user_id)
                    self.db.save_workflow(data=data_to_save, user_id=self.user_id, accessible_dept_ids=selected_dept_ids, workflow_id=new_wf_id)
                    self.toast.show_message("✔ نسخه جدید ایجاد و ذخیره شد.", "success"); self._refresh_and_reselect(new_wf_id)
                except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد نسخه جدید:\n{e}")
        else:
             try: 
                saved_id = self.db.save_workflow(data=data_to_save, user_id=self.user_id, accessible_dept_ids=selected_dept_ids, workflow_id=self.current_workflow_id)
                self.toast.show_message("✔ تغییرات فرآیند ذخیره شد.", "success"); self._refresh_and_reselect(saved_id)
             except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره فرآیند:\n{e}")

    # --- *** اصلاح ۶: یک متد جدید برای مدیریت انتخاب والد/فرزند در درخت اضافه می‌شود *** ---
    def _on_dept_access_item_changed(self, item, column):
        """وقتی وضعیت تیک یک آیتم در درخت تغییر می‌کند، وضعیت فرزندانش را نیز آپدیت می‌کند."""
        self.dept_access_tree.blockSignals(True)
        # آپدیت فرزندان
        if item.checkState(0) != QtCore.Qt.PartiallyChecked:
            for i in range(item.childCount()):
                item.child(i).setCheckState(0, item.checkState(0))
        # آپدیت والد
        parent = item.parent()
        if parent:
            child_states = [parent.child(i).checkState(0) for i in range(parent.childCount())]
            if all(s == QtCore.Qt.Checked for s in child_states):
                parent.setCheckState(0, QtCore.Qt.Checked)
            elif all(s == QtCore.Qt.Unchecked for s in child_states):
                parent.setCheckState(0, QtCore.Qt.Unchecked)
            else:
                parent.setCheckState(0, QtCore.Qt.PartiallyChecked)
        self.dept_access_tree.blockSignals(False)


        
    def _populate_process_types_combo(self):
        self.wf_type_combo.clear(); self.wf_type_combo.addItem("--- انتخاب کنید ---", None)
        for cat in self.db.get_process_categories(): self.wf_type_combo.addItem(cat['display_name'], cat['category_key'])

    def _load_workflows(self):
        self.workflows_list.clear()
        workflows = self.db.get_workflows()
        status_colors = {'DRAFT': '#6c757d', 'PENDING_APPROVAL': '#fd7e14', 'ACTIVE': '#198754', 'ARCHIVED': '#adb5bd'}
        for wf in workflows:
            item = QtWidgets.QListWidgetItem(f"{wf['name']} (v{wf['version']})"); item.setData(Qt.UserRole, wf)
            item.setForeground(QtGui.QColor(status_colors.get(wf.get('status', 'DRAFT'), '#000000')))
            self.workflows_list.addItem(item)

    def _edit_workflow_from_list(self, item):
        if item: self.workflows_list.setCurrentItem(item)

    def _update_status_and_controls(self, status):
            status_map = {'DRAFT': ("پیش‌نویس", "#6c757d", True, True), 'PENDING_APPROVAL': ("در انتظار تایید", "#fd7e14", False, False), 'ACTIVE': ("فعال", "#198754", True, False), 'ARCHIVED': ("آرشیو شده", "#adb5bd", False, False)}
            text, color, is_editable, can_submit = status_map.get(status, ("نامشخص", "#000", False, False))
            self.status_label.setText(text); self.status_label.setStyleSheet(f"color: {color};")
            can_edit_fields = (status != 'ARCHIVED')
            
            # --- *** اصلاح کلیدی در این خط انجام شده است *** ---
            for widget in [self.wf_name_edit, self.wf_desc_edit, self.wf_form_combo, self.btn_save_details, self.final_action_type_combo, self.final_action_value_widget, self.dept_access_tree, self.wf_is_manual_check]: widget.setEnabled(can_edit_fields)
            
            self.btn_submit_approval.setEnabled(can_submit)
            if status in ['ACTIVE', 'PENDING_APPROVAL']: self.btn_save_details.setText("ایجاد نسخه جدید برای ویرایش")
            else: self.btn_save_details.setText("ذخیره مشخصات")
            self.steps_group.setEnabled(status == 'DRAFT')
        
    def _refresh_and_reselect(self, workflow_id_to_select):
        self._load_workflows()
        for i in range(self.workflows_list.count()):
            item = self.workflows_list.item(i);
            if item.data(Qt.UserRole)['id'] == workflow_id_to_select: self.workflows_list.setCurrentRow(i); break
    
    def _submit_for_approval(self):
        if not self.current_workflow_id: return
        if QtWidgets.QMessageBox.question(self, "ارسال برای تایید", "آیا از ارسال این فرآیند برای تایید نهایی مطمئنید؟") == QtWidgets.QMessageBox.Yes:
            try: self.db.submit_workflow_for_approval(self.current_workflow_id, self.user_id); self.toast.show_message("فرآیند برای تایید ارسال شد.", "success"); self._refresh_and_reselect(self.current_workflow_id)
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ارسال برای تایید:\n{e}")

    def _load_steps(self):
        self.steps_table.setRowCount(0);
        if not self.current_workflow_id: return
        steps = self.db.get_workflow_steps(self.current_workflow_id); self.steps_table.setRowCount(len(steps)); type_map = {'ROLE': 'نقش سازمانی', 'REQUESTER_MANAGER': 'مدیر واحد درخواست دهنده', 'CEO': 'مدیر عامل'}
        for r, step in enumerate(steps): self.steps_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(step['id']))); self.steps_table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(step['step_order']))); self.steps_table.setItem(r, 2, QtWidgets.QTableWidgetItem(step['step_name'])); self.steps_table.setItem(r, 3, QtWidgets.QTableWidgetItem(type_map.get(step['approver_type'], ''))); self.steps_table.setItem(r, 4, QtWidgets.QTableWidgetItem(step.get('role_name', '---')))
    
    def _add_step(self):
        if not self.current_workflow_id: return
        form_id = self.wf_form_combo.currentData(); dlg = WorkflowStepDialog(self.db, self.current_workflow_id, form_id, parent=self)
        if dlg.exec_():
            data = dlg.get_data()
            if data: self.db.save_workflow_step(self.current_workflow_id, data, step_id=None); self._load_steps()
    
    def _edit_step(self):
        selected = self.steps_table.selectedItems()
        if not selected: return
        step_id = int(self.steps_table.item(selected[0].row(), 0).text()); step_data = self.db.execute_query("SELECT * FROM workflow_steps WHERE id = %s", (step_id,), fetch_one=True); form_id = self.wf_form_combo.currentData(); dlg = WorkflowStepDialog(self.db, self.current_workflow_id, form_id, dict(step_data), self)
        if dlg.exec_():
            data = dlg.get_data()
            if data: self.db.save_workflow_step(self.current_workflow_id, data, step_id=step_id); self._load_steps()
    
    def _delete_step(self):
        selected = self.steps_table.selectedItems()
        if not selected: return
        step_id = int(self.steps_table.item(selected[0].row(), 0).text()); self.db.delete_workflow_step(step_id); self._load_steps()
    
    def _add_workflow(self):
        self._clear_details(); self._update_status_and_controls('DRAFT'); self.wf_name_edit.setReadOnly(False); self.wf_desc_edit.setReadOnly(False); self.wf_name_edit.setFocus()
        if self.toast: self.toast.show_message("اطلاعات فرآیند جدید را وارد و ذخیره کنید.", "info")
    
    def _delete_workflow(self):
        if not self.current_workflow_id:
            if self.toast: self.toast.show_message("لطفا ابتدا یک فرآیند را از لیست انتخاب کنید.", "warning"); return
        wf_name = self.wf_name_edit.text()
        if QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا از حذف یا آرشیو کردن فرآیند «{wf_name}» مطمئنید؟") == QtWidgets.QMessageBox.Yes:
            try:
                result = self.db.delete_workflow(self.current_workflow_id)
                if result == "ARCHIVED": self.toast.show_message("این فرآیند دارای سابقه بود و با موفقیت آرشیو شد.", "info")
                elif result == "DELETED": self.toast.show_message("فرآیند با موفقیت به طور کامل حذف شد.", "success")
                self._load_workflows(); self._clear_details()
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"عملیات با خطا مواجه شد:\n{e}")
    
    def _populate_qa_forms_combo(self):
        self.wf_form_combo.clear(); self.wf_form_combo.addItem("--- انتخاب کنید ---", None); qa_forms = self.db.list_form_defs_by_type(form_type='QA', is_admin=True)
        for form in qa_forms: self.wf_form_combo.addItem(form['name'], form['id'])
                
                
                                                            
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید

class DynamicFormDialog(QtWidgets.QDialog):
    """
    نسخه 3.4 (نهایی):
    - از فیلد "لیست کشویی" (dropdown) پشتیبانی می‌کند.
    - فیلد "لیست کالاها" را به صورت یک نمای درختی کامل (دسته‌بندی > مادر > فرزند) نمایش می‌دهد.
    """
    def __init__(self, db: DB, form_id: int, title: str, parent=None,initial_data: dict = None):
        super().__init__(parent)
        self.db = db
        self.form_id = form_id
        self.initial_data = initial_data # <<<<<<< پارامتر جدید را ذخیره کن

        
        self.form_fields = self.db.get_form_fields(self.form_id)
        
        self.setWindowTitle(title)
        self.setMinimumWidth(500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        self.layout = QtWidgets.QFormLayout(self)
        self.layout.setSpacing(15)
        self.widgets = {}
        self.condition_map = {}

        if not self.form_fields:
            self.layout.addRow(QtWidgets.QLabel("خطا: هیچ فیلدی برای این فرم تعریف نشده است."))
            return

        for field in self.form_fields:
            self._create_widget_for_field(field)

        self._connect_conditional_signals()
        self._evaluate_all_conditions()

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.validate_and_accept)
        buttons.rejected.connect(self.reject)
        self.layout.addRow(buttons)

    def _populate_items_tree_model(self, model, category_filter):
        """یک QStandardItemModel را با ساختار درختی کالاها (دسته‌بندی > مادر > فرزند) پر می‌کند."""
        all_items = self.db.items_brief()
        
        items_by_category = {}
        for item in all_items:
            category = item.get('category', 'نامشخص')
            if category not in items_by_category:
                items_by_category[category] = []
            items_by_category[category].append(item)

        root_node = model.invisibleRootItem()
        
        categories_to_show = [category_filter] if category_filter else sorted(items_by_category.keys())

        for category in categories_to_show:
            if category not in items_by_category: continue

            category_node = QtGui.QStandardItem(category)
            category_node.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
            category_node.setFlags(category_node.flags() & ~Qt.ItemIsSelectable)
            root_node.appendRow(category_node)

            items_in_this_category = items_by_category[category]
            items_by_id = {item['id']: dict(item) for item in items_in_this_category}
            child_map = {}
            top_level_items = []

            for item_id, item_data in items_by_id.items():
                parent_id = item_data.get('parent_item_id')
                if parent_id and parent_id in items_by_id:
                    if parent_id not in child_map:
                        child_map[parent_id] = []
                    child_map[parent_id].append(item_data)
                else:
                    top_level_items.append(item_data)
            
            for item_data in sorted(top_level_items, key=lambda x: x['name']):
                parent_node = QtGui.QStandardItem(item_data.get('name', ''))
                parent_node.setData(item_data, Qt.UserRole)
                is_selectable = not item_data.get('is_parent_product', False)
                parent_node.setFlags(parent_node.flags() if is_selectable else parent_node.flags() & ~Qt.ItemIsSelectable)
                category_node.appendRow(parent_node)

                if item_data['id'] in child_map:
                    for child_data in sorted(child_map[item_data['id']], key=lambda x: x['name']):
                        child_node = QtGui.QStandardItem(f"  └ {child_data.get('name', '')}")
                        child_node.setData(child_data, Qt.UserRole)
                        parent_node.appendRow(child_node)

# در کلاس DynamicFormDialog، این متد را به طور کامل جایگزین کنید

    def _create_widget_for_field(self, field_data):
        """یک ویجت می‌سازد و آن را بر اساس اتصال داده سیستمی، پیش‌جمعیت می‌کند."""
        label_text = field_data['label']
        field_id = field_data['id']
        properties = field_data
        
        if properties.get('required'): label_text += " (*)"
        field_type = properties.get('type', 'text')
        widget = None
        
        # ... (بخش ساخت ویجت‌ها بدون تغییر باقی می‌ماند) ...
        if field_type == 'text': widget = QtWidgets.QLineEdit()
        elif field_type == 'number':
            widget = QtWidgets.QLineEdit(); min_val = properties.get('min', -float('inf')); max_val = properties.get('max', float('inf'))
            widget.setValidator(QtGui.QDoubleValidator(float(min_val or -float('inf')), float(max_val or float('inf')), 2))
        elif field_type == 'date': widget = QtWidgets.QLineEdit(); widget.setInputMask("0000/00/00;_")
        elif field_type == 'checkbox': widget = QtWidgets.QCheckBox()
        elif field_type == 'dropdown':
            widget = QtWidgets.QComboBox(); options = properties.get('options', [])
            if isinstance(options, list): widget.addItems(["--- انتخاب کنید ---"] + options)
        # ... (و الی آخر) ...
        elif field_type == 'item_list':
            widget = QtWidgets.QComboBox(); model = QtGui.QStandardItemModel(); placeholder_item = QtGui.QStandardItem("--- انتخاب کنید ---"); placeholder_item.setData(None, Qt.UserRole); model.appendRow(placeholder_item)
            category_filter = properties.get('category_filter'); self._populate_items_tree_model(model, category_filter)
            widget.setModel(model); widget.setView(QtWidgets.QTreeView()); widget.setCurrentIndex(0)
        elif field_type == 'user_list':
            widget = QtWidgets.QComboBox(); widget.addItem("--- انتخاب کنید ---", None)
            for user in self.db.get_all_users_brief(): widget.addItem(user['username'], user['id'])
        elif field_type == 'supplier_list':
            widget = QtWidgets.QComboBox(); widget.addItem("--- انتخاب کنید ---", None)
            for supplier in self.db.get_all_suppliers(active_only=True): widget.addItem(supplier['name'], supplier['id'])
        elif field_type == 'department_list':
            widget = QtWidgets.QComboBox(); widget.addItem("--- انتخاب کنید ---", None)
            for dept in self.db.get_departments_tree(): widget.addItem(dept['name'], dept['id'])
        if widget:
            if isinstance(widget, QtWidgets.QLineEdit) and 'placeholder' in properties:
                 widget.setPlaceholderText(str(properties['placeholder']))
            
            # --- *** بخش جدید و کلیدی: پر کردن خودکار فیلد بر اساس کلید سیستمی *** ---
            system_data_key = properties.get('system_data_key')
            if self.initial_data and system_data_key and system_data_key in self.initial_data:
                value = self.initial_data[system_data_key]
                if isinstance(widget, QtWidgets.QLineEdit):
                    widget.setText(str(value))
                elif isinstance(widget, QtWidgets.QCheckBox):
                    widget.setChecked(bool(value))
            # --- ***************************************************************** ---

            self.layout.addRow(label_text, widget)
            self.widgets[field_id] = {'widget': widget, 'properties': properties, 'label': field_data['label']}
            if 'conditional_logic' in properties and properties['conditional_logic']:
                logic = properties['conditional_logic']; trigger_id = logic.get('trigger_field_id')
                if trigger_id not in self.condition_map: self.condition_map[trigger_id] = []
                self.condition_map[trigger_id].append(field_id)
                
                                
    def _connect_conditional_signals(self):
        for trigger_id, target_ids in self.condition_map.items():
            if trigger_id in self.widgets:
                trigger_widget = self.widgets[trigger_id]['widget']
                if isinstance(trigger_widget, QtWidgets.QLineEdit):
                    trigger_widget.textChanged.connect(self._evaluate_all_conditions)
                elif isinstance(trigger_widget, QtWidgets.QCheckBox):
                    trigger_widget.toggled.connect(self._evaluate_all_conditions)
                elif isinstance(trigger_widget, QtWidgets.QComboBox):
                    trigger_widget.currentIndexChanged.connect(self._evaluate_all_conditions)

    def _evaluate_all_conditions(self):
        for field_id, data in self.widgets.items():
            props = data['properties']
            if 'conditional_logic' in props and props['conditional_logic']:
                logic = props['conditional_logic']
                trigger_id = logic.get('trigger_field_id')
                if trigger_id in self.widgets:
                    trigger_widget = self.widgets[trigger_id]['widget']
                    trigger_value = ""
                    if isinstance(trigger_widget, QtWidgets.QLineEdit):
                        trigger_value = trigger_widget.text()
                    elif isinstance(trigger_widget, QtWidgets.QCheckBox):
                        trigger_value = trigger_widget.isChecked()
                    elif isinstance(trigger_widget, QtWidgets.QComboBox):
                        trigger_value = trigger_widget.currentText()

                    condition_met = self._check_single_condition(trigger_value, logic)
                    should_be_visible = (logic.get('action') == 'نمایش بده' and condition_met) or \
                                      (logic.get('action') == 'مخفی کن' and not condition_met)
                    
                    data['widget'].setVisible(should_be_visible)
                    self.layout.labelForField(data['widget']).setVisible(should_be_visible)

    def _check_single_condition(self, trigger_value, logic):
        operator = logic.get('operator'); value_to_compare = logic.get('value'); trigger_type = logic.get('trigger_field_type')
        if trigger_type == 'checkbox':
            if operator == 'تیک خورده باشد': return trigger_value is True
            if operator == 'تیک نخورده باشد': return trigger_value is False
        else:
            if operator == 'خالی باشد': return not str(trigger_value)
            if operator == 'خالی نباشد': return bool(str(trigger_value))
            if not str(trigger_value): return False
            if operator == 'برابر با': return str(trigger_value) == value_to_compare
            if operator == 'مخالف با': return str(trigger_value) != value_to_compare
            if operator == 'شامل': return value_to_compare in str(trigger_value)
            try:
                val_compare_num = float(value_to_compare); rec_val_num = float(trigger_value)
                if operator == 'بزرگتر از': return rec_val_num > val_compare_num
                if operator == 'کوچکتر از': return rec_val_num < val_compare_num
            except (ValueError, TypeError): pass
        return False

    def validate_and_accept(self):
        for field_id, data in self.widgets.items():
            if data['widget'].isVisible():
                props = data['properties']; is_required = props.get('required', False)
                widget = data['widget']; value = None
                
                if isinstance(widget, QtWidgets.QLineEdit): value = widget.text().strip()
                elif isinstance(widget, QtWidgets.QCheckBox): value = widget.isChecked()
                elif isinstance(widget, QtWidgets.QComboBox):
                    # For item_list, data is a dict in UserRole
                    item_data = widget.model().item(widget.currentIndex()).data(Qt.UserRole)
                    if item_data: # If it's not the placeholder
                        value = item_data
                    else:
                         # For simple dropdowns, the value is the text
                        value = widget.currentText() if "---" not in widget.currentText() else None

                if is_required and not value:
                    QtWidgets.QMessageBox.warning(self, "خطای اعتبارسنجی", f"فیلد «{data['label']}» اجباری است و نمی‌تواند خالی باشد.")
                    return
                
                if props.get('type') == 'text' and props.get('min_length') is not None:
                    if len(value) < props['min_length']:
                        QtWidgets.QMessageBox.warning(self, "خطای اعتبارسنجی", f"طول فیلد «{data['label']}» باید حداقل {props['min_length']} کاراکتر باشد.")
                        return
        self.accept()

    def get_data(self) -> dict:
        if not self.form_fields: return None
        data = {}
        for field_id, widget_data in self.widgets.items():
            if widget_data['widget'].isVisible():
                label = widget_data['label']
                widget = widget_data['widget']
                if isinstance(widget, QtWidgets.QLineEdit):
                    data[label] = widget.text()
                elif isinstance(widget, QtWidgets.QCheckBox):
                    data[label] = widget.isChecked()
                elif isinstance(widget, QtWidgets.QComboBox):
                    current_data = widget.model().item(widget.currentIndex()).data(Qt.UserRole)
                    if isinstance(current_data, dict): # Smart list (item, user, etc.)
                        data[label] = {"id": current_data.get('id'), "name": widget.currentText().strip().replace("└", "").strip()}
                    else: # Simple dropdown
                        data[label] = widget.currentText()
        return data
    
        
                                
# این کلاس را به طور کامل جایگزین نسخه قبلی کنید

class EventMappingDialog(QtWidgets.QDialog):
    """پنجره‌ای برای اتصال رویدادهای سیستم به فرآیندهای تعریف شده توسط QA."""
    def __init__(self, db: DB, system_events: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.system_events = system_events

        self.setWindowTitle("مرکز کنترل رویدادها و فرآیندها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(750, 400)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر رویداد سیستم، مشخص کنید کدام فرآیند باید به طور خودکار اجرا شود:"))

        self.table = QtWidgets.QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(['رویداد سیستمی', 'فرآیند تخصیص یافته'])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره اتصالات")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_mappings)
        layout.addWidget(btn_save)
        
        self._load_data()

    def _load_data(self):
        active_workflows = self.db.execute_query("SELECT id, name, version FROM workflows WHERE is_active = TRUE ORDER BY name, version")
        current_mappings = self.db.get_event_mappings()

        self.table.setRowCount(len(self.system_events))
        for r, (event_code, event_desc) in enumerate(self.system_events.items()):
            event_item = QtWidgets.QTableWidgetItem(event_desc)
            event_item.setData(Qt.UserRole, event_code)
            event_item.setFlags(event_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.table.setItem(r, 0, event_item)

            combo = QtWidgets.QComboBox()
            combo.addItem("--- هیچ فرآیندی متصل نیست ---", None)
            for wf in active_workflows:
                combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])
            
            if event_code in current_mappings:
                workflow_id = current_mappings[event_code]['workflow_id']
                index = combo.findData(workflow_id)
                if index != -1:
                    combo.setCurrentIndex(index)

            self.table.setCellWidget(r, 1, combo)

    def _save_mappings(self):
        mappings_to_save = {}
        for r in range(self.table.rowCount()):
            event_code = self.table.item(r, 0).data(Qt.UserRole)
            combo = self.table.cellWidget(r, 1)
            workflow_id = combo.currentData()
            mappings_to_save[event_code] = workflow_id
        
        try:
            self.db.save_event_mappings(mappings_to_save)
            if self.toast: self.toast.show_message("✔ اتصالات فرآیند با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی اتصالات:\n{e}")
                        
            
# این کلاس را به طور کامل با نسخه نهایی و جمله‌ساز زیر جایگزین کنید
class RuleEditorDialog(QtWidgets.QDialog):
    """
    نسخه 3.0 (جمله‌ساز طبیعی):
    - رابط کاربری کاملاً بازطراحی شده برای ساخت قوانین به صورت جملات خوانا.
    - حذف کامل QTreeWidget و پیچیدگی‌های آن.
    """
    def __init__(self, db: DB, workflow_id: int, current_step_order: int, form_fields: list, current_rules: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.workflow_id = workflow_id
        self.current_step_order = current_step_order
        self.form_fields = form_fields
        self.setWindowTitle("ویرایشگر قوانین شرطی (حالت جمله‌سازی)")
        self.setMinimumSize(800, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        main_layout = QtWidgets.QVBoxLayout(self)
        
        scroll_area = QtWidgets.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_content = QtWidgets.QWidget()
        self.rules_layout = QtWidgets.QVBoxLayout(scroll_content) # Layout اصلی برای ردیف‌ها
        self.rules_layout.setSpacing(10)
        self.rules_layout.setAlignment(Qt.AlignTop)
        scroll_area.setWidget(scroll_content)
        main_layout.addWidget(scroll_area)

        controls_layout = QtWidgets.QHBoxLayout()
        btn_add_cond = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن شرط جدید")
        self.btn_del_cond = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " حذف آخرین شرط")
        controls_layout.addWidget(btn_add_cond); controls_layout.addWidget(self.btn_del_cond); controls_layout.addStretch()
        main_layout.addLayout(controls_layout)
        
        action_layout = QtWidgets.QFormLayout(); action_layout.setContentsMargins(0, 15, 0, 5)
        self.action_combo = QtWidgets.QComboBox(); self.action_combo.addItems(['رد شدن از این مرحله (Skip)', 'پرش به مرحله خاص', 'خاتمه موفق فرآیند', 'خاتمه ناموفق فرآیند'])
        self.jump_target_combo = QtWidgets.QComboBox()
        action_layout.addRow("<b>آنگاه</b> اقدام نهایی:", self.action_combo)
        action_layout.addRow("مرحله مقصد برای پرش:", self.jump_target_combo)
        main_layout.addLayout(action_layout)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        main_layout.addWidget(buttons)

        btn_add_cond.clicked.connect(self._add_rule_row)
        self.btn_del_cond.clicked.connect(self._delete_last_row)
        self.action_combo.currentIndexChanged.connect(self._on_action_change)

        self._populate_jump_targets()
        if current_rules:
            self._populate_from_rules(current_rules)
        else:
            self._add_rule_row() # با یک ردیف خالی شروع کن

        self._on_action_change()
        self._update_button_states()

    def _add_rule_row(self, data=None):
        is_first = self.rules_layout.count() == 0
        row_widget = ConditionRowWidget(is_first, self.form_fields, self)
        if data:
            row_widget.set_data(data)
        self.rules_layout.addWidget(row_widget)
        self._update_button_states()
        
    def _delete_last_row(self):
        if self.rules_layout.count() > 1: # همیشه حداقل یک ردیف باقی بماند
            widget_to_remove = self.rules_layout.itemAt(self.rules_layout.count() - 1).widget()
            widget_to_remove.deleteLater()
        self._update_button_states()

    def _update_button_states(self):
        self.btn_del_cond.setEnabled(self.rules_layout.count() > 1)
        
    def _populate_jump_targets(self):
        self.jump_target_combo.clear()
        steps = self.db.execute_query("SELECT id, step_name, step_order FROM workflow_steps WHERE workflow_id = %s AND step_order > %s ORDER BY step_order", (self.workflow_id, self.current_step_order))
        for step in steps:
            self.jump_target_combo.addItem(f"{step['step_order']} - {step['step_name']}", step['id'])
    
    def _on_action_change(self):
        is_jump = self.action_combo.currentText() == 'پرش به مرحله خاص'
        self.jump_target_combo.setVisible(is_jump)
        self.layout().findChild(QtWidgets.QFormLayout).labelForField(self.jump_target_combo).setVisible(is_jump)

    def get_rules(self) -> dict:
        # ساختار JSON از روی ویجت‌های جمله‌ساز خوانده می‌شود
        all_conditions = []
        for i in range(self.rules_layout.count()):
            widget = self.rules_layout.itemAt(i).widget()
            if widget:
                data = widget.get_data()
                if not data['condition']['value']:
                     QtWidgets.QMessageBox.warning(self, "خطا", f"مقدار برای شرط در ردیف {i+1} نمی‌تواند خالی باشد.")
                     return None
                all_conditions.append(data)

        if not all_conditions:
            return None
        
        # در این مدل ساده، تمام شروط را در یک گروه AND قرار می‌دهیم.
        # در آینده می‌توان گروه‌بندی‌های پیچیده‌تر را هم اضافه کرد.
        logic_structure = {"and": [c['condition'] for c in all_conditions]}

        final_rules = { "action": self.action_combo.currentText(), "logic": logic_structure }
        if self.action_combo.currentText() == 'پرش به مرحله خاص':
            final_rules['target_step_id'] = self.jump_target_combo.currentData()
            if not final_rules['target_step_id']:
                QtWidgets.QMessageBox.warning(self, "خطا", "برای اقدام 'پرش'، باید یک مرحله مقصد انتخاب شود.")
                return None
        return final_rules

    def _populate_from_rules(self, rules):
        # این تابع فعلا یک ساختار ساده and را می‌خواند
        logic = rules.get('logic')
        if not logic or 'and' not in logic:
            self._add_rule_row()
            return

        for i, cond in enumerate(logic['and']):
            self._add_rule_row({"logic": "and" if i > 0 else "if", "condition": cond})
        
        if 'action' in rules: self.action_combo.setCurrentText(rules['action'])
        if 'target_step_id' in rules:
            index = self.jump_target_combo.findData(rules['target_step_id'])
            if index != -1: self.jump_target_combo.setCurrentIndex(index)
            
                    
# این کلاس کاملا جدید را به فایل خود اضافه کنید
class ConditionRowWidget(QtWidgets.QWidget):
    """یک ویجت سفارشی که یک ردیف کامل از قانون را به صورت یک جمله نمایش می‌دهد."""
    def __init__(self, is_first_row: bool, form_fields: list, parent=None):
        super().__init__(parent)
        self.form_fields = form_fields
        
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(0, 5, 0, 5)

        if is_first_row:
            self.logic_combo = QtWidgets.QLabel("<b>اگر</b>")
        else:
            self.logic_combo = QtWidgets.QComboBox()
            self.logic_combo.addItems(["و", "یا"])
        
        self.field_combo = QtWidgets.QComboBox()
        for field in self.form_fields:
            self.field_combo.addItem(field['label'])

        self.op_combo = QtWidgets.QComboBox()
        self.op_combo.addItems(['برابر با', 'مخالف با', 'بزرگتر از', 'کوچکتر از', 'شامل'])
        
        self.value_edit = QtWidgets.QLineEdit()

        layout.addWidget(self.logic_combo)
        layout.addWidget(self.field_combo, 1) # Stretch factor 1
        layout.addWidget(self.op_combo)
        layout.addWidget(self.value_edit, 1) # Stretch factor 1

    def get_data(self):
        """اطلاعات این ردیف را به صورت دیکشنری برمی‌گرداند."""
        logic = "and" # پیش‌فرض برای ردیف اول
        if isinstance(self.logic_combo, QtWidgets.QComboBox):
            logic = "and" if self.logic_combo.currentText() == "و" else "or"
            
        return {
            "logic": logic,
            "condition": {
                "field": self.field_combo.currentText(),
                "operator": self.op_combo.currentText(),
                "value": self.value_edit.text().strip()
            }
        }

    def set_data(self, data):
        """اطلاعات یک قانون را در ویجت‌ها تنظیم می‌کند."""
        if isinstance(self.logic_combo, QtWidgets.QComboBox):
            self.logic_combo.setCurrentText("و" if data.get('logic') == 'and' else "یا")
        
        condition = data.get('condition', {})
        self.field_combo.setCurrentText(condition.get('field', ''))
        self.op_combo.setCurrentText(condition.get('operator', ''))
        self.value_edit.setText(condition.get('value', ''))
                                    
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ConditionEditorDialog(QtWidgets.QDialog):
    """دیالوگ کمکی برای افزودن یا ویرایش یک شرط منفرد در ویرایشگر قوانین."""
    def __init__(self, form_fields: list, condition_data=None, parent=None):
        super().__init__(parent)
        self.form_fields = form_fields
        self.setWindowTitle("افزودن / ویرایش شرط")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)
        
        self.field_combo = QtWidgets.QComboBox()
        for field in self.form_fields:
            self.field_combo.addItem(field['label'])
            
        self.op_combo = QtWidgets.QComboBox()
        self.op_combo.addItems(['برابر با', 'مخالف با', 'بزرگتر از', 'کوچکتر از', 'شامل'])
        
        self.value_edit = QtWidgets.QLineEdit()

        layout.addRow("فیلد:", self.field_combo)
        layout.addRow("عملگر:", self.op_combo)
        layout.addRow("مقدار:", self.value_edit)
        
        if condition_data:
            self.field_combo.setCurrentText(condition_data.get('field', ''))
            self.op_combo.setCurrentText(condition_data.get('operator', ''))
            self.value_edit.setText(str(condition_data.get('value', '')))

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        if not self.value_edit.text().strip():
            return None
        return {
            "field": self.field_combo.currentText(),
            "operator": self.op_combo.currentText(),
            "value": self.value_edit.text().strip()
        }
                                            
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید

class ManageQaFormsDialog(QtWidgets.QDialog):
    def __init__(self, db: DB, user_id: int, user_role: str, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.user_role = db, user_id, user_role
        self.toast = getattr(parent, 'toast', None)
        self.main_window = parent

        self.setWindowTitle("مدیریت فرم‌های تضمین کیفیت (QA)")
        self.setMinimumSize(700, 500); self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        self.tbl_forms = QtWidgets.QTableWidget(0, 3)
        self.tbl_forms.setHorizontalHeaderLabels(["ID", "نام فرم", "ID سازنده"]); self.tbl_forms.setColumnHidden(0, True)
        self.tbl_forms.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_forms.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl_forms.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_forms.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tbl_forms.itemDoubleClicked.connect(self._edit_form)
        layout.addWidget(self.tbl_forms)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " فرم QA جدید")
        btn_edit = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), " ویرایش فرم انتخاب شده")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف فرم انتخاب شده"); btn_del.setProperty("class", "danger")
        btn_layout.addStretch(); btn_layout.addWidget(btn_add); btn_layout.addWidget(btn_edit); btn_layout.addWidget(btn_del)
        layout.addLayout(btn_layout)
        
        btn_add.clicked.connect(self._add_form); btn_edit.clicked.connect(self._edit_form); btn_del.clicked.connect(self._delete_form)
        self._load_forms()

    def _load_forms(self):
        self.tbl_forms.setRowCount(0)
        forms = self.db.list_form_defs_by_type(form_type='QA', user_id=self.user_id, is_admin=(self.user_role == 'Admin'))
        self.tbl_forms.setRowCount(len(forms))
        for r, form in enumerate(forms):
            self.tbl_forms.setItem(r, 0, QtWidgets.QTableWidgetItem(str(form['id'])))
            self.tbl_forms.setItem(r, 1, QtWidgets.QTableWidgetItem(form['name']))
            self.tbl_forms.setItem(r, 2, QtWidgets.QTableWidgetItem(str(form.get('user_id', ''))))

    def _add_form(self):
        if not self.main_window.has_permission('qa:manage_forms'):
            self.toast.show_message("شما دسترسی لازم برای ایجاد فرم جدید را ندارید.", "error"); return
        
        dlg = AdvancedFormBuilderDialog(self.db, self.user_id, form_id=None, default_form_type='QA', parent=self.main_window)
        
        if dlg.exec_():
            self.toast.show_message("✔ فرم QA جدید با موفقیت ایجاد شد.", "success")
            self._load_forms()

# در کلاس ManageQaFormsDialog، این متد را جایگزین کنید
    def _edit_form(self):
        selected = self.tbl_forms.selectedItems()
        if not selected:
            self.toast.show_message("لطفاً ابتدا یک فرم را برای ویرایش انتخاب کنید.", "warning"); return
        form_id = int(self.tbl_forms.item(selected[0].row(), 0).text())
        
        # --- *** بخش جدید: پیدا کردن نوع فرآیند متصل به این فرم *** ---
        process_type_key = None
        workflow_using_form = self.db.execute_query("SELECT process_type_key FROM workflows WHERE form_def_id = %s LIMIT 1", (form_id,), fetch_one=True)
        if workflow_using_form:
            process_type_key = workflow_using_form.get('process_type_key')
        # --- ****************************************************** ---

        dlg = AdvancedFormBuilderDialog(self.db, self.user_id, form_id=form_id, process_type_key=process_type_key, parent=self.main_window)
        if dlg.exec_():
            self.toast.show_message("✔ فرم با موفقیت ویرایش شد.", "success")
            self._load_forms()
            
    def _delete_form(self):
        selected = self.tbl_forms.selectedItems()
        if not selected:
            self.toast.show_message("لطفا ابتدا یک فرم را برای حذف انتخاب کنید.", "warning")
            return

        row = selected[0].row()
        form_id = int(self.tbl_forms.item(row, 0).text())
        form_name = self.tbl_forms.item(row, 1).text()

        workflow_in_use = self.db.check_form_in_use(form_id)
        if workflow_in_use:
            msg = f"<b>امکان حذف فرم «{form_name}» وجود ندارد.</b><br><br>این فرم در حال حاضر به فرآیند «{workflow_in_use['name']}» متصل است."
            QtWidgets.QMessageBox.critical(self, "خطای وابستگی", msg)
            return

        reply = QtWidgets.QMessageBox.question(self, 'تایید حذف', f"آیا از حذف کامل فرم «{form_name}» مطمئنید؟", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_form_def(form_id)
                self.toast.show_message("✔ فرم با موفقیت حذف شد.", "success")
                self._load_forms()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در هنگام حذف فرم:\n{e}")
                
                                                                                            
# کلاس ProcessActionDialog را به طور کامل با این نسخه جایگزین کنید
class ProcessActionDialog(QtWidgets.QDialog):
    """دیالوگ گرافیکی و هوشمند برای انجام تایید/رد/بازبینی (نسخه امن)."""
    def __init__(self, task_data: dict, parent=None):
        super().__init__(parent)
        self.task_data = task_data
        self.outcome = None # برای ذخیره نتیجه نهایی اقدام کاربر
        
        self.setWindowTitle(f"اقدام برای: {task_data.get('workflow_name')}")
        self.setMinimumWidth(500); self.setFont(QFont(FONT_FAMILY, 11)); self.setObjectName("actionDialog")
        self.setStyleSheet("#actionDialog { background-color: #f8f9fa; }")

        layout = QtWidgets.QVBoxLayout(self); layout.setContentsMargins(0, 0, 0, 20)
        header = QtWidgets.QLabel(f"مرحله: {task_data.get('step_name')}")
        header.setStyleSheet("background-color: #34495e; color: white; padding: 15px; font-size: 14pt; font-weight: bold;")
        layout.addWidget(header)

        form_layout = QtWidgets.QFormLayout(); form_layout.setContentsMargins(20, 20, 20, 20); form_layout.setSpacing(15)
        if task_data.get('related_table_name') == 'purchase_requests':
            details = task_data.get('details', {})
            form_layout.addRow("کالا:", QtWidgets.QLabel(f"<b>{details.get('item_name', '')}</b>"))
            form_layout.addRow("مقدار:", QtWidgets.QLabel(f"<b>{details.get('qty', '')}</b>"))
            form_layout.addRow("درخواست دهنده:", QtWidgets.QLabel(f"<b>{details.get('requester', '')}</b>"))
            form_layout.addRow(QtWidgets.QLabel("---"))

        self.reason_edit = QtWidgets.QTextEdit(placeholderText="در صورت رد کردن یا ارسال برای بازبینی، وارد کردن دلیل الزامی است...")
        form_layout.addRow("دلیل/توضیحات:", self.reason_edit)
        layout.addLayout(form_layout)

        buttons = QtWidgets.QDialogButtonBox()
        btn_rework = buttons.addButton("ارسال برای بازبینی", QtWidgets.QDialogButtonBox.HelpRole)
        btn_reject = buttons.addButton("رد کردن نهایی", QtWidgets.QDialogButtonBox.RejectRole)
        btn_approve = buttons.addButton("تایید", QtWidgets.QDialogButtonBox.AcceptRole)

        btn_rework.setProperty("class", "warning"); btn_rework.setMinimumHeight(40)
        btn_reject.setProperty("class", "danger"); btn_reject.setMinimumHeight(40)
        btn_approve.setProperty("class", "primary"); btn_approve.setMinimumHeight(40)
        layout.addWidget(buttons)

        # اتصال دکمه‌ها به توابع داخلی جدید
        btn_approve.clicked.connect(self._handle_approve)
        btn_reject.clicked.connect(self._handle_reject)
        btn_rework.clicked.connect(self._handle_rework)

    def _handle_approve(self):
        self.outcome = "APPROVED"
        self.accept() # این متد باعث می‌شود دیالوگ با موفقیت بسته شود

    def _handle_reject(self):
        if not self.reason_edit.toPlainText().strip():
            QtWidgets.QMessageBox.warning(self, "خطا", "برای رد کردن، وارد کردن دلیل الزامی است.")
            return
        self.outcome = "REJECTED"
        self.accept()

    def _handle_rework(self):
        if not self.reason_edit.toPlainText().strip():
            QtWidgets.QMessageBox.warning(self, "خطا", "برای ارسال به بازبینی، وارد کردن دلیل الزامی است.")
            return
        self.outcome = "REWORK"
        self.accept()

    def get_data(self):
        # این تابع حالا هم نتیجه و هم دلیل را برمی‌گرداند
        return {"outcome": self.outcome, "reason": self.reason_edit.toPlainText().strip()}            
                
    
class DelegationManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت تفویض اختیارها."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db, self.user_id, self.toast = db, user_id, getattr(parent, 'toast', None)
        self.setWindowTitle("مدیریت تفویض اختیار")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        
        # ... (بقیه کد دیالوگ در اینجا قرار می‌گیرد - به دلیل طولانی بودن فعلا خلاصه شده)
        
        self.table = QtWidgets.QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["ID", "جانشین", "برای فرآیند", "از تاریخ", "تا تاریخ", "یادداشت"])
        layout.addWidget(self.table)
        
        btn_add = QtWidgets.QPushButton("ثبت تفویض اختیار جدید")
        btn_add.clicked.connect(self._add_delegation)
        layout.addWidget(btn_add)
        
        self._load_delegations()

    def _load_delegations(self):
        # ... (منطق بارگذاری اطلاعات در جدول)
        pass

    def _add_delegation(self):
        # ... (باز کردن دیالوگ برای افزودن رکورد جدید)
        pass
    
class SetUrgencyDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب فوریت خرید."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("تعیین فوریت خرید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.urgency_combo = QtWidgets.QComboBox()
        self.urgency_combo.addItems(["فوری (۱ روزه)", "عادی (۱ هفته‌ای)", "غیر فوری (۲ هفته‌ای)"])
        layout.addRow("سطح فوریت:", self.urgency_combo)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_urgency(self):
        return self.urgency_combo.currentText()
    
    
# این کلاس را به طور کامل جایگزین نسخه قبلی RolesAssignmentPanel کنید

class RolesAssignmentPanel(QtWidgets.QWidget):
    """
    یک پنل سفارشی که چیدمان داخلی خود را به صورت دستی و تضمین شده مدیریت می‌کند
    تا مشکل اسکرول به طور قطعی حل شود. نسخه نهایی و اصلاح شده.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id = None
        
        main_layout = QtWidgets.QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        
        left_panel = QtWidgets.QGroupBox("۱. واحد سازمانی")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.dept_list = QtWidgets.QListWidget()
        self.dept_list.itemSelectionChanged.connect(self._on_department_selected)
        left_layout.addWidget(self.dept_list)
        splitter.addWidget(left_panel)
        
        self.right_panel_content = QtWidgets.QWidget()
        self.right_panel_content.setObjectName("rightPanel")
        self.right_panel_content.setStyleSheet("#rightPanel { background-color: #f8f9fa; border: 1px solid #dfe4ea; border-radius: 8px; }")

        self.roles_label = QtWidgets.QLabel("<b>۲. نقش‌های مجاز</b>", self.right_panel_content)
        self.roles_list_widget = QtWidgets.QListWidget(self.right_panel_content)
        self.roles_list_widget.setSpacing(5)
        self.roles_list_widget.setStyleSheet("border: 1px solid #ced4da; background-color: white;")
        
        self.btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات", self.right_panel_content)
        self.btn_save.setProperty("class", "primary")
        self.btn_save.clicked.connect(self._save_assignments)
        
        splitter.addWidget(self.right_panel_content)
        main_layout.addWidget(splitter)
        splitter.setSizes([250, 500])

        self._load_departments()
        self._load_all_roles()
        
        # --- اصلاح کلیدی: اتصال مستقیم رویداد به متد کلاس ---
        self.right_panel_content.resizeEvent = self.custom_resize_event

    def custom_resize_event(self, event: QtGui.QResizeEvent):
        """مهمترین بخش: محاسبه و تنظیم دستی موقعیت و اندازه ویجت‌ها با مقادیر صحیح (integer)."""
        super(QtWidgets.QWidget, self.right_panel_content).resizeEvent(event)
        
        panel_width = self.right_panel_content.width()
        panel_height = self.right_panel_content.height()
        margin = 10
        button_height = 40
        label_height = 30
        spacing = 5

        # --- محاسبات با تبدیل قطعی به integer ---
        self.roles_label.setGeometry(margin, margin, panel_width - (2 * margin), label_height)
        
        list_y = self.roles_label.y() + self.roles_label.height() + spacing
        list_height = panel_height - list_y - button_height - (margin * 2)
        
        self.roles_list_widget.setGeometry(
            int(margin), 
            int(list_y), 
            int(panel_width - (2 * margin)), 
            int(list_height)
        )
        
        self.btn_save.setGeometry(
            int(margin), 
            int(self.roles_list_widget.y() + self.roles_list_widget.height() + margin), 
            int(panel_width - (2 * margin)), 
            int(button_height)
        )

    def _load_departments(self):
        self.dept_list.clear()
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            item = QtWidgets.QListWidgetItem(dept['name']); item.setData(Qt.UserRole, dept['id']); self.dept_list.addItem(item)
            
    def _load_all_roles(self):
        self.roles_list_widget.clear()
        all_roles = self.db.get_all_roles()
        for role in all_roles:
            item = QtWidgets.QListWidgetItem(role['name'])
            item.setData(Qt.UserRole, role['id'])
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Unchecked)
            self.roles_list_widget.addItem(item)
        self.roles_list_widget.setEnabled(False)

    def _on_department_selected(self):
        selected = self.dept_list.selectedItems()
        if not selected:
            self.current_dept_id = None; self.roles_list_widget.setEnabled(False); return
        self.current_dept_id = selected[0].data(Qt.UserRole); self.roles_list_widget.setEnabled(True)
        self.roles_label.setText(f"<b>۲. نقش‌های مجاز برای «{selected[0].text()}»:</b>")
        assigned_role_ids = self.db.get_role_ids_for_department(self.current_dept_id)
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i)
            role_id = item.data(Qt.UserRole)
            item.setCheckState(QtCore.Qt.Checked if role_id in assigned_role_ids else QtCore.Qt.Unchecked)

    def _save_assignments(self):
        if self.current_dept_id is None:
            self.toast.show_message("لطفاً ابتدا یک واحد سازمانی را انتخاب کنید.", "warning"); return
        selected_role_ids = []
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i)
            if item.checkState() == QtCore.Qt.Checked:
                selected_role_ids.append(item.data(Qt.UserRole))
        try:
            self.db.update_roles_for_department(self.current_dept_id, selected_role_ids)
            self.toast.show_message("✔ ارتباط نقش‌ها و واحد با موفقیت ذخیره شد.", "success")
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
        

# کل کلاس UserManager را با این نسخه نهایی و استاندارد جایگزین کنید

class UserManager(QtWidgets.QDialog):
    def __init__(self, db: DB, all_roles: list, current_user: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.all_roles_cache = all_roles
        self.current_user = current_user
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id_for_roles = None

        self.setWindowTitle('مرکز مدیریت کاربران و دسترسی‌ها')
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.resize(850, 600)

        main_layout = QtWidgets.QVBoxLayout(self)
        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setStyleSheet("QTabBar::tab { min-width: 200px; padding: 10px; }")
        main_layout.addWidget(self.tabs)

        user_management_page = self._create_user_management_tab()
        role_assignment_page = self._create_role_assignment_tab()

        self.tabs.addTab(user_management_page, "مدیریت کاربران")
        self.tabs.addTab(role_assignment_page, "تخصیص نقش به واحد")
        
        self._load_table()
        self._load_departments_for_roles_tab()
        self._load_all_roles_for_roles_tab()

    def _create_user_management_tab(self):
        page = QtWidgets.QWidget()
        v_layout = QtWidgets.QVBoxLayout(page)
        self.tbl_users = QtWidgets.QTableWidget()
        self.tbl_users.setColumnCount(3); self.tbl_users.setHorizontalHeaderLabels(['نام کاربری', 'نقش', 'واحد سازمانی']); self.tbl_users.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch); self.tbl_users.verticalHeader().hide(); self.tbl_users.setEditTriggers(QtWidgets.QTableWidget.NoEditTriggers); self.tbl_users.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows); self.tbl_users.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        v_layout.addWidget(self.tbl_users, 1)
        form = QtWidgets.QFormLayout()
        self.e_user = QtWidgets.QLineEdit()
        self.e_pass = QtWidgets.QLineEdit(); self.e_pass.setEchoMode(self.e_pass.Password)
        self.c_dept_users = QtWidgets.QComboBox()
        self.c_role_users = QtWidgets.QComboBox()
        form.addRow('نام کاربری:', self.e_user); form.addRow('رمز عبور:', self.e_pass); form.addRow('واحد سازمانی:', self.c_dept_users); form.addRow('نقش (*وابسته به واحد):', self.c_role_users)
        v_layout.addLayout(form)
        btn_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("save"), " ایجاد / به‌روزرسانی"); btn_add.setProperty("class", "primary")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " حذف کاربر"); btn_del.setProperty("class", "danger")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), " پاک کردن فرم")
        btn_layout.addWidget(btn_add); btn_layout.addWidget(btn_del); btn_layout.addStretch(); btn_layout.addWidget(btn_clear)
        v_layout.addLayout(btn_layout)
        btn_add.clicked.connect(self._add_or_update); btn_del.clicked.connect(self._delete_user); btn_clear.clicked.connect(self._reset_fields)
        self.tbl_users.itemClicked.connect(self._populate_fields_for_edit)
        self.c_dept_users.currentIndexChanged.connect(self._update_roles_for_department)
        self._populate_departments_combo()
        return page

    def _create_role_assignment_tab(self):
        page = QtWidgets.QWidget()
        main_layout = QtWidgets.QHBoxLayout(page)
        main_layout.setSpacing(15)
        
        left_panel = QtWidgets.QGroupBox("۱. واحد سازمانی را انتخاب کنید")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        self.dept_list_roles = QtWidgets.QListWidget()
        self.dept_list_roles.itemSelectionChanged.connect(self._on_department_selected_for_roles_tab)
        left_layout.addWidget(self.dept_list_roles)
        
        right_panel = QtWidgets.QGroupBox("۲. نقش‌های مجاز را مشخص کنید")
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        self.roles_list_widget = QtWidgets.QListWidget()
        self.roles_list_widget.setSpacing(5)
        right_layout.addWidget(self.roles_list_widget, 1) # ضریب کشش 1
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات برای این واحد")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_role_assignments)
        right_layout.addWidget(btn_save)

        main_layout.addWidget(left_panel, 1)
        main_layout.addWidget(right_panel, 2)
        
        return page

    def _load_table(self):
        self.tbl_users.setSortingEnabled(False); rows = self.db.get_all_users_detailed(); self.tbl_users.setRowCount(len(rows))
        for r, row in enumerate(rows):
            name_item = QtWidgets.QTableWidgetItem(row['username']); name_item.setData(Qt.UserRole, row); self.tbl_users.setItem(r, 0, name_item)
            self.tbl_users.setItem(r, 1, QtWidgets.QTableWidgetItem(row.get('role_name') or 'بدون نقش')); self.tbl_users.setItem(r, 2, QtWidgets.QTableWidgetItem(row.get('department_name') or '---'))
        self.tbl_users.resizeColumnsToContents(); self.tbl_users.setSortingEnabled(True)
    def _populate_departments_combo(self):
        self.c_dept_users.blockSignals(True); self.c_dept_users.clear(); self.c_dept_users.addItem("--- انتخاب کنید ---", None)
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']): self.c_dept_users.addItem(dept['name'], dept['id'])
        self.c_dept_users.blockSignals(False)
    def _update_roles_for_department(self):
        self.c_role_users.clear(); dept_id = self.c_dept_users.currentData()
        if dept_id is None: self.c_role_users.addItem("ابتدا یک واحد انتخاب کنید", None); self.c_role_users.setEnabled(False); return
        self.c_role_users.setEnabled(True); roles_for_dept = self.db.get_roles_for_department(dept_id)
        if not roles_for_dept: self.c_role_users.addItem("نقشی برای این واحد تعریف نشده", None); self.c_role_users.setEnabled(False)
        else:
            self.c_role_users.addItem("--- انتخاب کنید ---", None)
            for role in roles_for_dept: self.c_role_users.addItem(role['name'], role['id'])
    def _populate_fields_for_edit(self, item: QtWidgets.QTableWidgetItem):
        user_data = self.tbl_users.item(item.row(), 0).data(Qt.UserRole);
        if not user_data: return
        self.e_user.setText(user_data['username']); self.e_user.setReadOnly(True); self.e_pass.clear(); self.e_pass.setPlaceholderText("برای تغییر رمز، رمز جدید را وارد کنید")
        dept_id = user_data.get('department_id'); dept_index = self.c_dept_users.findData(dept_id) if dept_id else 0
        self.c_dept_users.setCurrentIndex(dept_index if dept_index != -1 else 0)
        QtCore.QTimer.singleShot(50, lambda: self._select_role_after_dept_update(user_data.get('role_id')))
    def _select_role_after_dept_update(self, role_id_to_select):
        role_index = self.c_role_users.findData(role_id_to_select); self.c_role_users.setCurrentIndex(role_index if role_index != -1 else 0)
    def _add_or_update(self):
        uname = self.e_user.text().strip(); pwd = self.e_pass.text(); role_id = self.c_role_users.currentData(); dept_id = self.c_dept_users.currentData()
        if not uname: QtWidgets.QMessageBox.warning(self, 'خطا', 'نام کاربری نمی‌تواند خالی باشد.'); return
        is_new_user = not self.e_user.isReadOnly()
        try:
            self.db.add_or_update_user(uname, pwd, role_id, dept_id, is_new_user)
            if self.toast: self.toast.show_message(f"✔ کاربر '{uname}' با موفقیت ذخیره شد.", "success")
            self._load_table(); self._reset_fields()
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام ذخیره کاربر: {e}")
    def _delete_user(self):
        if self.e_user.isReadOnly() == False or not self.e_user.text():
             if self.toast: self.toast.show_message("لطفاً ابتدا یک کاربر را از جدول انتخاب کنید.", "warning"); return
        username_to_delete = self.e_user.text()
        if username_to_delete.lower() == self.current_user.lower(): QtWidgets.QMessageBox.critical(self, "عملیات غیرمجاز", "شما نمی‌توانید حساب کاربری خودتان را حذف کنید."); return
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف دائمی کاربر '{username_to_delete}' مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_user(username_to_delete)
                if self.toast: self.toast.show_message(f"کاربر '{username_to_delete}' با موفقیت حذف شد.", "success")
                self._load_table(); self._reset_fields()
            except ValueError as e: QtWidgets.QMessageBox.critical(self, "عملیات غیرمجاز", str(e))
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطای دیتابیس", f"خطا در هنگام حذف کاربر: {e}")
    def _reset_fields(self):
        self.e_user.clear(); self.e_user.setReadOnly(False); self.e_user.setFocus(); self.e_pass.clear(); self.e_pass.setPlaceholderText(""); self.c_dept_users.setCurrentIndex(0); self.tbl_users.clearSelection()
    def _load_departments_for_roles_tab(self):
        self.dept_list_roles.clear()
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            item = QtWidgets.QListWidgetItem(dept['name']); item.setData(Qt.UserRole, dept['id']); self.dept_list_roles.addItem(item)
    def _load_all_roles_for_roles_tab(self):
        self.roles_list_widget.clear()
        all_roles = self.db.get_all_roles()
        for role in all_roles:
            item = QtWidgets.QListWidgetItem(role['name']); item.setData(Qt.UserRole, role['id'])
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable); item.setCheckState(QtCore.Qt.Unchecked); self.roles_list_widget.addItem(item)
        self.roles_list_widget.setEnabled(False)
    def _on_department_selected_for_roles_tab(self):
        selected = self.dept_list_roles.selectedItems()
        if not selected: self.current_dept_id_for_roles = None; self.roles_list_widget.setEnabled(False); return
        self.current_dept_id_for_roles = selected[0].data(Qt.UserRole); self.roles_list_widget.setEnabled(True)
        self.roles_list_widget.parentWidget().setTitle(f"۲. نقش‌های مجاز برای «{selected[0].text()}»")
        assigned_role_ids = self.db.get_role_ids_for_department(self.current_dept_id_for_roles)
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i); role_id = item.data(Qt.UserRole); item.setCheckState(QtCore.Qt.Checked if role_id in assigned_role_ids else QtCore.Qt.Unchecked)
    def _save_role_assignments(self):
        if self.current_dept_id_for_roles is None: self.toast.show_message("لطفاً ابتدا یک واحد سازمانی را انتخاب کنید.", "warning"); return
        selected_role_ids = []
        for i in range(self.roles_list_widget.count()):
            item = self.roles_list_widget.item(i)
            if item.checkState() == QtCore.Qt.Checked: selected_role_ids.append(item.data(Qt.UserRole))
        try:
            self.db.update_roles_for_department(self.current_dept_id_for_roles, selected_role_ids)
            self.toast.show_message("✔ ارتباط نقش‌ها و واحد با موفقیت ذخیره شد.", "success")
        except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
        
        #
# این کلاس را به طور کامل با نسخه قبلی DepartmentNode جایگزین کنید
#
class DepartmentNode(QtWidgets.QGraphicsRectItem):
    """یک گره گرافیکی حرفه‌ای برای نمایش یک واحد سازمانی در چارت."""
    def __init__(self, department_data, dialog):
        super().__init__()
        self.dialog = dialog
        self.data = department_data
        self.setRect(0, 0, 200, 70)
        
        # --- ارتقاء گرافیکی ---
        self.setPen(QtGui.QPen(QtGui.QColor("#adb5bd"), 1.5))
        gradient = QtGui.QLinearGradient(self.rect().topLeft(), self.rect().bottomLeft())
        gradient.setColorAt(0, QtGui.QColor("#ffffff"))
        gradient.setColorAt(1, QtGui.QColor("#f1f3f5"))
        self.setBrush(QtGui.QBrush(gradient))
        
        shadow = QtWidgets.QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setColor(QtGui.QColor(0, 0, 0, 50))
        shadow.setOffset(2, 2)
        self.setGraphicsEffect(shadow)
        
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable)
        self.setFlag(QtWidgets.QGraphicsItem.ItemSendsScenePositionChanges)

        self.name_text = QtWidgets.QGraphicsTextItem(self.data['name'], self)
        font = QFont(FONT_FAMILY, 11, QFont.Bold); self.name_text.setFont(font)
        self.name_text.setDefaultTextColor(QtGui.QColor("#212529")); self.name_text.setPos(10, 10)

        manager_name = self.data.get('manager_name') or "---"
        self.manager_text = QtWidgets.QGraphicsTextItem(f"مدیر: {manager_name}", self)
        font.setBold(False); font.setPointSize(9); self.manager_text.setFont(font)
        self.manager_text.setDefaultTextColor(QtGui.QColor("#495057")); self.manager_text.setPos(10, 38)

    def itemChange(self, change, value):
        if change == QtWidgets.QGraphicsItem.ItemPositionHasChanged:
            self.dialog._draw_connections()
        return super().itemChange(change, value)

    def mouseDoubleClickEvent(self, event):
        try:
            if self.dialog and hasattr(self.dialog, 'tree') and self.dialog.tree:
                self.dialog.tree.clearSelection()
                item_in_tree = self.dialog.item_map.get(self.data['id'])
                if item_in_tree:
                    item_in_tree.setSelected(True)
                    self.dialog.tree.scrollToItem(item_in_tree)
                    self.dialog._on_item_selected(item_in_tree)
        except RuntimeError:
            print("INFO: Caught a RuntimeError on a deleted widget, ignoring.")
        super().mouseDoubleClickEvent(event)
        
    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        new_pos = self.scenePos()
        self.dialog.db.update_department_position(self.data['id'], new_pos.x(), new_pos.y())
        
        colliding_items = self.collidingItems()
        target_node = None
        for item in colliding_items:
            if isinstance(item, DepartmentNode) and item is not self:
                target_node = item
                break
        
        if target_node:
            self.dialog._handle_drop(self, target_node)
        else:
            self.dialog._draw_connections()

#
# بلوک ۲: کلاس اصلی مدیریت چارت سازمانی
#
class OrgChartManagerDialog(QtWidgets.QDialog):
    """پنجره مدیریت چارت سازمانی با رابط کاربری گرافیکی، چیدمان هوشمند و Drag & Drop."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id = None

        self.setWindowTitle("مدیریت چارت سازمانی (نسخه گرافیکی پیشرفته)")
        self.setMinimumSize(1200, 800)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        graphics_panel = QtWidgets.QWidget(); graphics_layout = QtWidgets.QVBoxLayout(graphics_panel)
        graphics_layout.setContentsMargins(0,0,0,0)
        self.scene = QtWidgets.QGraphicsScene(); self.scene.setBackgroundBrush(QtGui.QBrush(QtGui.QColor("#f8f9fa")))
        self.view = QtWidgets.QGraphicsView(self.scene); self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        
        graphics_toolbar = QtWidgets.QHBoxLayout()
        btn_reset_layout = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), "بازنشانی چیدمان")
        btn_reset_layout.setToolTip("تمام تغییرات دستی در چیدمان را لغو کرده و چارت را به صورت خودکار مرتب می‌کند.")
        btn_reset_layout.clicked.connect(self._reset_layout)
        graphics_toolbar.addStretch()
        graphics_toolbar.addWidget(btn_reset_layout)
        graphics_layout.addLayout(graphics_toolbar)
        graphics_layout.addWidget(self.view)
        splitter.addWidget(graphics_panel)

        details_panel = QtWidgets.QWidget(); details_layout = QtWidgets.QVBoxLayout(details_panel)
        self.details_group = QtWidgets.QGroupBox("جزئیات واحد"); self.details_group.setDisabled(True)
        details_form = QtWidgets.QFormLayout(self.details_group)
        self.dept_name_edit = QtWidgets.QLineEdit()
        self.manager_combo = QtWidgets.QComboBox()
        self.user_list_label = QtWidgets.QLabel("<b>کارمندان این واحد:</b>")
        self.user_list_widget = QtWidgets.QListWidget()
        self.user_list_widget.setStyleSheet("border: 1px solid #dfe4ea;")
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات"); btn_save.clicked.connect(self._save_details)
        details_form.addRow("نام واحد:", self.dept_name_edit); details_form.addRow("مدیر واحد:", self.manager_combo)
        details_form.addRow(self.user_list_label); details_form.addRow(self.user_list_widget)
        details_form.addRow(btn_save)
        details_layout.addWidget(self.details_group, 1)

        tree_group = QtWidgets.QGroupBox("ساختار درختی (برای افزودن/حذف راست‌کلیک کنید)")
        tree_layout = QtWidgets.QVBoxLayout(tree_group)
        self.tree = QtWidgets.QTreeWidget(); self.tree.setHeaderHidden(True)
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self._show_context_menu)
        self.tree.itemClicked.connect(self._on_item_selected)
        tree_layout.addWidget(self.tree)
        
        toolbar_layout = QtWidgets.QHBoxLayout()
        btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن واحد")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف واحد")
        btn_add.clicked.connect(self._add_department_action)
        btn_del.clicked.connect(self._delete_department_action)
        toolbar_layout.addWidget(btn_add); toolbar_layout.addWidget(btn_del); toolbar_layout.addStretch()
        tree_layout.addLayout(toolbar_layout)
        details_layout.addWidget(tree_group, 2)
        
        splitter.addWidget(details_panel)
        splitter.setSizes([800, 400])
        self._load_chart_data()
        self._load_users_for_combo()

    def _load_chart_data(self):
        self.scene.clear(); self.tree.clear(); self.nodes = {}; self.item_map = {}
        departments = self.db.get_departments_tree()
        self.dept_map = {d['id']: d for d in departments}

        self.child_map = {d['id']: [] for d in departments}
        root_ids = []
        for dept in departments:
            parent_id = dept.get('parent_id')
            if parent_id in self.child_map: self.child_map[parent_id].append(dept['id'])
            else: root_ids.append(dept['id'])

        for dept in departments:
            node = DepartmentNode(dept, self); self.nodes[dept['id']] = node; self.scene.addItem(node)
            item = QtWidgets.QTreeWidgetItem([dept['name']]); item.setData(0, Qt.UserRole, dept); self.item_map[dept['id']] = item

        for dept_id, item in self.item_map.items():
            parent_id = self.dept_map.get(dept_id, {}).get('parent_id')
            if parent_id and parent_id in self.item_map: self.item_map[parent_id].addChild(item)
            else: self.tree.addTopLevelItem(item)
        
        self.tree.expandAll()
        self._auto_layout_and_draw()

    def _auto_layout_and_draw(self):
        root_ids = [dept_id for dept_id, dept in self.dept_map.items() if dept.get('parent_id') is None]
        self._auto_layout_recursive(root_ids, 0, 0)
        self._draw_connections()
        self.view.centerOn(0,0)

    def _auto_layout_recursive(self, node_ids, x, y, x_spacing=220, y_spacing=120):
        subtree_widths = {}
        def calculate_width(d_id):
            if d_id in subtree_widths: return subtree_widths[d_id]
            children = self.child_map.get(d_id, [])
            width = sum(calculate_width(c_id) for c_id in children) if children else x_spacing
            subtree_widths[d_id] = width
            return width

        total_width = sum(calculate_width(d_id) for d_id in node_ids)
        current_x = x - total_width / 2

        for d_id in node_ids:
            subtree_width = subtree_widths[d_id]
            node_x = current_x + subtree_width / 2
            
            # فقط گره‌های بدون موقعیت دستی را جابجا می‌کند
            if d_id in self.nodes:
                if self.dept_map[d_id].get('pos_x') is not None and self.dept_map[d_id].get('pos_y') is not None:
                    self.nodes[d_id].setPos(self.dept_map[d_id]['pos_x'], self.dept_map[d_id]['pos_y'])
                else:
                    self.nodes[d_id].setPos(node_x - self.nodes[d_id].rect().width()/2, y)
            
            children = self.child_map.get(d_id, [])
            if children:
                self._auto_layout_recursive(children, node_x, y + y_spacing)
            
            current_x += subtree_width

    def _draw_connections(self):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsPathItem):
                self.scene.removeItem(item)

        pen = QtGui.QPen(QtGui.QColor("#6c757d"), 1.5, Qt.DashLine)
        
        for dept_id, node in self.nodes.items():
            parent_id = self.dept_map[dept_id].get('parent_id')
            if parent_id and parent_id in self.nodes:
                parent_node = self.nodes[parent_id]
                
                p1 = parent_node.scenePos() + QtCore.QPointF(parent_node.rect().width()/2, parent_node.rect().height())
                p4 = node.scenePos() + QtCore.QPointF(node.rect().width()/2, 0)
                
                p2 = QtCore.QPointF(p1.x(), (p1.y() + p4.y()) / 2)
                p3 = QtCore.QPointF(p4.x(), (p1.y() + p4.y()) / 2)

                path = QtGui.QPainterPath(); path.moveTo(p1); path.lineTo(p2); path.lineTo(p3); path.lineTo(p4)
                line = self.scene.addPath(path, pen); line.setZValue(-1)
    
    def _load_users_for_combo(self):
        self.manager_combo.clear(); self.manager_combo.addItem("--- هیچکس ---", None)
        users = self.db.get_all_users_brief()
        for user in users: self.manager_combo.addItem(user['username'], user['id'])

    def _on_item_selected(self, item):
        dept_data = item.data(0, Qt.UserRole)
        if not dept_data: self._clear_fields(); return
        
        self.details_group.setDisabled(False); self.current_dept_id = dept_data['id']; self.dept_name_edit.setText(dept_data['name'])
        
        for node in self.nodes.values(): node.setSelected(False)
        if self.current_dept_id in self.nodes: self.nodes[self.current_dept_id].setSelected(True)

        manager_id = dept_data.get('manager_user_id')
        index = self.manager_combo.findData(manager_id) if manager_id is not None else 0
        self.manager_combo.setCurrentIndex(index if index != -1 else 0)
        
        self.user_list_widget.clear()
        users_in_dept = self.db.get_users_in_department(self.current_dept_id)
        if users_in_dept: self.user_list_widget.addItems([u['username'] for u in users_in_dept])
        else: self.user_list_widget.addItem("هیچ کارمندی در این واحد نیست.")

    def _show_context_menu(self, pos):
        menu = QtWidgets.QMenu(self); add_action = menu.addAction("افزودن زیرمجموعه جدید"); del_action = menu.addAction("حذف واحد انتخاب شده")
        action = menu.exec_(self.tree.mapToGlobal(pos)); selected_item = self.tree.itemAt(pos)
        item_id = selected_item.data(0, Qt.UserRole)['id'] if selected_item else None
        if action == add_action: self._add_department(item_id)
        elif action == del_action and item_id: self._delete_department(item_id, selected_item.text(0))

    def _add_department_action(self):
        selected_item = self.tree.currentItem()
        parent_id = selected_item.data(0, Qt.UserRole)['id'] if selected_item else None
        self._add_department(parent_id)

    def _delete_department_action(self):
        selected_item = self.tree.currentItem()
        if not selected_item:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک واحد را برای حذف انتخاب کنید.", "warning")
            return
        dept_id = selected_item.data(0, Qt.UserRole)['id']; dept_name = selected_item.text(0)
        self._delete_department(dept_id, dept_name)

    def _add_department(self, parent_id):
        name, ok = QtWidgets.QInputDialog.getText(self, "واحد جدید", "نام واحد سازمانی جدید را وارد کنید:")
        if ok and name:
            try:
                self.db.add_department(name, parent_id); self._load_chart_data()
            except psycopg2.errors.UniqueViolation: QtWidgets.QMessageBox.critical(self, "خطا", "واحدی با این نام از قبل وجود دارد.")
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"خطای پیش‌بینی نشده:\n{e}")

    def _delete_department(self, dept_id, dept_name):
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف واحد «{dept_name}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_department(dept_id); self._load_chart_data(); self._clear_fields()
            except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا", f"امکان حذف این واحد وجود ندارد.\nاحتمالاً کاربرانی به آن اختصاص یافته‌اند یا دارای زیرمجموعه است.\n{e}")

# در کلاس OrgChartManagerDialog، این متد را جایگزین کنید

    def _save_details(self):
        if self.current_dept_id is None:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک واحد را از درخت انتخاب کنید.", "warning")
            return
        
        name = self.dept_name_edit.text().strip()
        manager_id = self.manager_combo.currentData()
        
        # --- *** اصلاح کلیدی: پیدا کردن والد از طریق داده‌های ذخیره شده به جای آیتم فعلی *** ---
        # به جای self.tree.currentItem() از self.dept_map که قابل اطمینان‌تر است استفاده می‌کنیم
        current_dept_data = self.dept_map.get(self.current_dept_id)
        parent_id = current_dept_data.get('parent_id') if current_dept_data else None
        # --- ************************************************************************** ---
        
        if name:
            try:
                self.db.update_department(self.current_dept_id, name, parent_id, manager_id)
                if self.toast: self.toast.show_message("✔ تغییرات با موفقیت ذخیره شد.", "success")
                self._load_chart_data() # رفرش کردن کل چارت
            except psycopg2.errors.UniqueViolation:
                QtWidgets.QMessageBox.critical(self, "خطا", "واحدی با این نام از قبل وجود دارد.")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطای پیش‌بینی نشده:\n{e}")
                                
    def _clear_fields(self):
        self.current_dept_id = None; self.dept_name_edit.clear(); self.manager_combo.setCurrentIndex(0)
        self.details_group.setDisabled(True); self.tree.clearSelection(); self.user_list_widget.clear()

    def _handle_drop(self, dragged_node, target_node):
        dragged_id = dragged_node.data['id']
        new_parent_id = target_node.data['id']

        temp_id = new_parent_id
        while temp_id is not None:
            if temp_id == dragged_id:
                QtWidgets.QMessageBox.warning(self, "عملیات غیرمجاز", "امکان انتقال یک واحد به زیرمجموعه خودش وجود ندارد.")
                self._auto_layout_and_draw(); return
            temp_id = self.dept_map.get(temp_id, {}).get('parent_id')
        
        try:
            self.db.update_department_parent(dragged_id, new_parent_id)
            if self.toast: self.toast.show_message("ساختار با موفقیت به‌روزرسانی شد.", "success")
            self._load_chart_data()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در به‌روزرسانی ساختار:\n{e}")
            self._auto_layout_and_draw()

    def _reset_layout(self):
        """تمام موقعیت‌های دستی را پاک کرده و چارت را دوباره می‌چیند."""
        reply = QtWidgets.QMessageBox.question(self, "تایید بازنشانی", "آیا می‌خواهید تمام تغییرات چیدمان به حالت خودکار بازگردد؟")
        if reply == QtWidgets.QMessageBox.Yes:
            self.db.reset_all_department_positions()
            self._load_chart_data()
            
class WorkflowReviewDialog(QtWidgets.QDialog):
    """پنجره‌ای برای بازبینی کامل یک فرآیند قبل از تایید نهایی."""
    def __init__(self, db: DB, workflow_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.workflow_id = workflow_id
        
        wf_data = self.db.execute_query("SELECT * FROM workflows WHERE id = %s", (workflow_id,), fetch_one=True)
        self.setWindowTitle(f"بازبینی فرآیند: {wf_data.get('name', '')}")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        form_name = "مشخص نشده"
        if wf_data.get('form_def_id'):
            form_rec = self.db.execute_query("SELECT name FROM form_defs WHERE id=%s", (wf_data['form_def_id'],), fetch_one=True)
            if form_rec: form_name = form_rec['name']
            
        form_layout.addRow("نام فرآیند:", QtWidgets.QLabel(f"<b>{wf_data.get('name', '')}</b>"))
        form_layout.addRow("توضیحات:", QtWidgets.QLabel(wf_data.get('description', '')))
        form_layout.addRow("فرم مرتبط:", QtWidgets.QLabel(form_name))
        layout.addLayout(form_layout)

        steps_group = QtWidgets.QGroupBox("مراحل تعریف شده")
        steps_layout = QtWidgets.QVBoxLayout(steps_group)
        self.steps_tree = QtWidgets.QTreeWidget()
        self.steps_tree.setHeaderLabels(["مرحله", "تایید کننده", "نقش"])
        steps_layout.addWidget(self.steps_tree)
        layout.addWidget(steps_group)
        
        steps = self.db.get_workflow_steps(self.workflow_id)
        for step in steps:
            approver_type_map = {'ROLE': 'نقش سازمانی', 'REQUESTER_MANAGER': 'مدیر واحد درخواست دهنده', 'CEO': 'مدیر عامل'}
            QtWidgets.QTreeWidgetItem(self.steps_tree, [step['step_name'], approver_type_map.get(step['approver_type']), step.get('role_name', '---')])
        self.steps_tree.expandAll()

        buttons = QtWidgets.QDialogButtonBox()
        self.btn_reject = buttons.addButton("رد کردن و بازگرداندن", QtWidgets.QDialogButtonBox.RejectRole)
        self.btn_approve = buttons.addButton("تایید و ابلاغ فرآیند", QtWidgets.QDialogButtonBox.AcceptRole)
        self.btn_approve.setProperty("class", "primary")
        layout.addWidget(buttons)
        
        self.btn_approve.clicked.connect(self.accept)
        self.btn_reject.clicked.connect(self.reject)
        
#
# این کلاس را به طور کامل جایگزین ReplenishmentDialog قبلی کنید
#
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class ReplenishmentDialog(QtWidgets.QDialog):
    """پنجره مرکز تامین کالا برای ایجاد درخواست خرید (پشتیبانی از حالت گروهی و تکی)."""
    def __init__(self, db: DB, user_id: int, parent=None, preselected_item_id=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.toast = getattr(parent, 'toast', None)
        self.preselected_item_id = preselected_item_id
        
        title = "ایجاد درخواست خرید موردی" if self.preselected_item_id else "مرکز هوشمند تامین کالا"
        self.setWindowTitle(title)
        self.setMinimumSize(800, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        
        # --- *** اصلاح کلیدی: فیلد انتخاب واحد به بالای فرم منتقل شد *** ---
        form_layout = QtWidgets.QFormLayout()
        form_layout.setContentsMargins(0, 0, 0, 10)
        self.dept_combo = QtWidgets.QComboBox()
        form_layout.addRow("<b>درخواست برای واحد (*):</b>", self.dept_combo)
        layout.addLayout(form_layout)

        label_text = "مقدار نهایی خرید را مشخص و درخواست را ثبت کنید:" if self.preselected_item_id else "<b>لیست کالاهای نیازمند سفارش مجدد:</b>"
        layout.addWidget(QtWidgets.QLabel(label_text))
        
        self.table = QtWidgets.QTableWidget()
        parent._style_table(self.table)
        self.table.setEditTriggers(QtWidgets.QAbstractItemView.DoubleClicked)
        layout.addWidget(self.table)
        
        btn_layout = QtWidgets.QHBoxLayout()
        btn_create = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-send"), "ایجاد درخواست برای موارد انتخابی")
        btn_create.setProperty("class", "primary")
        btn_create.clicked.connect(self._create_requests)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_create)
        layout.addLayout(btn_layout)

        self._populate_departments_combo()
        self._load_data()

    def _populate_departments_combo(self):
        self.dept_combo.clear()
        self.dept_combo.addItem("--- انتخاب کنید ---", None)
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            self.dept_combo.addItem(dept['name'], dept['id'])

# در کلاس ReplenishmentDialog، این متد را جایگزین کنید

    def _load_data(self):
        items_to_display = []
        if self.preselected_item_id:
            item_details = self.db.execute_query(
                "SELECT i.id, i.name, i.category, u.name as unit, i.min_qty, i.max_qty, COALESCE(s.non_prod_qty, 0) as current_qty, (i.max_qty - COALESCE(s.non_prod_qty, 0)) as suggested_qty FROM items i LEFT JOIN units u ON i.unit_id = u.id LEFT JOIN (SELECT item_id, SUM(CASE WHEN w.name != 'Production' THEN qty ELSE 0 END) as non_prod_qty FROM stock JOIN locations l ON stock.location_id = l.id JOIN warehouses w ON l.warehouse_id = w.id GROUP BY item_id) s ON i.id = s.item_id WHERE i.id = %s",
                (self.preselected_item_id,), fetch_one=True
            )
            if item_details:
                if item_details['suggested_qty'] <= 0: item_details['suggested_qty'] = 1.0
                items_to_display.append(item_details)
        else:
            items_to_display = self.db.get_items_below_minimum()

        # --- *** اصلاح ۱: افزودن هدرهای جدول *** ---
        headers = ["", "ID", "نام کالا", "موجودی فعلی", "حد سفارش", "مقدار پیشنهادی خرید", "مقدار نهایی خرید (*)"]
        self.table.setColumnCount(len(headers))
        self.table.setHorizontalHeaderLabels(headers)
        # --- *********************************** ---
        
        self.table.setRowCount(len(items_to_display))
        
        for r, item in enumerate(items_to_display):
            checkbox_widget = QtWidgets.QWidget(); chk_layout = QtWidgets.QHBoxLayout(checkbox_widget); chk_box = QtWidgets.QCheckBox()
            if self.preselected_item_id: chk_box.setChecked(True)
            chk_layout.addWidget(chk_box); chk_layout.setAlignment(QtCore.Qt.AlignCenter); chk_layout.setContentsMargins(0,0,0,0)
            self.table.setCellWidget(r, 0, checkbox_widget)

            self.table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.table.setItem(r, 2, QtWidgets.QTableWidgetItem(item['name']))
            self.table.setItem(r, 3, NumericTableWidgetItem(str(item['current_qty'])))
            self.table.setItem(r, 4, NumericTableWidgetItem(str(item['min_qty'])))
            self.table.setItem(r, 5, NumericTableWidgetItem(str(item.get('suggested_qty', 0))))
            
            final_qty_item = NumericTableWidgetItem(str(item.get('suggested_qty', 0)))
            final_qty_item.setBackground(QtGui.QColor("#e7f1ff")) # هایلایت برای تاکید
            self.table.setItem(r, 6, final_qty_item)

            # --- *** اصلاح ۲: غیرفعال کردن ویرایش سلول‌های غیرضروری *** ---
            for c in range(6): # ستون‌های ۰ تا ۵
                cell = self.table.item(r, c)
                if cell:
                    # حذف پرچم "قابل ویرایش" از سلول
                    cell.setFlags(cell.flags() & ~QtCore.Qt.ItemIsEditable)
            # --- *************************************************** ---

        self.table.setColumnHidden(1, True)
        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        
        
    def _create_requests(self):
        # --- *** اصلاح کلیدی: اعتبارسنجی انتخاب واحد *** ---
        original_dept_id = self.dept_combo.currentData()
        if original_dept_id is None:
            if self.toast: self.toast.show_message("لطفاً «واحد درخواست‌دهنده» را مشخص کنید.", "warning")
            return
            
        requests_to_create = []
        for r in range(self.table.rowCount()):
            checkbox = self.table.cellWidget(r, 0).findChild(QtWidgets.QCheckBox)
            if checkbox and checkbox.isChecked():
                try:
                    item_id = int(self.table.item(r, 1).text())
                    final_qty = float(self.table.item(r, 6).text())
                    if final_qty > 0:
                        requests_to_create.append({'item_id': item_id, 'qty': final_qty})
                except (ValueError, TypeError, AttributeError):
                    continue
        
        if not requests_to_create:
            if self.toast: self.toast.show_message("هیچ کالایی برای ایجاد درخواست انتخاب نشده است.", "warning")
            return
            
        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا برای {len(requests_to_create)} کالای انتخاب شده، به نام واحد «{self.dept_combo.currentText()}» درخواست خرید ثبت شود؟")
        if reply == QtWidgets.QMessageBox.Yes:
            success_count = 0
            for req in requests_to_create:
                try:
                    self.db.create_purchase_request(
                        item_id=req['item_id'], 
                        qty=req['qty'], 
                        user_id=self.user_id, 
                        original_dept_id=original_dept_id, 
                        notes="ایجاد شده از مرکز تامین کالا"
                    )
                    success_count += 1
                except Exception as e:
                    print(f"Failed to create PR for item {req['item_id']}: {e}")
            
            if self.toast: self.toast.show_message(f"✔ تعداد {success_count} درخواست خرید با موفقیت ثبت شد.", "success")
            if hasattr(self.parent(), 'refresh_all'):
                self.parent().refresh_all()
            self.accept()
            
                        
class InternalRequestDialog(QtWidgets.QDialog):
    """دیالوگی برای کاربران جهت ثبت درخواست داخلی کالا از انبار."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت درخواست جدید از انبار")
        self.setMinimumWidth(450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.item_combo = QtWidgets.QComboBox()
        self.item_combo.setEditable(True)
        self.item_combo.setCompleter(QtWidgets.QCompleter(self.item_combo.model()))
        
        self.qty_edit = QtWidgets.QLineEdit("1.0")
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, 1e9, 3))
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری (مثال: برای پروژه X)")
        
        layout.addRow("انتخاب کالا:", self.item_combo)
        layout.addRow("مقدار مورد نیاز:", self.qty_edit)
        layout.addRow("توضیحات:", self.notes_edit)
        
        # پر کردن لیست کالاها
        all_items = self.db.items_brief()
        for item in all_items:
            # فقط کالاهای غیر مادر قابل درخواست هستند
            if not item.get('is_parent_product'):
                self.item_combo.addItem(f"{item['name']} ({item['unit']})", item['id'])

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        try:
            return {
                'item_id': self.item_combo.currentData(),
                'quantity': float(self.qty_edit.text()),
                'notes': self.notes_edit.text().strip()
            }
        except (ValueError, TypeError):
            return None
        
#
# این کلاس جدید را به طور کامل به فایل خود اضافه کنید
#
class AddQuoteDialog(QtWidgets.QDialog):
    """دیالوگی برای ثبت جزئیات یک پیشنهاد قیمت از طرف یک تامین‌کننده."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("افزودن پیشنهاد قیمت جدید")
        self.setMinimumWidth(500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.supplier_combo = QtWidgets.QComboBox()
        self.price_edit = QtWidgets.QLineEdit()
        self.price_edit.setValidator(QtGui.QDoubleValidator(0, 1e12, 2))
        self.lead_time_edit = QtWidgets.QLineEdit("1")
        self.lead_time_edit.setValidator(QtGui.QIntValidator(0, 365))
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری (مثال: شامل هزینه حمل)")

        # بخش انتخاب فایل پیوست
        path_layout = QtWidgets.QHBoxLayout()
        self.doc_path_edit = QtWidgets.QLineEdit()
        self.doc_path_edit.setReadOnly(True)
        btn_browse = QtWidgets.QPushButton("...")
        btn_browse.setFixedSize(30, 30)
        btn_browse.clicked.connect(self._browse_file)
        path_layout.addWidget(self.doc_path_edit)
        path_layout.addWidget(btn_browse)

        # پر کردن لیست تامین‌کنندگان فعال
        suppliers = self.db.get_all_suppliers(active_only=True)
        for s in suppliers:
            self.supplier_combo.addItem(s['name'], s['id'])
            
        layout.addRow("تامین کننده (*):", self.supplier_combo)
        layout.addRow("قیمت واحد (*):", self.price_edit)
        layout.addRow("زمان تحویل (روز):", self.lead_time_edit)
        layout.addRow("یادداشت:", self.notes_edit)
        layout.addRow("فایل پیش‌فاکتور:", path_layout)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def _browse_file(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل پیش‌فاکتور')
        if path:
            self.doc_path_edit.setText(path)

    def get_data(self):
        """اطلاعات وارد شده در فرم را به صورت دیکشنری برمی‌گرداند."""
        if self.supplier_combo.currentIndex() == -1 or not self.price_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "اطلاعات ناقص", "لطفاً تامین‌کننده و قیمت واحد را مشخص کنید.")
            return None
        try:
            return {
                "supplier_id": self.supplier_combo.currentData(),
                "unit_price": float(self.price_edit.text()),
                "lead_time": int(self.lead_time_edit.text() or 0),
                "notes": self.notes_edit.text().strip(),
                "doc_path": self.doc_path_edit.text()
            }
        except (ValueError, TypeError):
            QtWidgets.QMessageBox.warning(self, "مقدار نامعتبر", "لطفاً مقادیر عددی را به درستی وارد کنید.")
            return None
        
                                        
class MemoDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نوشتن و ارسال نامه داخلی جدید."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("نامه جدید")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()

        self.to_list = QtWidgets.QListWidget(); self.to_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.cc_list = QtWidgets.QListWidget(); self.cc_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.subject_edit = QtWidgets.QLineEdit()
        self.body_edit = QtWidgets.QTextEdit()
        
        # پر کردن لیست کاربران برای انتخاب
        users = self.db.get_all_users_brief()
        for user in users:
            item_to = QtWidgets.QListWidgetItem(user['username']); item_to.setData(Qt.UserRole, user['id'])
            item_cc = QtWidgets.QListWidgetItem(user['username']); item_cc.setData(Qt.UserRole, user['id'])
            self.to_list.addItem(item_to)
            self.cc_list.addItem(item_cc)

        # استفاده از اسپلیتر برای انتخاب گیرندگان
        recipient_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        to_group = QtWidgets.QGroupBox("گیرندگان اصلی (To)"); to_layout = QtWidgets.QVBoxLayout(to_group); to_layout.addWidget(self.to_list)
        cc_group = QtWidgets.QGroupBox("رونوشت (CC)"); cc_layout = QtWidgets.QVBoxLayout(cc_group); cc_layout.addWidget(self.cc_list)
        recipient_splitter.addWidget(to_group); recipient_splitter.addWidget(cc_group)
        
        form_layout.addRow(recipient_splitter)
        form_layout.addRow("موضوع:", self.subject_edit)
        layout.addLayout(form_layout)
        layout.addWidget(self.body_edit)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ارسال نامه")
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def get_data(self):
        to_ids = [self.to_list.item(i).data(Qt.UserRole) for i in range(self.to_list.count()) if self.to_list.item(i).isSelected()]
        cc_ids = [self.cc_list.item(i).data(Qt.UserRole) for i in range(self.cc_list.count()) if self.cc_list.item(i).isSelected()]
        
        if not to_ids and not cc_ids:
            QtWidgets.QMessageBox.warning(self, "خطا", "حداقل یک گیرنده باید انتخاب شود.")
            return None
        if not self.subject_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "خطا", "موضوع نامه نمی‌تواند خالی باشد.")
            return None
            
        return {
            "subject": self.subject_edit.text().strip(),
            "body": self.body_edit.toPlainText(),
            "to_user_ids": to_ids,
            "cc_user_ids": cc_ids
        }
        
class CommunicationWidget(QtWidgets.QWidget):
    """ویجت یکپارچه برای نمایش صندوق ورودی و نامه‌های ارسالی."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        self.tabs = QtWidgets.QTabWidget()
        self.tbl_inbox = QtWidgets.QTableWidget()
        self.tbl_sent = QtWidgets.QTableWidget()
        
        self.parent_window._style_table(self.tbl_inbox)
        self.parent_window._style_table(self.tbl_sent)
        
        self.tbl_inbox.itemDoubleClicked.connect(self._on_inbox_double_clicked)
        self.tbl_sent.itemDoubleClicked.connect(self._on_sent_double_clicked)

        self.tabs.addTab(self.tbl_inbox, "صندوق ورودی (Inbox)")
        self.tabs.addTab(self.tbl_sent, "نامه‌های ارسالی (Sent)")
        layout.addWidget(self.tabs)
        
        self.refresh_inbox()
        self.refresh_sent()

    def refresh_inbox(self):
        inbox_items = self.db.get_user_inbox(self.user_id)
        headers = ["ID", "", "فرستنده", "موضوع", "تاریخ"]
        self.tbl_inbox.setColumnCount(len(headers)); self.tbl_inbox.setHorizontalHeaderLabels(headers)
        self.tbl_inbox.setRowCount(len(inbox_items))
        for r, item in enumerate(inbox_items):
            self.tbl_inbox.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            read_status = "✔" if item['read_at'] else ""
            self.tbl_inbox.setItem(r, 1, QtWidgets.QTableWidgetItem(read_status))
            self.tbl_inbox.setItem(r, 2, QtWidgets.QTableWidgetItem(item['author_name']))
            self.tbl_inbox.setItem(r, 3, QtWidgets.QTableWidgetItem(item['subject']))
            self.tbl_inbox.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(item['created_at'])))
            if not item['read_at']:
                for c in range(len(headers)):
                    font = self.tbl_inbox.item(r, c).font(); font.setBold(True); self.tbl_inbox.item(r, c).setFont(font)
        self.tbl_inbox.setColumnHidden(0, True)
        self.tbl_inbox.resizeColumnsToContents()
        self.tbl_inbox.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)

    def refresh_sent(self):
        sent_items = self.db.get_user_sent_items_detailed(self.user_id)
        headers = ["ID", "گیرندگان", "موضوع", "تاریخ ارسال"]
        self.tbl_sent.setColumnCount(len(headers)); self.tbl_sent.setHorizontalHeaderLabels(headers)
        self.tbl_sent.setRowCount(len(sent_items))
        for r, item in enumerate(sent_items):
            self.tbl_sent.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.tbl_sent.setItem(r, 1, QtWidgets.QTableWidgetItem(item.get('recipients_list', '')))
            self.tbl_sent.setItem(r, 2, QtWidgets.QTableWidgetItem(item['subject']))
            self.tbl_sent.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(item['created_at'])))
        self.tbl_sent.setColumnHidden(0, True)
        self.tbl_sent.resizeColumnsToContents()
        self.tbl_sent.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _on_inbox_double_clicked(self, item):
        memo_id = int(self.tbl_inbox.item(item.row(), 0).text())
        memo_data = self.db.get_memo_details(memo_id, self.user_id)
        if memo_data:
            dlg = MemoViewDialog(dict(memo_data), self)
            dlg.exec_()
            self.refresh_inbox() # رفرش برای اینکه وضعیت "خوانده شده" آپدیت شود

    def _on_sent_double_clicked(self, item):
        memo_id = int(self.tbl_sent.item(item.row(), 0).text())
        memo_data = self.db.get_memo_details(memo_id, self.user_id)
        if memo_data:
            dlg = MemoViewDialog(dict(memo_data), self)
            dlg.exec_()
                
class MemoViewDialog(QtWidgets.QDialog):
    """پنجره‌ای برای نمایش جزئیات یک نامه (فقط خواندنی)."""
    def __init__(self, memo_data: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"مشاهده نامه: {memo_data.get('subject', '')}")
        self.setMinimumSize(600, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        to_list = ", ".join(memo_data.get('to_list') or [])
        cc_list = ", ".join(memo_data.get('cc_list') or [])
        
        form_layout.addRow("شماره نامه:", QtWidgets.QLabel(f"<b>{memo_data.get('memo_number')}</b>"))
        form_layout.addRow("از:", QtWidgets.QLabel(memo_data.get('author_name', '')))
        form_layout.addRow("به:", QtWidgets.QLabel(to_list))
        if cc_list:
            form_layout.addRow("رونوشت:", QtWidgets.QLabel(cc_list))
        form_layout.addRow("تاریخ:", QtWidgets.QLabel(to_shamsi(memo_data.get('created_at'))))
        form_layout.addRow("موضوع:", QtWidgets.QLabel(f"<b>{memo_data.get('subject')}</b>"))

        body_edit = QtWidgets.QTextEdit()
        body_edit.setPlainText(memo_data.get('body', ''))
        body_edit.setReadOnly(True)
        
        layout.addLayout(form_layout)
        layout.addWidget(body_edit)
        
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class ProcessTrackerWidget(QtWidgets.QWidget):
    """ویجت یکپارچه و هوشمند برای نمایش و ردیابی فرآیندهای مرتبط با کاربر (مرکز اسناد)."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        
        self.PROCESS_HANDLERS = {
            "PURCHASING": {
                "builder": self._build_purchasing_history_table
            },
            "GENERIC": {
                "builder": self._build_general_history_table
            }
        }

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setObjectName("interfaceTabWidget")
        layout.addWidget(self.tabs)
        
        self.refresh_history()

    def refresh_history(self):
        """تاریخچه فرآیندهای کاربر را خوانده، دسته‌بندی کرده و به صورت تب‌های پویا نمایش می‌دهد."""
        self.tabs.clear()
        
        all_docs = self.db.get_user_document_history(self.user_id)
        if not all_docs:
            placeholder = QtWidgets.QLabel("هیچ سند یا فرآیندی برای نمایش در تاریخچه شما یافت نشد.")
            placeholder.setAlignment(QtCore.Qt.AlignCenter)
            self.tabs.addTab(placeholder, "اطلاعات")
            return

        grouped_docs = {}
        for doc in all_docs:
            handler_key = doc.get('handler_key', 'GENERIC')
            if handler_key not in grouped_docs:
                grouped_docs[handler_key] = {'docs': [], 'title': doc.get('process_category_name', 'عمومی')}
            grouped_docs[handler_key]['docs'].append(doc)
            
        for handler_key, data in grouped_docs.items():
            handler_config = self.PROCESS_HANDLERS.get(handler_key, self.PROCESS_HANDLERS['GENERIC'])
            tab_widget = handler_config["builder"](data['docs'])
            self.tabs.addTab(tab_widget, data['title'])

    def _build_purchasing_history_table(self, docs: list) -> QtWidgets.QWidget:
        """یک ویجت جدول تخصصی برای نمایش تاریخچه خرید می‌سازد."""
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        table = QtWidgets.QTableWidget()
        if self.parent_window: self.parent_window._style_table(table)
        
        headers = ["نام فرآیند", "کالا", "مقدار درخواستی", "وضعیت نهایی سند", "تاریخ شروع", "شروع کننده"]
        table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers); table.setRowCount(len(docs))

        for r, doc in enumerate(docs):
            details = doc.get('document_details', {})
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(doc['workflow_name']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(details.get('item_name', '---')))
            table.setItem(r, 2, NumericTableWidgetItem(str(details.get('requested_qty', '---'))))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(details.get('status', doc.get('process_status'))))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(doc['started_at'])))
            table.setItem(r, 5, QtWidgets.QTableWidgetItem(doc['initiator_name']))
        
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(table)
        return container
        
    def _build_general_history_table(self, docs: list) -> QtWidgets.QWidget:
        """یک ویجت جدول عمومی برای نمایش تاریخچه فرآیندهای عمومی می‌سازد."""
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        table = QtWidgets.QTableWidget()
        if self.parent_window: self.parent_window._style_table(table)

        headers = ["نام فرآیند", "وضعیت فرآیند", "مرحله فعلی", "تاریخ شروع", "تاریخ اتمام"]
        table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers); table.setRowCount(len(docs))
        
        for r, doc in enumerate(docs):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(doc['workflow_name']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(doc['process_status']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(doc.get('current_step_name', '---')))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(doc['started_at'])))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(doc['completed_at'])))
        
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(table)
        return container                
                    
            
class InternalRequestDialog(QtWidgets.QDialog):
    """دیالوگی برای کاربران جهت ثبت درخواست داخلی کالا از انبار."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ثبت درخواست جدید از انبار")
        self.setMinimumWidth(450)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QFormLayout(self)
        self.item_combo = QtWidgets.QComboBox()
        self.item_combo.setEditable(True)
        self.item_combo.setCompleter(QtWidgets.QCompleter(self.item_combo.model()))
        
        self.qty_edit = QtWidgets.QLineEdit("1.0")
        self.qty_edit.setValidator(QtGui.QDoubleValidator(0.01, 1e9, 3))
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری (مثال: برای پروژه X)")
        
        layout.addRow("انتخاب کالا:", self.item_combo)
        layout.addRow("مقدار مورد نیاز:", self.qty_edit)
        layout.addRow("توضیحات:", self.notes_edit)
        
        all_items = self.db.items_brief()
        for item in all_items:
            if not item.get('is_parent_product'):
                self.item_combo.addItem(f"{item['name']} ({item['unit']})", item['id'])

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_data(self):
        try:
            return {'item_id': self.item_combo.currentData(), 'quantity': float(self.qty_edit.text()), 'notes': self.notes_edit.text().strip()}
        except (ValueError, TypeError): return None
        
# کلاس CardWidget را به طور کامل با این نسخه جایگزین کنید
class CardWidget(QtWidgets.QFrame):
    """یک ویجت کارتی مدرن و جمع‌شونده (نسخه اصلاح شده برای محتوای گرافیکی)."""
    def __init__(self, title, icon_name, color, parent=None):
        super().__init__(parent)
        self.setObjectName("cardWidget")
        self.setStyleSheet("#cardWidget { border: 1px solid #dfe4ea; border-radius: 5px; background-color: white; }")
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        self.header = CardWidgetHeader(title, icon_name, color)
        self.content = QtWidgets.QWidget()
        self.content.setContentsMargins(10, 10, 10, 10)
        
        main_layout.addWidget(self.header)
        main_layout.addWidget(self.content)
        
        self.animation = QtCore.QPropertyAnimation(self.content, b"maximumHeight")
        self.animation.setDuration(200)
        self.header.toggled.connect(self.toggle_content)
        
    def setContentLayout(self, layout):
        old_layout = self.content.layout()
        if old_layout is not None:
            QtWidgets.QWidget().setLayout(old_layout)
        self.content.setLayout(layout)
        self.content.adjustSize()
        self.toggle_content(True)

    def toggle_content(self, expanded):
        """نسخه اصلاح شده: محتوا را قبل و بعد از انیمیشن، مخفی/نمایش می‌دهد."""
        if expanded:
            # قبل از باز شدن، ویجت را نمایش بده
            self.content.setVisible(True)
            start_height = 0
            end_height = self.content.sizeHint().height()
        else:
            start_height = self.content.height()
            end_height = 0
        
        self.animation.setStartValue(start_height)
        self.animation.setEndValue(end_height)
        # پس از اتمام انیمیشن بسته شدن، ویجت را مخفی کن
        if not expanded:
            self.animation.finished.connect(lambda: self.content.setVisible(False))
        else:
            # اطمینان از حذف کانکشن‌های قبلی برای جلوگیری از اجرای چندباره
            try: self.animation.finished.disconnect()
            except TypeError: pass

        self.animation.start()
        
# این کلاس کاملاً جدید را به انتهای فایل اضافه کنید
class TaskCardWidget(QtWidgets.QFrame):
    """یک کارت گرافیکی زیبا برای نمایش یک وظیفه در بورد کانبان."""
    approveClicked = QtCore.pyqtSignal(int)
    rejectClicked = QtCore.pyqtSignal(int)
    detailsClicked = QtCore.pyqtSignal(dict)

# در کلاس TaskCardWidget، این متد را جایگزین کنید

    def __init__(self, task_data: dict, parent=None):
        super().__init__(parent)
        self.task_data = task_data
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setObjectName("taskCard")
        self.setStyleSheet("""
            QFrame#taskCard {
                background-color: white;
                border: 1px solid #dfe4ea;
                border-radius: 6px;
            }
        """)

        main_layout = QtWidgets.QVBoxLayout(self)

        # بخش هدر کارت
        header_layout = QtWidgets.QHBoxLayout()
        workflow_label = QtWidgets.QLabel(f"<b>{task_data.get('workflow_name', 'فرآیند نامشخص')}</b>")
        header_layout.addWidget(workflow_label)
        header_layout.addStretch()
        main_layout.addLayout(header_layout)

        # بخش بدنه کارت
        step_label = QtWidgets.QLabel(f"مرحله: {task_data.get('step_name', '')}")
        details_text = ""
        if task_data.get('related_table_name') == 'purchase_requests':
            details = task_data.get('details', {})
            details_text = f"برای: «{details.get('item_name', '')}»"
        details_label = QtWidgets.QLabel(details_text)
        details_label.setStyleSheet("color: #6c757d;")
        main_layout.addWidget(step_label)
        main_layout.addWidget(details_label)

        # بخش دکمه‌ها
        btn_layout = QtWidgets.QHBoxLayout()
        btn_details = QtWidgets.QPushButton("جزئیات")
        btn_reject = QtWidgets.QPushButton("رد")
        btn_approve = QtWidgets.QPushButton("تایید")

        btn_reject.setProperty("class", "danger")
        btn_approve.setProperty("class", "primary")

        btn_layout.addWidget(btn_details)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_reject)
        btn_layout.addWidget(btn_approve)
        main_layout.addLayout(btn_layout)

        # اتصال سیگنال‌ها
        task_id = self.task_data['process_instance_id']
        btn_approve.clicked.connect(lambda: self.approveClicked.emit(task_id))
        btn_reject.clicked.connect(lambda: self.rejectClicked.emit(task_id))
        # --- *** اصلاح کلیدی: تبدیل داده به دیکشنری قبل از ارسال *** ---
        btn_details.clicked.connect(lambda: self.detailsClicked.emit(dict(self.task_data)))
    
    def mouseMoveEvent(self, event):
        """برای شروع عملیات Drag & Drop."""
        if event.buttons() != QtCore.Qt.LeftButton:
            return

        drag = QtGui.QDrag(self)
        mime_data = QtCore.QMimeData()
        # ID وظیفه را به عنوان متن ارسال می‌کنیم
        mime_data.setText(str(self.task_data['process_instance_id']))
        drag.setMimeData(mime_data)
        
        # یک تصویر کوچک از کارت را به عنوان پیش‌نمایش درگ نمایش می‌دهیم
        pixmap = self.grab()
        drag.setPixmap(pixmap)
        drag.setHotSpot(event.pos())
        
        drag.exec_(QtCore.Qt.MoveAction)            
                                    
# این کلاس را به طور کامل جایگزین نسخه قبلی کنید
class KanbanColumnWidget(QtWidgets.QListWidget):
    """یک ستون در بورد کانبان که قابلیت پذیرش کارت‌های وظیفه را دارد."""
    def __init__(self, state_key, parent_board):
        super().__init__(parent_board)
        self.state_key = state_key
        self.parent_board = parent_board
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        self.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)
        self.setDefaultDropAction(QtCore.Qt.MoveAction)
        self.setSpacing(10)
        self.setStyleSheet("QListWidget { border: 2px dashed #b0bec5; border-radius: 5px; background-color: #f1f3f5; }")

    def add_task(self, task_data):
        card = TaskCardWidget(task_data, self)
        # اتصال سیگنال‌های کارت به متدهای والد (KanbanBoardWidget)
        card.approveClicked.connect(self.parent_board.approve_task)
        card.rejectClicked.connect(self.parent_board.reject_task)
        card.detailsClicked.connect(self.parent_board.show_task_details)
        
        item = QtWidgets.QListWidgetItem(self)
        item.setSizeHint(card.sizeHint())
        item.setData(Qt.UserRole, task_data['process_instance_id']) # ذخیره ID برای شناسایی
        self.addItem(item)
        self.setItemWidget(item, card)

    # --- *** اصلاح کلیدی: افزودن این دو متد برای فعال‌سازی Drop *** ---
    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()
    # --- ********************************************************** ---

    def dropEvent(self, event):
        if event.source() is not self: # اگر کارت از ستون دیگری آمده بود
            task_id = int(event.mimeData().text())
            
            source_widget = event.source()
            if not isinstance(source_widget, TaskCardWidget): return
            
            source_column = source_widget.parent()
            if not isinstance(source_column, KanbanColumnWidget): return

            task_data = source_column.parent_board.get_task_data_by_id(task_id)

            if task_data:
                self.add_task(task_data)
                # حذف آیتم از لیست مبدا
                for i in range(source_column.count()):
                    if source_column.item(i).data(Qt.UserRole) == task_id:
                        source_column.takeItem(i)
                        break
                
                self.parent_board.update_task_state(task_id, self.state_key)
                event.acceptProposedAction()
        else:
            super().dropEvent(event)
                        
                                                
# این کلاس را به طور کامل با نسخه قبلی جایگزین کنید
class KanbanBoardWidget(QtWidgets.QWidget):
    """ویجت اصلی که بورد کانبان را شامل ستون‌ها و کارت‌ها می‌سازد."""
    task_activated = QtCore.pyqtSignal(dict) 

    def __init__(self, db: DB, user_id: int, user_role_id: int, parent=None):
        super().__init__(parent)
        self.db = db; self.user_id = user_id; self.user_role_id = user_role_id
        self.tasks_data_map = {}
        self.parent_window = parent

        layout = QtWidgets.QHBoxLayout(self); layout.setSpacing(15)

        self.columns = {}; self.column_counts = {}
        column_map = {"new": "جدید", "in_progress": "در حال انجام", "done": "انجام شده"}

        for key, name in column_map.items():
            col_container = QtWidgets.QWidget(); col_layout = QtWidgets.QVBoxLayout(col_container)
            header_layout = QtWidgets.QHBoxLayout(); title_label = QtWidgets.QLabel(f"<h3>{name}</h3>"); count_label = QtWidgets.QLabel("0")
            count_label.setStyleSheet("background-color: #ced4da; color: #495057; border-radius: 8px; padding: 2px 8px; font-weight: bold;"); self.column_counts[key] = count_label
            header_layout.addWidget(title_label); header_layout.addStretch(); header_layout.addWidget(count_label); col_layout.addLayout(header_layout)
            list_widget = KanbanColumnWidget(key, self); self.columns[key] = list_widget; col_layout.addWidget(list_widget); layout.addWidget(col_container)
        self.refresh_board()

    def approve_task(self, task_id):
        """یک وظیفه را با ارسال کد وضعیت و یک دیکشنری خالی، تایید می‌کند."""
        task_data = self.get_task_data_by_id(task_id)
        if task_data:
            # --- *** اصلاح کلیدی: ارسال آرگومان سوم به صورت یک دیکشنری خالی *** ---
            self.parent_window._execute_workflow_action(dict(task_data), QtWidgets.QDialog.Accepted, {})

    def reject_task(self, task_id):
        """
        برای رد کردن یک وظیفه، پنجره کامل اقدام را باز می‌کند تا دلیل از کاربر دریافت شود.
        """
        task_data = self.get_task_data_by_id(task_id)
        if task_data:
            # --- *** بهبود فرآیندی: فراخوانی دیالوگ اصلی برای دریافت دلیل *** ---
            self.show_task_details(dict(task_data))

    # (سایر متدهای این کلاس بدون تغییر باقی می‌مانند)
    def refresh_board(self):
        for col in self.columns.values(): col.clear()
        tasks = self.db.get_user_tasks_for_kanban(self.user_id, self.user_role_id)
        self.tasks_data_map = {task['process_instance_id']: task for task in tasks}
        for task in tasks:
            state = task.get('kanban_state', 'new')
            if state in self.columns: self.columns[state].add_task(task)
        self._update_column_counts()
    def update_task_state(self, task_id, new_state):
        self.db.update_task_kanban_state(task_id, new_state)
        self._update_column_counts()
    def get_task_data_by_id(self, task_id):
        return self.tasks_data_map.get(task_id)
    def _update_column_counts(self):
        for key, list_widget in self.columns.items():
            self.column_counts[key].setText(str(list_widget.count()))
    def show_task_details(self, task_data):
        self.parent_window._process_task_action_from_data(task_data)
                            
                                                            
        
class CardWidgetHeader(QtWidgets.QWidget):
    """هدر سفارشی برای کارت‌های داشبورد که قابل کلیک است."""
    toggled = QtCore.pyqtSignal(bool)

    def __init__(self, title, icon_name, color, parent=None):
        super().__init__(parent)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.is_expanded = True
        
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(10, 5, 5, 5)
        
        self.icon_label = QtWidgets.QLabel()
        self.icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(18, 18))
        
        self.title_label = QtWidgets.QLabel(f"<b>{title}</b>")
        
        self.toggle_button = QtWidgets.QToolButton()
        self.toggle_button.setArrowType(QtCore.Qt.DownArrow)
        self.toggle_button.setStyleSheet("QToolButton { border: none; }")
        
        layout.addWidget(self.icon_label)
        layout.addWidget(self.title_label)
        layout.addStretch()
        layout.addWidget(self.toggle_button)
        
        self.setStyleSheet(f"border-bottom: 2px solid {color};")

    def mousePressEvent(self, event):
        self.is_expanded = not self.is_expanded
        self.toggle_button.setArrowType(QtCore.Qt.DownArrow if self.is_expanded else QtCore.Qt.RightArrow)
        self.toggled.emit(self.is_expanded)
        super().mousePressEvent(event)

class CardWidget(QtWidgets.QFrame):
    """یک ویجت کارتی مدرن و جمع‌شونده."""
    def __init__(self, title, icon_name, color, parent=None):
        super().__init__(parent)
        self.setObjectName("cardWidget")
        self.setStyleSheet("#cardWidget { border: 1px solid #dfe4ea; border-radius: 5px; background-color: white; }")
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        self.header = CardWidgetHeader(title, icon_name, color)
        self.content = QtWidgets.QWidget()
        self.content.setContentsMargins(10, 10, 10, 10)
        
        main_layout.addWidget(self.header)
        main_layout.addWidget(self.content)
        
        self.animation = QtCore.QPropertyAnimation(self.content, b"maximumHeight")
        self.animation.setDuration(200) # ms
        self.header.toggled.connect(self.toggle_content)
        
    def setContentLayout(self, layout):
        # حذف layout قبلی
        old_layout = self.content.layout()
        if old_layout is not None:
            QtWidgets.QWidget().setLayout(old_layout)
        self.content.setLayout(layout)
        self.content.adjustSize()
        self.toggle_content(True) # برای تنظیم ارتفاع اولیه

    def toggle_content(self, expanded):
        if expanded:
            start_height = 0
            end_height = self.content.sizeHint().height()
        else:
            start_height = self.content.height()
            end_height = 0
        
        self.animation.setStartValue(start_height)
        self.animation.setEndValue(end_height)
        self.animation.start()
        
#
# بلوک ۱: این کلاس جدید را قبل از کلاس MainWindow اضافه کنید
#
class NavCardWidget(QtWidgets.QFrame):
    """یک کارت گرافیکی زیبا و قابل کلیک برای راهبری در داشبورد."""
    clicked = QtCore.pyqtSignal()
    
    def __init__(self, title, description, icon_name, color, parent=None):
        super().__init__(parent)
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.setMinimumHeight(150)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        
        self.color_strip = QtWidgets.QFrame()
        self.color_strip.setFixedWidth(10)
        self.color_strip.setStyleSheet(f"background-color: {color};")
        
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(48, 48))
        
        text_layout = QtWidgets.QVBoxLayout()
        title_label = QtWidgets.QLabel(f"<h2>{title}</h2>")
        desc_label = QtWidgets.QLabel(description)
        desc_label.setStyleSheet("color: #6c757d;")
        self.badge_label = QtWidgets.QLabel("")
        self.badge_label.setStyleSheet("background-color: #e44d26; color: white; border-radius: 8px; padding: 2px 8px; font-weight: bold;")
        self.badge_label.hide()
        
        text_layout.addWidget(title_label); text_layout.addWidget(desc_label); text_layout.addStretch()
        
        badge_layout = QtWidgets.QHBoxLayout()
        badge_layout.addStretch(); badge_layout.addWidget(self.badge_label)
        text_layout.addLayout(badge_layout)
        
        main_layout.addWidget(self.color_strip); main_layout.addWidget(icon_label, 0, QtCore.Qt.AlignCenter)
        main_layout.addLayout(text_layout, 1)
        
        self.setObjectName("navCard")
        self.setStyleSheet("#navCard { background-color: white; border-radius: 5px; border: 1px solid #dfe4ea; }")
        
    def mousePressEvent(self, event):
        self.setStyleSheet("#navCard { background-color: #e9ecef; border-radius: 5px; border: 1px solid #ced4da; }")
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        self.setStyleSheet("#navCard { background-color: white; border-radius: 5px; border: 1px solid #dfe4ea; }")
        if self.rect().contains(event.pos()):
            self.clicked.emit()
        super().mouseReleaseEvent(event)
        
    def set_badge_count(self, count):
        if count > 0:
            self.badge_label.setText(str(count))
            self.badge_label.show()
        else:
            self.badge_label.hide()

# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class TasksWidget(QtWidgets.QWidget):
    """ویجت یکپارچه و هوشمند برای نمایش کارتابل وظایف کاربر."""
    task_activated = QtCore.pyqtSignal(dict) 

    def __init__(self, db: DB, user_id: int, user_role_id: int, parent_window, title: str):
        super().__init__(parent_window)
        self.db = db
        self.user_id = user_id
        self.user_role_id = user_role_id
        self.parent_window = parent_window
        
        layout = QtWidgets.QVBoxLayout(self)
        group = QtWidgets.QGroupBox(title)
        group_layout = QtWidgets.QVBoxLayout(group)
        
        self.table = QtWidgets.QTableWidget()
        self.parent_window._style_table(self.table)
        self.table.itemDoubleClicked.connect(self._on_task_activated)
        
        group_layout.addWidget(self.table)
        layout.addWidget(group)

    def refresh_tasks(self):
        """وظایف کاربر را خوانده و جدول را به‌روزرسانی می‌کند."""
        table = self.table
        table.setSortingEnabled(False)
        table.setRowCount(0)
        
        try:
            tasks = self.db.get_pending_tasks_for_user_role(self.user_id, self.user_role_id)
            
            headers = ['ID', 'نوع فرآیند', 'مرحله فعلی', 'جزئیات', 'تاریخ ایجاد', 'ارجاع از طرف']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(tasks))

            for r, task in enumerate(tasks):
                details_text = ""
                if task['related_table_name'] == 'purchase_requests':
                    details = task.get('details', {})
                    details_text = f"درخواست خرید برای «{details.get('item_name')}»"

                item_id = QtWidgets.QTableWidgetItem(str(task['process_instance_id']))
                item_id.setData(Qt.UserRole, task)
                table.setItem(r, 0, item_id)
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(task['workflow_name']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(task['step_name']))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(details_text))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(task['started_at'])))
                
                delegation_text = f"نیابت از نقش «{task['original_approver_role']}»" if task.get('is_delegated') else "مستقیم"
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(delegation_text))

            table.setColumnHidden(0, True); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ کار جدیدی در کارتابل شما وجود ندارد.")
            table.setSortingEnabled(True)
        except Exception as e:
            print(f"Error loading pending tasks: {e}")


    def _on_task_activated(self, item: QtWidgets.QTableWidgetItem):
        """با دابل کلیک، سیگنالی حاوی اطلاعات کامل وظیفه را ارسال می‌کند."""
        task_data = self.table.item(item.row(), 0).data(Qt.UserRole)
        if task_data:
            # --- *** اصلاح کلیدی: تبدیل DictRow به dict استاندارد *** ---
            self.task_activated.emit(dict(task_data))
                    
# این متد جدید را به کلاس TasksWidget اضافه کنید

    def _load_tasks_from_data(self, tasks: list):
        """جدول را با لیستی از دیکشنری‌های وظایف که از بیرون ارسال شده، پر می‌کند."""
        table = self.table
        table.setRowCount(0)
        
        headers = ['ID', 'نوع فرآیند', 'مرحله فعلی', 'جزئیات', 'تاریخ ایجاد', 'ارجاع از طرف']
        table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
        table.setRowCount(len(tasks))

        for r, task in enumerate(tasks):
            details_text = ""
            if task.get('workflow_approval_id'): # حالت خاص برای تایید فرآیند
                context = task.get('context', {})
                details_text = f"فرآیند «{task.get('step_name')}» ایجاد شده توسط {context.get('created_by', '')}"
            elif task.get('related_table_name') == 'purchase_requests':
                details = task.get('details', {})
                details_text = f"درخواست خرید برای «{details.get('item_name')}»"

            # آیتم جدول را با داده کامل تسک می‌سازیم
            item_id_text = str(task.get('process_instance_id') or task.get('workflow_approval_id'))
            item_id = QtWidgets.QTableWidgetItem(item_id_text)
            item_id.setData(Qt.UserRole, task)
            
            table.setItem(r, 0, item_id)
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(task['workflow_name']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(task['step_name']))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(details_text))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(task['started_at'])))
            
            delegation_text = f"نیابت از نقش «{task.get('original_approver_role', '')}»" if task.get('is_delegated') else "مستقیم"
            table.setItem(r, 5, QtWidgets.QTableWidgetItem(delegation_text))

        table.setColumnHidden(0, True); table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(table, "هیچ کار جدیدی در کارتابل شما وجود ندارد.")
            
                            
                                        
# کلاس StartProcessDialog قبلی را حذف و این نسخه جدید را جایگزین کنید
class StartProcessDialog(QtWidgets.QDialog):
    """
    نسخه 2.0 (بازطراحی شده):
    - رابط کاربری گرافیکی و خوانا برای انتخاب فرآیند.
    - نمایش نام و توضیحات هر فرآیند.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("شروع یک فرآیند جدید")
        self.setMinimumWidth(550)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.addWidget(QtWidgets.QLabel("لطفاً فرآیندی که می‌خواهید شروع کنید را از لیست زیر انتخاب نمایید:"))
        
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setStyleSheet("QListWidget::item { padding: 8px; }")
        layout.addWidget(self.list_widget)
        
        workflows = self.db.execute_query("SELECT id, name, description FROM workflows WHERE is_active = TRUE AND is_manual_start = TRUE ORDER BY name")
        if workflows:
            for wf in workflows:
                item = QtWidgets.QListWidgetItem()
                # یک ویجت سفارشی برای هر آیتم می‌سازیم
                item_widget = QtWidgets.QWidget()
                item_layout = QtWidgets.QVBoxLayout(item_widget)
                item_layout.setContentsMargins(5, 5, 5, 5)
                item_layout.setSpacing(0)
                title_label = QtWidgets.QLabel(f"<b>{wf['name']}</b>")
                desc_label = QtWidgets.QLabel(wf.get('description', 'بدون توضیحات'))
                desc_label.setStyleSheet("color: #6c757d;")
                item_layout.addWidget(title_label)
                item_layout.addWidget(desc_label)
                
                item.setSizeHint(item_widget.sizeHint())
                item.setData(Qt.UserRole, wf['id'])
                self.list_widget.addItem(item)
                self.list_widget.setItemWidget(item, item_widget)
        else:
            self.list_widget.addItem("هیچ فرآیند قابل شروعی تعریف نشده است.")
            self.list_widget.setEnabled(False)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("بعدی (تکمیل فرم)")
        if not workflows:
            buttons.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)
            
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def get_selected_workflow_id(self):
        selected_items = self.list_widget.selectedItems()
        if not selected_items:
            return None
        return selected_items[0].data(Qt.UserRole)
    
# این کلاس را به کد خود اضافه کنید (اگر از قبل وجود دارد، جایگزین کنید)
class FormFieldWidget(QtWidgets.QFrame):
    """یک ویجت سفارشی که یک فیلد را روی بوم طراحی فرم نمایندگی می‌کند و قابل انتخاب است."""
    selected = QtCore.pyqtSignal(object)

    def __init__(self, field_id, field_type_text, field_type_key, field_label, parent=None):
        super().__init__(parent)
        self.field_id = field_id
        self.properties = {'type': field_type_key, 'label': field_label, 'required': False, 'placeholder': '', 'min': None, 'max': None}
        
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.setStyleSheet("QFrame { background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 5px; } QFrame:hover { border-color: #3498db; }")

        layout = QtWidgets.QHBoxLayout(self)
        self.icon_label = QtWidgets.QLabel()
        self.label_widget = QtWidgets.QLabel(f"<b>{field_label}</b>")
        self.required_indicator = QtWidgets.QLabel("")
        self.required_indicator.setStyleSheet("color: red; font-weight: bold; font-size: 14pt;")
        
        layout.addWidget(self.icon_label); layout.addWidget(self.label_widget); layout.addStretch(); layout.addWidget(self.required_indicator)
        self.update_display(field_type_text)

    def mousePressEvent(self, event):
        self.selected.emit(self)
        super().mousePressEvent(event)

    def set_selected(self, is_selected):
        if is_selected:
            self.setStyleSheet("QFrame { background-color: #dbeafe; border: 2px solid #0d6efd; border-radius: 5px; }")
        else:
            self.setStyleSheet("QFrame { background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 5px; } QFrame:hover { border-color: #3498db; }")

    def update_display(self, field_type_text=None):
        self.label_widget.setText(f"<b>{self.properties['label']}</b>")
        self.required_indicator.setText("*" if self.properties.get('required') else "")
        type_to_display = field_type_text or self.properties['type']
        icon_map = {"فیلد متنی": "edit-rename", "فیلد عددی": "format-text-direction-ltr", "فیلد تاریخ": "x-office-calendar", "چک‌باکس": "object-select"}
        icon_name = icon_map.get(type_to_display, 'document-properties')
        self.icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(24, 24))

    def get_data_for_json(self):
        clean_properties = {k: v for k, v in self.properties.items() if v is not None and v != ''}
        return {'id': self.field_id, **clean_properties} 
    
    
class StartConditionDialog(QtWidgets.QDialog):
    """دیالوگ پیشرفته برای تعریف محرک‌های شروع یک فرآیند (رویداد سیستمی یا فرآیند دیگر)."""
    def __init__(self, db, current_conditions: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تنظیم قوانین شروع خودکار فرآیند")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(600)

        # --- کاتالوگ رویدادهای سیستمی ---
        self.SYSTEM_EVENTS = {
            'stock.level.below_minimum': "موجودی کالا به حد سفارش رسید",
            'stock.receipt.confirmed': "ورود کالا از تامین‌کننده تایید شد",
            'production.batch.completed': "تولید بچ محصول فله تکمیل شد",
            'qc.inspection.passed': "نتیجه کنترل کیفیت ورودی 'موفق' بود",
            'qc.inspection.failed': "نتیجه کنترل کیفیت ورودی 'ناموفق' بود",
        }

        layout = QtWidgets.QVBoxLayout(self)
        
        self.trigger_type_combo = QtWidgets.QComboBox()
        self.trigger_type_combo.addItems(["این فرآیند به صورت خودکار شروع نمی‌شود", "وقتی یک رویداد سیستمی رخ می‌دهد", "وقتی یک فرآیند دیگر به نتیجه می‌رسد"])
        layout.addWidget(self.trigger_type_combo)

        self.stack = QtWidgets.QStackedWidget()
        layout.addWidget(self.stack)

        # پنل خالی
        self.stack.addWidget(QtWidgets.QWidget())

        # پنل رویدادهای سیستمی
        event_panel = QtWidgets.QWidget(); event_layout = QtWidgets.QFormLayout(event_panel)
        self.system_event_combo = QtWidgets.QComboBox()
        for code, desc in self.SYSTEM_EVENTS.items():
            self.system_event_combo.addItem(desc, code)
        event_layout.addRow("نام رویداد:", self.system_event_combo)
        self.stack.addWidget(event_panel)

        # پنل فرآیندهای دیگر
        process_panel = QtWidgets.QWidget(); process_layout = QtWidgets.QFormLayout(process_panel)
        self.parent_process_combo = QtWidgets.QComboBox()
        self.process_outcome_combo = QtWidgets.QComboBox()
        self.process_outcome_combo.addItems(["با موفقیت تمام شود", "رد (ناموفق) شود"])
        process_layout.addRow("فرآیند والد:", self.parent_process_combo)
        process_layout.addRow("اگر آن فرآیند:", self.process_outcome_combo)
        self.stack.addWidget(process_panel)
        
        active_workflows = self.db.get_active_workflows()
        for wf in active_workflows:
            self.parent_process_combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])

        self.trigger_type_combo.currentIndexChanged.connect(self.stack.setCurrentIndex)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        if current_conditions:
            self._load_existing_conditions(current_conditions)

    def _load_existing_conditions(self, conditions):
        cond_type = conditions.get('type')
        if cond_type == 'system_event':
            self.trigger_type_combo.setCurrentIndex(1)
            index = self.system_event_combo.findData(conditions.get('event_code'))
            if index != -1: self.system_event_combo.setCurrentIndex(index)
        elif cond_type == 'process_outcome':
            self.trigger_type_combo.setCurrentIndex(2)
            index = self.parent_process_combo.findData(conditions.get('parent_process_id'))
            if index != -1: self.parent_process_combo.setCurrentIndex(index)
            self.process_outcome_combo.setCurrentIndex(1 if conditions.get('outcome') == 'REJECTED' else 0)
        else:
            self.trigger_type_combo.setCurrentIndex(0)

    def get_data(self):
        idx = self.trigger_type_combo.currentIndex()
        if idx == 0:
            return None
        elif idx == 1:
            return {
                "type": "system_event",
                "event_code": self.system_event_combo.currentData()
            }
        elif idx == 2:
            return {
                "type": "process_outcome",
                "parent_process_id": self.parent_process_combo.currentData(),
                "outcome": "COMPLETED" if self.process_outcome_combo.currentIndex() == 0 else "REJECTED"
            }
        return None   

# کلاس ConditionalLogicDialog را به طور کامل با این نسخه نهایی جایگزین کنید
class ConditionalLogicDialog(QtWidgets.QDialog):
    """
    نسخه 2.2 (نهایی و کاملاً پویا):
    - رفع قطعی مشکل عدم تغییر لیست عملگرها بر اساس نوع فیلد.
    """
    def __init__(self, all_fields: list, current_field_id: str, existing_logic: dict, parent=None):
        super().__init__(parent)
        self.all_fields = all_fields
        self.setWindowTitle("تنظیم منطق شرطی نمایش")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(500)
        
        layout = QtWidgets.QFormLayout(self)
        layout.setSpacing(15)

        self.action_combo = QtWidgets.QComboBox()
        self.action_combo.addItems(["نمایش بده", "مخفی کن"])
        
        self.trigger_field_combo = QtWidgets.QComboBox()
        for field in self.all_fields:
            if field['id'] != current_field_id:
                self.trigger_field_combo.addItem(field['label'], field) # ذخیره کل دیکشنری به عنوان دیتا

        self.op_combo = QtWidgets.QComboBox()
        self.value_edit = QtWidgets.QLineEdit()

        layout.addRow("این فیلد را:", self.action_combo)
        layout.addRow("اگر فیلد:", self.trigger_field_combo)
        layout.addRow("...شرط زیر را داشت:", self.op_combo)
        self.value_label_widget = layout.labelForField(self.op_combo) # گرفتن لیبل برای مخفی‌سازی
        layout.addRow("مقدار:", self.value_edit)
        
        # --- **اتصال سیگنال کلیدی** ---
        self.trigger_field_combo.currentIndexChanged.connect(self._update_operators)
        
        if existing_logic:
            self._load_existing_logic(existing_logic)
        else:
            self._update_operators()

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def _update_operators(self):
        """عملگرها را بر اساس نوع فیلد انتخاب شده، به‌روز می‌کند."""
        # --- **اصلاح کلیدی: استفاده از itemData برای بازیابی صحیح دیکشنری** ---
        current_index = self.trigger_field_combo.currentIndex()
        if current_index < 0:
            self.op_combo.clear()
            return
        
        selected_data = self.trigger_field_combo.itemData(current_index)
        if not isinstance(selected_data, dict):
            self.op_combo.clear()
            return

        field_type = selected_data.get('type')
        self.op_combo.clear()
        
        operators = {
            'text': ['برابر با', 'مخالف با', 'شامل', 'خالی باشد', 'خالی نباشد'],
            'number': ['برابر با', 'مخالف با', 'بزرگتر از', 'کوچکتر از', 'خالی باشد', 'خالی نباشد'],
            'date': ['برابر با', 'قبل از', 'بعد از', 'خالی باشد', 'خالی نباشد'],
            'checkbox': ['تیک خورده باشد', 'تیک نخورده باشد']
        }
        
        self.op_combo.addItems(operators.get(field_type, ['برابر با', 'مخالف با']))
        
        is_checkbox = (field_type == 'checkbox') or "خالی" in self.op_combo.currentText()
        self.value_edit.setVisible(not is_checkbox)
        self.layout().labelForField(self.value_edit).setVisible(not is_checkbox)

    def _load_existing_logic(self, logic):
        self.action_combo.setCurrentText(logic.get('action', 'نمایش بده'))
        trigger_id = logic.get('trigger_field_id')
        if trigger_id:
            for i in range(self.trigger_field_combo.count()):
                item_data = self.trigger_field_combo.itemData(i)
                if isinstance(item_data, dict) and item_data.get('id') == trigger_id:
                    self.trigger_field_combo.setCurrentIndex(i)
                    break
        
        self._update_operators()
        self.op_combo.setCurrentText(logic.get('operator', ''))
        self.value_edit.setText(logic.get('value', ''))

    def get_data(self):
        current_index = self.trigger_field_combo.currentIndex()
        if current_index < 0: return None
        trigger_data = self.trigger_field_combo.itemData(current_index)

        value = self.value_edit.text().strip()
        op = self.op_combo.currentText()
        
        if trigger_data.get('type') != 'checkbox' and not value and "خالی" not in op:
            return None

        return {
            "action": self.action_combo.currentText(),
            "trigger_field_id": trigger_data['id'],
            "trigger_field_type": trigger_data['type'],
            "operator": op,
            "value": value
        }
        
    def __init__(self, db: DB, current_conditions: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("تنظیم قوانین شروع خودکار فرآیند")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumWidth(600)

        # --- کاتالوگ رویدادهای سیستمی ---
        self.SYSTEM_EVENTS = {
            'stock.level.below_minimum': "موجودی کالا به حد سفارش رسید",
            'stock.receipt.confirmed': "ورود کالا از تامین‌کننده تایید شد",
            'production.batch.completed': "تولید بچ محصول فله تکمیل شد",
            'qc.inspection.passed': "نتیجه کنترل کیفیت ورودی 'موفق' بود",
            'qc.inspection.failed': "نتیجه کنترل کیفیت ورودی 'ناموفق' بود",
        }

        layout = QtWidgets.QVBoxLayout(self)
        
        self.trigger_type_combo = QtWidgets.QComboBox()
        self.trigger_type_combo.addItems(["این فرآیند به صورت خودکار شروع نمی‌شود", "وقتی یک رویداد سیستمی رخ می‌دهد", "وقتی یک فرآیند دیگر به نتیجه می‌رسد"])
        layout.addWidget(self.trigger_type_combo)

        self.stack = QtWidgets.QStackedWidget()
        layout.addWidget(self.stack)

        # پنل خالی
        self.stack.addWidget(QtWidgets.QWidget())

        # پنل رویدادهای سیستمی
        event_panel = QtWidgets.QWidget(); event_layout = QtWidgets.QFormLayout(event_panel)
        self.system_event_combo = QtWidgets.QComboBox()
        for code, desc in self.SYSTEM_EVENTS.items():
            self.system_event_combo.addItem(desc, code)
        event_layout.addRow("نام رویداد:", self.system_event_combo)
        self.stack.addWidget(event_panel)

        # پنل فرآیندهای دیگر
        process_panel = QtWidgets.QWidget(); process_layout = QtWidgets.QFormLayout(process_panel)
        self.parent_process_combo = QtWidgets.QComboBox()
        self.process_outcome_combo = QtWidgets.QComboBox()
        self.process_outcome_combo.addItems(["با موفقیت تمام شود", "رد (ناموفق) شود"])
        process_layout.addRow("فرآیند والد:", self.parent_process_combo)
        process_layout.addRow("اگر آن فرآیند:", self.process_outcome_combo)
        self.stack.addWidget(process_panel)
        
        # --- *** اصلاح کلیدی اینجاست: استفاده از تابع جدید و فیلتر شده *** ---
        active_workflows = self.db.get_active_workflows()
        for wf in active_workflows:
            self.parent_process_combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])

        self.trigger_type_combo.currentIndexChanged.connect(self.stack.setCurrentIndex)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        # بارگذاری تنظیمات فعلی
        if current_conditions:
            self._load_existing_conditions(current_conditions)
            
    def _load_existing_conditions(self, conditions):
        cond_type = conditions.get('type')
        if cond_type == 'system_event':
            self.trigger_type_combo.setCurrentIndex(1)
            index = self.system_event_combo.findData(conditions.get('event_code'))
            if index != -1: self.system_event_combo.setCurrentIndex(index)
        elif cond_type == 'process_outcome':
            self.trigger_type_combo.setCurrentIndex(2)
            index = self.parent_process_combo.findData(conditions.get('parent_process_id'))
            if index != -1: self.parent_process_combo.setCurrentIndex(index)
            self.process_outcome_combo.setCurrentIndex(1 if conditions.get('outcome') == 'REJECTED' else 0)
        else:
            self.trigger_type_combo.setCurrentIndex(0)

    def get_data(self):
        idx = self.trigger_type_combo.currentIndex()
        if idx == 0:
            return None # اگر شروع خودکار ندارد، قانون را null ذخیره می‌کنیم
        elif idx == 1:
            return {
                "type": "system_event",
                "event_code": self.system_event_combo.currentData()
            }
        elif idx == 2:
            return {
                "type": "process_outcome",
                "parent_process_id": self.parent_process_combo.currentData(),
                "outcome": "COMPLETED" if self.process_outcome_combo.currentIndex() == 0 else "REJECTED"
            }
        return None
    
# این کلاس کاملاً جدید را به فایل خود اضافه کنید (قبل از MainWindow)

class ProcessHistoryDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش تاریخچه کامل و مراحل طی شده یک فرآیند."""
    def __init__(self, db: DB, process_instance_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.process_instance_id = process_instance_id
        
        self.setWindowTitle(f"تاریخچه فرآیند شماره {process_instance_id}")
        self.setMinimumSize(700, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        self.table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(self.table)
            
        layout.addWidget(self.table)
        self._load_history()

    def _load_history(self):
        history = self.db.get_process_instance_history(self.process_instance_id)
        
        headers = ["مرحله", "اقدام", "کاربر", "تاریخ و ساعت", "توضیحات/دلیل"]
        self.table.setColumnCount(len(headers))
        self.table.setHorizontalHeaderLabels(headers)
        self.table.setRowCount(len(history))
        
        for r, entry in enumerate(history):
            outcome_map = {"APPROVED": "تایید شد", "REJECTED": "رد شد"}
            outcome_text = outcome_map.get(entry.get('outcome'), entry.get('outcome'))
            
            self.table.setItem(r, 0, QtWidgets.QTableWidgetItem(entry.get('step_name')))
            self.table.setItem(r, 1, QtWidgets.QTableWidgetItem(outcome_text))
            self.table.setItem(r, 2, QtWidgets.QTableWidgetItem(entry.get('actor_username')))
            self.table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(entry.get('timestamp'))))
            self.table.setItem(r, 4, QtWidgets.QTableWidgetItem(entry.get('reason')))

        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.Stretch)
        
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید

class TaskDetailWidget(QtWidgets.QWidget):
    """پنل هوشمند برای نمایش جزئیات و انجام اقدام روی یک وظیفه انتخاب شده."""
    task_acted_on = QtCore.pyqtSignal()

    def __init__(self, db: DB, user_id: int, parent_window):
        super().__init__()
        self.db = db
        self.user_id = user_id
        self.parent_window = parent_window
        self.current_task_data = None

        self.main_layout = QtWidgets.QVBoxLayout(self)
        self.main_layout.setContentsMargins(0,0,0,0)
        
        self.stack = QtWidgets.QStackedWidget()
        
        self.placeholder_widget = QtWidgets.QLabel("برای مشاهده جزئیات و انجام اقدام،\nیک وظیفه را از لیست انتخاب کنید.")
        self.placeholder_widget.setAlignment(Qt.AlignCenter)
        self.placeholder_widget.setStyleSheet("color: #7f8c8d; font-size: 12pt;")
        
        self.details_container = QtWidgets.QWidget()
        container_layout = QtWidgets.QVBoxLayout(self.details_container)
        
        self.details_group = QtWidgets.QGroupBox("جزئیات وظیفه")
        # --- *** اصلاح ۱: استفاده از QVBoxLayout برای انعطاف‌پذیری بیشتر *** ---
        self.details_group_layout = QtWidgets.QVBoxLayout(self.details_group)
        self.details_form_layout = QtWidgets.QFormLayout() # فرم برای اطلاعات اصلی
        self.steps_list_widget = QtWidgets.QListWidget() # لیست برای نمایش مراحل
        self.steps_list_widget.setStyleSheet("border: 1px solid #dfe4ea; background-color: #f8f9fa;")

        self.details_group_layout.addLayout(self.details_form_layout)
        self.details_group_layout.addWidget(QtWidgets.QLabel("<b>مراحل فرآیند:</b>"))
        self.details_group_layout.addWidget(self.steps_list_widget)
        
        container_layout.addWidget(self.details_group, 1)

        self.actions_group = QtWidgets.QGroupBox("اقدام")
        self.actions_layout = QtWidgets.QHBoxLayout(self.actions_group)
        container_layout.addWidget(self.actions_group, 0)

        self.stack.addWidget(self.placeholder_widget)
        self.stack.addWidget(self.details_container)
        self.main_layout.addWidget(self.stack)

    def update_with_task(self, task_data):
        """این متد پنل را با اطلاعات یک وظیفه جدید پر می‌کند."""
        self.current_task_data = task_data
        self._clear_panel()

        if not task_data:
            self.stack.setCurrentWidget(self.placeholder_widget)
            return

        self.details_group.setTitle(f"وظیفه: {task_data['workflow_name']} / مرحله: {task_data['step_name']}")
        
        tasks_widget_instance = self.parent().findChild(TasksWidget)
        details_text = tasks_widget_instance._generate_details_from_context(task_data) if tasks_widget_instance else ""
            
        self.details_form_layout.addRow("شرح:", QtWidgets.QLabel(f"<b>{details_text}</b>"))
        self.details_form_layout.addRow("تاریخ ایجاد:", QtWidgets.QLabel(to_shamsi(task_data['started_at'])))

        if task_data.get('workflow_approval_id'):
            # --- *** اصلاح ۲: بارگذاری و نمایش مراحل فرآیند *** ---
            workflow_id = task_data['workflow_approval_id']
            steps = self.db.get_workflow_steps(workflow_id)
            for step in steps:
                approver_text = step.get('role_name', step.get('approver_type', ''))
                list_item = QtWidgets.QListWidgetItem(f"{step['step_order']}. {step['step_name']} (تایید کننده: {approver_text})")
                self.steps_list_widget.addItem(list_item)
            # --- ****************************************** ---

            btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "تایید و ابلاغ فرآیند")
            btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), "رد کردن و بازگرداندن")
            btn_approve.setProperty("class", "primary"); btn_reject.setProperty("class", "danger")
            btn_approve.clicked.connect(lambda: self._handle_ceo_approval(True))
            btn_reject.clicked.connect(lambda: self._handle_ceo_approval(False))
            self.actions_layout.addStretch()
            self.actions_layout.addWidget(btn_reject)
            self.actions_layout.addWidget(btn_approve)
        
        self.stack.setCurrentWidget(self.details_container)
        
    def _clear_panel(self):
        """محتویات پنل را برای بارگذاری داده جدید پاک می‌کند."""
        while self.details_form_layout.count():
            self.details_form_layout.removeRow(0)
        while self.actions_layout.count():
            child = self.actions_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        # --- *** اصلاح ۳: پاک کردن لیست مراحل *** ---
        self.steps_list_widget.clear()
            
    def _handle_ceo_approval(self, is_approved):
        """منطق تایید یا رد یک فرآیند توسط مدیرعامل."""
        workflow_id = self.current_task_data.get('workflow_approval_id')
        if not workflow_id: return

        reason = ""
        if not is_approved:
            reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد فرآیند", "لطفاً دلیل بازگرداندن این فرآیند به واحد QA را ذکر کنید:")
            if not ok or not reason.strip():
                self.parent_window.toast.show_message("عملیات لغو شد.", "info")
                return
        
        try:
            if is_approved:
                self.db.approve_workflow(workflow_id, self.user_id)
                self.parent_window.toast.show_message("✔ فرآیند با موفقیت تایید و در سیستم فعال شد.", "success")
            else:
                self.db.reject_workflow(workflow_id, self.user_id, reason)
                self.parent_window.toast.show_message("فرآیند به واحد QA بازگردانده شد.", "info")
            
            self.task_acted_on.emit()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"عملیات با خطا مواجه شد:\n{e}")
            
# این کلاس را به طور کامل با نسخه جدید جایگزین کنید
class ProcessCategoryManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت دسته‌بندی‌های فرآیند (Process Categories)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_cat_id = None

        # --- دیکشنری نهایی و کامل‌تر کنترل‌گرهای سیستمی ---
        self.SYSTEM_HANDLERS = {
            "GENERIC": "عمومی / اداری",
            "PURCHASING": "خرید و تدارکات",
            "INVENTORY": "انبارداری",
            "PRODUCTION": "تولید",
            "QUALITY_CONTROL": "کنترل کیفیت",
            "SALES": "فروش",
            "ENGINEERING": "فنی و مهندسی", # <--- اضافه شد
            "MAINTENANCE": "نگهداری و تعمیرات", # <--- اضافه شد
            "IT": "فناوری اطلاعات", # <--- اضافه شد
            "HR": "منابع انسانی",
            "FINANCE": "مالی و حسابداری"
        }

        self.setWindowTitle("مدیریت دسته‌بندی فرآیندها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 450)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        
        list_panel = QtWidgets.QWidget(); list_layout = QtWidgets.QVBoxLayout(list_panel)
        self.tbl_cats = QtWidgets.QTableWidget(0, 4)
        self.tbl_cats.setHorizontalHeaderLabels(['ID', 'نام نمایشی', 'کلید سیستمی', 'نوع کنترل‌گر'])
        self.tbl_cats.setColumnHidden(0, True)
        self.tbl_cats.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tbl_cats.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_cats.itemClicked.connect(self._populate_fields_for_edit)
        list_layout.addWidget(self.tbl_cats)
        
        form_panel = QtWidgets.QWidget(); form_panel.setFixedWidth(280)
        form_layout = QtWidgets.QVBoxLayout(form_panel)
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش")
        self.form = QtWidgets.QFormLayout(form_group)
        self.name_edit = QtWidgets.QLineEdit()
        self.key_edit = QtWidgets.QLineEdit()
        self.key_edit.setToolTip("یک شناسه منحصر به فرد انگلیسی و بدون فاصله (مثال: ENGINEERING_CHANGE_REQUEST)")
        
        self.handler_combo = QtWidgets.QComboBox()
        for key, name in self.SYSTEM_HANDLERS.items():
            self.handler_combo.addItem(name, key)
            
        self.handler_combo.setToolTip("این گزینه مشخص می‌کند وظایف این نوع فرآیند در کدام میزکار تخصصی نمایش داده شوند.")

        self.form.addRow("نام نمایشی (*):", self.name_edit)
        self.form.addRow("کلید سیستمی (*):", self.key_edit)
        self.form.addRow("نوع کنترل‌گر (*):", self.handler_combo)
        form_layout.addWidget(form_group)

        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_del = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن")
        form_layout.addWidget(btn_save); form_layout.addWidget(btn_del); form_layout.addStretch(); form_layout.addWidget(btn_clear)
        
        main_layout.addWidget(list_panel, 1); main_layout.addWidget(form_panel)
        
        btn_save.clicked.connect(self._save); btn_del.clicked.connect(self._delete); btn_clear.clicked.connect(self._clear_fields)
        self._load_categories()

    def _load_categories(self):
        self.tbl_cats.setRowCount(0)
        cats = self.db.get_process_categories()
        self.tbl_cats.setRowCount(len(cats))
        for r, cat in enumerate(cats):
            self.tbl_cats.setItem(r, 0, QtWidgets.QTableWidgetItem(str(cat['id'])))
            self.tbl_cats.setItem(r, 1, QtWidgets.QTableWidgetItem(cat['display_name']))
            self.tbl_cats.setItem(r, 2, QtWidgets.QTableWidgetItem(cat['category_key']))
            handler_name = self.SYSTEM_HANDLERS.get(cat.get('handler_key'), cat.get('handler_key'))
            self.tbl_cats.setItem(r, 3, QtWidgets.QTableWidgetItem(handler_name))
    
    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.current_cat_id = int(self.tbl_cats.item(row, 0).text())
        self.name_edit.setText(self.tbl_cats.item(row, 1).text())
        self.key_edit.setText(self.tbl_cats.item(row, 2).text())
        self.key_edit.setReadOnly(True)
        
        cat_details = self.db.execute_query("SELECT handler_key FROM process_categories WHERE id = %s", (self.current_cat_id,), fetch_one=True)
        if cat_details:
            handler_key = cat_details.get('handler_key')
            index = self.handler_combo.findData(handler_key)
            if index != -1: self.handler_combo.setCurrentIndex(index)

    def _clear_fields(self):
        self.current_cat_id = None; self.tbl_cats.clearSelection(); self.name_edit.clear(); self.key_edit.clear()
        self.key_edit.setReadOnly(False); self.handler_combo.setCurrentIndex(0); self.name_edit.setFocus()

    def _save(self):
        name = self.name_edit.text().strip()
        key = self.key_edit.text().strip().upper()
        handler_key = self.handler_combo.currentData()
        if not name or not key or not handler_key:
            self.toast.show_message("تمام فیلدها اجباری هستند.", "warning"); return
        
        try:
            self.db.add_or_update_process_category(name, key, handler_key, self.current_cat_id)
            self.toast.show_message("✔ دسته‌بندی با موفقیت ذخیره شد.", "success")
            self._load_categories(); self._clear_fields()
        except psycopg2.errors.UniqueViolation:
            QtWidgets.QMessageBox.critical(self, "خطا", "این کلید سیستمی قبلاً استفاده شده است.")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
            
    def _delete(self):
        if self.current_cat_id is None:
            self.toast.show_message("لطفاً یک دسته‌بندی را برای حذف انتخاب کنید.", "warning"); return
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", "آیا از حذف این دسته‌بندی مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_process_category(self.current_cat_id)
                self.toast.show_message("✔ دسته‌بندی حذف شد.", "info")
                self._load_categories(); self._clear_fields()
            except ValueError as e:
                QtWidgets.QMessageBox.critical(self, "عملیات ناموفق", str(e))
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در حذف: {e}")
                
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ReceivePoDialog(QtWidgets.QDialog):
    """دیالوگی برای ثبت دریافت اقلام یک سفارش خرید در انبار (با قابلیت تصمیم‌گیری برای QC)."""
    def __init__(self, db: DB, po_data: dict, parent=None):
        super().__init__(parent)
        self.db = db
        self.po_data = po_data
        self.parent_window = parent
        self.setWindowTitle(f"ثبت رسید برای PO: {po_data.get('po_number')}")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)

        info_layout = QtWidgets.QFormLayout()
        info_layout.addRow("شماره سفارش:", QtWidgets.QLabel(f"<b>{po_data.get('po_number')}</b>"))
        info_layout.addRow("تامین‌کننده:", QtWidgets.QLabel(f"<b>{po_data.get('supplier_name')}</b>"))
        layout.addLayout(info_layout)

        self.items_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.items_table)
        layout.addWidget(self.items_table)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ثبت نهایی رسید")
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self._load_po_items()

    def _load_po_items(self):
        po_id = self.po_data.get('id')
        items = self.db.execute_query("""
            SELECT poi.id, i.id as item_id, i.name, i.requires_qc, poi.quantity as ordered_qty
            FROM purchase_order_items poi
            JOIN items i ON poi.item_id = i.id
            WHERE poi.purchase_order_id = %s
        """, (po_id,))

        headers = ["ID", "کالا", "مقدار سفارش", "مقدار دریافتی", "نیاز به QC؟", "شماره بچ", "تاریخ انقضا", "محل انبارش"]
        self.items_table.setColumnCount(len(headers)); self.items_table.setHorizontalHeaderLabels(headers)
        self.items_table.setRowCount(len(items)); self.items_table.setColumnHidden(0, True)

        all_locations = self.db.list_locations(exclude_warehouses=['Production'])

        for r, item in enumerate(items):
            self.items_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(item['id'])))
            self.items_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['name']))
            self.items_table.setItem(r, 2, NumericTableWidgetItem(str(item['ordered_qty'])))

            qty_edit = QtWidgets.QLineEdit(str(item['ordered_qty'])); qty_edit.setValidator(QtGui.QDoubleValidator(0, item['ordered_qty'], 3)); self.items_table.setCellWidget(r, 3, qty_edit)

            qc_check_widget = QtWidgets.QWidget(); chk_layout = QtWidgets.QHBoxLayout(qc_check_widget)
            chk_box = QtWidgets.QCheckBox(); chk_box.setChecked(item.get('requires_qc', True)); chk_layout.addWidget(chk_box); chk_layout.setAlignment(QtCore.Qt.AlignCenter)
            self.items_table.setCellWidget(r, 4, qc_check_widget)

            batch_edit = QtWidgets.QLineEdit(f"PO-{self.po_data.get('po_number')}-{r+1}"); self.items_table.setCellWidget(r, 5, batch_edit)
            expiry_edit = QtWidgets.QLineEdit(); expiry_edit.setInputMask("0000/00/00;_"); self.items_table.setCellWidget(r, 6, expiry_edit)
            loc_combo = QtWidgets.QComboBox()
            for loc in all_locations: loc_combo.addItem(loc['loc_label'], loc['id'])
            self.items_table.setCellWidget(r, 7, loc_combo)

        self.items_table.resizeColumnsToContents()
        self.items_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def get_received_data(self):
        received_items = []
        for r in range(self.items_table.rowCount()):
            try:
                qty_received = float(self.items_table.cellWidget(r, 3).text())
                if qty_received > 0:
                    expiry_date_str = self.items_table.cellWidget(r, 6).text()
                    expiry_date = shamsi_to_gregorian(expiry_date_str)

                    received_items.append({
                        "po_item_id": int(self.items_table.item(r, 0).text()),
                        "item_id": self.db.execute_query("SELECT item_id FROM purchase_order_items WHERE id = %s", (int(self.items_table.item(r, 0).text()),), fetch_one=True)['item_id'],
                        "qty": qty_received,
                        "requires_qc": self.items_table.cellWidget(r, 4).findChild(QtWidgets.QCheckBox).isChecked(),
                        "batch_no": self.items_table.cellWidget(r, 5).text().strip(),
                        "expiry_date": expiry_date,
                        "location_id": self.items_table.cellWidget(r, 7).currentData()
                    })
            except (ValueError, TypeError, AttributeError): continue
        return received_items
        
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class SelectPoDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب یک سفارش خرید باز."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("انتخاب سفارش خرید برای ثبت رسید")
        self.setMinimumSize(700, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("لطفاً سفارش خریدی که کالای آن را تحویل گرفته‌اید، از لیست زیر انتخاب کنید:"))
        
        self.table = QtWidgets.QTableWidget()
        parent._style_table(self.table)
        layout.addWidget(self.table)
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("ادامه")
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self._load_open_pos()

    def _load_open_pos(self):
        orders = self.db.execute_query("SELECT po.*, s.name as supplier_name FROM purchase_orders po JOIN suppliers s ON po.supplier_id = s.id WHERE po.status = 'تایید شده' ORDER BY po.id DESC")
        
        headers = ["ID", "شماره PO", "تامین‌کننده", "تاریخ صدور"]
        self.table.setColumnCount(len(headers)); self.table.setHorizontalHeaderLabels(headers)
        self.table.setRowCount(len(orders))

        for r, order in enumerate(orders):
            self.table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
            self.table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['po_number']))
            self.table.setItem(r, 2, QtWidgets.QTableWidgetItem(order['supplier_name']))
            self.table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(order['issue_date'])))

        self.table.setColumnHidden(0, True)
        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(self.table, "هیچ سفارش خرید بازی برای دریافت کالا وجود ندارد.")

    def get_selected_po_id(self):
        selected = self.table.selectedItems()
        if not selected:
            return None
        return int(self.table.item(selected[0].row(), 0).text())
    
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class IncomingQCWidget(QtWidgets.QWidget):
    """ویجت میزکار واحد کنترل کیفیت برای بازرسی کالاهای ورودی در قرنطینه (با رفرش خودکار)."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.toast = getattr(parent, 'toast', None)
        self.parent_window = parent

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        # نوار ابزار بالا حذف شد چون دکمه رفرش دیگر لازم نیست
        
        self.tbl_quarantine = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_quarantine)
        layout.addWidget(self.tbl_quarantine, 1)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), " رد کیفی")
        btn_reject.setProperty("class", "danger")
        btn_approve = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), " تایید کیفی")
        btn_approve.setProperty("class", "primary")
        
        btn_layout.addStretch()
        btn_layout.addWidget(btn_reject)
        btn_layout.addWidget(btn_approve)
        layout.addLayout(btn_layout)

        # --- بخش جدید: تعریف و تنظیم تایمر برای رفرش خودکار ---
        self.refresh_timer = QtCore.QTimer(self)
        self.refresh_timer.setInterval(60000) # هر ۶۰ ثانیه
        self.refresh_timer.timeout.connect(self.refresh_data)
        # ---------------------------------------------------------

        btn_approve.clicked.connect(self._approve_selected)
        btn_reject.clicked.connect(self._reject_selected)

        self.refresh_data() # اولین اجرا به صورت دستی

    def showEvent(self, event):
        """وقتی ویجت نمایش داده می‌شود، تایمر را فعال می‌کند."""
        super().showEvent(event)
        self.refresh_timer.start()
        print("INFO: QC Widget became visible. Auto-refresh timer started.")

    def hideEvent(self, event):
        """وقتی ویجت مخفی می‌شود، تایمر را متوقف می‌کند تا منابع مصرف نشود."""
        super().hideEvent(event)
        self.refresh_timer.stop()
        print("INFO: QC Widget hidden. Auto-refresh timer stopped.")

    def refresh_data(self):
        """لیست اقلام در قرنطینه را از دیتابیس خوانده و در جدول نمایش می‌دهد."""
        try:
            # برای جلوگیری از پرش ناگهانی هنگام رفرش، آیتم انتخاب شده فعلی را ذخیره می‌کنیم
            current_selected_id = self._get_selected_stock_id(silent=True)

            items = self.db.get_quarantined_stock()
            self.tbl_quarantine.setSortingEnabled(False) # برای عملکرد بهتر حین آپدیت
            self.tbl_quarantine.setRowCount(0)
            headers = ['ID موجودی', 'نام کالا', 'شماره بچ', 'تامین‌کننده', 'مقدار', 'واحد', 'محل در انبار', 'تاریخ انقضا']
            self.tbl_quarantine.setColumnCount(len(headers))
            self.tbl_quarantine.setHorizontalHeaderLabels(headers)
            self.tbl_quarantine.setRowCount(len(items))

            new_row_to_select = -1
            for r, item in enumerate(items):
                stock_id = item['stock_id']
                if stock_id == current_selected_id:
                    new_row_to_select = r
                
                self.tbl_quarantine.setItem(r, 0, QtWidgets.QTableWidgetItem(str(stock_id)))
                self.tbl_quarantine.setItem(r, 1, QtWidgets.QTableWidgetItem(item['item_name']))
                self.tbl_quarantine.setItem(r, 2, QtWidgets.QTableWidgetItem(item['batch_no']))
                self.tbl_quarantine.setItem(r, 3, QtWidgets.QTableWidgetItem(item.get('supplier_name', '---')))
                self.tbl_quarantine.setItem(r, 4, NumericTableWidgetItem(str(item['qty'])))
                self.tbl_quarantine.setItem(r, 5, QtWidgets.QTableWidgetItem(item.get('unit', '')))
                self.tbl_quarantine.setItem(r, 6, QtWidgets.QTableWidgetItem(item['location_label']))
                self.tbl_quarantine.setItem(r, 7, QtWidgets.QTableWidgetItem(to_shamsi(item.get('expiry_date'))))
            
            self.tbl_quarantine.setColumnHidden(0, True)
            self.tbl_quarantine.resizeColumnsToContents()
            self.tbl_quarantine.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            self.tbl_quarantine.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_quarantine, "هیچ کالایی در حال حاضر در قرنطینه نیست.")
            
            # انتخاب قبلی کاربر را بازیابی می‌کنیم
            if new_row_to_select != -1:
                self.tbl_quarantine.selectRow(new_row_to_select)

            self.tbl_quarantine.setSortingEnabled(True)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست قرنطینه: {e}", "critical")

    def _get_selected_stock_id(self, silent=False):
        """ID ردیف انتخاب شده در جدول را برمی‌گرداند."""
        selected_rows = self.tbl_quarantine.selectionModel().selectedRows()
        if not selected_rows:
            if not silent and self.toast:
                self.toast.show_message("لطفاً ابتدا یک ردیف را از جدول انتخاب کنید.", "warning")
            return None
        try:
            return int(self.tbl_quarantine.item(selected_rows[0].row(), 0).text())
        except (AttributeError, ValueError):
            return None

    def _approve_selected(self):
        """کالای انتخاب شده را تایید کیفی می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        stock_details = self.db.get_stock_details_by_id(stock_id)
        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی", 
            f"آیا از تایید کیفی کالای «{stock_details.get('item_name')}» با بچ نامبر «{stock_details.get('batch_no')}» مطمئن هستید؟\n"
            "این کالا پس از تایید، به موجودی قابل مصرف انبار اضافه خواهد شد.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
        
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.update_stock_status(stock_id, 'موجود', self.user_id, "تایید شده توسط واحد کنترل کیفیت.")
                if self.toast: self.toast.show_message("✔ کالا با موفقیت تایید و به موجودی اصلی اضافه شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))

    def _reject_selected(self):
        """کالای انتخاب شده را رد کیفی می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کیفی", "لطفاً دلیل رد کردن این کالا را به طور کامل وارد کنید:")
        if ok and reason.strip():
            try:
                self.db.update_stock_status(stock_id, 'رد شده', self.user_id, f"رد کیفی: {reason.strip()}")
                if self.toast: self.toast.show_message("✖ کالا رد کیفی شد و به موجودی 'رد شده' منتقل گردید.", "info")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
        elif ok:
            self.toast.show_message("عملیات لغو شد. دلیل رد کیفی باید وارد شود.", "warning")
            
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class QCHistoryWidget(QtWidgets.QWidget):
    """ویجت بایگانی و جستجوی گزارش‌های کنترل کیفیت."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        # بخش فیلتر و جستجو
        filter_group = QtWidgets.QGroupBox("جستجو در گزارش‌ها")
        filter_layout = QtWidgets.QHBoxLayout(filter_group)
        self.product_search = QtWidgets.QLineEdit(placeholderText="بخشی از نام محصول...")
        self.batch_search = QtWidgets.QLineEdit(placeholderText="بخشی از شماره بچ...")
        btn_search = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), " جستجو")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), " پاک کردن فیلتر")

        filter_layout.addWidget(QtWidgets.QLabel("نام محصول:"))
        filter_layout.addWidget(self.product_search)
        filter_layout.addWidget(QtWidgets.QLabel("شماره بچ:"))
        filter_layout.addWidget(self.batch_search)
        filter_layout.addStretch()
        filter_layout.addWidget(btn_search)
        filter_layout.addWidget(btn_clear)
        layout.addWidget(filter_group)

        # جدول نتایج
        self.tbl_history = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_history)
        self.tbl_history.itemDoubleClicked.connect(self._show_form_details)
        layout.addWidget(self.tbl_history, 1)

        btn_search.clicked.connect(self.search_records)
        btn_clear.clicked.connect(self._clear_search)

        self.search_records() # بارگذاری اولیه

    def search_records(self):
        """جستجو را اجرا کرده و نتایج را در جدول نمایش می‌دهد."""
        product_name = self.product_search.text().strip()
        batch_no = self.batch_search.text().strip()
        
        try:
            records = self.db.search_qc_form_entries(product_name, batch_no)
            self.tbl_history.setRowCount(0)
            
            # استخراج تمام کلیدهای ممکن از داده‌های JSON برای ساخت هدرهای داینامیک
            all_keys = set()
            for rec in records:
                if isinstance(rec['data'], dict):
                    all_keys.update(rec['data'].keys())
            
            static_headers = ['ID', 'تاریخ ثبت', 'ثبت توسط']
            dynamic_headers = sorted(list(all_keys))
            headers = static_headers + dynamic_headers

            self.tbl_history.setColumnCount(len(headers))
            self.tbl_history.setHorizontalHeaderLabels(headers)
            self.tbl_history.setRowCount(len(records))

            for r, rec in enumerate(records):
                self.tbl_history.setItem(r, 0, QtWidgets.QTableWidgetItem(str(rec['id'])))
                self.tbl_history.setItem(r, 1, QtWidgets.QTableWidgetItem(to_shamsi(rec['submission_date'])))
                self.tbl_history.setItem(r, 2, QtWidgets.QTableWidgetItem(rec['submitted_by']))
                
                data = rec.get('data', {})
                for c, key in enumerate(dynamic_headers):
                    value = data.get(key, '')
                    self.tbl_history.setItem(r, 3 + c, QtWidgets.QTableWidgetItem(str(value)))
            
            self.tbl_history.setColumnHidden(0, True)
            self.tbl_history.resizeColumnsToContents()
            set_empty_placeholder(self.tbl_history, "هیچ گزارش کنترل کیفی با این مشخصات یافت نشد.")

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در جستجو: {e}", "critical")

    def _clear_search(self):
        self.product_search.clear()
        self.batch_search.clear()
        self.search_records()

    def _show_form_details(self, item):
        """یک دیالوگ برای نمایش کامل اطلاعات فرم انتخاب شده باز می‌کند."""
        # این بخش در آینده می‌تواند یک دیالوگ زیباتر برای نمایش فرم باشد
        # فعلا جزئیات را در یک QMessageBox نمایش می‌دهیم
        row = item.row()
        details = []
        for col in range(self.tbl_history.columnCount()):
            header = self.tbl_history.horizontalHeaderItem(col).text()
            cell_item = self.tbl_history.item(row, col)
            value = cell_item.text() if cell_item else ""
            if header != 'ID':
                details.append(f"<b>{header}:</b> {value}")
        
        QtWidgets.QMessageBox.information(self, "جزئیات کامل گزارش", "<br>".join(details))
        
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class NonConformingWidget(QtWidgets.QWidget):
    """ویجت مدیریت اقلام نامنطبق (با رفرش خودکار)."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        self.tbl_rejected = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_rejected)
        layout.addWidget(self.tbl_rejected, 1)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_scrap = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " ثبت به عنوان ضایعات")
        btn_return = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " مرجوع به تامین‌کننده")
        btn_return.setProperty("class", "primary")
        
        btn_layout.addStretch()
        btn_layout.addWidget(btn_scrap)
        btn_layout.addWidget(btn_return)
        layout.addLayout(btn_layout)

        # --- بخش جدید: تعریف و تنظیم تایمر برای رفرش خودکار ---
        self.refresh_timer = QtCore.QTimer(self)
        self.refresh_timer.setInterval(60000) # هر ۶۰ ثانیه
        self.refresh_timer.timeout.connect(self.refresh_data)
        # ---------------------------------------------------------

        btn_return.clicked.connect(self._return_to_supplier)
        btn_scrap.clicked.connect(self._scrap_item)

        self.refresh_data() # اولین اجرا به صورت دستی

    def showEvent(self, event):
        """وقتی ویجت نمایش داده می‌شود، تایمر را فعال می‌کند."""
        super().showEvent(event)
        self.refresh_timer.start()
        print("INFO: Non-Conforming Widget became visible. Auto-refresh timer started.")

    def hideEvent(self, event):
        """وقتی ویجت مخفی می‌شود، تایمر را متوقف می‌کند."""
        super().hideEvent(event)
        self.refresh_timer.stop()
        print("INFO: Non-Conforming Widget hidden. Auto-refresh timer stopped.")

    def refresh_data(self):
        """لیست اقلام رد کیفی شده را از دیتابیس خوانده و در جدول نمایش می‌دهد."""
        try:
            current_selected_id = self._get_selected_stock_id(silent=True)

            items = self.db.get_rejected_stock()
            self.tbl_rejected.setSortingEnabled(False)
            self.tbl_rejected.setRowCount(0)
            headers = ['ID موجودی', 'نام کالا', 'شماره بچ', 'مقدار', 'واحد', 'محل در انبار']
            self.tbl_rejected.setColumnCount(len(headers))
            self.tbl_rejected.setHorizontalHeaderLabels(headers)
            self.tbl_rejected.setRowCount(len(items))

            new_row_to_select = -1
            for r, item in enumerate(items):
                stock_id = item['stock_id']
                if stock_id == current_selected_id:
                    new_row_to_select = r

                self.tbl_rejected.setItem(r, 0, QtWidgets.QTableWidgetItem(str(stock_id)))
                self.tbl_rejected.setItem(r, 1, QtWidgets.QTableWidgetItem(item['item_name']))
                self.tbl_rejected.setItem(r, 2, QtWidgets.QTableWidgetItem(item['batch_no']))
                self.tbl_rejected.setItem(r, 3, NumericTableWidgetItem(str(item['qty'])))
                self.tbl_rejected.setItem(r, 4, QtWidgets.QTableWidgetItem(item.get('unit', '')))
                self.tbl_rejected.setItem(r, 5, QtWidgets.QTableWidgetItem(item['location_label']))
            
            self.tbl_rejected.setColumnHidden(0, True)
            self.tbl_rejected.resizeColumnsToContents()
            self.tbl_rejected.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_rejected, "هیچ کالای رد کیفی شده‌ای برای تعیین تکلیف وجود ندارد.")

            if new_row_to_select != -1:
                self.tbl_rejected.selectRow(new_row_to_select)

            self.tbl_rejected.setSortingEnabled(True)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری لیست اقلام مردود: {e}", "critical")

    def _get_selected_stock_id(self, silent=False):
        """ID ردیف انتخاب شده در جدول را برمی‌گرداند."""
        selected_rows = self.tbl_rejected.selectionModel().selectedRows()
        if not selected_rows:
            if not silent and self.toast:
                self.toast.show_message("لطفاً ابتدا یک ردیف را از جدول انتخاب کنید.", "warning")
            return None
        try:
            return int(self.tbl_rejected.item(selected_rows[0].row(), 0).text())
        except (AttributeError, ValueError):
            return None

    def _return_to_supplier(self):
        """فرآیند تعیین تکلیف یک کالا به عنوان 'مرجوعی' را اجرا می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        notes, ok = QtWidgets.QInputDialog.getText(self, "مرجوع به تامین‌کننده", "توضیحات یا شماره سند مرجوعی را وارد کنید:")
        if ok and notes.strip():
            try:
                self.db.resolve_rejected_stock(stock_id, 'مرجوع به تامین‌کننده', self.user_id, notes)
                if self.toast: self.toast.show_message("✔ کالا با موفقیت به عنوان 'مرجوعی' ثبت و از موجودی خارج شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
        elif ok:
            if self.toast: self.toast.show_message("عملیات لغو شد. وارد کردن توضیحات الزامی است.", "warning")

    def _scrap_item(self):
        """فرآیند تعیین تکلیف یک کالا به عنوان 'ضایعات' را اجرا می‌کند."""
        stock_id = self._get_selected_stock_id()
        if stock_id is None: return

        notes, ok = QtWidgets.QInputDialog.getText(self, "ثبت به عنوان ضایعات", "دلیل ضایعات شدن کالا را وارد کنید:")
        if ok and notes.strip():
            try:
                self.db.resolve_rejected_stock(stock_id, 'ضایعات', self.user_id, notes)
                if self.toast: self.toast.show_message("✔ کالا با موفقیت به عنوان 'ضایعات' ثبت و از موجودی خارج شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))
        elif ok:
            if self.toast: self.toast.show_message("عملیات لغو شد. وارد کردن دلیل الزامی است.", "warning")
            
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
class CustomerManagerDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت کامل مشتریان."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_customer_id = None

        self.setWindowTitle("مدیریت مشتریان")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 600)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        list_panel = QtWidgets.QWidget(); list_layout = QtWidgets.QVBoxLayout(list_panel)
        list_layout.addWidget(QtWidgets.QLabel("<b>لیست مشتریان</b>"))
        self.tbl_customers = QtWidgets.QTableWidget()
        parent._style_table(self.tbl_customers)
        self.tbl_customers.itemClicked.connect(self._populate_fields_for_edit)
        list_layout.addWidget(self.tbl_customers)
        splitter.addWidget(list_panel)

        form_panel = QtWidgets.QWidget(); form_layout = QtWidgets.QVBoxLayout(form_panel)
        form_group = QtWidgets.QGroupBox("افزودن / ویرایش مشتری")
        self.form = QtWidgets.QFormLayout(form_group)
        self.form.setSpacing(10)
        
        self.name_edit = QtWidgets.QLineEdit()
        self.contact_edit = QtWidgets.QLineEdit()
        self.phone_edit = QtWidgets.QLineEdit()
        self.email_edit = QtWidgets.QLineEdit()
        self.address_edit = QtWidgets.QTextEdit(); self.address_edit.setFixedHeight(60)
        self.tax_id_edit = QtWidgets.QLineEdit()
        self.notes_edit = QtWidgets.QTextEdit(); self.notes_edit.setFixedHeight(60)
        self.is_active_check = QtWidgets.QCheckBox("فعال"); self.is_active_check.setChecked(True)

        self.form.addRow("نام مشتری/شرکت (*):", self.name_edit)
        self.form.addRow("فرد رابط:", self.contact_edit)
        self.form.addRow("تلفن:", self.phone_edit)
        self.form.addRow("ایمیل:", self.email_edit)
        self.form.addRow("آدرس:", self.address_edit)
        self.form.addRow("کد اقتصادی/شناسه ملی:", self.tax_id_edit)
        self.form.addRow("یادداشت:", self.notes_edit)
        self.form.addRow("وضعیت:", self.is_active_check)
        form_layout.addWidget(form_group)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره")
        btn_save.setProperty("class", "primary")
        btn_delete = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), "حذف"); btn_delete.setProperty("class", "danger")
        btn_clear = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "پاک کردن فرم")
        btn_layout.addWidget(btn_save); btn_layout.addWidget(btn_delete); btn_layout.addStretch(); btn_layout.addWidget(btn_clear)
        form_layout.addLayout(btn_layout)
        
        splitter.addWidget(form_panel)
        splitter.setSizes([550, 350])

        btn_save.clicked.connect(self._save_customer)
        btn_delete.clicked.connect(self._delete_customer)
        btn_clear.clicked.connect(self._clear_fields)
        
        self._load_customers()

    def _load_customers(self):
        self.tbl_customers.setRowCount(0)
        customers = self.db.get_all_customers()
        headers = ['ID', 'نام مشتری', 'فرد رابط', 'تلفن', 'وضعیت']
        self.tbl_customers.setColumnCount(len(headers))
        self.tbl_customers.setHorizontalHeaderLabels(headers)
        self.tbl_customers.setColumnHidden(0, True)
        self.tbl_customers.setRowCount(len(customers))
        for r, cust in enumerate(customers):
            self.tbl_customers.setItem(r, 0, QtWidgets.QTableWidgetItem(str(cust['id'])))
            self.tbl_customers.setItem(r, 1, QtWidgets.QTableWidgetItem(cust['name']))
            self.tbl_customers.setItem(r, 2, QtWidgets.QTableWidgetItem(cust.get('contact_person', '')))
            self.tbl_customers.setItem(r, 3, QtWidgets.QTableWidgetItem(cust.get('phone', '')))
            status_item = QtWidgets.QTableWidgetItem("فعال" if cust.get('is_active') else "غیرفعال")
            status_item.setForeground(QtGui.QColor("green") if cust.get('is_active') else QtGui.QColor("red"))
            self.tbl_customers.setItem(r, 4, status_item)
        self.tbl_customers.resizeColumnsToContents()
        self.tbl_customers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _populate_fields_for_edit(self, item):
        row = item.row()
        self.current_customer_id = int(self.tbl_customers.item(row, 0).text())
        customer_details = self.db.execute_query("SELECT * FROM customers WHERE id = %s", (self.current_customer_id,), fetch_one=True)
        if not customer_details: return

        self.name_edit.setText(customer_details.get('name', ''))
        self.contact_edit.setText(customer_details.get('contact_person', ''))
        self.phone_edit.setText(customer_details.get('phone', ''))
        self.email_edit.setText(customer_details.get('email', ''))
        self.address_edit.setPlainText(customer_details.get('address', ''))
        self.tax_id_edit.setText(customer_details.get('tax_id', ''))
        self.notes_edit.setPlainText(customer_details.get('notes', ''))
        self.is_active_check.setChecked(customer_details.get('is_active', True))

    def _clear_fields(self):
        self.current_customer_id = None
        self.tbl_customers.clearSelection()
        for widget in [self.name_edit, self.contact_edit, self.phone_edit, self.email_edit, self.tax_id_edit]: widget.clear()
        for widget in [self.address_edit, self.notes_edit]: widget.clear()
        self.is_active_check.setChecked(True)
        self.name_edit.setFocus()

    def _save_customer(self):
        customer_data = {
            "name": self.name_edit.text().strip(),
            "contact_person": self.contact_edit.text().strip(),
            "phone": self.phone_edit.text().strip(),
            "email": self.email_edit.text().strip(),
            "address": self.address_edit.toPlainText().strip(),
            "tax_id": self.tax_id_edit.text().strip(),
            "notes": self.notes_edit.toPlainText().strip(),
            "is_active": self.is_active_check.isChecked()
        }
        try:
            self.db.add_or_update_customer(customer_data, self.current_customer_id)
            if self.toast: self.toast.show_message("✔ اطلاعات مشتری با موفقیت ذخیره شد.", "success")
            self._load_customers()
            self._clear_fields()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ذخیره‌سازی", str(e))

    def _delete_customer(self):
        if self.current_customer_id is None:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک مشتری را از لیست انتخاب کنید.", "warning")
            return
        
        reply = QtWidgets.QMessageBox.question(self, "تایید حذف", f"آیا از حذف مشتری «{self.name_edit.text()}» مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.delete_customer(self.current_customer_id)
                if self.toast: self.toast.show_message("✔ مشتری با موفقیت حذف شد.", "info")
                self._load_customers()
                self._clear_fields()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در حذف", f"این مشتری احتمالاً دارای سفارش فروش است و قابل حذف نیست.\n{e}")
                
# کلاس SalesOrderDialog را به طور کامل با این نسخه جایگزین کنید
class SalesOrderDialog(QtWidgets.QDialog):
    """دیالوگ جامع برای ایجاد سفارش فروش (با قابلیت تعیین نوع سفارش)."""
    def __init__(self, db: DB, parent_window):
        super().__init__(parent_window)
        self.db = db
        self.parent_window = parent_window
        self.toast = getattr(parent_window, 'toast', None)
        self.setWindowTitle("ایجاد سفارش فروش جدید")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(800, 600)

        main_layout = QtWidgets.QVBoxLayout(self)
        header_group = QtWidgets.QGroupBox("اطلاعات اصلی سفارش")
        form_layout = QtWidgets.QFormLayout(header_group)
        self.customer_combo = QtWidgets.QComboBox()
        self.date_edit = QtWidgets.QLineEdit(to_shamsi(datetime.now()))
        self.date_edit.setInputMask("0000/00/00;_")
        self.notes_edit = QtWidgets.QLineEdit(placeholderText="اختیاری: توضیحات مربوط به کل سفارش")
        self.order_type_group = QtWidgets.QGroupBox("نوع سفارش")
        order_type_layout = QtWidgets.QHBoxLayout(self.order_type_group)
        self.type_stock = QtWidgets.QRadioButton("فروش از انبار (Stock)")
        self.type_mto = QtWidgets.QRadioButton("سفارش تولید (Make-to-Order)")
        self.type_stock.setChecked(True)
        order_type_layout.addWidget(self.type_stock)
        order_type_layout.addWidget(self.type_mto)
        form_layout.addRow("مشتری (*):", self.customer_combo)
        form_layout.addRow("تاریخ صدور:", self.date_edit)
        form_layout.addRow(self.order_type_group)
        form_layout.addRow("یادداشت:", self.notes_edit)
        main_layout.addWidget(header_group)
        items_group = QtWidgets.QGroupBox("اقلام سفارش")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        self.items_table = QtWidgets.QTableWidget(0, 5)
        self.items_table.setHorizontalHeaderLabels(['ID کالا', 'نام کالا', 'تعداد/مقدار', 'قیمت واحد (ریال)', 'قیمت کل'])
        self.items_table.setColumnHidden(0, True); self.items_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.items_table.itemChanged.connect(self._update_total_price); items_layout.addWidget(self.items_table)
        items_toolbar = QtWidgets.QHBoxLayout(); btn_add_item = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن کالا"); btn_del_item = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), "حذف کالا"); items_toolbar.addWidget(btn_add_item); items_toolbar.addWidget(btn_del_item); items_toolbar.addStretch(); self.total_label = QtWidgets.QLabel("<b>مبلغ کل سفارش: 0 ریال</b>"); items_toolbar.addWidget(self.total_label); items_layout.addLayout(items_toolbar); main_layout.addWidget(items_group, 1)
        buttons = QtWidgets.QDialogButtonBox(); btn_cancel = buttons.addButton("انصراف", QtWidgets.QDialogButtonBox.RejectRole); btn_save = buttons.addButton("ذخیره سفارش", QtWidgets.QDialogButtonBox.AcceptRole); btn_save_print = buttons.addButton("ذخیره و صدور پیش‌فاکتور", QtWidgets.QDialogButtonBox.ActionRole); btn_save_print.setProperty("class", "primary"); buttons.rejected.connect(self.reject); btn_save.clicked.connect(self._save_order_and_close); btn_save_print.clicked.connect(self._save_order_and_print); main_layout.addWidget(buttons)
        btn_add_item.clicked.connect(self._add_item_row); btn_del_item.clicked.connect(self._remove_item_row); self._populate_customers()

    def _save_order(self):
        if self.customer_combo.currentIndex() <= 0: self.toast.show_message("لطفاً یک مشتری را انتخاب کنید.", "warning"); return None
        if self.items_table.rowCount() == 0: self.toast.show_message("سفارش فروش باید حداقل شامل یک کالا باشد.", "warning"); return None

        so_data = {
            "customer_id": self.customer_combo.currentData(),
            "issue_date": datetime.now().date(),
            "notes": self.notes_edit.text().strip(),
            "order_type": "MTO" if self.type_mto.isChecked() else "STOCK"
        }
        items_data = []
        for r in range(self.items_table.rowCount()):
            try:
                items_data.append({ "item_id": int(self.items_table.item(r, 0).text()), "quantity": float(self.items_table.item(r, 2).text()), "unit_price": float(self.items_table.item(r, 3).text()) })
            except (ValueError, TypeError, AttributeError): self.toast.show_message(f"اطلاعات در ردیف {r+1} جدول کالاها نامعتبر است.", "error"); return None

        if so_data["order_type"] == "STOCK":
            try:
                with self.db.transaction() as cur:
                    for item in items_data:
                        available_qty = self.db._get_available_stock(item['item_id'], cur)
                        if available_qty < item['quantity']:
                            item_details = self.db.get_item_details(item['item_id']); item_name = item_details.get('name', '')
                            raise ValueError(f"موجودی کالای «{item_name}» برای فروش از انبار کافی نیست. (موجود: {available_qty})")
            except ValueError as e:
                QtWidgets.QMessageBox.warning(self, "موجودی ناکافی", str(e))
                return None

        try:
            so_id = self.db.create_sales_order(so_data, items_data, self.parent_window.user_id)
            self.toast.show_message("✔ سفارش فروش با موفقیت ثبت شد.", "success")
            return so_id
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ثبت سفارش", f"خطا: {e}"); return None

    def _save_order_and_close(self):
        so_id = self._save_order();
        if so_id: self.accept()
    def _save_order_and_print(self):
        so_id = self._save_order();
        if so_id: self.parent_window._generate_proforma_pdf(so_id); self.accept()
    def _populate_customers(self):
        self.customer_combo.addItem("--- انتخاب کنید ---", None); customers = self.db.get_all_customers(active_only=True)
        for cust in customers: self.customer_combo.addItem(cust['name'], cust['id'])
    def _add_item_row(self):
        dlg = ProductSelectionDialog(self.db, self)
        if dlg.exec_() and dlg.selected_product:
            item_data = dlg.selected_product; row_pos = self.items_table.rowCount(); self.items_table.insertRow(row_pos)
            self.items_table.setItem(row_pos, 0, QtWidgets.QTableWidgetItem(str(item_data['id']))); self.items_table.setItem(row_pos, 1, QtWidgets.QTableWidgetItem(item_data['name'])); self.items_table.setItem(row_pos, 2, QtWidgets.QTableWidgetItem("1")); self.items_table.setItem(row_pos, 3, QtWidgets.QTableWidgetItem(str(item_data.get('cost', 0.0)))); total_price_item = QtWidgets.QTableWidgetItem("0"); total_price_item.setFlags(total_price_item.flags() & ~QtCore.Qt.ItemIsEditable); self.items_table.setItem(row_pos, 4, total_price_item); self._update_total_price(); self.items_table.setCurrentCell(row_pos, 2)
    def _remove_item_row(self):
        current_row = self.items_table.currentRow();
        if current_row >= 0: self.items_table.removeRow(current_row); self._update_total_price()
    def _update_total_price(self, item=None):
        if item and item.column() not in [2, 3]: return
        total_order_amount = 0
        for r in range(self.items_table.rowCount()):
            try:
                qty = float(self.items_table.item(r, 2).text()); price = float(self.items_table.item(r, 3).text()); row_total = qty * price
                self.items_table.blockSignals(True); self.items_table.item(r, 4).setText(f"{row_total:,.0f}"); self.items_table.blockSignals(False); total_order_amount += row_total
            except (ValueError, TypeError, AttributeError): continue
        self.total_label.setText(f"<b>مبلغ کل سفارش: {total_order_amount:,.0f} ریال</b>")        
                
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class ProductSelectionDialog(QtWidgets.QDialog):
    """دیالوگی برای انتخاب یک محصول نهایی از نمای درختی مادر-فرزندی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.selected_product = None
        
        self.setWindowTitle("انتخاب محصول")
        self.setMinimumSize(500, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        self.search_edit = QtWidgets.QLineEdit(placeholderText="جستجوی نام محصول یا پک...")
        self.search_edit.textChanged.connect(self._filter_tree)
        layout.addWidget(self.search_edit)

        self.tree = QtWidgets.QTreeWidget()
        
        self.tree.setAlternatingRowColors(True)
        self.tree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tree.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tree.setStyleSheet("""
            QTreeWidget::item { padding: 8px; }
            QTreeWidget::item:selected { background-color: #e7f1ff; color: #2c3e50; }
            QHeaderView::section { background-color: #ecf0f1; padding: 10px 5px; border-bottom: 2px solid #3498db; font-weight: bold; }
        """)

        self.tree.setHeaderLabels(["محصولات قابل فروش"])
        self.tree.itemDoubleClicked.connect(self.accept_selection)
        layout.addWidget(self.tree)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept_selection)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self._populate_tree()

    def _populate_tree(self):
        """درخت محصولات را با ساختار مادر-فرزندی پر می‌کند."""
        # --- **اصلاح کلیدی: ارسال آرگومان‌های صحیح به متد items_brief** ---
        final_products = self.db.items_brief(category_filter=CATEGORY_FINAL_PRODUCT, limit=10000, offset=0)
        
        items_by_id = {item['id']: dict(item) for item in final_products}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id and parent_id in items_by_id:
                if parent_id not in child_map: child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)
        
        for item_data in sorted(top_level_items, key=lambda x: x['name']):
            parent_item = QtWidgets.QTreeWidgetItem(self.tree)
            parent_item.setText(0, item_data.get('name', ''))
            
            is_parent_product = item_data.get('is_parent_product', False)
            if is_parent_product:
                parent_item.setFlags(parent_item.flags() & ~QtCore.Qt.ItemIsSelectable)
                parent_item.setFont(0, QFont(FONT_FAMILY, 10, QFont.Bold))
            else:
                parent_item.setData(0, QtCore.Qt.UserRole, item_data)

            if item_data['id'] in child_map:
                for child_data in sorted(child_map[item_data['id']], key=lambda x: x['name']):
                    child_item = QtWidgets.QTreeWidgetItem(parent_item)
                    child_item.setText(0, f"  {child_data.get('name', '')}")
                    child_item.setData(0, QtCore.Qt.UserRole, child_data)
        
        self.tree.expandAll()
    
    def _filter_tree(self, text):
        """درخت را بر اساس متن جستجو فیلتر می‌کند."""
        text = text.lower().strip()
        root = self.tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            parent_matches = text in parent_item.text(0).lower()
            
            has_visible_child = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j)
                child_matches = text in child_item.text(0).lower()
                child_item.setHidden(not child_matches)
                if not child_item.isHidden():
                    has_visible_child = True
            
            parent_item.setHidden(not (parent_matches or has_visible_child))

    def accept_selection(self):
        """داده‌های محصول انتخاب شده را ذخیره کرده و دیالوگ را می‌بندد."""
        selected_items = self.tree.selectedItems()
        if not selected_items:
            QtWidgets.QMessageBox.warning(self, "خطا", "لطفاً یک محصول (پک) را انتخاب کنید.")
            return
        
        item_data = selected_items[0].data(0, QtCore.Qt.UserRole)
        if not isinstance(item_data, dict):
            QtWidgets.QMessageBox.warning(self, "خطا", "لطفاً یک پک (زیرمجموعه) را انتخاب کنید، نه محصول مادر.")
            return
            
        self.selected_product = item_data
        self.accept()
                
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class BatchQCInquiryDialog(QtWidgets.QDialog):
    """دیالوگی برای جستجوی پیشرفته و نمایش سوابق کیفی بچ محصول."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.parent_window = parent

        self.setWindowTitle("استعلام سوابق کیفی بچ محصول")
        self.setMinimumSize(800, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        # بخش جستجوی پیشرفته
        search_group = QtWidgets.QGroupBox("پارامترهای جستجو")
        search_layout = QtWidgets.QHBoxLayout(search_group)
        self.product_search_edit = QtWidgets.QLineEdit(placeholderText="مثال: چسب اپوکسی")
        self.batch_search_edit = QtWidgets.QLineEdit(placeholderText="مثال: P-2501-123")
        self.start_date_edit = QtWidgets.QLineEdit(); self.start_date_edit.setInputMask("0000/00/00;_")
        self.end_date_edit = QtWidgets.QLineEdit(); self.end_date_edit.setInputMask("0000/00/00;_")
        btn_search = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), "جستجو")
        
        search_layout.addWidget(QtWidgets.QLabel("نام محصول:"))
        search_layout.addWidget(self.product_search_edit, 1)
        search_layout.addWidget(QtWidgets.QLabel("شماره بچ:"))
        search_layout.addWidget(self.batch_search_edit, 1)
        search_layout.addWidget(QtWidgets.QLabel("از تاریخ:"))
        search_layout.addWidget(self.start_date_edit)
        search_layout.addWidget(QtWidgets.QLabel("تا تاریخ:"))
        search_layout.addWidget(self.end_date_edit)
        search_layout.addWidget(btn_search)
        layout.addWidget(search_group)

        # جدول نتایج
        self.results_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.results_table)
        layout.addWidget(self.results_table, 1)

        btn_search.clicked.connect(self._search_batch)
        # اتصال کلید Enter در هر فیلد به جستجو
        for editor in [self.product_search_edit, self.batch_search_edit, self.start_date_edit, self.end_date_edit]:
            editor.returnPressed.connect(self._search_batch)

    def _search_batch(self):
        product_name = self.product_search_edit.text().strip()
        batch_no = self.batch_search_edit.text().strip()
        start_date = shamsi_to_gregorian(self.start_date_edit.text())
        end_date = shamsi_to_gregorian(self.end_date_edit.text())

        if not any([product_name, batch_no, start_date, end_date]):
            if self.toast: self.toast.show_message("حداقل یک پارامتر برای جستجو وارد کنید.", "warning")
            return
        
        try:
            records = self.db.search_qc_form_entries(product_name, batch_no, start_date, end_date)
            self.results_table.setRowCount(0)

            if not records:
                set_empty_placeholder(self.results_table, "هیچ گزارش کیفی با این مشخصات یافت نشد.")
                return

            all_keys = set()
            for rec in records:
                if isinstance(rec['data'], dict):
                    all_keys.update(rec['data'].keys())
            
            static_headers = ['تاریخ ثبت', 'ثبت توسط']
            dynamic_headers = sorted(list(all_keys))
            headers = static_headers + dynamic_headers

            self.results_table.setColumnCount(len(headers))
            self.results_table.setHorizontalHeaderLabels(headers)
            self.results_table.setRowCount(len(records))

            for r, rec in enumerate(records):
                self.results_table.setItem(r, 0, QtWidgets.QTableWidgetItem(to_shamsi(rec['submission_date'])))
                self.results_table.setItem(r, 1, QtWidgets.QTableWidgetItem(rec['submitted_by']))
                
                data = rec.get('data', {})
                for c, key in enumerate(dynamic_headers):
                    value = data.get(key, '')
                    self.results_table.setItem(r, 2 + c, QtWidgets.QTableWidgetItem(str(value)))
            
            self.results_table.resizeColumnsToContents()
            self.results_table.horizontalHeader().setSectionResizeMode(headers.index("انتخاب بچ تولید جهت بازرسی"), QtWidgets.QHeaderView.Stretch)

        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در جستجو: {e}", "critical")
            
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class WarehouseDashboardWidget(QtWidgets.QWidget):
    """داشبورد اختصاصی انبار (نسخه نهایی با طراحی گرافیکی و ساختار دو ستونی)."""
    def __init__(self, db: DB, parent_window=None):
        super().__init__(parent_window)
        self.db = db
        self.parent_window = parent_window
        self.toast = getattr(parent_window, 'toast', None)
        
        main_layout = QtWidgets.QHBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15); main_layout.setSpacing(20)

        right_column_layout = QtWidgets.QVBoxLayout(); right_column_layout.setSpacing(20)
        self.card_total_items = self._create_kpi_card("تعداد کل کالاها", "0", "#2980b9", "view-list-tree")
        self.card_shortage = self._create_kpi_card("کالاهای نیازمند سفارش", "0 مورد", "#c0392b", "dialog-warning")
        self.card_expiring = self._create_kpi_card("کالاهای در شرف انقضا", "0 مورد", "#f39c12", "appointment-soon")
        self.card_shortage.clicked.connect(self._show_shortage_items); self.card_expiring.clicked.connect(self._show_expiring_items)
        right_column_layout.addWidget(self.card_total_items); right_column_layout.addWidget(self.card_shortage); right_column_layout.addWidget(self.card_expiring)
        
        transactions_group = QtWidgets.QGroupBox("آخرین تراکنش‌های انبار")
        transactions_layout = QtWidgets.QVBoxLayout(transactions_group)
        self.pinned_table = PinnedTable(self.db, limit=10)
        transactions_layout.addWidget(self.pinned_table); right_column_layout.addWidget(transactions_group, 1)

        left_column_layout = QtWidgets.QVBoxLayout(); left_column_layout.setSpacing(20)
        analysis_group = QtWidgets.QGroupBox("ابزارهای تحلیلی")
        analysis_layout = QtWidgets.QVBoxLayout(analysis_group)
        btn_abc = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-sort-descending"), "   اجرای تحلیل ABC")
        btn_abc.setMinimumHeight(40); btn_abc.clicked.connect(lambda: AbcAnalysisDialog(self.db, self.parent_window).exec_())
        analysis_layout.addWidget(btn_abc); left_column_layout.addWidget(analysis_group)
        
        smo_group = QtWidgets.QGroupBox("گزارش کالاهای راکد (Slow-Moving)")
        smo_layout = QtWidgets.QVBoxLayout(smo_group)
        toolbar = QtWidgets.QHBoxLayout(); toolbar.addWidget(QtWidgets.QLabel("کالاهای بدون جابجایی برای بیش از:"))
        self.days_idle_spinbox = QtWidgets.QSpinBox(); self.days_idle_spinbox.setRange(30, 730); self.days_idle_spinbox.setValue(90); self.days_idle_spinbox.setSuffix(" روز")
        toolbar.addWidget(self.days_idle_spinbox); toolbar.addStretch(); smo_layout.addLayout(toolbar)
        self.tbl_slow_moving = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'): self.parent_window._style_table(self.tbl_slow_moving)
        smo_layout.addWidget(self.tbl_slow_moving); left_column_layout.addWidget(smo_group, 1)
        
        main_layout.addLayout(left_column_layout, 2); main_layout.addLayout(right_column_layout, 1)
        self.days_idle_spinbox.valueChanged.connect(self.refresh_data)

    
    def _create_kpi_card(self, title, value, color, icon_name):
        """A clickable KPI card (Final version with correct layout and styling)."""
        card = ClickableFrame(); card.setObjectName("kpiCard")
        
        card.setStyleSheet(f"""
            QFrame#kpiCard {{
                background-color: {color};
                border-radius: 8px;
            }}
            QFrame#kpiCard:hover {{
                background-color: {QtGui.QColor(color).lighter(115).name()};
            }}
            QFrame#kpiCard QLabel {{
                color: white;
                background-color: transparent;
                border: none;
            }}
            QLabel#kpiTitle {{
                font-size: 11pt;
                font-weight: bold;
            }}
            QLabel#kpiValue {{
                font-size: 20pt;
                font-weight: bold;
            }}
        """)
        
        card_layout = QtWidgets.QHBoxLayout(card)
        card_layout.setContentsMargins(20, 15, 20, 15)
        card_layout.setSpacing(15)

        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(32, 32))
        
        text_layout = QtWidgets.QVBoxLayout(); text_layout.setSpacing(0)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setObjectName("kpiTitle")
        title_label.setAlignment(QtCore.Qt.AlignVCenter)
        
        value_label = QtWidgets.QLabel(value)
        value_label.setObjectName("kpiValue")
        value_label.setAlignment(QtCore.Qt.AlignCenter)
        
        text_layout.addWidget(title_label)
        text_layout.addWidget(value_label)
        
        # **Final Fix: The order of adding widgets is corrected for RTL layout**
        card_layout.addWidget(icon_label) 
        card_layout.addLayout(text_layout, 1)
            
        card.value_label = value_label
        return card
    
        
        
        
# در کلاس WarehouseDashboardWidget، این متد را جایگزین کنید
    def refresh_data(self):
        """تمام داده‌های داشبورد انبار را بارگذاری و بروزرسانی می‌کند (با نمایش نام مادر)."""
        # ... (بخش رفرش کارت‌های KPI بدون تغییر باقی می‌ماند) ...
        try:
            cnt, _ = self.db.stats()
            low_items = self.db.min_alert()
            exp_items = self.db.exp_alert()

            self.card_total_items.value_label.setText(str(cnt))
            self.card_shortage.value_label.setText(f"{len(low_items)} مورد")
            self.card_expiring.value_label.setText(f"{len(exp_items)} مورد")
        except Exception as e:
            print(f"Error refreshing KPI cards: {e}")

        if hasattr(self, 'pinned_table'):
            last_id = self.db.get_setting('last_cleared_trans_id', '0')
            self.pinned_table.refresh(since_id=int(last_id))

        # رفرش جدول کالاهای راکد
        table = self.tbl_slow_moving
        days_idle = self.days_idle_spinbox.value()
        try:
            records = self.db.get_slow_moving_stock(days_idle)
            table.setRowCount(0)
            headers = ['نام کالا', 'شماره بچ', 'مقدار موجود', 'آخرین جابجایی']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(records))

            for r, rec in enumerate(records):
                # --- اصلاح کلیدی: ترکیب نام مادر و فرزند ---
                full_item_name = rec['item_name']
                if rec.get('parent_name'):
                    full_item_name = f"{rec['parent_name']} - {rec['item_name']}"
                # -------------------------------------------
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(full_item_name))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(rec['batch_no']))
                table.setItem(r, 2, NumericTableWidgetItem(str(rec['qty'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(rec.get('last_moved_at'))))

            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, f"هیچ کالای راکدی (با بیش از {days_idle} روز عدم جابجایی) یافت نشد.")
        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری کالاهای راکد: {e}", "critical")
            
            
    def _show_shortage_items(self):
        """کاربر را به صفحه کالاها برده و فیلتر کمبود موجودی را اعمال می‌کند."""
        if not hasattr(self.parent_window, 'pg_items'): return
        self.parent_window.pages.setCurrentWidget(self.parent_window.pg_items)
        QtCore.QTimer.singleShot(50, self.parent_window._filter_for_shortage)

    def _show_expiring_items(self):
        """یک دیالوگ برای نمایش لیست کامل کالاهای در شرف انقضا باز می‌کند."""
        expiring_items = self.db.exp_alert()
        if not expiring_items:
            if self.toast: self.toast.show_message("هیچ کالایی در شرف انقضا یافت نشد.", "info")
            return
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("کالاهای در شرف انقضا"); dlg.setMinimumWidth(500)
        layout = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(expiring_items), 3)
        table.setHorizontalHeaderLabels(['نام کالا', 'شماره بچ', 'تاریخ انقضا'])
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for r, item in enumerate(expiring_items):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(item['name'])); table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['batch_no'])); table.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(item['expiry_date'])))
        layout.addWidget(table)
        dlg.exec_()
                
                    
                        
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class AbcAnalysisDialog(QtWidgets.QDialog):
    """دیالوگی برای تنظیم، اجرا و نمایش گزارش تحلیل ABC (نسخه اصلاح شده)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent

        self.setWindowTitle("گزارش تحلیلی ABC موجودی انبار")
        self.setMinimumSize(800, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        settings_group = QtWidgets.QGroupBox("تنظیمات تحلیل")
        settings_layout = QtWidgets.QHBoxLayout(settings_group)
        settings_layout.addWidget(QtWidgets.QLabel("تحلیل بر اساس:"))
        self.mode_combo = QtWidgets.QComboBox()
        self.mode_combo.addItems(["ارزش ریالی (Value)", "تعداد تراکنش خروج (Movement)"])
        settings_layout.addWidget(self.mode_combo)
        
        settings_layout.addWidget(QtWidgets.QLabel("در بازه زمانی:"))
        self.period_spinbox = QtWidgets.QSpinBox()
        self.period_spinbox.setRange(30, 730); self.period_spinbox.setValue(90); self.period_spinbox.setSuffix(" روز گذشته")
        settings_layout.addWidget(self.period_spinbox)
        
        btn_run = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), "اجرای تحلیل")
        btn_run.setProperty("class", "primary")
        settings_layout.addStretch(); settings_layout.addWidget(btn_run)
        layout.addWidget(settings_group)

        self.tbl_report = QtWidgets.QTableWidget()
        self.tbl_report.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers) # <<<<<<< اصلاح: جدول فقط خواندنی شد
        add_filter_export_tools(self.tbl_report, layout)
        layout.addWidget(self.tbl_report, 1)

        btn_run.clicked.connect(self._run_analysis)
        self._run_analysis()

    def _run_analysis(self):
        """تحلیل را اجرا کرده و جدول را با نام کامل محصول پر می‌کند."""
        mode = 'value' if self.mode_combo.currentIndex() == 0 else 'movement'
        period = self.period_spinbox.value()
        
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            records = self.db.get_abc_analysis_data(period, mode)
            self.tbl_report.setRowCount(0)
            
            headers = ['کلاس', 'نام کالا', 'دسته', 'معیار تحلیل', 'درصد تجمعی']
            self.tbl_report.setColumnCount(len(headers)); self.tbl_report.setHorizontalHeaderLabels(headers)
            self.tbl_report.setRowCount(len(records))

            class_colors = {'A': QtGui.QColor("#f8d7da"), 'B': QtGui.QColor("#fff3cd"), 'C': QtGui.QColor("#d1e7dd")}

            for r, rec in enumerate(records):
                # --- اصلاح کلیدی: ترکیب نام مادر و فرزند ---
                full_item_name = rec['name']
                if rec.get('parent_name'):
                    full_item_name = f"{rec['parent_name']} - {rec['name']}"
                # -------------------------------------------
                
                abc_class = rec.get('abc_class', '')
                measure_value = rec.get('total_value', rec.get('total_movements', 0))
                
                self.tbl_report.setItem(r, 0, QtWidgets.QTableWidgetItem(abc_class))
                self.tbl_report.setItem(r, 1, QtWidgets.QTableWidgetItem(full_item_name))
                self.tbl_report.setItem(r, 2, QtWidgets.QTableWidgetItem(rec['category']))
                self.tbl_report.setItem(r, 3, NumericTableWidgetItem(f"{measure_value:,.2f}"))
                self.tbl_report.setItem(r, 4, NumericTableWidgetItem(f"{rec.get('cumulative_percentage', 0):.2%}"))

                bg_color = class_colors.get(abc_class)
                if bg_color:
                    for c in range(len(headers)):
                        self.tbl_report.item(r, c).setBackground(bg_color)
            
            self.tbl_report.resizeColumnsToContents()
            self.tbl_report.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_report, "هیچ داده‌ای برای تحلیل در بازه زمانی مشخص شده یافت نشد.")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
# کلاس WarehouseLayoutWidget را به طور کامل با این نسخه جایگزین کنید

class WarehouseLayoutWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش و ویرایش گرافیکی چیدمان انبار (نسخه 2.0 با UI بهبود یافته)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.scene = QtWidgets.QGraphicsScene()
        self.view = QtWidgets.QGraphicsView(self.scene)
        self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.scene.setBackgroundBrush(QtGui.QBrush(QtGui.QColor("#f1f2f6"))) # رنگ پس‌زمینه بهتر

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        toolbar = QtWidgets.QHBoxLayout()
        toolbar.addWidget(QtWidgets.QLabel("<b>نقشه حرارتی:</b>"))
        self.heatmap_combo = QtWidgets.QComboBox()
        self.heatmap_combo.addItems(["غیرفعال", "فراوانی برداشت", "حجم موجودی", "کالاهای راکد"])
        toolbar.addWidget(self.heatmap_combo)
        toolbar.addStretch()

        # --- بخش جدید: ابزارهای ناوبری ---
        btn_zoom_in = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-in"), "")
        btn_zoom_out = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-out"), "")
        btn_fit_view = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-fit-best"), "")
        btn_zoom_in.setFixedSize(30, 30); btn_zoom_out.setFixedSize(30, 30); btn_fit_view.setFixedSize(30, 30)
        btn_zoom_in.setToolTip("بزرگ‌نمایی")
        btn_zoom_out.setToolTip("کوچک‌نمایی")
        btn_fit_view.setToolTip("نمایش کامل نقشه")
        toolbar.addWidget(btn_zoom_in)
        toolbar.addWidget(btn_zoom_out)
        toolbar.addWidget(btn_fit_view)
        # ------------------------------------
        
        btn_refresh = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), "")
        btn_refresh.setFixedSize(30, 30); btn_refresh.setToolTip("بارگذاری مجدد نقشه")
        toolbar.addWidget(btn_refresh)
        layout.addLayout(toolbar)

        layout.addWidget(self.view)

        btn_refresh.clicked.connect(self.refresh_layout)
        self.heatmap_combo.currentIndexChanged.connect(self.refresh_layout)
        btn_zoom_in.clicked.connect(lambda: self.view.scale(1.2, 1.2))
        btn_zoom_out.clicked.connect(lambda: self.view.scale(1/1.2, 1/1.2))
        btn_fit_view.clicked.connect(lambda: self.view.fitInView(self.scene.itemsBoundingRect(), QtCore.Qt.KeepAspectRatio))

        self.refresh_layout()

    def refresh_layout(self):
        """چیدمان انبار را از دیتابیس خوانده و آیتم‌های گرافیکی را روی نقشه ترسیم می‌کند."""
        self.scene.clear()
        locations = self.db.list_locations()
        if not locations: return

        for loc in locations:
            interactive_item = InteractiveRackItem(loc, self)
            self.scene.addItem(interactive_item)
            
                        
                        
# کلاس InteractiveRackItem را به طور کامل با این نسخه جایگزین کنید

class InteractiveRackItem(QtWidgets.QGraphicsRectItem):
    """
    نسخه 2.0 (طراحی گرافیکی):
    - یک آیتم گرافیکی زیبا و خوانا برای نمایش قفسه در نقشه انبار.
    """
    def __init__(self, location_data, parent_widget):
        # آیتم اصلی به عنوان یک کانتینر نامرئی عمل می‌کند
        super().__init__(location_data['pos_x'], location_data['pos_y'], location_data['width'], location_data['height'])
        self.location_data = location_data
        self.parent_widget = parent_widget

        # تنظیمات اصلی آیتم برای تعامل
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | QtWidgets.QGraphicsItem.ItemIsSelectable | QtWidgets.QGraphicsItem.ItemSendsScenePositionChanges)
        self.setPen(QtGui.QPen(QtCore.Qt.NoPen)) # کانتینر اصلی بدون حاشیه است

        # بدنه اصلی قفسه
        self.body = QtWidgets.QGraphicsRectItem(0, 0, location_data['width'], location_data['height'], self)
        self.body.setBrush(QtGui.QBrush(QtGui.QColor("#dfe4ea")))
        self.body.setPen(QtGui.QPen(QtGui.QColor("#808e9b"), 1))

        # هدر رنگی بالای قفسه
        header_height = 25
        self.header = QtWidgets.QGraphicsRectItem(0, 0, location_data['width'], header_height, self)
        self.header.setBrush(QtGui.QBrush(QtGui.QColor("#57606f")))
        self.header.setPen(QtGui.QPen(QtCore.Qt.NoPen))
        
        # متن نام قفسه
        self.text_item = QtWidgets.QGraphicsTextItem(self.location_data['rack'], self)
        font = QFont(FONT_FAMILY, 10, QFont.Bold)
        self.text_item.setFont(font)
        self.text_item.setDefaultTextColor(QtCore.Qt.white)
        # قرار دادن متن در وسط هدر
        text_rect = self.text_item.boundingRect()
        self.text_item.setPos((location_data['width'] - text_rect.width()) / 2, (header_height - text_rect.height()) / 2)

        self.setToolTip(f"{self.location_data['loc_label']}\nمختصات: ({self.location_data['pos_x']:.0f}, {self.location_data['pos_y']:.0f})")

    def mouseReleaseEvent(self, event):
        """پس از رها کردن آیتم، موقعیت جدید آن را در دیتابیس ذخیره می‌کند."""
        super().mouseReleaseEvent(event)
        new_pos = self.scenePos()
        
        # فقط در صورتی که موقعیت واقعا تغییر کرده، در دیتابیس ذخیره کن
        if int(new_pos.x()) != int(self.location_data['pos_x']) or int(new_pos.y()) != int(self.location_data['pos_y']):
            self.location_data['pos_x'] = new_pos.x()
            self.location_data['pos_y'] = new_pos.y()
            self.parent_widget.db.update_location_position(self.location_data['id'], new_pos.x(), new_pos.y())
            self.setToolTip(f"{self.location_data['loc_label']}\nمختصات: ({new_pos.x():.0f}, {new_pos.y():.0f})")
            if self.parent_widget.toast:
                self.parent_widget.toast.show_message(f"موقعیت {self.location_data['loc_label']} به‌روز شد.", "info")
                
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
class PurchaseOrderDetailDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش جزئیات کامل یک سفارش خرید."""
    def __init__(self, db: DB, po_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.po_id = po_id
        self.parent_window = parent

        self.setWindowTitle(f"جزئیات سفارش خرید")
        self.setMinimumSize(750, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        # بخش اطلاعات اصلی
        header_group = QtWidgets.QGroupBox("مشخصات سفارش")
        form_layout = QtWidgets.QFormLayout(header_group)
        self.lbl_po_number = QtWidgets.QLabel("...")
        self.lbl_supplier = QtWidgets.QLabel("...")
        self.lbl_issue_date = QtWidgets.QLabel("...")
        self.lbl_status = QtWidgets.QLabel("...")
        self.lbl_total_amount = QtWidgets.QLabel("...")
        
        form_layout.addRow("شماره سفارش (PO):", self.lbl_po_number)
        form_layout.addRow("تامین‌کننده:", self.lbl_supplier)
        form_layout.addRow("تاریخ صدور:", self.lbl_issue_date)
        form_layout.addRow("وضعیت:", self.lbl_status)
        form_layout.addRow("مبلغ کل (ریال):", self.lbl_total_amount)
        layout.addWidget(header_group)

        # بخش اقلام سفارش
        items_group = QtWidgets.QGroupBox("اقلام سفارش")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        self.tbl_items = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_items)
        items_layout.addWidget(self.tbl_items)
        layout.addWidget(items_group, 1)

        self._load_data()

    def _load_data(self):
        """داده‌های هدر و اقلام سفارش را از دیتابیس خوانده و نمایش می‌دهد."""
        po_details = self.db.get_po_details(self.po_id)
        if not po_details:
            self.close()
            return

        self.setWindowTitle(f"جزئیات سفارش خرید: {po_details.get('po_number')}")
        self.lbl_po_number.setText(f"<b>{po_details.get('po_number')}</b>")
        self.lbl_supplier.setText(po_details.get('supplier_name', ''))
        self.lbl_issue_date.setText(to_shamsi(po_details.get('issue_date')))
        self.lbl_status.setText(f"<b>{po_details.get('status')}</b>")
        self.lbl_total_amount.setText(f"{po_details.get('total_amount', 0):,.0f}")

        line_items = self.db.get_po_line_items(self.po_id)
        headers = ['نام کالا', 'مقدار', 'واحد', 'قیمت واحد', 'قیمت کل']
        self.tbl_items.setColumnCount(len(headers))
        self.tbl_items.setHorizontalHeaderLabels(headers)
        self.tbl_items.setRowCount(len(line_items))

        for r, item in enumerate(line_items):
            quantity = item.get('quantity', 0)
            unit_price = item.get('unit_price', 0)
            total_price = quantity * unit_price
            
            self.tbl_items.setItem(r, 0, QtWidgets.QTableWidgetItem(item.get('item_name')))
            self.tbl_items.setItem(r, 1, NumericTableWidgetItem(str(quantity)))
            self.tbl_items.setItem(r, 2, QtWidgets.QTableWidgetItem(item.get('unit', '')))
            self.tbl_items.setItem(r, 3, NumericTableWidgetItem(f"{unit_price:,.0f}"))
            self.tbl_items.setItem(r, 4, NumericTableWidgetItem(f"{total_price:,.0f}"))

        self.tbl_items.resizeColumnsToContents()
        self.tbl_items.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class DispatchCenterWidget(QtWidgets.QWidget):
    """ویجت مرکز ارسال برای مشاهده سفارشات فروش باز و شروع فرآیند ارسال."""
    def __init__(self, db: DB, user_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        self.tbl_open_orders = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.tbl_open_orders)
        layout.addWidget(self.tbl_open_orders, 1)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_start_dispatch = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), "شروع فرآیند ارسال برای سفارش انتخابی")
        btn_start_dispatch.setProperty("class", "primary")
        btn_start_dispatch.setMinimumHeight(35)
        
        btn_layout.addStretch()
        btn_layout.addWidget(btn_start_dispatch)
        layout.addLayout(btn_layout)

        btn_start_dispatch.clicked.connect(self._start_dispatch_process)
        self.refresh_data()

    def refresh_data(self):
        """لیست سفارشات فروش باز را بارگذاری می‌کند."""
        try:
            orders = self.db.get_open_sales_orders()
            self.tbl_open_orders.setRowCount(0)
            headers = ['ID سفارش', 'شماره سفارش', 'مشتری', 'خلاصه اقلام', 'تاریخ صدور']
            self.tbl_open_orders.setColumnCount(len(headers))
            self.tbl_open_orders.setHorizontalHeaderLabels(headers)
            self.tbl_open_orders.setRowCount(len(orders))

            for r, order in enumerate(orders):
                self.tbl_open_orders.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                self.tbl_open_orders.setItem(r, 1, QtWidgets.QTableWidgetItem(order['so_number']))
                self.tbl_open_orders.setItem(r, 2, QtWidgets.QTableWidgetItem(order['customer_name']))
                self.tbl_open_orders.setItem(r, 3, QtWidgets.QTableWidgetItem(order.get('items_summary', '')))
                self.tbl_open_orders.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(order.get('issue_date'))))
            
            self.tbl_open_orders.setColumnHidden(0, True)
            self.tbl_open_orders.resizeColumnsToContents()
            self.tbl_open_orders.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(self.tbl_open_orders, "هیچ سفارش فروش بازی برای ارسال وجود ندارد.")
        except Exception as e:
            if self.toast: self.toast.show_message(f"خطا در بارگذاری سفارشات فروش: {e}", "critical")

# در کلاس DispatchCenterWidget، این متد را به طور کامل جایگزین کنید

    def _start_dispatch_process(self):
        """فرآیند ارسال را بر اساس کلید سیستمی DISPATCH آغاز می‌کند."""
        selected_rows = self.tbl_open_orders.selectionModel().selectedRows()
        if not selected_rows:
            if self.toast: self.toast.show_message("لطفاً ابتدا یک سفارش فروش را از لیست انتخاب کنید.", "warning")
            return
            
        so_id = int(self.tbl_open_orders.item(selected_rows[0].row(), 0).text())
        so_number = self.tbl_open_orders.item(selected_rows[0].row(), 1).text()

        # --- *** اصلاح کلیدی: جستجو بر اساس کلید سیستمی به جای نام *** ---
        # ما به دنبال فرآیندی می‌گردیم که نوع آن DISPATCH باشد.
        OPERATION_KEY = 'DISPATCH_CENTER_START_PROCESS'
        mapping = self.db.execute_query(
            "SELECT workflow_id FROM system_operation_mappings WHERE operation_key = %s",
            (OPERATION_KEY,), fetch_one=True
        )

        if not mapping or not mapping.get('workflow_id'):
            QtWidgets.QMessageBox.critical(self, "خطا در پیکربندی", 
                f"هیچ فرآیندی به عملیات «شروع ارسال از مرکز توزیع» متصل نشده است.\n\n"
                f"لطفاً از طریق ماژول QA -> اتصال فرآیندها به عملیات، یک فرآیند را به این عملیات متصل کنید.")
            return
        
        workflow_id = mapping['workflow_id']
        # --- ********************************************************** ---

        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا می‌خواهید فرآیند ارسال را برای سفارش شماره «{so_number}» آغاز کنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                with self.db.transaction() as cur:
                    self.db.start_workflow_instance(
                        workflow_id=workflow_id,
                        related_record_id=so_id,
                        related_table_name='sales_orders',
                        cur=cur,
                        user_id=self.user_id
                    )
                self.toast.show_message("✔ فرآیند ارسال با موفقیت آغاز شد.", "success")
                self.refresh_data()
                if hasattr(self.parent_window, 'refresh_all'):
                    self.parent_window.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در شروع فرآیند", str(e))
                
                                
# این دو کلاس را به طور کامل با نسخه‌های قبلی جایگزین کنید

class SalesChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش گرافیکی روند فروش (نسخه نهایی با قابلیت کلیک)."""
    dateClicked = QtCore.pyqtSignal(dt.date)
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(10, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        self.df = None # تعریف اولیه به عنوان متغیر کلاس
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.canvas)
        
        self.canvas.mpl_connect('pick_event', self._on_pick)
        self.refresh_data()

    def refresh_data(self):
        self.ax.clear()
        try:
            sales_data = self.db.get_sales_summary_by_day(days_history=30)
            if sales_data and pd:
                self.df = pd.DataFrame([dict(row) for row in sales_data]) # <<-- اصلاح: استفاده از self.df
                self.df['report_date'] = pd.to_datetime(self.df['report_date'])
                self.df['shamsi_date_str'] = self.df['report_date'].apply(lambda d: to_shamsi(d).split(' ')[0])

                # آرگومان 'picker=5' نقاط داده را قابل کلیک می‌کند
                self.ax.plot(self.df['shamsi_date_str'], self.df['total_sales'], marker='o', linestyle='-', color='#0d6efd', picker=5)
                self.ax.set_title(fa("روند فروش ۳۰ روز گذشته (به ریال)"), fontsize=14, weight='bold')
                self.ax.set_ylabel(fa("مبلغ فروش روزانه"))
                self.ax.grid(axis='y', linestyle='--', alpha=0.7)
                self.ax.tick_params(axis='x', rotation=45, labelsize=9)
                formatter = mpl.ticker.FuncFormatter(lambda x, p: format(int(x), ','))
                self.ax.get_yaxis().set_major_formatter(formatter)
                self.figure.tight_layout()
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش در نمودار فروش یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating sales chart: {e}")
            self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')
        self.canvas.draw()
        
# در کلاس SalesChartWidget، این متد را جایگزین کنید
    def _on_pick(self, event):
        """کلیک روی نقاط داده نمودار را مدیریت می‌کند."""
        # --- اصلاح کلیدی: بررسی وجود دیتافریم قبل از هر کاری ---
        if self.df is None or self.df.empty or not isinstance(event.artist, mpl.lines.Line2D): return
        try:
            ind = event.ind[0]
            clicked_date = self.df['report_date'].iloc[ind].date()
            self.dateClicked.emit(clicked_date)
        except (IndexError, AttributeError) as e:
            print(f"Could not process pick event: {e}")
            
                              
class TopProductsChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش نمودار ۵ محصول پرفروش (نسخه نهایی با رفع خطا)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(5, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.canvas)
        self.refresh_data()

    def refresh_data(self):
        self.ax.clear()
        try:
            top_products = self.db.get_sales_summary_by_product(days_history=30, top_n=5)
            if top_products and pd:
                df = pd.DataFrame(top_products)
                # --- *** اصلاح کلیدی: بررسی خالی نبودن دیتافریم *** ---
                if not df.empty:
                    product_labels = [fa(name) for name in df['product_name']]
                    bars = self.ax.barh(product_labels, df['total_quantity'], color='#8e44ad')
                    
                    self.ax.set_title(fa("۵ محصول پرفروش (بر اساس تعداد)"), fontsize=12, weight='bold')
                    self.ax.set_xlabel(fa("تعداد کل فروخته شده در ۳۰ روز گذشته"))
                    self.ax.invert_yaxis()
                    self.ax.bar_label(bars, fmt='{:,.0f}', padding=3)
                else:
                    self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش یافت نشد."), ha='center', va='center')
                # --- *********************************************** ---
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating top products chart: {e}")
            self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')

        self.figure.tight_layout()
        self.canvas.draw()
                    
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class ProductionChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش گرافیکی روند تولید در داشبورد مدیرعامل."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(10, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.canvas)
        self.refresh_data()

    # در کلاس ProductionChartWidget، این متد را جایگزین کنید
    def refresh_data(self):
        """داده‌های تولید را از دیتابیس خوانده و نمودار را مجدداً ترسیم می‌کند."""
        self.ax.clear()
        try:
            prod_data = self.db.get_production_summary_by_day(days_history=30)
            if prod_data and pd:
                # --- *** اصلاح کلیدی: تبدیل صریح به لیست دیکشنری‌ها *** ---
                df = pd.DataFrame([dict(row) for row in prod_data])
                df['report_date'] = pd.to_datetime(df['report_date'])
                df['shamsi_date_str'] = df['report_date'].apply(lambda d: to_shamsi(d))

                bars = self.ax.bar(df['shamsi_date_str'], df['total_production'], color='#1abc9c')
                self.ax.set_title(fa("روند تولید ۳۰ روز گذشته (محصولات نهایی)"), fontsize=14, weight='bold'); self.ax.set_ylabel(fa("مقدار تولید روزانه (واحد اصلی)")); self.ax.grid(axis='y', linestyle='--', alpha=0.7); self.ax.tick_params(axis='x', rotation=45, labelsize=9)
                formatter = mpl.ticker.FuncFormatter(lambda x, p: format(int(x), ',')); self.ax.get_yaxis().set_major_formatter(formatter)
                self.ax.bar_label(bars, fmt='{:,.0f}', padding=3)
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش در نمودار تولید یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating production chart: {e}"); self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')
        self.figure.tight_layout(); self.canvas.draw()
    
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
        
        # کلاس ProfitabilityChartWidget را به طور کامل با این نسخه جایگزین کنید
class ProfitabilityChartWidget(QtWidgets.QWidget):
    """ویجتی برای نمایش نمودار تحلیل سودآوری (نسخه اصلاح شده)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.figure, self.ax = plt.subplots(figsize=(10, 4), dpi=90)
        self.canvas = Canvas(self.figure)
        
        layout = QtWidgets.QVBoxLayout(self); layout.addWidget(self.canvas)
        self.refresh_data()

    def refresh_data(self):
        self.ax.clear()
        try:
            sales_data = self.db.get_sales_summary_by_day(days_history=30)
            cogs_data = self.db.get_cogs_summary_by_day(days_history=30)
            if sales_data and cogs_data and pd:
                df_sales = pd.DataFrame(sales_data); df_cogs = pd.DataFrame(cogs_data)
                df_sales['shamsi_date_str'] = pd.to_datetime(df_sales['report_date']).apply(lambda d: to_shamsi(d))
                
                self.ax.plot(df_sales['shamsi_date_str'], df_sales['total_sales'], marker='o', linestyle='-', color='#0d6efd', label=fa('فروش کل'))
                self.ax.plot(df_sales['shamsi_date_str'], df_cogs['total_cogs'], marker='x', linestyle='--', color='#dc3545', label=fa('بهای تمام شده'))
                
                self.ax.set_title(fa("تحلیل سودآوری ۳۰ روز گذشته"), fontsize=14, weight='bold')
                self.ax.set_ylabel(fa("مبلغ (ریال)"))
                self.ax.grid(True, linestyle='--', alpha=0.6)
                self.ax.tick_params(axis='x', rotation=45, labelsize=9) # <<<< اصلاح: چرخش برچسب‌ها
                self.ax.legend(prop={'family': FONT_FAMILY_MATPLOTLIB, 'size': 10})

                formatter = mpl.ticker.FuncFormatter(lambda x, p: format(int(x), ','))
                self.ax.get_yaxis().set_major_formatter(formatter)
            else:
                self.ax.text(0.5, 0.5, fa("داده‌ای برای نمایش یافت نشد."), ha='center', va='center')
        except Exception as e:
            print(f"Error creating profitability chart: {e}"); self.ax.text(0.5, 0.5, fa(f"خطا در ساخت نمودار: {e}"), ha='center', va='center')
        self.figure.tight_layout(); self.canvas.draw()
        
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های ویجت اضافه کنید
class FormulaBuilderWidget(QtWidgets.QWidget):
    """یک ویجت بصری و تعاملی برای ساخت فرمول‌های محاسباتی."""
    formulaChanged = QtCore.pyqtSignal(str)

    def __init__(self, available_fields: list, current_formula: str, parent=None):
        super().__init__(parent)
        self.available_fields = available_fields
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(8)

        self.formula_display = QtWidgets.QLineEdit(current_formula)
        self.formula_display.setReadOnly(True)
        self.formula_display.setAlignment(QtCore.Qt.AlignLeft)
        self.formula_display.setStyleSheet("background-color: #e9ecef;")
        main_layout.addWidget(self.formula_display)

        builder_layout = QtWidgets.QHBoxLayout()

        # پنل فیلدهای قابل انتخاب
        fields_group = QtWidgets.QGroupBox("فیلدهای عددی فرم")
        fields_layout = QtWidgets.QVBoxLayout(fields_group)
        self.fields_list = QtWidgets.QListWidget()
        self.fields_list.addItems(self.available_fields)
        self.fields_list.itemDoubleClicked.connect(self._add_field_to_formula)
        fields_layout.addWidget(self.fields_list)
        
        # پنل دکمه‌های عملیاتی
        ops_group = QtWidgets.QGroupBox("عملگرها")
        ops_layout = QtWidgets.QGridLayout(ops_group)
        ops = ['+', '-', '*', '/', '(', ')']
        positions = [(i, j) for i in range(3) for j in range(2)]
        for position, op in zip(positions, ops):
            btn = QtWidgets.QPushButton(op)
            btn.setFixedSize(40, 40)
            btn.clicked.connect(lambda _, o=op: self._add_operator_to_formula(f" {o} "))
            ops_layout.addWidget(btn, *position)
        
        btn_clear = QtWidgets.QPushButton("پاک کردن")
        btn_clear.clicked.connect(self.formula_display.clear)

        builder_layout.addWidget(fields_group, 2) # 2/3 فضا
        builder_layout.addWidget(ops_group, 1)    # 1/3 فضا
        main_layout.addLayout(builder_layout)
        main_layout.addWidget(btn_clear)

        self.formula_display.textChanged.connect(self.formulaChanged)

    def _add_field_to_formula(self, item):
        field_name = item.text()
        current_text = self.formula_display.text()
        self.formula_display.setText(current_text + f"[{field_name}]")

    def _add_operator_to_formula(self, operator):
        current_text = self.formula_display.text()
        self.formula_display.setText(current_text + operator)

    def get_formula(self):
        return self.formula_display.text().strip()
    
# این کلاس کاملا جدید را به انتهای فایل، کنار بقیه کلاس‌های دیالوگ اضافه کنید
class ProformaPreviewDialog(QtWidgets.QDialog):
    """دیالوگی برای پیش‌نمایش اطلاعات پیش‌فاکتور قبل از شروع فرآیند."""
# در کلاس ProformaPreviewDialog، متد __init__ را جایگزین کنید
    def __init__(self, invoice_data: dict, parent=None):
        super().__init__(parent)
        header = invoice_data.get('header', {})
        self.setWindowTitle(f"پیش‌نمایش پیش‌فاکتور برای: {header.get('customer_name')}")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        
        customer_group = QtWidgets.QGroupBox("مشخصات خریدار")
        form_layout = QtWidgets.QFormLayout(customer_group)
        form_layout.addRow("شماره سفارش:", QtWidgets.QLabel(f"<b>{header.get('so_number')}</b>"))
        form_layout.addRow("نام شرکت:", QtWidgets.QLabel(header.get('customer_name', '')))
        form_layout.addRow("آدرس:", QtWidgets.QLabel(header.get('address', '')))
        form_layout.addRow("کد اقتصادی:", QtWidgets.QLabel(header.get('tax_id', '')))
        layout.addWidget(customer_group)
        
        items_group = QtWidgets.QGroupBox("اقلام پیش‌فاکتور")
        items_layout = QtWidgets.QVBoxLayout(items_group)
        items_table = QtWidgets.QTableWidget()
        parent._style_table(items_table)
        
        headers = ['شرح کالا', 'تعداد', 'قیمت واحد', 'قیمت کل']
        items_table.setColumnCount(len(headers)); items_table.setHorizontalHeaderLabels(headers)
        
        line_items = invoice_data.get('items', [])
        items_table.setRowCount(len(line_items))
        total_amount = 0
        for r, item in enumerate(line_items):
            total_price = item['quantity'] * item['unit_price']
            total_amount += total_price
            # --- *** اصلاح کلیدی اینجاست: استفاده از فیلد جدید full_item_name *** ---
            items_table.setItem(r, 0, QtWidgets.QTableWidgetItem(item['full_item_name']))
            items_table.setItem(r, 1, NumericTableWidgetItem(str(item['quantity'])))
            items_table.setItem(r, 2, NumericTableWidgetItem(f"{item['unit_price']:,.0f}"))
            items_table.setItem(r, 3, NumericTableWidgetItem(f"{total_price:,.0f}"))
        
        items_table.resizeColumnsToContents()
        items_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        items_layout.addWidget(items_table)
        layout.addWidget(items_group)

        footer_layout = QtWidgets.QHBoxLayout()
        total_label = QtWidgets.QLabel(f"<b>مبلغ کل: {total_amount:,.0f} ریال</b>")
        total_label.setFont(QFont(FONT_FAMILY, 12, QFont.Bold))
        footer_layout.addWidget(total_label)
        footer_layout.addStretch()
        
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setText("✔ تایید و شروع فرآیند")
        buttons.button(QtWidgets.QDialogButtonBox.Ok).setProperty("class", "primary")
        buttons.accepted.connect(self.accept); buttons.rejected.connect(self.reject)
        footer_layout.addWidget(buttons)
        layout.addLayout(footer_layout)
        
# این کلاس جدید را برای اجرای عملیات در پس‌زمینه اضافه کنید
class ItemLoaderWorker(QtCore.QObject):
    """
    یک Worker برای اجرای عملیات سنگین خواندن لیست کالاها در یک رشته مجزا.
    """
    finished = QtCore.pyqtSignal(list)

    def __init__(self, db_instance: 'DB'):
        super().__init__()
        self.db = db_instance

    def run(self):
        """این متد در رشته جدید اجرا شده و لیست کامل کالاها را برمی‌گرداند."""
        results = []
        try:
            results = self.db.items_brief()
        except Exception as e:
            print(f"Error in ItemLoaderWorker: {e}")
            traceback.print_exc()
        
        self.finished.emit(results)
        
# این کلاس کاملا جدید را به انتهای فایل اضافه کنید
class SystemStatusDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش اطلاعات و دسترسی‌های کاربر فعلی جهت دیباگ."""
    def __init__(self, user_info: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle("گزارش وضعیت سیستم و کاربر فعلی")
        self.setMinimumSize(500, 400)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        
        form_layout.addRow("نام کاربری:", QtWidgets.QLabel(f"<b>{user_info.get('username', '---')}</b>"))
        form_layout.addRow("نقش:", QtWidgets.QLabel(f"<b>{user_info.get('role_name', '---')}</b>"))
        layout.addLayout(form_layout)
        
        perms_group = QtWidgets.QGroupBox("لیست دسترسی‌های فعال این نقش")
        perms_layout = QtWidgets.QVBoxLayout(perms_group)
        
        perms_list_widget = QtWidgets.QListWidget()
        permissions = sorted(user_info.get('permissions', []))
        if permissions:
            perms_list_widget.addItems(permissions)
        else:
            perms_list_widget.addItem("هیچ دسترسی فعالی یافت نشد!")

        perms_layout.addWidget(perms_list_widget)
        layout.addWidget(perms_group)
        
# این کلاس کاملا جدید را به فایل اضافه کنید
class NotificationButton(QtWidgets.QPushButton):
    """یک دکمه اعلان هوشمند و مستقل که ظاهر و انیمیشن خودش را مدیریت می‌کند."""
    def __init__(self, parent=None):
        super().__init__("  کارتابل", parent)
        self.animation = None
        
        # تلاش برای بارگذاری آیکون سفارشی با قابلیت جایگزینی (Fallback)
        icon_path = BASE_DIR / 'icons' / 'bell.png'
        icon = QtGui.QIcon(str(icon_path))
        if icon.isNull():
            print("WARNING: 'bell.png' not found or invalid. Falling back to theme icon.")
            icon = QtGui.QIcon.fromTheme("dialog-information")
        
        self.setIcon(icon)
        self.setIconSize(QtCore.QSize(24, 24))
        self.setProperty("class", "sidebar-button")

    def update_count(self, count: int):
        """تعداد اعلان‌ها را گرفته و ظاهر و انیمیشن دکمه را به‌روز می‌کند."""
        self.setText(f"  کارتابل ({count})" if count > 0 else "  کارتابل")
        
        if count > 0:
            if self.animation is None:
                self.animation = QtCore.QSequentialAnimationGroup(self)
                anim1 = QtCore.QPropertyAnimation(self, b"iconSize"); anim1.setDuration(300); anim1.setStartValue(QtCore.QSize(24, 24)); anim1.setEndValue(QtCore.QSize(28, 28)); anim1.setEasingCurve(QtCore.QEasingCurve.OutCubic)
                anim2 = QtCore.QPropertyAnimation(self, b"iconSize"); anim2.setDuration(500); anim2.setStartValue(QtCore.QSize(28, 28)); anim2.setEndValue(QtCore.QSize(24, 24)); anim2.setEasingCurve(QtCore.QEasingCurve.InOutSine)
                self.animation.addAnimation(anim1); self.animation.addAnimation(anim2)
                self.animation.setLoopCount(-1)

            if self.animation.state() != QtCore.QAbstractAnimation.Running:
                self.animation.start()

            self.setStyleSheet("""
                QPushButton { color: #1abc9c; background-color: #ecf0f1; border: none; text-align: right;
                padding: 13px 22px; font-size: 11pt; font-weight: bold;
                border-right: 5px solid #1abc9c; }
                QPushButton:hover { background-color: #ffffff; }
            """)
        else:
            if self.animation and self.animation.state() == QtCore.QAbstractAnimation.Running:
                self.animation.stop()
                self.setIconSize(QtCore.QSize(24, 24))
            self.setStyleSheet("") # بازگشت به استایل پیش‌فرض کلاس خودش
            
# این کلاس جدید را برای مدیریت سیگنال‌ها اضافه کنید
class DBsignals(QtCore.QObject):
    dataChanged = QtCore.pyqtSignal(str) # سیگنالی که یک رشته (کلید) را منتشر می‌کند
    
# کلاس PurchasingWorkbenchWidget را به طور کامل با این نسخه جایگزین کنید
class PurchasingWorkbenchWidget(QtWidgets.QWidget):
    """میزکار یکپارچه و هوشمند برای مدیریت کامل فرآیند خرید."""
    def __init__(self, db: DB, user_id: int, parent_window):
        super().__init__(parent_window)
        self.db = db; self.user_id = user_id; self.parent_window = parent_window
        self.toast = getattr(parent_window, 'toast', None)
        self.current_pr_id = None

        main_layout = QtWidgets.QVBoxLayout(self); main_layout.setContentsMargins(0, 10, 0, 0)
        self.tabs = QtWidgets.QTabWidget(); self.tabs.setObjectName("interfaceTabWidget")
        main_layout.addWidget(self.tabs)

        # Tab 1: Sourcing Center
        sourcing_page = QtWidgets.QWidget()
        sourcing_layout = QtWidgets.QHBoxLayout(sourcing_page)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        
        pr_list_group = QtWidgets.QGroupBox("۱. درخواست‌های نیازمند استعلام")
        pr_list_layout = QtWidgets.QVBoxLayout(pr_list_group)
        self.tbl_sourcing_prs = QtWidgets.QTableWidget(); self.parent_window._style_table(self.tbl_sourcing_prs)
        self.tbl_sourcing_prs.itemSelectionChanged.connect(self._on_pr_selected)
        pr_list_layout.addWidget(self.tbl_sourcing_prs)
        splitter.addWidget(pr_list_group)

        quotes_group = QtWidgets.QGroupBox("۲. پیشنهاد قیمت‌ها برای درخواست انتخاب شده")
        quotes_layout = QtWidgets.QVBoxLayout(quotes_group)
        self.tbl_quotes = QtWidgets.QTableWidget(); self.parent_window._style_table(self.tbl_quotes)
        quotes_layout.addWidget(self.tbl_quotes)
        quotes_toolbar = QtWidgets.QHBoxLayout()
        btn_add_quote = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), "افزودن پیشنهاد قیمت")
        btn_select_quote = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "انتخاب به عنوان برنده"); btn_select_quote.setProperty("class", "primary")
        quotes_toolbar.addStretch(); quotes_toolbar.addWidget(btn_add_quote); quotes_toolbar.addWidget(btn_select_quote)
        quotes_layout.addLayout(quotes_toolbar)
        splitter.addWidget(quotes_group)
        splitter.setSizes([400, 550])
        sourcing_layout.addWidget(splitter)
        
        btn_add_quote.clicked.connect(self._add_quote_action)
        btn_select_quote.clicked.connect(self._select_quote_action)
        
        # Tab 2: Ordering Center
        ordering_page = QtWidgets.QWidget()
        ordering_layout = QtWidgets.QVBoxLayout(ordering_page)
        ordering_layout.addWidget(QtWidgets.QLabel("درخواست‌ها بر اساس تامین‌کننده برای صدور سفارش خرید تجمیعی (Aggregated PO) گروه‌بندی شده‌اند."))
        self.tree_ordering = QtWidgets.QTreeWidget(); self.parent_window._style_tree(self.tree_ordering, headers=["تامین‌کننده / کالا", "تعداد درخواستی"])
        ordering_layout.addWidget(self.tree_ordering)
        btn_issue_po = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-send"), "صدور سفارش خرید برای تامین‌کننده انتخابی"); btn_issue_po.setProperty("class", "primary")
        btn_issue_po.clicked.connect(self._issue_aggregated_po_action)
        ordering_layout.addWidget(btn_issue_po, 0, QtCore.Qt.AlignRight)

        self.tabs.addTab(sourcing_page, "مرکز استعلام (Sourcing)")
        self.tabs.addTab(ordering_page, "مرکز سفارش (Ordering)")
        self.tabs.currentChanged.connect(self.refresh_data)

    def refresh_data(self):
        """تمام داده‌های میزکار را بر اساس تب فعال، بارگذاری مجدد می‌کند."""
        current_tab_index = self.tabs.currentIndex()
        if current_tab_index == 0:
            self._load_sourcing_requests()
            self._load_quotes_for_pr(None)
        elif current_tab_index == 1:
            self._load_requests_ready_for_po()

    def _load_sourcing_requests(self):
        table = self.tbl_sourcing_prs
        table.setRowCount(0); requests = self.db.get_approved_purchase_requests_for_sourcing()
        headers = ['ID درخواست', 'کالا', 'مقدار', 'درخواست‌دهنده', 'تاریخ']
        table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
        table.setRowCount(len(requests))
        for r, req in enumerate(requests):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(req['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(req['item_name']))
            table.setItem(r, 2, NumericTableWidgetItem(str(req['requested_qty'])))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(req['requester_name']))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(req['request_date'])))
        table.setColumnHidden(0, True); table.resizeColumnsToContents(); table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        set_empty_placeholder(table, "هیچ درخواست خریدی نیازمند استعلام قیمت نیست.")

    def _on_pr_selected(self):
        selected = self.tbl_sourcing_prs.selectedItems()
        if not selected:
            self.current_pr_id = None; self._load_quotes_for_pr(None); return
        self.current_pr_id = int(self.tbl_sourcing_prs.item(selected[0].row(), 0).text())
        self._load_quotes_for_pr(self.current_pr_id)
        
    def _load_quotes_for_pr(self, request_id):
        table = self.tbl_quotes
        table.setRowCount(0)
        if request_id is None: return
        quotes = self.db.get_quotes_for_request(request_id)
        headers = ['ID', 'تامین‌کننده', 'قیمت واحد', 'زمان تحویل', 'یادداشت']
        table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers); table.setRowCount(len(quotes))
        for r, quote in enumerate(quotes):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(quote['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(quote['supplier_name']))
            table.setItem(r, 2, NumericTableWidgetItem(f"{quote['unit_price']:,.0f}"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(f"{quote['lead_time_days']} روز"))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(quote['notes']))
        table.setColumnHidden(0, True); table.resizeColumnsToContents(); table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
    
    def _add_quote_action(self):
        if self.current_pr_id is None:
            self.toast.show_message("ابتدا یک درخواست خرید را از لیست سمت چپ انتخاب کنید.", "warning"); return
        dlg = AddQuoteDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            quote_data = dlg.get_data();
            if quote_data:
                quote_data['request_id'] = self.current_pr_id
                self.db.add_quote(quote_data, self.user_id)
                self.toast.show_message("✔ پیشنهاد قیمت جدید ثبت شد.", "success")
                self._load_quotes_for_pr(self.current_pr_id)
                self._load_sourcing_requests() # برای آپدیت وضعیت

    def _select_quote_action(self):
        selected_quote = self.tbl_quotes.selectedItems()
        if self.current_pr_id is None or not selected_quote:
            self.toast.show_message("لطفاً هم درخواست خرید و هم پیشنهاد برنده را انتخاب کنید.", "warning"); return
        quote_id = int(self.tbl_quotes.item(selected_quote[0].row(), 0).text())
        self.db.select_winning_quote(self.current_pr_id, quote_id, self.user_id)
        self.toast.show_message("✔ پیشنهاد برنده انتخاب شد.", "success")
        self.refresh_data() # برای انتقال درخواست به تب بعدی

    def _load_requests_ready_for_po(self):
        tree = self.tree_ordering
        tree.clear()
        grouped_data = self.db.get_requests_ready_for_po_grouped_by_supplier()
        for group in grouped_data:
            parent_item = QtWidgets.QTreeWidgetItem(tree, [f"{group['supplier_name']} ({group['request_count']} درخواست)", ""])
            parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
            parent_item.setData(0, Qt.UserRole, {'supplier_id': group['supplier_id'], 'pr_ids': [r['pr_id'] for r in group['requests']]})
            for req in group['requests']:
                QtWidgets.QTreeWidgetItem(parent_item, [req['item_name'], str(req['requested_qty'])])
        tree.expandAll()

    def _issue_aggregated_po_action(self):
        selected = self.tree_ordering.selectedItems()
        if not selected or selected[0].parent() is not None: # فقط روی آیتم‌های والد (تامین‌کننده) کار کند
            self.toast.show_message("لطفاً یک تامین‌کننده را از لیست برای صدور سفارش انتخاب کنید.", "warning"); return
        
        data = selected[0].data(0, Qt.UserRole)
        supplier_id = data['supplier_id']; pr_ids = data['pr_ids']
        
        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا برای {len(pr_ids)} درخواست از این تامین‌کننده، یک سفارش خرید صادر شود؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                po_number = self.db.create_aggregated_purchase_order(supplier_id, pr_ids, self.user_id)
                self.toast.show_message(f"✔ سفارش خرید تجمیعی با شماره {po_number} با موفقیت صادر شد.", "success")
                self.refresh_data()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند صدور PO با خطا مواجه شد:\n{e}")
                                                
# کلاس TraceabilityDialog را به طور کامل با این نسخه جایگزین کنید

class TraceabilityDialog(QtWidgets.QDialog):
    """دیالوگی برای نمایش گزارش ردیابی و دارای ابزار دیباگ."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle("ابزار ردیابی محصول به تامین‌کننده")
        self.setMinimumSize(700, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))

        layout = QtWidgets.QVBoxLayout(self)
        search_layout = QtWidgets.QHBoxLayout()
        self.batch_input = QtWidgets.QLineEdit(placeholderText="شماره بچ محصول نهایی (بسته‌بندی شده) یا محصول فله را وارد کنید...")
        search_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), "ردیابی کن")
        search_btn.setProperty("class", "primary")
        
        # --- دکمه جدید دیباگ ---
        debug_btn = QtWidgets.QPushButton("دیباگ لاگ")
        debug_btn.setStyleSheet("background-color: #f39c12; color: white;") # Orange color
        
        search_layout.addWidget(self.batch_input, 1)
        search_layout.addWidget(search_btn)
        search_layout.addWidget(debug_btn) # افزودن دکمه به layout
        layout.addLayout(search_layout)

        self.results_tree = QtWidgets.QTreeWidget()
        self.results_tree.setHeaderLabels(["شرح ردیابی", "جزئیات"])
        self.results_tree.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.results_tree)

        search_btn.clicked.connect(self._run_trace)
        debug_btn.clicked.connect(self._debug_log) # اتصال دکمه جدید
        self.batch_input.returnPressed.connect(self._run_trace)

    def _debug_log(self):
        """تابع جدید برای اجرای عملیات دیباگ."""
        batch_no = self.batch_input.text().strip()
        if not batch_no:
            print("DEBUG: Please enter a batch number first.")
            return
        print(f"\n--- DEBUGGING TRACEABILITY FOR BATCH: {batch_no} ---")
        log_content = self.db.debug_get_packing_audit_log(batch_no)
        
        # چاپ نتیجه در کنسول
        print("--- RAW AUDIT LOG CONTENT ---")
        print(log_content)
        print("-----------------------------")
        
        QtWidgets.QMessageBox.information(self, "دیباگ", "نتیجه دیباگ در کنسول چاپ شد. لطفاً آن را برای تحلیل ارسال کنید.")

    def _run_trace(self):
        self.results_tree.clear()
        batch_no = self.batch_input.text().strip()
        if not batch_no: return

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            full_report = self.db.get_full_traceability_report(batch_no)
            if not full_report:
                QtWidgets.QTreeWidgetItem(self.results_tree, ["هیچ سابقه‌ای برای این بچ یافت نشد."])
                return

            root_item = QtWidgets.QTreeWidgetItem(self.results_tree, [f"نتایج ردیابی برای بچ ورودی: {batch_no}"])
            root_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))

            for bulk_batch, raw_materials in full_report.items():
                bulk_item = QtWidgets.QTreeWidgetItem(root_item, [f"ساخته شده از محصول فله با بچ: {bulk_batch}"])
                bulk_item.setIcon(0, QtGui.QIcon.fromTheme("lab-flask"))
                
                if not raw_materials:
                    QtWidgets.QTreeWidgetItem(bulk_item, ["مواد اولیه برای این بچ فله یافت نشد."])
                    continue
                
                for material in raw_materials:
                    material_item = QtWidgets.QTreeWidgetItem(bulk_item, [material['raw_material_name'], f"بچ: {material['raw_batch']}"])
                    supplier_name = material.get('supplier_name') or "نامشخص (موجودی اولیه)"
                    QtWidgets.QTreeWidgetItem(material_item, ["تامین‌کننده", supplier_name])
                    if material.get('po_number'):
                        QtWidgets.QTreeWidgetItem(material_item, ["شماره سفارش خرید", material['po_number']])

            self.results_tree.expandAll()
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
                                    
            
# این کلاس را به طور کامل با نسخه قبلی خودش جایگزین کنید
class ProcessMonitorWidget(QtWidgets.QWidget):
    """یک ویجت گرافیکی برای نمایش وضعیت تمام فرآیندهای در حال اجرا به صورت کانبان (با مدیریت حالت خالی)."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.columns = {}
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 10, 0, 0)

        selector_layout = QtWidgets.QHBoxLayout()
        selector_layout.addWidget(QtWidgets.QLabel("<b>فرآیند مورد نظر برای مانیتورینگ را انتخاب کنید:</b>"))
        self.workflow_combo = QtWidgets.QComboBox()
        self.workflow_combo.setMinimumWidth(300)
        selector_layout.addWidget(self.workflow_combo)
        selector_layout.addStretch()
        main_layout.addLayout(selector_layout)

        # --- بخش جدید: استفاده از QStackedWidget ---
        self.stack = QtWidgets.QStackedWidget()
        main_layout.addWidget(self.stack, 1)

        # پنل ۱: بورد کانبان
        scroll_area = QtWidgets.QScrollArea(); scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("QScrollArea { border: none; background-color: transparent; }")
        self.board_widget = QtWidgets.QWidget()
        self.board_layout = QtWidgets.QHBoxLayout(self.board_widget)
        self.board_layout.setSpacing(15)
        scroll_area.setWidget(self.board_widget)
        self.stack.addWidget(scroll_area)

        # پنل ۲: پیام راهنما برای حالت خالی
        self.placeholder_label = QtWidgets.QLabel(
            "هیچ فرآیند فعالی (Active) برای مانیتورینگ یافت نشد.\n\n"
            "لطفاً ابتدا از تب 'مدیریت فرآیندها'، یک فرآیند را به طور کامل تایید و فعال کنید."
        )
        self.placeholder_label.setAlignment(Qt.AlignCenter)
        self.placeholder_label.setFont(QFont(FONT_FAMILY, 12, QFont.Bold))
        self.placeholder_label.setStyleSheet("color: #6c757d;")
        self.stack.addWidget(self.placeholder_label)
        # --- پایان بخش جدید ---

        self.workflow_combo.currentIndexChanged.connect(self._on_workflow_selected)
        self._populate_workflows()

    def _populate_workflows(self):
        """لیست فرآیندهای فعال را در کمبوباکس بارگذاری کرده و وضعیت نمایش را تنظیم می‌کند."""
        self.workflow_combo.blockSignals(True)
        self.workflow_combo.clear()
        
        active_workflows = self.db.get_active_workflows()
        
        if not active_workflows:
            self.workflow_combo.addItem("--- هیچ فرآیند فعالی یافت نشد ---")
            self.workflow_combo.setEnabled(False)
            self.stack.setCurrentWidget(self.placeholder_label) # نمایش پیام راهنما
        else:
            self.workflow_combo.setEnabled(True)
            self.workflow_combo.addItem("--- یک فرآیند را انتخاب کنید ---", None)
            for wf in active_workflows:
                self.workflow_combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])
            self.stack.setCurrentWidget(self.board_widget.parent()) # نمایش بورد کانبان
        
        self.workflow_combo.blockSignals(False)
        self._clear_board()

    def _on_workflow_selected(self):
        workflow_id = self.workflow_combo.currentData()
        self._clear_board()
        if not workflow_id:
            return

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            steps = self.db.get_workflow_steps(workflow_id)
            instances = self.db.get_all_process_instances_for_workflow(workflow_id)
            
            for step in steps:
                step_id = step['id']
                col_widget = QtWidgets.QListWidget()
                col_widget.setStyleSheet("QListWidget { border: 1px solid #dfe4ea; border-radius: 5px; background-color: #f8f9fa; }")
                col_widget.setSpacing(8)
                
                col_container = QtWidgets.QWidget(); col_layout = QtWidgets.QVBoxLayout(col_container)
                col_layout.addWidget(QtWidgets.QLabel(f"<b>{step['step_name']} ({sum(1 for i in instances if i['current_step_id'] == step_id)})</b>"))
                col_layout.addWidget(col_widget)
                self.board_layout.addWidget(col_container)
                self.columns[step_id] = col_widget

            for instance in instances:
                step_id = instance['current_step_id']
                if step_id in self.columns:
                    card_widget = self._create_instance_card(instance)
                    list_item = QtWidgets.QListWidgetItem(self.columns[step_id])
                    list_item.setSizeHint(card_widget.sizeHint())
                    self.columns[step_id].addItem(list_item)
                    self.columns[step_id].setItemWidget(list_item, card_widget)
            
            self.board_layout.addStretch()

        finally:
            QtWidgets.QApplication.restoreOverrideCursor()

    def _clear_board(self):
        self.columns = {}
        while self.board_layout.count():
            child = self.board_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

    def _create_instance_card(self, instance_data):
        card = QtWidgets.QFrame(); card.setFrameShape(QtWidgets.QFrame.StyledPanel)
        card.setStyleSheet("background-color: white; border-radius: 4px; border: 1px solid #ced4da; padding: 8px;")
        layout = QtWidgets.QVBoxLayout(card)
        
        details = instance_data.get('document_details', {})
        item_name = details.get('item_name', f"سند شماره {instance_data['related_record_id']}")
        
        layout.addWidget(QtWidgets.QLabel(f"<b>{item_name}</b>"))
        layout.addWidget(QtWidgets.QLabel(f"شروع توسط: {instance_data['initiator_name']}"))
        layout.addWidget(QtWidgets.QLabel(f"تاریخ: {to_shamsi(instance_data['started_at'])}"))
        card.setToolTip(f"جزئیات: {details}")
        return card
    
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ProductionStockDetailDialog(QtWidgets.QDialog):
    """
    دیالوگی اختصاصی برای نمایش جزئیات موجودی یک کالا فقط در انبار تولید.
    """
    def __init__(self, db: DB, item_id: int, item_name: str, parent=None):
        super().__init__(parent)
        self.db = db
        self.setWindowTitle(f"جزئیات موجودی در انبار تولید: {item_name}")
        self.setMinimumWidth(550)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(table)
        
        headers = ["شماره بچ", "تاریخ انقضا", "مقدار موجود", "واحد"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        
        stock_details = self.db.get_stock_details_for_item_in_warehouse(item_id, 'Production')
        table.setRowCount(len(stock_details))

        for r, detail in enumerate(stock_details):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(detail['batch_no']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(to_shamsi(detail.get('expiry_date'))))
            table.setItem(r, 2, NumericTableWidgetItem(str(detail['qty'])))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(detail.get('unit', '')))
        
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(table)
        
# این کلاس جدید را به فایل خود اضافه کنید
class WorkflowActionWorker(QtCore.QObject):
    """یک کارگر برای اجرای اقدامات فرآیند در یک نخ پس‌زمینه."""
    finished = QtCore.pyqtSignal(bool, str) # سیگنال خروجی: وضعیت موفقیت، پیام

    def __init__(self, db_instance, task_data, user_id, outcome, reason):
        super().__init__()
        self.db = db_instance
        self.task_data = task_data
        self.user_id = user_id
        self.outcome = outcome
        self.reason = reason

    def run(self):
        """این متد در نخ جدید اجرا می‌شود."""
        try:
            self.db.advance_workflow_instance(
                process_instance_id=self.task_data['process_instance_id'],
                user_id=self.user_id,
                outcome=self.outcome,
                reason=self.reason
            )
            self.finished.emit(True, "اقدام شما با موفقیت ثبت و اجرا شد.")
        except Exception as e:
            # ارسال متن خطا به پنجره اصلی
            self.finished.emit(False, str(e))
            
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید
class ProductionWorkbenchDialog(QtWidgets.QDialog):
    """میزکار هوشمند برای برنامه‌ریزی تولید."""
    def __init__(self, db: DB, user_id: int, production_order_id: int, parent=None):
        super().__init__(parent)
        self.db = db
        self.user_id = user_id
        self.production_order_id = production_order_id
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)
        self.requirements_data = [] # برای نگهداری اطلاعات نیازمندی‌ها

        # خواندن اطلاعات سفارش از دیتابیس
        order_details = self.db.execute_query("SELECT po.*, i.name as item_name FROM production_orders po JOIN items i ON po.item_id = i.id WHERE po.id = %s", (self.production_order_id,), fetch_one=True)
        self.order_data = dict(order_details) if order_details else {}

        self.setWindowTitle(f"میزکار برنامه‌ریزی برای سفارش: {self.order_data.get('item_name', '')}")
        self.setMinimumSize(900, 500)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel(f"<b>بررسی نیازمندی‌ها برای تولید {self.order_data.get('quantity', 0)} پک از محصول:</b>"))
        
        self.requirements_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'):
            self.parent_window._style_table(self.requirements_table)
        layout.addWidget(self.requirements_table)

        self.pack_button = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("utilities-x-archive"), "موجودی کافیست، شروع عملیات بسته‌بندی")
        self.pack_button.setProperty("class", "primary")
        self.pack_button.setMinimumHeight(40)
        self.pack_button.setEnabled(False) # در ابتدا غیرفعال است
        self.pack_button.clicked.connect(self._start_packing_process)
        layout.addWidget(self.pack_button)
        
        self._load_requirements()

    def _load_requirements(self):
        """نیازمندی‌های سفارش (مواد فله و لوازم بسته‌بندی) را محاسبه و نمایش می‌دهد."""
        pack_item_details = self.db.get_item_details(self.order_data.get('item_id'))
        if not pack_item_details or not pack_item_details.get('parent_item_id'):
            self.toast.show_message("این سفارش به یک محصول مادر متصل نیست.", "critical", msec=10000)
            self.close(); return

        parent_item_details = self.db.get_item_details(pack_item_details['parent_item_id'])
        if not parent_item_details:
             QtWidgets.QMessageBox.critical(self, "خطای داده", "محصول مادر مرتبط با این پک یافت نشد."); self.close(); return
        
        # گام ۱: تشخیص نوع محصول (تک یا دوجزئی) از روی اطلاعات محصول مادر
        is_two_component_product = parent_item_details.get('is_two_component', False)
        
        bulk_components_to_process = []
        total_ratio_parts = 0

        # گام ۲: پیدا کردن فرمول‌های فعال بر اساس نوع محصول
        if is_two_component_product:
            master_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'MASTER' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            if not master_recipe:
                QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"برای محصول دوجزئی «{parent_item_details['name']}» یک «دستور ساخت مادر» فعال تعریف نشده است."); self.close(); return
            
            # خواندن نسبت اختلاط از فرمول مادر
            properties = master_recipe.get('properties', {});
            if isinstance(properties, str) and properties: properties = json.loads(properties)
            mix_ratio = properties.get('mix_ratio', {}); ratio_a = mix_ratio.get('A', 0); ratio_b = mix_ratio.get('B', 0)
            total_ratio_parts = ratio_a + ratio_b
            if total_ratio_parts <= 0:
                 QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"نسبت اختلاط در دستور ساخت مادر برای محصول «{parent_item_details['name']}» به درستی تعریف نشده است."); self.close(); return
            
            part_a_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'A' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            part_b_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'B' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            
            if not part_a_recipe or not part_b_recipe: 
                QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"برای محصول «{parent_item_details['name']}» فرمول ساخت فعال برای پارت A یا B تعریف نشده است."); self.close(); return
            
            bulk_components_to_process.append({'recipe': part_a_recipe, 'ratio': ratio_a})
            bulk_components_to_process.append({'recipe': part_b_recipe, 'ratio': ratio_b})
        else: # محصول تک‌جزئی
            single_part_recipe = self.db.execute_query("SELECT * FROM recipes WHERE parent_product_id = %s AND part_type = 'P' AND status = 'ACTIVE' LIMIT 1", (pack_item_details['parent_item_id'],), fetch_one=True)
            if not single_part_recipe: 
                QtWidgets.QMessageBox.critical(self, "خطای فرآیند", f"هیچ فرمول ساخت فعال (تک جزئی - پارت P) برای محصول «{parent_item_details['name']}» تعریف نشده است."); self.close(); return
            total_ratio_parts = 1.0
            bulk_components_to_process.append({'recipe': single_part_recipe, 'ratio': 1.0})

        # گام ۳: پیدا کردن لیست لوازم بسته‌بندی
        packaging_bom = self.db.get_bom_for_product(pack_item_details['name'])

        # گام ۴: پر کردن جدول نیازمندی‌ها
        headers = ["نوع جزء", "نام جزء", "مقدار مورد نیاز", "موجودی در دسترس (کف کارگاه)", "کسری", "اقدام"]
        self.requirements_table.setColumnCount(len(headers)); self.requirements_table.setHorizontalHeaderLabels(headers)
        all_requirements_met = True
        
        # افزودن ردیف برای مواد فله
        for comp_data in bulk_components_to_process:
            bulk_item_id = comp_data['recipe'].get('produces_item_id')
            if not bulk_item_id:
                all_requirements_met = False
                continue # اگر فرمول به محصول خروجی متصل نباشد
                
            bulk_item_details = self.db.get_item_details(bulk_item_id)
            if not bulk_item_details:
                all_requirements_met = False
                continue

            r = self.requirements_table.rowCount(); self.requirements_table.insertRow(r)
            required_qty = (pack_item_details.get('net_weight', 0) / total_ratio_parts) * comp_data['ratio'] * self.order_data['quantity']
            available_qty = self.db.get_item_stock_in_warehouse(bulk_item_details['id'], PRODUCTION_WAREHOUSE_NAME)
            deficit = max(0, required_qty - available_qty)

            if deficit > 0: all_requirements_met = False
                
            self.requirements_data.append({'component_details': bulk_item_details, 'required_qty': required_qty, 'is_bulk': True})
            
            self.requirements_table.setItem(r, 0, QtWidgets.QTableWidgetItem("محصول فله"))
            self.requirements_table.setItem(r, 1, QtWidgets.QTableWidgetItem(bulk_item_details['name']))
            self.requirements_table.setItem(r, 2, NumericTableWidgetItem(f"{required_qty:.3f}"))
            self.requirements_table.setItem(r, 3, NumericTableWidgetItem(f"{available_qty:.3f}"))
            
            deficit_item = NumericTableWidgetItem(f"{deficit:.3f}"); 
            if deficit > 0: deficit_item.setBackground(QtGui.QColor("#fff3cd"))
            self.requirements_table.setItem(r, 4, deficit_item)
            
            if deficit > 0:
                btn_produce = QtWidgets.QPushButton("شروع تولید..."); btn_produce.setProperty("class", "danger")
                btn_produce.clicked.connect(lambda _, d=bulk_item_details, q=deficit: self._trigger_bulk_production(d, q))
                self.requirements_table.setCellWidget(r, 5, btn_produce)
            else:
                ok_item = QtWidgets.QTableWidgetItem("✔"); ok_item.setForeground(QtGui.QColor("green"))
                self.requirements_table.setItem(r, 5, ok_item)

        # افزودن ردیف برای لوازم بسته‌بندی
        for item in packaging_bom:
            comp_details = self.db.get_item_details(item['component_item_id'])
            if not comp_details or comp_details['category'] != CATEGORY_PACKAGING: continue
            
            r = self.requirements_table.rowCount(); self.requirements_table.insertRow(r)
            required_qty = item['quantity'] * self.order_data['quantity']
            available_qty = self.db.get_item_stock_in_warehouse(comp_details['id'], PRODUCTION_WAREHOUSE_NAME)
            deficit = max(0, required_qty - available_qty)

            if deficit > 0: all_requirements_met = False

            self.requirements_data.append({'component_details': comp_details, 'required_qty': required_qty, 'is_bulk': False})

            self.requirements_table.setItem(r, 0, QtWidgets.QTableWidgetItem("لوازم بسته‌بندی"))
            self.requirements_table.setItem(r, 1, QtWidgets.QTableWidgetItem(comp_details['name']))
            self.requirements_table.setItem(r, 2, NumericTableWidgetItem(f"{required_qty:.3f}"))
            self.requirements_table.setItem(r, 3, NumericTableWidgetItem(f"{available_qty:.3f}"))
            
            deficit_item = NumericTableWidgetItem(f"{deficit:.3f}"); 
            if deficit > 0: deficit_item.setBackground(QtGui.QColor("#fff3cd"))
            self.requirements_table.setItem(r, 4, deficit_item)
            
            if deficit > 0:
                btn_request = QtWidgets.QPushButton("درخواست از انبار")
                # بررسی اینکه آیا درخواست فعال از قبل وجود دارد یا خیر
                if not self.db.does_active_material_request_exist(self.production_order_id, comp_details['id']):
                    btn_request.clicked.connect(lambda _, d=comp_details, q=deficit, b=btn_request: self._request_supply_from_warehouse(d, q, b))
                else:
                    btn_request.setText("درخواست ارسال شده")
                    btn_request.setEnabled(False)
                self.requirements_table.setCellWidget(r, 5, btn_request)
            else:
                ok_item = QtWidgets.QTableWidgetItem("✔"); ok_item.setForeground(QtGui.QColor("green"))
                self.requirements_table.setItem(r, 5, ok_item)

        self.pack_button.setEnabled(all_requirements_met)
        self.requirements_table.resizeColumnsToContents()
        self.requirements_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        
    def _request_supply_from_warehouse(self, component_details: dict, required_qty: float, sender_button: QtWidgets.QPushButton):
        """یک درخواست مواد اولیه برای لوازم بسته‌بندی کسری، به انبار ارسال می‌کند."""
        try:
            self.db.submit_material_request(
                item_id=component_details['id'], 
                requested_qty=required_qty, 
                requester_id=self.user_id,
                notes=f"درخواست خودکار از میزکار تولید برای سفارش شماره {self.production_order_id}"
            )
            self.toast.show_message(f"✔ درخواست برای «{component_details['name']}» به کارتابل انبار ارسال شد.", "success")
            if sender_button:
                sender_button.setText("درخواست ارسال شده")
                sender_button.setEnabled(False)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در ثبت درخواست", f"خطا: {e}")

    def _trigger_bulk_production(self, bulk_item_details: dict, needed_qty: float):
        """کاربر را به فرم گزارش تولید هدایت می‌کند تا برای کسری محصول فله، تولید جدیدی ثبت کند."""
        min_batch_size, ok = QtWidgets.QInputDialog.getDouble(self, "حداقل بچ تولید", f"برای «{bulk_item_details['name']}» حداقل چه مقداری باید تولید شود؟\n(نیاز فعلی سفارش: {needed_qty:.3f})", 250.0, needed_qty, 10000, 2)
        if ok and min_batch_size > 0:
            prefill_data = {
                'product_name': bulk_item_details['name'],
                'quantity': min_batch_size,
                'linked_pack_order_id': self.production_order_id # اتصال به سفارش پک مادر
            }
            # فراخوانی متد اصلی پنجره مادر برای باز کردن دیالوگ تولید
            self.parent_window._open_report_production_dialog(prefill_data=prefill_data)
            self.close() # بستن میزکار فعلی

    def _start_packing_process(self):
        """پلن مصرف را ساخته، به کاربر نمایش داده و در صورت تایید، عملیات را در دیتابیس اجرا می‌کند."""
        # این متد در گام بعدی تکمیل خواهد شد
        self.toast.show_message("منطق نهایی بسته‌بندی در مرحله بعد پیاده‌سازی می‌شود.", "info")
        
        
# این کلاس کاملا جدید را به فایل کد خود اضافه کنید

class ManageDepartmentRolesDialog(QtWidgets.QDialog):
    """پنجره‌ای برای مدیریت تخصیص نقش‌ها به واحدهای سازمانی."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)
        self.current_dept_id = None

        self.setWindowTitle("مدیریت نقش‌های واحدها")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(700, 500)

        main_layout = QtWidgets.QHBoxLayout(self)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # پنل چپ: لیست واحدها
        left_panel = QtWidgets.QWidget(); left_layout = QtWidgets.QVBoxLayout(left_panel)
        left_layout.addWidget(QtWidgets.QLabel("<b>۱. واحد سازمانی را انتخاب کنید:</b>"))
        self.dept_list = QtWidgets.QListWidget()
        self.dept_list.itemSelectionChanged.connect(self._on_department_selected)
        left_layout.addWidget(self.dept_list)
        splitter.addWidget(left_panel)
        
        # پنل راست: لیست نقش‌ها با چک‌باکس
        right_panel = QtWidgets.QWidget(); right_layout = QtWidgets.QVBoxLayout(right_panel)
        self.roles_label = QtWidgets.QLabel("<b>۲. نقش‌های مجاز را مشخص کنید:</b>")
        right_layout.addWidget(self.roles_label)
        self.roles_table = QtWidgets.QTableWidget(0, 2)
        self.roles_table.setHorizontalHeaderLabels(['نام نقش', 'مجاز است؟'])
        self.roles_table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        right_layout.addWidget(self.roles_table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره تغییرات برای این واحد")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_assignments)
        right_layout.addWidget(btn_save)
        splitter.addWidget(right_panel)
        
        main_layout.addWidget(splitter)
        
        self._load_departments()
        self._load_all_roles()

    def _load_departments(self):
        departments = self.db.get_departments_tree()
        for dept in sorted(departments, key=lambda d: d['name']):
            item = QtWidgets.QListWidgetItem(dept['name'])
            item.setData(Qt.UserRole, dept['id'])
            self.dept_list.addItem(item)
            
    def _load_all_roles(self):
        all_roles = self.db.get_all_roles()
        self.roles_table.setRowCount(len(all_roles))
        for r, role in enumerate(all_roles):
            name_item = QtWidgets.QTableWidgetItem(role['name'])
            name_item.setData(Qt.UserRole, role['id'])
            name_item.setFlags(name_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.roles_table.setItem(r, 0, name_item)
            
            checkbox_widget = QtWidgets.QWidget()
            chk_layout = QtWidgets.QHBoxLayout(checkbox_widget)
            chk_box = QtWidgets.QCheckBox()
            chk_layout.addWidget(chk_box)
            chk_layout.setAlignment(QtCore.Qt.AlignCenter)
            self.roles_table.setCellWidget(r, 1, checkbox_widget)
        self.roles_table.setEnabled(False)

    def _on_department_selected(self):
        selected = self.dept_list.selectedItems()
        if not selected:
            self.current_dept_id = None
            self.roles_table.setEnabled(False)
            return
            
        self.current_dept_id = selected[0].data(Qt.UserRole)
        self.roles_table.setEnabled(True)
        self.roles_label.setText(f"<b>۲. نقش‌های مجاز برای «{selected[0].text()}»:</b>")
        
        assigned_role_ids = self.db.get_role_ids_for_department(self.current_dept_id)
        
        for r in range(self.roles_table.rowCount()):
            role_id = self.roles_table.item(r, 0).data(Qt.UserRole)
            chk_box = self.roles_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            chk_box.setChecked(role_id in assigned_role_ids)

    def _save_assignments(self):
        if self.current_dept_id is None:
            self.toast.show_message("لطفاً ابتدا یک واحد سازمانی را انتخاب کنید.", "warning")
            return
        
        selected_role_ids = []
        for r in range(self.roles_table.rowCount()):
            chk_box = self.roles_table.cellWidget(r, 1).findChild(QtWidgets.QCheckBox)
            if chk_box.isChecked():
                selected_role_ids.append(self.roles_table.item(r, 0).data(Qt.UserRole))

        try:
            self.db.update_roles_for_department(self.current_dept_id, selected_role_ids)
            self.toast.show_message("✔ ارتباط نقش‌ها و واحد با موفقیت ذخیره شد.", "success")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی: {e}")
            
# این کلاس کاملا جدید را به انتهای فایل اضافه کنید

class SystemOperationMappingDialog(QtWidgets.QDialog):
    """پنجره‌ای برای اتصال بصری عملیات‌های سیستمی به فرآیندهای QA."""
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.toast = getattr(parent, 'toast', None)

        # دیکشنری اصلی عملیات‌های سیستمی
        self.SYSTEM_OPERATIONS = {
            'DISPATCH_CENTER_START_PROCESS': "شروع فرآیند از مرکز ارسال"
            # در آینده می‌توانید عملیات‌های دیگر را به این دیکشنری اضافه کنید
        }

        self.setWindowTitle("اتصال فرآیندها به عملیات سیستمی")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(750, 400)
        
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(QtWidgets.QLabel("برای هر عملیات سیستم، مشخص کنید کدام فرآیند باید اجرا شود:"))

        self.table = QtWidgets.QTableWidget()
        if hasattr(parent, '_style_table'):
            parent._style_table(self.table)
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(['عملیات سیستمی', 'فرآیند تخصیص یافته'])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        layout.addWidget(self.table)
        
        btn_save = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), "ذخیره اتصالات")
        btn_save.setProperty("class", "primary")
        btn_save.clicked.connect(self._save_mappings)
        layout.addWidget(btn_save)
        
        self._load_data()

    def _load_data(self):
        active_workflows = self.db.get_active_workflows()
        current_mappings = self.db.execute_query("SELECT operation_key, workflow_id FROM system_operation_mappings")
        mappings_map = {m['operation_key']: m['workflow_id'] for m in current_mappings}

        self.table.setRowCount(len(self.SYSTEM_OPERATIONS))
        for r, (op_key, op_desc) in enumerate(self.SYSTEM_OPERATIONS.items()):
            op_item = QtWidgets.QTableWidgetItem(op_desc)
            op_item.setData(Qt.UserRole, op_key)
            op_item.setFlags(op_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.table.setItem(r, 0, op_item)

            combo = QtWidgets.QComboBox()
            combo.addItem("--- هیچ فرآیندی متصل نیست ---", None)
            for wf in active_workflows:
                combo.addItem(f"{wf['name']} (v{wf['version']})", wf['id'])
            
            if op_key in mappings_map:
                workflow_id = mappings_map[op_key]
                index = combo.findData(workflow_id)
                if index != -1:
                    combo.setCurrentIndex(index)

            self.table.setCellWidget(r, 1, combo)

    def _save_mappings(self):
        mappings_to_save = {}
        for r in range(self.table.rowCount()):
            op_key = self.table.item(r, 0).data(Qt.UserRole)
            combo = self.table.cellWidget(r, 1)
            workflow_id = combo.currentData()
            if workflow_id is not None:
                 mappings_to_save[op_key] = workflow_id
        
        try:
            # یک متد جدید در DB برای این کار می‌سازیم
            self.db.save_system_operation_mappings(mappings_to_save)
            if self.toast: self.toast.show_message("✔ اتصالات عملیات با موفقیت ذخیره شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ذخیره‌سازی اتصالات:\n{e}")
            
# کلاس PackingDialog را به طور کامل با این نسخه هوشمند و جدید جایگزین کنید
class PackingDialog(QtWidgets.QDialog):
    """
    نسخه 3.0 (هوشمند): پنجره بسته‌بندی دستی که نیازمندی‌ها را به صورت خودکار از دستور ساخت فعال محاسبه می‌کند.
    """
    def __init__(self, db: DB, parent=None):
        super().__init__(parent)
        self.db = db
        self.parent_window = parent
        self.toast = getattr(parent, 'toast', None)
        self.setWindowTitle("ثبت بسته‌بندی محصول (دستی)")
        self.setMinimumSize(800, 600)
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.requirements = []

        main_layout = QtWidgets.QVBoxLayout(self); main_layout.setSpacing(15)
        
        # بخش ۱: ورودی‌های اصلی کاربر
        input_group = QtWidgets.QGroupBox("مشخصات تولید")
        form_layout = QtWidgets.QFormLayout(input_group)
        self.output_sku_combo = QtWidgets.QComboBox()
        self.pack_count_edit = QtWidgets.QLineEdit("1"); self.pack_count_edit.setValidator(QtGui.QIntValidator(1, 10000))
        self.output_batch_edit = QtWidgets.QLineEdit(); self.output_batch_edit.setReadOnly(True)
        form_layout.addRow("انتخاب پک نهایی (*):", self.output_sku_combo)
        form_layout.addRow("تعداد پک برای تولید (*):", self.pack_count_edit)
        form_layout.addRow("شماره بچ نهایی (خودکار):", self.output_batch_edit)
        main_layout.addWidget(input_group)

        # بخش ۲: نیازمندی‌های محاسبه شده
        req_group = QtWidgets.QGroupBox("نیازمندی‌های محاسبه شده (بر اساس فرمول فعال)")
        req_layout = QtWidgets.QVBoxLayout(req_group)
        self.req_table = QtWidgets.QTableWidget()
        if hasattr(self.parent_window, '_style_table'): self.parent_window._style_table(self.req_table)
        req_layout.addWidget(self.req_table)
        main_layout.addWidget(req_group, 1)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        self.ok_button = buttons.button(QtWidgets.QDialogButtonBox.Ok); self.ok_button.setText("شروع عملیات بسته‌بندی")
        self.ok_button.setProperty("class", "primary"); self.ok_button.setEnabled(False)
        buttons.accepted.connect(self._start_packing_process)
        buttons.rejected.connect(self.reject)
        main_layout.addWidget(buttons)

        self.output_sku_combo.currentIndexChanged.connect(self._calculate_requirements)
        self.pack_count_edit.textChanged.connect(self._calculate_requirements)
        self._setup_sku_combo()

    def _setup_sku_combo(self):
        # این متد فقط پک‌های نهایی که به یک محصول مادر متصل هستند را لیست می‌کند
        query = "SELECT i.*, p.name as parent_name, p.is_two_component FROM items i JOIN items p ON i.parent_item_id = p.id WHERE i.category = %s AND p.is_parent_product = TRUE ORDER BY p.name, i.name"
        all_packs = self.db.execute_query(query, (CATEGORY_FINAL_PRODUCT,))
        self.output_sku_combo.addItem("--- یک پک را انتخاب کنید ---", None)
        for pack in all_packs:
            display_text = f"{pack['parent_name']} / {pack['name']} (SKU: {pack.get('sku', 'ندارد')})"
            self.output_sku_combo.addItem(display_text, dict(pack))

    def _calculate_requirements(self):
        self.requirements.clear()
        self.req_table.setRowCount(0)
        self.ok_button.setEnabled(False)
        
        pack_details = self.output_sku_combo.currentData()
        try:
            num_packs = int(self.pack_count_edit.text())
        except (ValueError, TypeError):
            num_packs = 0

        if not pack_details or num_packs <= 0:
            return

        self.output_batch_edit.setText(self.db.get_next_packed_batch_no(pack_details.get('sku', 'NOSKU')))
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        
        try:
            # منطق کامل محاسبه نیازمندی‌ها مشابه میزکار هوشمند
            parent_id = pack_details['parent_item_id']
            is_two_comp = pack_details['is_two_component']
            total_ratio = 1.0

            # محاسبه نیازمندی‌های فله
            if is_two_comp:
                master_recipe = self.db.execute_query("SELECT properties FROM recipes WHERE parent_product_id = %s AND part_type = 'MASTER' AND status = 'ACTIVE' LIMIT 1", (parent_id,), fetch_one=True)
                if master_recipe and master_recipe.get('properties'):
                    props = json.loads(master_recipe['properties']) if isinstance(master_recipe['properties'], str) else (master_recipe['properties'] or {})
                    mix_ratio = props.get('mix_ratio', {}); ratio_a = mix_ratio.get('A', 0); ratio_b = mix_ratio.get('B', 0); total_ratio = ratio_a + ratio_b
                    if total_ratio <= 0: raise ValueError("نسبت اختلاط در دستور ساخت مادر صفر است.")
                    
                    part_a_recipe = self.db.execute_query("SELECT produces_item_id FROM recipes WHERE parent_product_id = %s AND part_type = 'A' AND status = 'ACTIVE' LIMIT 1", (parent_id,), fetch_one=True)
                    part_b_recipe = self.db.execute_query("SELECT produces_item_id FROM recipes WHERE parent_product_id = %s AND part_type = 'B' AND status = 'ACTIVE' LIMIT 1", (parent_id,), fetch_one=True)
                    if not part_a_recipe or not part_b_recipe: raise ValueError("فرمول فعال برای پارت A یا B یافت نشد.")

                    self.requirements.append({'item_id': part_a_recipe['produces_item_id'], 'required_qty': (pack_details['net_weight'] / total_ratio) * ratio_a * num_packs, 'type': 'BULK'})
                    self.requirements.append({'item_id': part_b_recipe['produces_item_id'], 'required_qty': (pack_details['net_weight'] / total_ratio) * ratio_b * num_packs, 'type': 'BULK'})
            else: # تک جزئی
                part_p_recipe = self.db.execute_query("SELECT produces_item_id FROM recipes WHERE parent_product_id = %s AND part_type = 'P' AND status = 'ACTIVE' LIMIT 1", (parent_id,), fetch_one=True)
                if not part_p_recipe: raise ValueError("فرمول فعال (پارت P) برای این محصول یافت نشد.")
                self.requirements.append({'item_id': part_p_recipe['produces_item_id'], 'required_qty': pack_details['net_weight'] * num_packs, 'type': 'BULK'})

            # محاسبه نیازمندی‌های بسته‌بندی
            packaging_bom = self.db.get_bom_for_product(pack_details['name'])
            for item in packaging_bom:
                self.requirements.append({'item_id': item['component_item_id'], 'required_qty': item['quantity'] * num_packs, 'type': 'SUPPLY'})

            # نمایش نتایج در جدول
            headers = ["نوع", "نام جزء", "مقدار لازم", "موجودی در کارگاه", "وضعیت"]; self.req_table.setColumnCount(len(headers)); self.req_table.setHorizontalHeaderLabels(headers)
            self.req_table.setRowCount(len(self.requirements))
            all_ok = True
            for r, req in enumerate(self.requirements):
                item_details = self.db.get_item_details(req['item_id'])
                available = self.db.get_item_stock_in_warehouse(req['item_id'], PRODUCTION_WAREHOUSE_NAME)
                is_sufficient = available >= req['required_qty']
                if not is_sufficient: all_ok = False
                
                self.req_table.setItem(r, 0, QtWidgets.QTableWidgetItem("فله" if req['type'] == 'BULK' else "بسته‌بندی"))
                self.req_table.setItem(r, 1, QtWidgets.QTableWidgetItem(item_details['name']))
                self.req_table.setItem(r, 2, NumericTableWidgetItem(f"{req['required_qty']:.3f}"))
                self.req_table.setItem(r, 3, NumericTableWidgetItem(f"{available:.3f}"))
                status_item = QtWidgets.QTableWidgetItem("✔ موجود" if is_sufficient else "❌ کسری موجودی"); status_item.setForeground(QtGui.QColor("green" if is_sufficient else "red"))
                self.req_table.setItem(r, 4, status_item)
            
            self.req_table.resizeColumnsToContents()
            self.req_table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            self.ok_button.setEnabled(all_ok)

        except Exception as e:
            self.toast.show_message(f"خطا در محاسبه نیازمندی‌ها: {e}", "critical")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()

    def _start_packing_process(self):
        pack_details = self.output_sku_combo.currentData()
        num_packs = int(self.pack_count_edit.text())
        final_batch_no = self.output_batch_edit.text()

        components_plan = []
        all_exp_dates = []
        try:
            for req in self.requirements:
                pick_plan = self.db.get_fifo_pick_plan(req['item_id'], req['required_qty'], PRODUCTION_WAREHOUSE_NAME)
                components_plan.extend(pick_plan)
                if req['type'] == 'BULK':
                    for pick in pick_plan:
                        if pick.get('expiry_date'): all_exp_dates.append(pick['expiry_date'])
            
            final_expiry = min(all_exp_dates) if all_exp_dates else dt.date.today() + dt.timedelta(days=730)
            
            packing_data = {
                "production_order_id": None, # چون این بسته‌بندی دستی است
                "components_plan": components_plan,
                "output_product": { "item_id": pack_details['id'], "name": pack_details['name'], "qty": num_packs, "batch": final_batch_no, "expiry_date": final_expiry }
            }

            self.db.execute_packing_plan_from_production(packing_data, self.parent_window.user_id)
            self.toast.show_message("✔ عملیات بسته‌بندی دستی با موفقیت ثبت شد.", "success")
            self.accept()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند بسته‌بندی با خطا مواجه شد:\n{e}")
            
# --- [UPDATED] QA Command Center: Alerts + Global KPI + Escalation refresh ----
class QaCommandCenterWidget(QtWidgets.QWidget):
    """
    تابلوی یکپارچه فرآیندها + KPI/SLA + هشدارها
    """
    def __init__(self, db: 'DB', main_window, parent=None):
        super().__init__(parent)
        self.db = db
        self.main_window = main_window

        layout = QtWidgets.QVBoxLayout(self)

        # --- نوار KPI بالا
        kpi_bar = QtWidgets.QHBoxLayout()
        layout.addLayout(kpi_bar)

        self.kpi_on = self._kpi_card("روی‌برنامه", "0")
        self.kpi_soon = self._kpi_card("نزدیک موعد", "0")
        self.kpi_over = self._kpi_card("دیرکرد", "0")

        kpi_bar.addWidget(self.kpi_on)
        kpi_bar.addWidget(self.kpi_soon)
        kpi_bar.addWidget(self.kpi_over)

        # --- هشدارهای Escalation (آخرین‌ها)
        alerts_box = QtWidgets.QGroupBox("هشدارهای SLA (۲۴ ساعت اخیر)")
        v_alert = QtWidgets.QVBoxLayout(alerts_box)
        self.lst_alerts = QtWidgets.QListWidget()
        self.btn_clear_view = QtWidgets.QPushButton("پاکسازی نمایش (از روی لیست نه)")
        v_alert.addWidget(self.lst_alerts)
        v_alert.addWidget(self.btn_clear_view)
        layout.addWidget(alerts_box)

        # --- فیلتر/جستجو
        header = QtWidgets.QHBoxLayout()
        layout.addLayout(header)

        header.addWidget(QtWidgets.QLabel("فرآیند:"))
        self.cb_workflows = QtWidgets.QComboBox()
        header.addWidget(self.cb_workflows, 1)

        self.search_edit = QtWidgets.QLineEdit(placeholderText="جستجو...")
        header.addWidget(self.search_edit, 1)

        self.chk_overdue_only = QtWidgets.QCheckBox("فقط دیرکرد")
        header.addWidget(self.chk_overdue_only)

        self.btn_refresh = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), " بروزرسانی")
        header.addWidget(self.btn_refresh)

        # --- جدول
        self.tbl = QtWidgets.QTableWidget(0, 7)
        self.tbl.setHorizontalHeaderLabels(['ID', 'نام فرآیند', 'مرحله فعلی', 'وضعیت', 'تاریخ شروع', 'ایجادکننده', 'توضیحات'])
        self.tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tbl.verticalHeader().hide()
        layout.addWidget(self.tbl, 1)

        # --- تایمر بروزرسانی خودکار (هر 30 ثانیه)
        self._timer = QtCore.QTimer(self)
        self._timer.setInterval(30_000)
        self._timer.timeout.connect(self._refresh)

        # wiring
        self._load_workflows()
        self.cb_workflows.currentIndexChanged.connect(self._refresh)
        self.btn_refresh.clicked.connect(self._refresh)
        self.search_edit.textChanged.connect(self._apply_search_filter)
        self.chk_overdue_only.toggled.connect(self._apply_filters)
        self.btn_clear_view.clicked.connect(self.lst_alerts.clear)

        # بار اول
        self._refresh()
        self._timer.start()

    # ---- UI helpers ----------------------------------------------------------
    def _kpi_card(self, title, value_text):
        box = QtWidgets.QGroupBox(title)
        v = QtWidgets.QVBoxLayout(box)
        lbl = QtWidgets.QLabel(value_text)
        f = lbl.font(); f.setPointSize(f.pointSize() + 8); f.setBold(True)
        lbl.setFont(f)
        lbl.setAlignment(Qt.AlignCenter)
        v.addWidget(lbl)
        box._value_label = lbl
        return box

    def _set_kpis(self, counts: dict):
        self.kpi_on._value_label.setText(str(counts.get('on_track', 0)))
        self.kpi_soon._value_label.setText(str(counts.get('due_soon', 0)))
        self.kpi_over._value_label.setText(str(counts.get('overdue', 0)))

    # ---- Data loading ---------------------------------------------------------
    def _load_workflows(self):
        rows = self.db.get_active_workflows()  # id, name, version
        self.cb_workflows.clear()
        # گزینهٔ «همهٔ فرآیندها»
        self.cb_workflows.addItem("— همهٔ فرآیندها —", None)
        for r in rows:
            self.cb_workflows.addItem(f"{r['name']} (v{r['version']})", r['id'])

    def _apply_search_filter(self, _text=None):
        self._apply_filters()

    def _apply_filters(self):
        text = (self.search_edit.text() or "").strip().lower()
        only_overdue = self.chk_overdue_only.isChecked()
        for r in range(self.tbl.rowCount()):
            visible = True
            # جستجو
            if text:
                row_txt = " ".join(self.tbl.item(r, c).text() if self.tbl.item(r, c) else "" for c in range(self.tbl.columnCount()))
                visible = text in row_txt.lower()
            # فقط دیرکرد
            if visible and only_overdue:
                state = self.tbl.item(r, 0).data(Qt.UserRole)
                visible = (state == 'overdue')
            self.tbl.setRowHidden(r, not visible)

    def _refresh(self):
        # 0) اجرای Escalation قبل از بارگذاری (تا هشدارهای جدید ساخته شوند)
        try:
            self.db.run_sla_escalations()
        except Exception as e:
            print("WARN: run_sla_escalations failed:", e)

        # 1) بارگذاری هشدارها
        try:
            alerts = self.db.execute_query("""
                SELECT a.id, a.process_instance_id, a.workflow_id, a.step_id, a.message, a.created_at,
                       w.name AS wf_name, ws.step_name
                FROM qa_escalation_alerts a
                LEFT JOIN workflows w ON w.id = a.workflow_id
                LEFT JOIN workflow_steps ws ON ws.id = a.step_id
                WHERE a.created_at >= NOW() - INTERVAL '24 HOURS'
                ORDER BY a.created_at DESC
                LIMIT 50
            """)
            self.lst_alerts.clear()
            for al in alerts:
                wf_name = al.get('wf_name') or f"WF-{al['workflow_id']}"
                step_name = al.get('step_name') or '—'
                when = al.get('created_at')
                when_txt = str(when)[:16] if when else ''
                txt = f"[{when_txt}] {al['message']} | {wf_name} / {step_name}"
                self.lst_alerts.addItem(txt)
        except Exception as e:
            print("WARN: load alerts failed:", e)

        # 2) جدول نمونه‌ها
        self.tbl.setRowCount(0)
        wf_id = self.cb_workflows.currentData()

        # دو حالت: یک Workflow خاص یا همهٔ Workflowها
        if wf_id:
            rows = self._fetch_instances_for_workflow(wf_id)
            sla = self.db.compute_sla_buckets(wf_id)
            counts = sla['counts']
            per_instance = sla['per_instance']
        else:
            rows, counts, per_instance = self._fetch_instances_all_workflows()

        self._set_kpis(counts)

        # 3) پر کردن جدول + رنگ‌بندی
        self.tbl.setRowCount(len(rows))
        for r, rec in enumerate(rows):
            pi_id = rec.get('pi_id') or rec.get('id')
            state_info = per_instance.get(int(pi_id))
            state = state_info[0] if state_info else 'on_track'

            vals = [
                pi_id,
                rec.get('wf_name') or '',
                rec.get('step_name') or '',
                rec.get('status') or '',
                to_shamsi(rec.get('started_at')) if rec.get('started_at') else '',
                rec.get('initiator_username') or '',
                (rec.get('details') or '')
            ]
            for c, v in enumerate(vals):
                it = QtWidgets.QTableWidgetItem(str(v))
                if c in [0, 4]:
                    it.setTextAlignment(Qt.AlignCenter)
                else:
                    it.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                if c == 0:
                    it.setData(Qt.UserRole, state)  # برای فیلتر «فقط دیرکرد»
                self.tbl.setItem(r, c, it)
            self._color_row_by_state(r, state)

        self._apply_filters()

    def _fetch_instances_for_workflow(self, wf_id: int):
        try:
            rows = self.db.get_all_process_instances_for_workflow(wf_id)
        except Exception:
            rows = self.db.execute_query("""
                SELECT pi.id as pi_id, w.name as wf_name, ws.step_name, pi.status,
                       pi.started_at, pi.initiator_user_id,
                       COALESCE(u.username, '—') as initiator_username, pi.current_step_id
                FROM process_instances pi
                JOIN workflows w ON w.id = pi.workflow_id
                LEFT JOIN workflow_steps ws ON ws.id = pi.current_step_id
                LEFT JOIN users u ON u.id = pi.initiator_user_id
                WHERE pi.workflow_id = %s
                ORDER BY pi.started_at DESC
            """, (wf_id,))
        sla = self.db.compute_sla_buckets(wf_id)
        return rows, sla['counts'], sla['per_instance']

    def _fetch_instances_all_workflows(self):
        # همهٔ نمونه‌های فعال برای همهٔ Workflowها
        rows = self.db.execute_query("""
            SELECT pi.id as pi_id, w.id as wf_id, w.name as wf_name, ws.step_name, pi.status,
                   pi.started_at, pi.initiator_user_id,
                   COALESCE(u.username, '—') as initiator_username, pi.current_step_id
            FROM process_instances pi
            JOIN workflows w ON w.id = pi.workflow_id
            LEFT JOIN workflow_steps ws ON ws.id = pi.current_step_id
            LEFT JOIN users u ON u.id = pi.initiator_user_id
            WHERE (pi.status IS NULL OR pi.status NOT IN ('COMPLETED','CANCELLED','REJECTED'))
            ORDER BY pi.started_at DESC
        """)

        # محاسبهٔ KPI تجمیعی با جمع نتایج همهٔ Workflowها
        counts = {'on_track': 0, 'due_soon': 0, 'overdue': 0}
        per_instance = {}
        # برای دقت، per workflow SLA محاسبه می‌کنیم
        wfs = {}
        for r in rows:
            wfs.setdefault(int(r['wf_id']), []).append(r)

        for wf_id, _ in wfs.items():
            sla = self.db.compute_sla_buckets(wf_id)
            # ادغام
            c = sla['counts']
            counts['on_track'] += c.get('on_track', 0)
            counts['due_soon'] += c.get('due_soon', 0)
            counts['overdue'] += c.get('overdue', 0)
            per_instance.update(sla['per_instance'])

        return rows, counts, per_instance

    def _color_row_by_state(self, row: int, state: str):
        if state == 'due_soon':
            brush = QtGui.QBrush(QtGui.QColor(255, 255, 180))
        elif state == 'overdue':
            brush = QtGui.QBrush(QtGui.QColor(255, 200, 200))
        else:
            brush = None
        if brush:
            for c in range(self.tbl.columnCount()):
                item = self.tbl.item(row, c)
                if item:
                    item.setBackground(brush)

class QaOrchestrator:
    """
    هسته‌ی ساده ارکستراسیون:
    هر ماژول به‌جای درگیر شدن با جزئیات WF، فقط orchestrator.start_event(...) را صدا می‌زند.
    """
    def __init__(self, db: 'DB'):
        self.db = db

    def start_event(self, event_name: str, table_name: str, record_id: int, user_id: int, context: dict | None = None):
        """
        یک رویداد سیستمی را به workflow مپ‌شده‌اش وصل می‌کند.
        از DB.trigger_event استفاده می‌کنیم (عدم تخریب).
        """
        # DB.trigger_event خودش از system_event_mappings استفاده می‌کند و
        # start_workflow_instance را با prepopulation/context صدا می‌زند.
        self.db.trigger_event(event_name, record_id, table_name, user_id, context_data=context)
        
class QaSettingsPanelWidget(QtWidgets.QWidget):
    """
    مدیریت قوانین QA:
      - SLA Rules
      - Escalation Policies
      - QA Gates
    """
    def __init__(self, db: 'DB', main_window, parent=None):
        super().__init__(parent)
        self.db = db
        self.main_window = main_window

        lay = QtWidgets.QVBoxLayout(self)
        self.tabs = QtWidgets.QTabWidget()
        lay.addWidget(self.tabs)

        # سه تب
        self.tab_sla = QtWidgets.QWidget(); self.tabs.addTab(self.tab_sla, "SLA")
        self.tab_esc = QtWidgets.QWidget(); self.tabs.addTab(self.tab_esc, "Escalation")
        self.tab_gate= QtWidgets.QWidget(); self.tabs.addTab(self.tab_gate, "Gates")

        self._build_sla_tab()
        self._build_esc_tab()
        self._build_gate_tab()

    # ── SLA TAB ─────────────────────────────────────────────────────────────
    def _build_sla_tab(self):
        v = QtWidgets.QVBoxLayout(self.tab_sla)

        # Filter bar
        h = QtWidgets.QHBoxLayout()
        v.addLayout(h)
        h.addWidget(QtWidgets.QLabel("Workflow:"))
        self.cb_sla_wf = QtWidgets.QComboBox(); h.addWidget(self.cb_sla_wf, 1)
        self.btn_sla_refresh = QtWidgets.QPushButton("بروزرسانی"); h.addWidget(self.btn_sla_refresh)
        self.btn_sla_add = QtWidgets.QPushButton("افزودن قانون"); h.addWidget(self.btn_sla_add)
        self.btn_sla_disable = QtWidgets.QPushButton("غیرفعال‌سازی"); h.addWidget(self.btn_sla_disable)

        # Table
        self.tbl_sla = QtWidgets.QTableWidget(0, 7)
        self.tbl_sla.setHorizontalHeaderLabels(['ID','Workflow','Step','Threshold (min)','Severity','Active',''])
        self.tbl_sla.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        v.addWidget(self.tbl_sla, 1)

        self._load_workflows_into(self.cb_sla_wf)
        self.cb_sla_wf.currentIndexChanged.connect(self._refresh_sla)
        self.btn_sla_refresh.clicked.connect(self._refresh_sla)
        self.btn_sla_add.clicked.connect(self._add_sla_rule)
        self.btn_sla_disable.clicked.connect(self._disable_sla_rule)
        self._refresh_sla()

    def _refresh_sla(self):
        wf_id = self.cb_sla_wf.currentData()
        rows = self.db.list_all_sla_rules(wf_id) if wf_id else self.db.list_all_sla_rules()
        self.tbl_sla.setRowCount(len(rows))
        for r, x in enumerate(rows):
            vals = [
                x['id'],
                x.get('workflow_name') or x['workflow_id'],
                x.get('step_name') or (x['step_id'] if x['step_id'] else '—'),
                x['threshold_minutes'],
                x.get('severity') or '—',
                'فعال' if x['active'] else 'غیرفعال',
                ''
            ]
            for c, v in enumerate(vals):
                it = QtWidgets.QTableWidgetItem(str(v))
                if c in [0,3]: it.setTextAlignment(Qt.AlignCenter)
                self.tbl_sla.setItem(r, c, it)

    def _add_sla_rule(self):
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("افزودن قانون SLA")
        fv = QtWidgets.QFormLayout(dlg)
        cb_wf = QtWidgets.QComboBox(); self._load_workflows_into(cb_wf)
        le_step = QtWidgets.QLineEdit(); le_step.setPlaceholderText("اختیاری: ID مرحله")
        le_thr  = QtWidgets.QLineEdit(); le_thr.setPlaceholderText("مثال: 240 (دقیقه)")
        le_sev  = QtWidgets.QLineEdit(); le_sev.setPlaceholderText("HIGH/MED/LOW … (اختیاری)")
        fv.addRow("Workflow:", cb_wf)
        fv.addRow("Step ID:", le_step)
        fv.addRow("Threshold (min):", le_thr)
        fv.addRow("Severity:", le_sev)
        bb = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok|QtWidgets.QDialogButtonBox.Cancel)
        fv.addRow(bb)
        bb.accepted.connect(dlg.accept); bb.rejected.connect(dlg.reject)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            wf_id = cb_wf.currentData()
            thr = int(le_thr.text() or '240')
            step_id = int(le_step.text()) if le_step.text().strip() else None
            sev = le_sev.text().strip() or 'HIGH'
            self.db.upsert_sla_rule(wf_id, thr, step_id=step_id, severity=sev, active=True)
            self._refresh_sla()

    def _disable_sla_rule(self):
        row = self.tbl_sla.currentRow()
        if row < 0: return
        rid = int(self.tbl_sla.item(row,0).text())
        self.db.deactivate_sla_rule(rid, active=False)
        self._refresh_sla()

    # ── ESCALATION TAB ──────────────────────────────────────────────────────
    def _build_esc_tab(self):
        v = QtWidgets.QVBoxLayout(self.tab_esc)

        h = QtWidgets.QHBoxLayout(); v.addLayout(h)
        h.addWidget(QtWidgets.QLabel("Workflow:"))
        self.cb_esc_wf = QtWidgets.QComboBox(); h.addWidget(self.cb_esc_wf, 1)
        self.btn_esc_refresh = QtWidgets.QPushButton("بروزرسانی"); h.addWidget(self.btn_esc_refresh)
        self.btn_esc_add = QtWidgets.QPushButton("افزودن سیاست"); h.addWidget(self.btn_esc_add)
        self.btn_esc_disable = QtWidgets.QPushButton("غیرفعال‌سازی"); h.addWidget(self.btn_esc_disable)

        self.tbl_esc = QtWidgets.QTableWidget(0, 9)
        self.tbl_esc.setHorizontalHeaderLabels(['ID','Workflow','Step','Overdue (min)','Repeat (min)','Role','UserID','Active',''])
        self.tbl_esc.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        v.addWidget(self.tbl_esc, 1)

        self._load_workflows_into(self.cb_esc_wf)
        self.cb_esc_wf.currentIndexChanged.connect(self._refresh_esc)
        self.btn_esc_refresh.clicked.connect(self._refresh_esc)
        self.btn_esc_add.clicked.connect(self._add_esc)
        self.btn_esc_disable.clicked.connect(self._disable_esc)
        self._refresh_esc()

    def _refresh_esc(self):
        wf_id = self.cb_esc_wf.currentData()
        rows = self.db.list_escalation_policies(wf_id) if wf_id else self.db.list_escalation_policies()
        self.tbl_esc.setRowCount(len(rows))
        for r, x in enumerate(rows):
            vals = [
                x['id'],
                x.get('workflow_name') or x['workflow_id'],
                x.get('step_name') or (x['step_id'] if x['step_id'] else '—'),
                x['minutes_overdue'],
                x['repeat_every_minutes'],
                x.get('notify_role') or '—',
                x.get('notify_user_id') or '—',
                'فعال' if x['active'] else 'غیرفعال',
                ''
            ]
            for c, v in enumerate(vals):
                it = QtWidgets.QTableWidgetItem(str(v))
                if c in [0,3,4]: it.setTextAlignment(Qt.AlignCenter)
                self.tbl_esc.setItem(r, c, it)

    def _add_esc(self):
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("افزودن سیاست Escalation")
        fv = QtWidgets.QFormLayout(dlg)
        cb_wf = QtWidgets.QComboBox(); self._load_workflows_into(cb_wf)
        le_step = QtWidgets.QLineEdit(); le_step.setPlaceholderText("اختیاری: ID مرحله")
        le_over = QtWidgets.QLineEdit(); le_over.setPlaceholderText("مثال: 0 (دقیقه پس از overdue)")
        le_rep  = QtWidgets.QLineEdit(); le_rep.setPlaceholderText("مثال: 120 (تکرار)")
        le_role = QtWidgets.QLineEdit(); le_role.setPlaceholderText("اختیاری: نقش هدف")
        le_uid  = QtWidgets.QLineEdit(); le_uid.setPlaceholderText("اختیاری: شناسه کاربر")
        fv.addRow("Workflow:", cb_wf)
        fv.addRow("Step ID:", le_step)
        fv.addRow("Overdue (min):", le_over)
        fv.addRow("Repeat (min):", le_rep)
        fv.addRow("Notify Role:", le_role)
        fv.addRow("Notify UserID:", le_uid)
        bb = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok|QtWidgets.QDialogButtonBox.Cancel)
        fv.addRow(bb)
        bb.accepted.connect(dlg.accept); bb.rejected.connect(dlg.reject)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            wf_id = cb_wf.currentData()
            step_id = int(le_step.text()) if le_step.text().strip() else None
            over = int(le_over.text() or '0')
            rep  = int(le_rep.text() or '120')
            role = le_role.text().strip() or None
            uid  = int(le_uid.text()) if le_uid.text().strip() else None
            self.db.upsert_escalation_policy(wf_id, step_id=step_id,
                                             minutes_overdue=over, repeat_every_minutes=rep,
                                             notify_role=role, notify_user_id=uid, active=True)
            self._refresh_esc()

    def _disable_esc(self):
        row = self.tbl_esc.currentRow()
        if row < 0: return
        pid = int(self.tbl_esc.item(row,0).text())
        self.db.deactivate_escalation_policy(pid, active=False)
        self._refresh_esc()

    # ── GATES TAB ───────────────────────────────────────────────────────────
    def _build_gate_tab(self):
        v = QtWidgets.QVBoxLayout(self.tab_gate)

        h = QtWidgets.QHBoxLayout(); v.addLayout(h)
        self.le_gate_table = QtWidgets.QLineEdit(); self.le_gate_table.setPlaceholderText("فیلتر جدول (اختیاری)")
        h.addWidget(self.le_gate_table, 1)
        self.btn_gate_refresh = QtWidgets.QPushButton("بروزرسانی"); h.addWidget(self.btn_gate_refresh)
        self.btn_gate_add = QtWidgets.QPushButton("افزودن قانون"); h.addWidget(self.btn_gate_add)
        self.btn_gate_disable = QtWidgets.QPushButton("غیرفعال‌سازی"); h.addWidget(self.btn_gate_disable)
        self.btn_gate_enable = QtWidgets.QPushButton("فعال‌سازی"); h.addWidget(self.btn_gate_enable)

        self.tbl_gate = QtWidgets.QTableWidget(0, 7)
        self.tbl_gate.setHorizontalHeaderLabels(['ID','Table','Status','Form','RequirePass','MinScore','Active'])
        self.tbl_gate.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        v.addWidget(self.tbl_gate, 1)

        self.btn_gate_refresh.clicked.connect(self._refresh_gate)
        self.btn_gate_add.clicked.connect(self._add_gate)
        self.btn_gate_disable.clicked.connect(lambda: self._set_gate_active(False))
        self.btn_gate_enable.clicked.connect(lambda: self._set_gate_active(True))
        self._refresh_gate()

    def _refresh_gate(self):
        t = self.le_gate_table.text().strip() or None
        rows = self.db.list_all_qa_gates(t)
        self.tbl_gate.setRowCount(len(rows))
        for r, x in enumerate(rows):
            vals = [
                x['id'],
                x['table_name'],
                x['transition_status'],
                x.get('form_name') or x['form_def_id'],
                'Yes' if x.get('require_pass', True) else 'No',
                x.get('min_score') if x.get('min_score') is not None else '—',
                'فعال' if x['active'] else 'غیرفعال'
            ]
            for c, v in enumerate(vals):
                it = QtWidgets.QTableWidgetItem(str(v))
                if c in [0,5]: it.setTextAlignment(Qt.AlignCenter)
                self.tbl_gate.setItem(r, c, it)

    def _add_gate(self):
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("افزودن Gate")
        fv = QtWidgets.QFormLayout(dlg)
        le_table = QtWidgets.QLineEdit(); le_table.setPlaceholderText("مثال: production_deliveries")
        le_status = QtWidgets.QLineEdit(); le_status.setPlaceholderText("مثال: APPROVED/SHIPPED/…")
        le_form_code_or_name = QtWidgets.QLineEdit(); le_form_code_or_name.setPlaceholderText("کُد یا نام فرم (مثال: QC_INBOUND)")
        chk_pass = QtWidgets.QCheckBox(); chk_pass.setChecked(True)
        le_min = QtWidgets.QLineEdit(); le_min.setPlaceholderText("اختیاری: حداقل امتیاز")
        fv.addRow("Table:", le_table)
        fv.addRow("Target Status:", le_status)
        fv.addRow("Form Code/Name:", le_form_code_or_name)
        fv.addRow("Require PASSED:", chk_pass)
        fv.addRow("Min Score:", le_min)
        bb = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok|QtWidgets.QDialogButtonBox.Cancel)
        fv.addRow(bb)
        bb.accepted.connect(dlg.accept); bb.rejected.connect(dlg.reject)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            t = le_table.text().strip()
            st = le_status.text().strip()
            fn = le_form_code_or_name.text().strip()
            ms = int(le_min.text()) if le_min.text().strip() else None

            # ثبت متای جدول + ترایگر (برای enforce خودکار)
            try:
                self.db.register_table_meta(t, 'id', 'status')
                self.db.ensure_qa_gate_triggers()
            except Exception as e:
                print("WARN meta/trigger:", e)

            # فرم را اگر نبود بساز/پیدا کن (با code یا name)
            # تلاش code
            try:
                fid = self.db.get_or_create_form_def(fn, fn)
            except Exception:
                fid = self.db.get_or_create_form_def('AUTO_'+fn.upper(), fn)

            self.db.safe_upsert_qa_gate(t, st, fid, require_pass=chk_pass.isChecked(), min_score=ms, active=True)
            self._refresh_gate()

    def _set_gate_active(self, active: bool):
        row = self.tbl_gate.currentRow()
        if row < 0: return
        gid = int(self.tbl_gate.item(row,0).text())
        self.db.set_qa_gate_active(gid, active)
        self._refresh_gate()

    # ── مشترک: بارگذاری لیست Workflow در ComboBox ──────────────────────────
    def _load_workflows_into(self, combo: QtWidgets.QComboBox):
        combo.clear()
        rows = self.db.get_active_workflows()
        for r in rows:
            combo.addItem(f"{r['name']} (v{r['version']})", r['id'])
            
# --- NEW: put this class near other dialogs (e.g., after other Dialog classes) ---
class WarehouseOpsDialog(QtWidgets.QDialog):
    """
    پنجره‌ی مستقل عملیات انبار:
    - تب‌ها: درخواست مواد اولیه، محصولات منتظر تایید، برگشتی از تولید، درخواست‌های داخلی
    - بدون حذف هیچ قابلیتی؛ همان دکمه‌ها و اتصالات قبلی استفاده می‌شوند.
    """
    def __init__(self, db: 'DB', main_window: 'MainWindow'):
        super().__init__(main_window)
        self.db = db
        self.main_window = main_window
        self.setWindowTitle("عملیات انبار")
        self.setFont(QFont(FONT_FAMILY, FONT_SIZE))
        self.setMinimumSize(900, 600)

        layout = QtWidgets.QVBoxLayout(self)
        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setObjectName("interfaceTabWidget")
        layout.addWidget(self.tabs)

        # --- درخواست‌های مواد اولیه
        self.tab_requests = None
        self.tbl_material_requests = None
        if self.main_window.has_permission('warehouse:fulfill_request'):
            self.tab_requests = QtWidgets.QWidget()
            v = QtWidgets.QVBoxLayout(self.tab_requests)
            self.tbl_material_requests = QtWidgets.QTableWidget()
            self.main_window._style_table(self.tbl_material_requests)
            v.addWidget(self.tbl_material_requests)
            actions = QtWidgets.QHBoxLayout()
            btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), "رد کردن درخواست")
            btn_ok = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "رسیدگی به درخواست")
            btn_ok.setProperty("class", "primary")
            btn_reject.clicked.connect(self.main_window._reject_material_request)
            btn_ok.clicked.connect(self.main_window._fulfill_material_request)
            actions.addStretch(); actions.addWidget(btn_reject); actions.addWidget(btn_ok)
            v.addLayout(actions)
            # ابزار فیلتر/اکسل
            self.main_window._add_filter_export_tools(self.tbl_material_requests, v)
            self.tabs.addTab(self.tab_requests, "درخواست‌های مواد اولیه")

        # --- محصولات منتظر تایید
        self.tab_deliveries = None
        self.tbl_pending_deliveries = None
        if self.main_window.has_permission('warehouse:approve_delivery'):
            self.tab_deliveries = QtWidgets.QWidget()
            v = QtWidgets.QVBoxLayout(self.tab_deliveries)
            self.tbl_pending_deliveries = QtWidgets.QTableWidget()
            self.main_window._style_table(self.tbl_pending_deliveries)
            v.addWidget(self.tbl_pending_deliveries)
            actions = QtWidgets.QHBoxLayout()
            btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), "رد کردن تحویل")
            btn_ok = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "تایید دریافت در انبار")
            btn_ok.setProperty("class", "primary")
            btn_reject.clicked.connect(self.main_window._reject_selected_delivery)
            btn_ok.clicked.connect(self.main_window._approve_selected_delivery)
            actions.addStretch(); actions.addWidget(btn_reject); actions.addWidget(btn_ok)
            v.addLayout(actions)
            self.main_window._add_filter_export_tools(self.tbl_pending_deliveries, v)
            self.tabs.addTab(self.tab_deliveries, "محصولات منتظر تایید")

        # --- برگشتی‌های تولید
        self.tab_returns = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(self.tab_returns)
        self.tbl_material_returns = QtWidgets.QTableWidget()
        self.main_window._style_table(self.tbl_material_returns)
        v.addWidget(self.tbl_material_returns)
        actions = QtWidgets.QHBoxLayout()
        btn_reject = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-cancel"), "رد کردن درخواست")
        btn_ok = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "تایید برگشت")
        btn_ok.setProperty("class", "primary")
        btn_reject.clicked.connect(self.main_window._reject_selected_return)
        btn_ok.clicked.connect(self.main_window._approve_selected_return)
        actions.addStretch(); actions.addWidget(btn_reject); actions.addWidget(btn_ok)
        v.addLayout(actions)
        self.main_window._add_filter_export_tools(self.tbl_material_returns, v)
        self.tabs.addTab(self.tab_returns, "کالاهای برگشتی از تولید")

        # --- درخواست‌های داخلی
        self.tab_internal = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(self.tab_internal)
        self.tbl_internal_requests = QtWidgets.QTableWidget()
        self.main_window._style_table(self.tbl_internal_requests)
        v.addWidget(self.tbl_internal_requests)
        actions = QtWidgets.QHBoxLayout()
        btn_pr = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), "ایجاد درخواست خرید برای مورد انتخابی")
        btn_fulfill = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("emblem-ok"), "رسیدگی و تحویل کالا")
        btn_fulfill.setProperty("class", "primary")
        btn_pr.clicked.connect(self.main_window._initiate_pr_from_internal_request)
        btn_fulfill.clicked.connect(self.main_window._fulfill_internal_request)
        actions.addStretch(); actions.addWidget(btn_pr); actions.addWidget(btn_fulfill)
        v.addLayout(actions)
        self.main_window._add_filter_export_tools(self.tbl_internal_requests, v)
        self.tabs.addTab(self.tab_internal, "درخواست‌های داخلی")

        # رفرنس جدول‌ها را روی MainWindow ست می‌کنیم تا متدهای لود فعلی بدون تغییر کار کنند.
        self._wire_mainwindow_refs()

    def _wire_mainwindow_refs(self):
        mw = self.main_window
        mw.tbl_material_requests = self.tbl_material_requests
        mw.tbl_pending_deliveries = self.tbl_pending_deliveries
        mw.tbl_material_returns = self.tbl_material_returns
        mw.tbl_internal_requests = self.tbl_internal_requests

    def select_tab(self, key: str):
        mapping = {
            'requests': self.tab_requests,
            'deliveries': self.tab_deliveries,
            'returns': self.tab_returns,
            'internal': self.tab_internal,
        }
        page = mapping.get(key)
        if page is not None:
            idx = self.tabs.indexOf(page)
            if idx != -1:
                self.tabs.setCurrentIndex(idx)

    def closeEvent(self, e: QtGui.QCloseEvent) -> None:
        # رفرنس‌ها را پاک می‌کنیم تا اشاره‌گرهای MainWindow هنگ نزنند
        if hasattr(self.main_window, "_detach_warehouse_ops_refs"):
            self.main_window._detach_warehouse_ops_refs()
        super().closeEvent(e)








                                    
                                                                                    
                                                                                                                                                            
class MainWindow(QtWidgets.QMainWindow):
    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def __init__(self, db: DB, user_info: dict, parent=None):
        super().__init__(parent)
        
        self.SYSTEM_EVENTS = {
            "PURCHASE_REQUEST_CREATED": "یک درخواست خرید جدید ثبت می‌شود",
            "WAREHOUSE_RECEIPT_CONFIRMED": "یک کالا وارد انبار اصلی می‌شود",
            "PRODUCTION_BATCH_COMPLETED": "تولید یک بچ محصول فله به اتمام می‌رسد",
            "PACKAGING_COMPLETED": "یک عملیات بسته‌بندی محصول نهایی انجام می‌شود",
            "ITEM_DISPOSED_AS_WASTE": "یک کالا به عنوان ضایعات ثبت می‌شود",
            "SALES_ORDER_PROFORMA_REQUESTED": "برای یک سفارش فروش، درخواست صدور پیش‌فاکتور می‌شود",
            "STOCK_ITEM_QUARANTINED": "یک بچ کالا در وضعیت قرنطینه قرار می‌گیرد",
            "MTO_SALES_ORDER_CREATED": "یک سفارش فروش از نوع 'سفارش تولید' ثبت می‌شود"
        }

        self.db = db
        self.pending_focus_trans_id = None
        
        # فعال‌سازی زیرساخت‌
        self.db.ensure_qa_gate_tables()        # از چرخه قبل
        self.db.ensure_qa_gate_meta_tables()   # جدول متادیتا
        self.db.register_default_gate_meta()   # ثبت متای جداول رایج
        self.db.ensure_qa_gate_triggers()      # ساخت ترایگر برای هر جدول فعال در متا

        # (اختیاری اما پیشنهادی) اگر قبلاً انجام نشده:
        self.db.seed_default_qa_gates()        # قوانین پیش‌فرض QC برای گذارهای حیاتی



        self.user_info = user_info; self.user_id = user_info.get('id'); self.user = user_info.get('username'); self.role = user_info.get('role_name'); self.user_dashboards = user_info.get('dashboards', []); self.permissions = set(user_info.get('permissions', [])); self.trans_delegate = CustomColorDelegate(self); self.bom_buttons = []; self.notification_panel = NotificationPanel(self.db, self); self.notification_animation = None; self.notifications_cache = []
        
        self.prod_interface_page = None; self.requests_page_tab = None; self.deliveries_page_tab = None; self.returns_page_tab = None; self.prod_page_loaded = False

        if not self.user_id:
            QtWidgets.QMessageBox.critical(None, "خطای بحرانی", "اطلاعات کاربر به درستی بارگذاری نشد. برنامه بسته می‌شود."); sys.exit()

        self.setWindowTitle('انبار MEGATITE'); self.setMinimumSize(1280, 800); self.setFont(QFont(FONT_FAMILY, 11)); self.toast = Toast(self); self.restart_on_close = False; self.refresh_mutex = QtCore.QMutex()

        central = QtWidgets.QWidget(); self.setCentralWidget(central); central.setLayoutDirection(QtCore.Qt.RightToLeft); layout = QtWidgets.QHBoxLayout(central); layout.setContentsMargins(0, 0, 0, 0)
        
        sidebar = QtWidgets.QFrame(); sidebar.setFixedWidth(220); sidebar.setObjectName("sidebar"); sb_lay = QtWidgets.QVBoxLayout(sidebar); sb_lay.setAlignment(Qt.AlignTop); sb_lay.setSpacing(5); sb_lay.setContentsMargins(0, 15, 0, 15); logo = QtWidgets.QLabel("MEGATITE"); logo.setFont(QFont(FONT_TITLE, 24)); logo.setAlignment(Qt.AlignCenter); logo.setStyleSheet("color:white; padding: 10px; background: transparent;"); sb_lay.addWidget(logo)

        self.pg_dash = QtWidgets.QWidget(); self.pg_items = QtWidgets.QWidget(); self.pg_trans = QtWidgets.QWidget(); self.pg_purchasing = QtWidgets.QWidget(); self.pg_qa = QtWidgets.QWidget(); self.pg_qc = QtWidgets.QWidget(); self.pg_sales = QtWidgets.QWidget(); self.pg_prod = QtWidgets.QWidget(); self.pg_inventory = QtWidgets.QWidget(); self.pg_kanban = QtWidgets.QWidget(); self.pg_communications = QtWidgets.QWidget(); self.pg_tracker = QtWidgets.QWidget(); self.pg_forms = QtWidgets.QWidget(); self.pg_settings = QtWidgets.QWidget()
        self.pages = QtWidgets.QStackedWidget()
        for page in [self.pg_dash, self.pg_items, self.pg_trans, self.pg_purchasing, self.pg_qa, self.pg_qc, self.pg_sales, self.pg_prod, self.pg_inventory, self.pg_kanban, self.pg_communications, self.pg_tracker, self.pg_forms, self.pg_settings]: self.pages.addWidget(page)

        self.sidebar_buttons = []; self.page_map = {}
        buttons_map = [
            ('داشبورد', QtWidgets.QStyle.SP_ComputerIcon, self.pg_dash, 'page:view:dashboard'), ('کالاها و دارایی‌ها', QtWidgets.QStyle.SP_DirOpenIcon, self.pg_items, 'page:view:items'),
            ('تراکنش‌ها', QtWidgets.QStyle.SP_BrowserReload, self.pg_trans, 'page:view:transactions'), ('بازرگانی', QtWidgets.QStyle.SP_DialogYesButton, self.pg_purchasing, 'page:view:purchasing'),
            ('تضمین کیفیت (QA)', QtWidgets.QStyle.SP_FileDialogDetailedView, self.pg_qa, 'page:view:qa'), ('کنترل کیفیت (QC)', QtWidgets.QStyle.SP_DialogApplyButton, self.pg_qc, 'page:view:qc'),
            ('فروش', QtWidgets.QStyle.SP_DialogHelpButton, self.pg_sales, 'page:view:sales'), ('مدیریت تولید', QtWidgets.QStyle.SP_ToolBarHorizontalExtensionButton, self.pg_prod, 'page:view:production'),
            ('انبارگردانی', QtWidgets.QStyle.SP_FileDialogListView, self.pg_inventory, 'page:view:inventory'), ('فرم‌ها', QtWidgets.QStyle.SP_FileIcon, self.pg_forms, 'page:view:forms'),
            ('تنظیمات و ابزارها', QtWidgets.QStyle.SP_FileDialogInfoView, self.pg_settings, 'page:view:settings')
        ]
        for text, style_icon, page, required_perm in buttons_map:
            if self.has_permission(required_perm):
                btn = QtWidgets.QPushButton(f"  {text}")
                # --- *** این خط باید حتما وجود داشته باشد *** ---
                btn.setLayoutDirection(QtCore.Qt.RightToLeft)
                # --- ************************************* ---
                icon = self.style().standardIcon(style_icon); btn.setIcon(icon); btn.setIconSize(QtCore.QSize(20, 20)); btn.setProperty("class", "sidebar-button"); btn.clicked.connect(lambda _, p=page: self.pages.setCurrentWidget(p)); sb_lay.addWidget(btn); self.sidebar_buttons.append(btn); self.page_map[page] = btn
        
        sb_lay.addStretch()
        btn_exit = QtWidgets.QPushButton("  خروج از برنامه")
        # --- *** این خط برای دکمه خروج نیز اعمال شود *** ---
        btn_exit.setLayoutDirection(QtCore.Qt.RightToLeft)
        # --- ****************************************** ---
        btn_exit.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_DialogCloseButton)); btn_exit.setIconSize(QtCore.QSize(20, 20)); btn_exit.setProperty("class", "sidebar-button"); btn_exit.clicked.connect(self.close); sb_lay.addWidget(btn_exit); self.sidebar_buttons.append(btn_exit)
        layout.addWidget(sidebar); layout.addWidget(self.pages, 1)
        
        self.pages.currentChanged.connect(self._on_page_changed)
        self._build_all_pages()
        if self.page_map: self.pages.setCurrentWidget(next(iter(self.page_map.keys())))
        self._on_page_changed(self.pages.currentIndex())
        self._load_app_data(); self.setup_auto_backup_timer(); self.setup_trigger_engine_timer(); self._is_refreshing = False
        if hasattr(self.db, 'signals') and hasattr(self.db.signals, 'dataChanged'):
            self.db.signals.dataChanged.connect(self.on_data_changed)
        QtCore.QTimer.singleShot(50, self.refresh_all)
                        
                                                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def on_data_changed(self, change_key: str):
        """این اسلات (slot) به سیگنال‌های دیتابیس گوش داده و در صورت لزوم برنامه را رفرش می‌کند."""
        print(f"INFO: Received dataChanged signal with key: {change_key}")
        if "NOTIFICATIONS" in change_key:
            self.refresh_all()                        
                    
    # <<< FIX
    def _build_qa_page(self):
        """داشبورد تضمین کیفیت (نسخه ساده شده و نهایی)."""
        layout = self.create_page_layout(self.pg_qa, "مرکز کنترل تضمین کیفیت (QA)")

        toolbar = QtWidgets.QFrame()
        toolbar_layout = QtWidgets.QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(0, 0, 0, 10)
        toolbar_layout.addStretch()

        if self.has_permission('qa:manage_workflows'):
            btn_new_workflow = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " طراحی فرآیند جدید")
            btn_new_workflow.clicked.connect(self._add_workflow)
            toolbar_layout.addWidget(btn_new_workflow)

        if self.has_permission('qa:manage_forms'):
            btn_manage_forms = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-properties"), " مدیریت فرم‌های QA")
            btn_manage_forms.clicked.connect(self._open_qa_forms_manager)
            toolbar_layout.addWidget(btn_manage_forms)

        if self.has_permission('qa:manage_workflows'):
            btn_manage_categories = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-dual"), " مدیریت دسته‌بندی فرآیندها")
            # قبلاً self.ui_facade پاس داده می‌شد که اشتباه بود؛ این دیالوگ db می‌خواهد
            btn_manage_categories.clicked.connect(lambda: ProcessCategoryManagerDialog(self.db, self).exec_())
            toolbar_layout.addWidget(btn_manage_categories)

        if self.has_permission('qa:manage_org_chart'):
            btn_org_chart = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-users"), " مدیریت چارت سازمانی")
            btn_org_chart.clicked.connect(self._open_org_chart_manager)
            toolbar_layout.addWidget(btn_org_chart)

        if self.has_permission('qa:map_events'):
            btn_event_map = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("network-wired"), " اتصال فرآیندها به رویدادها")
            btn_event_map.clicked.connect(self._open_event_mapping_dialog)
            toolbar_layout.addWidget(btn_event_map)

            btn_op_map = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("preferences-system"), " اتصال فرآیندها به عملیات")
            # این هم باید db بگیرد نه ui_facade
            btn_op_map.clicked.connect(lambda: SystemOperationMappingDialog(self.db, self).exec_())
            toolbar_layout.addWidget(btn_op_map)

        layout.addWidget(toolbar)

        group = QtWidgets.QGroupBox("نمای کلی فرآیندهای تعریف شده در سیستم (برای مدیریت، دابل-کلیک کنید)")
        group_layout = QtWidgets.QVBoxLayout(group)

        self.tbl_workflows = QtWidgets.QTableWidget()
        self._style_table(self.tbl_workflows)
        self.tbl_workflows.itemDoubleClicked.connect(self._open_workflow_manager)
        group_layout.addWidget(self.tbl_workflows)

        layout.addWidget(group)
        
                                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_qc_page(self):
        """صفحه اصلی ماژول کنترل کیفیت را با کنترل دسترسی کامل بر روی تب‌ها می‌سازد."""
        layout = self.create_page_layout(self.pg_qc, "مرکز کنترل کیفیت (QC)")
        
        self.qc_tabs = QtWidgets.QTabWidget()
        self.qc_tabs.setObjectName("interfaceTabWidget")
        layout.addWidget(self.qc_tabs)

        if self.has_permission('qc:manage_quarantine'):
            self.incoming_qc_widget = IncomingQCWidget(self.db, self.user_id, self)
            self.qc_tabs.addTab(self.incoming_qc_widget, "بازرسی کالاهای ورودی")
        
        if self.has_permission('qc:view_history'):
            self.qc_history_widget = QCHistoryWidget(self.db, self.user_id, self)
            self.qc_tabs.addTab(self.qc_history_widget, "بایگانی گزارش‌های کیفی")
        
        if self.has_permission('qc:resolve_nonconforming'):
            self.non_conforming_widget = NonConformingWidget(self.db, self.user_id, self)
            self.qc_tabs.addTab(self.non_conforming_widget, "مدیریت اقلام نامنطبق")

        if self.qc_tabs.count() == 0:
            no_access_label = QtWidgets.QLabel("شما به هیچ‌یک از بخش‌های کنترل کیفیت دسترسی ندارید.")
            no_access_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(no_access_label)
            self.qc_tabs.setVisible(False)
                        
                    
        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _refresh_qc_page(self):
        """داده‌های صفحه کنترل کیفیت را رفرش می‌کند."""
        if hasattr(self, 'incoming_qc_widget'):
            self.incoming_qc_widget.refresh_data()
        if hasattr(self, 'qc_history_widget'):
            self.qc_history_widget.search_records()
        if hasattr(self, 'non_conforming_widget'): # <<<<<<< این خط جدید را اضافه کن
            self.non_conforming_widget.refresh_data()
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_sales_page(self):
        """صفحه اصلی ماژول فروش را با کنترل دسترسی کامل بر روی تمام عملکردها می‌سازد."""
        layout = self.create_page_layout(self.pg_sales, "مرکز مدیریت فروش")
        
        self.sales_tabs = QtWidgets.QTabWidget()
        self.sales_tabs.setObjectName("interfaceTabWidget")
        self.sales_tabs.currentChanged.connect(self._on_sales_tab_changed)
        layout.addWidget(self.sales_tabs)

        # تب اول: تاریخچه سفارشات
        so_history_page = QtWidgets.QWidget()
        so_history_layout = QtWidgets.QVBoxLayout(so_history_page)
        so_history_layout.setContentsMargins(0, 10, 0, 0)
        
        toolbar = QtWidgets.QFrame(); toolbar_layout = QtWidgets.QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(0, 0, 0, 10)
        
        # --- *** بخش جدید و امنیتی: کنترل دسترسی برای هر دکمه *** ---
        if self.has_permission('sales:create_order'):
            btn_new_order = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " ثبت سفارش فروش جدید"); btn_new_order.setProperty("class", "primary"); btn_new_order.setMinimumHeight(35); btn_new_order.clicked.connect(self._open_sales_order_dialog)
            toolbar_layout.addWidget(btn_new_order)
        
        if self.has_permission('sales:manage_customers'):
            btn_manage_customers = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-users"), " مدیریت مشتریان"); btn_manage_customers.setMinimumHeight(35); btn_manage_customers.clicked.connect(lambda: CustomerManagerDialog(self.db, self).exec_())
            toolbar_layout.addWidget(btn_manage_customers)

        if self.has_permission('sales:inquire_qc'):
            btn_qc_inquiry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("dialog-information"), " استعلام سوابق کیفی بچ"); btn_qc_inquiry.setMinimumHeight(35); btn_qc_inquiry.clicked.connect(self._open_batch_qc_inquiry_dialog)
            toolbar_layout.addWidget(btn_qc_inquiry)

        toolbar_layout.addSpacing(20)

        if self.has_permission('sales:start_proforma_process'):
            btn_start_proforma = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), " ایجاد پیش‌فاکتور برای سفارش")
            btn_start_proforma.setMinimumHeight(35)
            btn_start_proforma.clicked.connect(self._start_proforma_process_action)
            toolbar_layout.addWidget(btn_start_proforma)
        # --- ****************************************************** ---

        toolbar_layout.addStretch()
        so_history_layout.addWidget(toolbar)

        info_label = QtWidgets.QLabel(" برای تهیه خروجی PDF، روی سفارش مورد نظر راست-کلیک کنید.")
        info_label.setStyleSheet("color: #2c3e50; font-style: italic; background-color: #e7f1ff; border: 1px solid #b3d1ff; border-radius: 4px; padding: 6px; margin-bottom: 5px;")
        so_history_layout.addWidget(info_label)

        self.tbl_sales_orders = QtWidgets.QTableWidget()
        self.tbl_sales_orders.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tbl_sales_orders.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tbl_sales_orders.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tbl_sales_orders.customContextMenuRequested.connect(self._show_sales_order_context_menu)
        add_filter_export_tools(self.tbl_sales_orders, so_history_layout)
        so_history_layout.addWidget(self.tbl_sales_orders, 1)
        self.sales_tabs.addTab(so_history_page, "تاریخچه سفارشات فروش")

        # تب دوم: کارتابل پیش‌فاکتورها
        proforma_page = QtWidgets.QWidget()
        proforma_layout = QtWidgets.QVBoxLayout(proforma_page)
        proforma_layout.setContentsMargins(0, 10, 0, 0)
        self.tbl_proforma_history = QtWidgets.QTableWidget()
        self._style_table(self.tbl_proforma_history)
        proforma_layout.addWidget(self.tbl_proforma_history, 1)
        self.sales_tabs.addTab(proforma_page, "پیش‌فاکتورهای در جریان")
        
                                                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _refresh_proforma_history(self):
        """جدول تاریخچه پیش‌فاکتورها را در صفحه فروش رفرش می‌کند."""
        if not hasattr(self, 'tbl_proforma_history'): return
        table = self.tbl_proforma_history
        table.setRowCount(0)
        
        try:
            records = self.db.get_proforma_invoice_history(self.user_id)
            headers = ["شماره سفارش", "مشتری", "تاریخ شروع فرآیند", "مرحله فعلی"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(records))
            
            for r, rec in enumerate(records):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(rec['so_number']))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(rec['customer_name']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(rec['started_at'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(rec.get('current_step', rec.get('process_status'))))
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ پیش‌فاکتوری توسط شما در جریان نیست.")
        except Exception as e:
            print(f"Error loading proforma history: {e}")
            
                        
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _on_sales_tab_changed(self, index=None):
        """با تغییر تب در صفحه فروش، محتوای آن را رفرش می‌کند."""
        if not hasattr(self, 'sales_tabs'): return

        current_tab_text = self.sales_tabs.tabText(self.sales_tabs.currentIndex())
        if current_tab_text == "تاریخچه سفارشات فروش":
            if hasattr(self, '_refresh_sales_page'):
                self._refresh_sales_page()
        elif current_tab_text == "پیش‌فاکتورهای در جریان":
            if hasattr(self, '_refresh_proforma_history'):
                self._refresh_proforma_history()
                                                        
                        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _start_proforma_process_action(self):
        """ابتدا پیش‌نمایش را نشان داده و سپس با اعلام رویداد، فرآیند را آغاز می‌کند."""
        if not hasattr(self, 'tbl_sales_orders'): return
        
        selected_rows = self.tbl_sales_orders.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً ابتدا یک سفارش فروش را از لیست انتخاب کنید.", "warning")
            return
            
        so_id = int(self.tbl_sales_orders.item(selected_rows[0].row(), 0).text())
        
        # --- بخش جدید: واکشی داده و نمایش دیالوگ پیش‌نمایش ---
        invoice_data = self.db.get_invoice_data_for_sales_order(so_id)
        if not invoice_data:
            self.toast.show_message("اطلاعات این سفارش برای ساخت پیش‌فاکتور یافت نشد.", "error")
            return
            
        preview_dlg = ProformaPreviewDialog(invoice_data, self)
        if preview_dlg.exec_() != QtWidgets.QDialog.Accepted:
            self.toast.show_message("عملیات لغو شد.", "info")
            return
        # --- پایان بخش جدید ---
            
        try:
            self.db.trigger_event(
                event_name='SALES_ORDER_PROFORMA_REQUESTED',
                record_id=so_id,
                table_name='sales_orders',
                user_id=self.user_id
            )
            self.toast.show_message("✔ درخواست صدور پیش‌فاکتور با موفقیت ارسال شد.", "success")
            self.refresh_all()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در شروع فرآیند", f"خطا: {e}\n\nآیا فرآیندی به این رویداد در ماژول QA متصل کرده‌اید؟")
                            
                                    
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _refresh_sales_page(self):
        """داده‌های صفحه فروش را به همراه ستون جدید "مرحله فرآیند" رفرش می‌کند."""
        if not hasattr(self, 'tbl_sales_orders'): return
        table = self.tbl_sales_orders
        table.setRowCount(0)
        
        try:
            orders = self.db.get_all_sales_orders()
            # --- *** افزودن ستون جدید به هدرها *** ---
            headers = ["ID", "شماره سفارش", "مشتری", "کالاهای سفارش", "حجم فروش (تعداد)", "مبلغ کل (ریال)", "تاریخ", "وضعیت تولید", "مرحله فرآیند"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(orders))

            for r, order in enumerate(orders):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['so_number']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(order['customer_name']))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(order.get('items_list', '')))
                table.setItem(r, 4, NumericTableWidgetItem(str(order.get('total_quantity', 0))))
                table.setItem(r, 5, NumericTableWidgetItem(f"{order.get('total_amount', 0):,.0f}"))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(to_shamsi(order['issue_date'])))
                table.setItem(r, 7, QtWidgets.QTableWidgetItem(order['status']))
                
                # --- *** پر کردن ستون جدید *** ---
                workflow_step = order.get('current_workflow_step')
                step_item = QtWidgets.QTableWidgetItem(workflow_step if workflow_step else '---')
                if workflow_step: # هایلایت کردن برای جلب توجه
                    step_item.setBackground(QtGui.QColor("#e7f1ff"))
                    step_item.setForeground(QtGui.QColor("#0d6efd"))
                table.setItem(r, 8, step_item)
                # --- ************************* ---

            table.setColumnHidden(0, True); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ سفارش فروشی تا کنون ثبت نشده است.")
        except Exception as e:
            print(f"Error loading sales orders: {e}")
            
            
            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _show_sales_order_context_menu(self, pos):
        """منوی راست‌کلیک را برای جدول سفارشات فروش با کنترل دسترسی نمایش می‌دهد."""
        table = self.tbl_sales_orders
        selected_item = table.itemAt(pos)
        if not selected_item:
            return

        menu = QtWidgets.QMenu(self)
        
        # --- *** بخش جدید و امنیتی: کنترل دسترسی برای هر اکشن منو *** ---
        added_action = False
        if self.has_permission('sales:export_pdf'):
            pdf_action = menu.addAction(QtGui.QIcon.fromTheme("document-export"), "تهیه خروجی PDF پیش‌فاکتور")
            action = menu.exec_(table.mapToGlobal(pos))
            
            if action == pdf_action:
                row = selected_item.row()
                so_id = int(table.item(row, 0).text())
                self._generate_proforma_pdf(so_id)
            added_action = True
        # --- ******************************************************* ---
        
        if not added_action:
            # اگر کاربر هیچ دسترسی مرتبطی نداشت، یک آیتم غیرفعال نمایش بده
            menu.addAction("هیچ عملیاتی مجاز نیست").setEnabled(False)
            menu.exec_(table.mapToGlobal(pos))
            
            
    def get_open_sales_orders(self):
        """
        رَپر ساده برای تأمین داده‌ی جدول سفارش‌های فروش باز.
        از DB می‌خواند و همان لیست دیکشنری‌ها را برمی‌گرداند.
        """
        try:
            return self.db.get_open_sales_orders()
        except Exception as e:
            # اگر توست/لاگر داری، همین‌جا هم پیام بده که UI خاموش نشود
            print(f"ERROR: get_open_sales_orders failed: {e}")
            return []

            
            
    def _generate_proforma_pdf(self, so_id: int):
        """داده‌های یک سفارش را گرفته و از آن یک فایل PDF پیش‌فاکتور تولید می‌کند."""
        invoice_data = self.db.get_invoice_data_for_sales_order(so_id)
        if not invoice_data:
            self.toast.show_message("اطلاعات سفارش برای ساخت PDF یافت نشد.", "error")
            return

        so_number = invoice_data.get('header', {}).get('so_number', 'invoice')
        default_path = f"{so_number}.pdf"
        
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "ذخیره فایل PDF پیش‌فاکتور", default_path, "PDF Files (*.pdf)")
        
        if file_path:
            try:
                # فراخوانی تابع سراسری که قبلاً نوشتیم
                create_invoice_pdf(invoice_data, file_path)
                self.toast.show_message("✔ فایل PDF پیش‌فاکتور با موفقیت ذخیره شد.", "success")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در ساخت PDF", f"یک خطای پیش‌بینی نشده رخ داد:\n{e}")
                print(traceback.format_exc())
            
                                    
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _open_batch_qc_inquiry_dialog(self):
        """دیالوگ استعلام سوابق کیفی را برای واحد فروش باز می‌کند."""
        if self.has_permission('page:view:sales'):
            dlg = BatchQCInquiryDialog(self.db, self)
            dlg.exec_()
        else:
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _open_sales_order_dialog(self):
        """دیالوگ ثبت سفارش فروش را باز کرده و در صورت تایید، جدول را رفرش می‌کند."""
        if not self.has_permission('page:view:sales'):
            self.toast.show_message("شما دسترسی لازم برای ثبت سفارش را ندارید.", "error")
            return
            
        # ارسال self (پنجره اصلی) به دیالوگ برای دسترسی به toast و سایر متدها
        dlg = SalesOrderDialog(self.db, self)
        
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            # در منطق جدید، ذخیره‌سازی داخل خود دیالوگ انجام می‌شود.
            # ما در اینجا فقط باید صفحه را برای نمایش سفارش جدید، رفرش کنیم.
            self._refresh_sales_page()
                                                                    
                                
    def _add_workflow(self):
        """یک میانبر برای باز کردن طراح فرآیند در حالت "جدید" است."""
        self._open_workflow_manager(item=None)

    def _load_workflows_list(self):
        """جدول نمای کلی فرآیندها در داشبورد QA را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_workflows'): return
        table = self.tbl_workflows
        table.setRowCount(0)
        workflows = self.db.get_workflows()
        
        headers = ["ID", "نام فرآیند", "فرم مرتبط", "وضعیت", "نسخه", "تاریخ ایجاد"]
        table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
        table.setRowCount(len(workflows))

        for r, wf in enumerate(workflows):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(wf['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(wf['name']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(str(wf.get('form_def_id', '---'))))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(wf.get('status', 'DRAFT')))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(str(wf.get('version', '1'))))
            table.setItem(r, 5, QtWidgets.QTableWidgetItem(to_shamsi(wf.get('created_at'))))

        table.setColumnHidden(0, True)
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
                    
    def _open_org_chart_manager(self):
        """دیالوگ مدیریت چارت سازمانی را باز می‌کند."""
        if self.has_permission('settings:manage_users'): # دسترسی موقت
            OrgChartManagerDialog(self.db, self).exec_()
        else:
            self.toast.show_message("شما دسترسی لازم برای مدیریت چارت سازمانی را ندارید.", "error")

    
# در کلاس MainWindow، این متد را جایگزین کنید
    def _open_qa_forms_manager(self):
        """دیالوگ مدیریت فرم‌های اختصاصی QA را با استفاده از فرم‌ساز پیشرفته باز می‌کند."""
        if self.has_permission('qa:manage_forms'):
            # فراخوانی دیالوگ مدیریتی جدید و کامل
            dlg = ManageQaFormsDialog(self.db, self.user_id, self.role, self)
            dlg.exec_()
            # پس از بسته شدن دیالوگ، ممکن است لازم باشد لیست فرم‌ها در طراح فرآیند رفرش شود
            # بنابراین یک رفرش کلی انجام می‌دهیم
            self.refresh_all()
        else:
            self.toast.show_message("شما دسترسی لازم برای مدیریت فرم‌های QA را ندارید.", "error")
                            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _open_event_mapping_dialog(self):
        """دیالوگ اتصال رویدادها به فرآیندها را باز می‌کند."""
        if self.has_permission('settings:manage_users'): # دسترسی موقت برای مدیر
            # ارسال دیکشنری رویدادهای سیستم به دیالوگ
            EventMappingDialog(self.db, self.SYSTEM_EVENTS, self).exec_()
        
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _show_po_details(self, item: QtWidgets.QTableWidgetItem):
        """دیالوگ جزئیات را برای سفارش خرید انتخاب شده باز می‌کند."""
        try:
            po_id = int(self.tbl_purchase_orders.item(item.row(), 0).text())
            dlg = PurchaseOrderDetailDialog(self.db, po_id, self)
            dlg.exec_()
        except (AttributeError, ValueError):
            # اگر روی ردیف نامعتبر کلیک شد، کاری نکن
            return

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_purchasing_page(self):
        """صفحه ماژول بازرگانی را با استفاده از میزکار هوشمند جدید می‌سازد."""
        layout = self.create_page_layout(self.pg_purchasing, "مدیریت بازرگانی و تامین")
        
        self.purchasing_tabs = QtWidgets.QTabWidget()
        self.purchasing_tabs.setObjectName("interfaceTabWidget")
        layout.addWidget(self.purchasing_tabs)

        # تب اول: میزکار اصلی بازرگانی
        self.purchasing_workbench_widget = PurchasingWorkbenchWidget(self.db, self.user_id, self)
        self.purchasing_tabs.addTab(self.purchasing_workbench_widget, "میزکار بازرگانی")

        # تب دوم: تاریخچه کلی سفارشات خرید
        po_history_page = QtWidgets.QWidget()
        po_history_layout = QtWidgets.QVBoxLayout(po_history_page)
        po_history_layout.setContentsMargins(0, 10, 0, 0)
        self.tbl_purchase_orders = QtWidgets.QTableWidget()
        self._style_table(self.tbl_purchase_orders)
        self.tbl_purchase_orders.itemDoubleClicked.connect(self._show_po_details)
        add_filter_export_tools(self.tbl_purchase_orders, po_history_layout)
        po_history_layout.addWidget(self.tbl_purchase_orders)
        self.purchasing_tabs.addTab(po_history_page, "تاریخچه سفارشات خرید")

        # تب سوم: داشبورد ارزیابی تامین‌کنندگان
        performance_page = QtWidgets.QWidget()
        performance_layout = QtWidgets.QVBoxLayout(performance_page)
        performance_layout.setContentsMargins(0, 10, 0, 0)
        toolbar = QtWidgets.QHBoxLayout()
        toolbar.addStretch()
        btn_manage_suppliers = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-users"), " مدیریت لیست تامین‌کنندگان")
        btn_manage_suppliers.setMinimumHeight(35)
        btn_manage_suppliers.clicked.connect(lambda: SupplierManagerDialog(self.db, self).exec_())
        toolbar.addWidget(btn_manage_suppliers)
        performance_layout.addLayout(toolbar)
        self.tbl_supplier_performance = QtWidgets.QTableWidget()
        self._style_table(self.tbl_supplier_performance)
        performance_layout.addWidget(self.tbl_supplier_performance)
        self.purchasing_tabs.addTab(performance_page, "داشبورد ارزیابی تامین‌کنندگان")
                        
                
        # این متد جدید را به کلاس MainWindow اضافه کنید

    def _load_supplier_performance(self):
        """داده‌های عملکرد کیفی تامین‌کنندگان را بارگذاری و در جدول مربوطه نمایش می‌دهد."""
        if not hasattr(self, 'tbl_supplier_performance'): return
        table = self.tbl_supplier_performance
        table.setRowCount(0)
        
        try:
            records = self.db.get_supplier_performance_data()
            headers = ['نام تامین‌کننده', 'تعداد کل بچ‌های دریافتی', 'تعداد بچ‌های رد شده', 'نرخ رد کیفی (%)']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(records))

            for r, rec in enumerate(records):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(rec['supplier_name']))
                table.setItem(r, 1, NumericTableWidgetItem(str(rec['total_batches'])))
                table.setItem(r, 2, NumericTableWidgetItem(str(rec['rejected_batches'])))
                
                rate_item = NumericTableWidgetItem(f"{rec['rejection_rate']:.2f} %")
                # رنگ‌آمیزی بر اساس نرخ رد کیفی
                if rec['rejection_rate'] > 10:
                    rate_item.setBackground(QtGui.QColor("#f8d7da")) # قرمز
                elif rec['rejection_rate'] > 5:
                    rate_item.setBackground(QtGui.QColor("#fff3cd")) # زرد
                table.setItem(r, 3, rate_item)

            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "داده‌ای برای ارزیابی عملکرد تامین‌کنندگان یافت نشد.")
        except Exception as e:
            print(f"Error loading supplier performance data: {e}")
            
                    
    def _add_quote_action(self):
        """دیالوگ افزودن پیشنهاد قیمت را برای درخواست انتخاب شده، باز می‌کند."""
        if not hasattr(self, 'tbl_actionable_prs'): return
        
        selected_pr = self.tbl_actionable_prs.selectedItems()
        if not selected_pr:
            self.toast.show_message("ابتدا یک درخواست خرید را از جدول بالا انتخاب کنید.", "warning")
            return
            
        request_id = int(self.tbl_actionable_prs.item(selected_pr[0].row(), 0).text())
        
        dlg = AddQuoteDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            quote_data = dlg.get_data()
            if quote_data:
                quote_data['request_id'] = request_id
                try:
                    self.db.add_quote(quote_data, self.user_id)
                    self.toast.show_message("✔ پیشنهاد قیمت جدید با موفقیت ثبت شد.", "success")
                    # رفرش کردن هر دو جدول در میزکار
                    self._load_actionable_purchase_requests()
                    self._load_quotes_for_pr(request_id)
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت پیشنهاد قیمت:\n{e}")
                    
    #
    # این متد جدید را به کلاس MainWindow اضافه کنید
    #
    def _select_quote_action(self):
        """پیشنهاد قیمت انتخاب شده را به عنوان برنده ثبت کرده و وضعیت درخواست را به‌روز می‌کند."""
        if not hasattr(self, 'tbl_actionable_prs') or not hasattr(self, 'tbl_quotes'): return

        selected_pr_items = self.tbl_actionable_prs.selectedItems()
        selected_quote_items = self.tbl_quotes.selectedItems()

        if not selected_pr_items or not selected_quote_items:
            self.toast.show_message("لطفاً هم درخواست خرید (از جدول بالا) و هم پیشنهاد برنده (از جدول پایین) را انتخاب کنید.", "warning")
            return
            
        try:
            request_id = int(self.tbl_actionable_prs.item(selected_pr_items[0].row(), 0).text())
            quote_id = int(self.tbl_quotes.item(selected_quote_items[0].row(), 0).text())
        except (ValueError, AttributeError):
            self.toast.show_message("انتخاب شما معتبر نیست.", "error")
            return

        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", "آیا از انتخاب این پیشنهاد به عنوان برنده و ارسال درخواست برای مرحله بعد اطمینان دارید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.select_winning_quote(request_id, quote_id, self.user_id)
                self.toast.show_message("✔ پیشنهاد برنده با موفقیت انتخاب شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند انتخاب برنده با خطا مواجه شد:\n{e}")
        
    def _on_pr_selected(self):
        """با انتخاب یک درخواست، لیست پیشنهادهای آن را بارگذاری و وضعیت دکمه PO را به‌روز می‌کند."""
        selected = self.tbl_actionable_prs.selectedItems()
        self.btn_issue_po.setEnabled(False) # غیرفعال کردن دکمه به صورت پیش‌فرض
        if not selected:
            self.tbl_quotes.setRowCount(0)
            return
            
        row = selected[0].row()
        request_id = int(self.tbl_actionable_prs.item(row, 0).text())
        status = self.tbl_actionable_prs.item(row, 4).text()
        
        # فقط اگر وضعیت "تامین‌کننده انتخاب شد" بود، دکمه فعال شود
        if status == 'تامین‌کننده انتخاب شد':
            self.btn_issue_po.setEnabled(True)
            
        self._load_quotes_for_pr(request_id)
            
# در کلاس MainWindow، این متد را جایگزین کنید

    def _process_task_action(self, item: QtWidgets.QTableWidgetItem):
        """با دابل کلیک روی یک کار، دیالوگ اقدام مناسب را باز می‌کند."""
        task_data = item.tableWidget().item(item.row(), 0).data(Qt.UserRole)
        if not task_data: return
        
        # --- بخش جدید: ایجاد منوی راست کلیک ---
        menu = QtWidgets.QMenu(self)
        
        action_perform = menu.addAction(QtGui.QIcon.fromTheme("system-run"), "انجام اقدام (تایید/رد)")
        action_history = menu.addAction(QtGui.QIcon.fromTheme("view-history"), "مشاهده تاریخچه فرآیند")
        
        # نمایش منو در موقعیت کلیک موس
        action = menu.exec_(QtGui.QCursor.pos())
        
        if action == action_perform:
            self._process_task_action_from_data(task_data)
        elif action == action_history:
            self._open_process_history_dialog(task_data)
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _process_task_action_from_data(self, task_data: dict):
        """پنجره اقدام را برای یک وظیفه مشخص باز کرده و نتیجه را به موتور گردش کار ارسال می‌کند."""
        if not task_data: return

        # این بخش بدون تغییر باقی می‌ماند
        if "فوریت" in task_data.get('step_name', ''):
            dlg = SetUrgencyDialog(self)
            if dlg.exec_():
                try:
                    self.db.set_purchase_request_urgency(request_id=task_data['related_record_id'], urgency=dlg.get_urgency(), user_id=self.user_id)
                    self.toast.show_message("✔ فوریت خرید با موفقیت ثبت شد.", "success"); self.refresh_all()
                except Exception as e: QtWidgets.QMessageBox.critical(self, "خطا در پردازش", f"عملیات با خطا مواجه شد:\n{e}")
            return

        dlg = ProcessActionDialog(task_data, self)
        
        # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
        # ما فقط زمانی فرآیند را ادامه می‌دهیم که کاربر یکی از دکمه‌های اصلی را زده باشد
        # و دیالوگ با موفقیت (accept) بسته شده باشد.
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            result = dlg.get_data()
            if result and result.get("outcome"):
                # تابع _execute_workflow_action را با مقادیر جدید فراخوانی می‌کنیم
                self._execute_workflow_action(
                    task_data=task_data, 
                    outcome_str=result["outcome"], 
                    reason=result["reason"]
                )
        # اگر کاربر پنجره را با "X" ببندد، dlg.exec_() مقدار Rejected برمی‌گرداند و این بلوک اجرا نمی‌شود.
        # --- ************************************** ---

    # تابع کمکی _execute_workflow_action را هم با این نسخه جدید جایگزین کنید
    def _execute_workflow_action(self, task_data, outcome_str: str, reason: str):
        """اقدام فرآیند را با استفاده از یک نخ پس‌زمینه آغاز می‌کند."""
        if not outcome_str: return

        self.toast.show_message("در حال پردازش اقدام شما در پس‌زمینه...", "info")

        self.action_thread = QtCore.QThread()
        # ارسال مستقیم رشته outcome به جای کد عددی
        self.action_worker = WorkflowActionWorker(self.db, task_data, self.user_id, outcome_str, reason)
        self.action_worker.moveToThread(self.action_thread)

        self.action_thread.started.connect(self.action_worker.run)
        self.action_worker.finished.connect(self._on_workflow_action_finished)
        self.action_worker.finished.connect(self.action_thread.quit)
        self.action_worker.finished.connect(self.action_worker.deleteLater)
        self.action_thread.finished.connect(self.action_thread.deleteLater)
        self.action_thread.finished.connect(lambda: setattr(self, 'action_thread', None))
        self.action_thread.start()
                                    
            
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _open_process_history_dialog(self, task_data: dict):
        """دیالوگ نمایش تاریخچه را برای یک وظیفه مشخص باز می‌کند."""
        if not task_data or not task_data.get('process_instance_id'):
            return
        
        process_id = task_data['process_instance_id']
        dlg = ProcessHistoryDialog(self.db, process_id, self)
        dlg.exec_()
        
                                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_pending_purchase_requests(self):
        """جدول کارتابل درخواست‌های خرید را بر اساس نقش کاربر فعلی و موتور فرآیند بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_my_pending_tasks'): return
        
        table = self.tbl_my_pending_tasks
        table.setRowCount(0)
        try:
            user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
            if not user_role_id_rec or not user_role_id_rec['role_id']:
                set_empty_placeholder(table, "نقش شما برای مشاهده درخواست‌ها تعریف نشده است.")
                return

            # فقط تسک‌های مربوط به خرید را فیلتر می‌کنیم
            all_tasks = self.db.get_pending_tasks_for_user_role(self.user_id, user_role_id_rec['role_id'])
            purchase_tasks = [t for t in all_tasks if t.get('related_table_name') == 'purchase_requests']
            
            headers = ['ID', 'نام کالا', 'مقدار', 'درخواست‌دهنده', 'تاریخ', 'یادداشت', 'مرحله فعلی']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(purchase_tasks))

            for r, task in enumerate(purchase_tasks):
                details = task.get('details', {})
                pr_id = task.get('related_record_id')
                
                # یک آیتم اصلی می‌سازیم و کل داده تسک را در آن ذخیره می‌کنیم
                id_item = QtWidgets.QTableWidgetItem(str(pr_id))
                id_item.setData(Qt.UserRole, task)
                table.setItem(r, 0, id_item)
                
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(details.get('item_name', '')))
                table.setItem(r, 2, NumericTableWidgetItem(str(details.get('qty', ''))))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(details.get('requester', '')))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(task.get('started_at'))))
                # یادداشت‌ها را باید از خود رکورد اصلی خواند
                # (این بخش در آینده می‌تواند بهینه‌تر شود)
                pr_rec = self.db.execute_query("SELECT notes FROM purchase_requests WHERE id=%s", (pr_id,), fetch_one=True)
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(pr_rec.get('notes', '') if pr_rec else ''))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(task.get('step_name', '')))
            
            table.setColumnHidden(0, True); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ درخواست خریدی در کارتابل شما وجود ندارد.")
        except Exception as e:
            print(f"Error loading purchase requests: {e}")
            
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _open_dynamic_form_for_workflow(self, workflow_id):
        """یک فرم را بر اساس ID فرآیند به صورت پویا ساخته و نمایش می‌دهد."""
        workflow_data = self.db.execute_query("SELECT form_def_id FROM workflows WHERE id = %s", (workflow_id,), fetch_one=True)
        if not workflow_data or not workflow_data.get('form_def_id'):
            self.toast.show_message("فرآیند انتخاب شده فرم مشخصی ندارد.", "error")
            return None

        form_id = workflow_data['form_def_id']
        form_fields = self.db.get_form_fields(form_id)
        if not form_fields:
            self.toast.show_message("فرم مرتبط با این فرآیند هیچ فیلدی ندارد.", "error")
            return None

        # اینجا در آینده کلاس DynamicFormDialog را فراخوانی خواهیم کرد
        # فعلا برای سادگی، فقط نام فیلدها را نمایش می‌دهیم
        # این بخش در فازهای بعدی تکمیل می‌شود
        
        # *** این یک راه حل موقت برای درخواست خرید است تا فاز ۱ کامل شود ***
        # در فاز بعدی این بخش با DynamicFormDialog واقعی جایگزین می‌شود
        if self.db.execute_query("SELECT 1 FROM system_event_mappings WHERE event_name='PURCHASE_REQUEST_CREATED' AND workflow_id=%s", (workflow_id,)):
             # فرض می‌کنیم فرم درخواست خرید همیشه ثابت است (تا زمان ساخت فرم‌ساز پیشرفته)
             dlg = ReplenishmentDialog(self.db, self.user_id, self) # از دیالوگ قبلی موقتا استفاده می‌کنیم
             if dlg.exec_():
                # ...
                pass

        # ... (منطق اصلی DynamicFormDialog در اینجا پیاده‌سازی خواهد شد) ...

        return True # به معنی موفقیت‌آمیز بودن باز شدن فرم 
    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _start_manual_process(self):
        """دیالوگ شروع فرآیند دستی را باز کرده و در صورت انتخاب، فرم آن را نمایش می‌دهد."""
        start_dlg = StartProcessDialog(self.db, self)
        if start_dlg.exec_():
            workflow_id = start_dlg.get_selected_workflow_id()
            if workflow_id:
                workflow_data = self.db.execute_query("SELECT name, form_def_id FROM workflows WHERE id = %s", (workflow_id,), fetch_one=True)
                if not workflow_data or not workflow_data.get('form_def_id'):
                    self.toast.show_message("فرآیند انتخاب شده فرم مشخصی ندارد.", "error")
                    return

                form_id = workflow_data['form_def_id']
                
                # فراخوانی فرم‌ساز پویا
                form_dlg = DynamicFormDialog(self.db, form_id, f"شروع فرآیند: {workflow_data['name']}", self)
                if form_dlg.exec_():
                    form_data = form_dlg.get_data()
                    if form_data:
                        try:
                            # داده‌های فرم را در دیتابیس ثبت کرده و فرآیند را آغاز می‌کنیم
                            entry_id = self.db.add_or_update_form_entry(form_id, self.user_id, json.dumps(form_data, ensure_ascii=False))
                            with self.db.transaction() as cur:
                                self.db.start_workflow_instance(workflow_id, entry_id, 'form_entries', cur)
                            
                            self.toast.show_message("✔ فرآیند با موفقیت شروع شد و به کارتابل اولین مسئول ارسال گردید.", "success")
                            self.refresh_all()
                        except Exception as e:
                             QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در شروع فرآیند:\n{e}")
                                                     
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _create_purchase_request_action(self, item_data):
        """گردش کار ایجاد درخواست خرید برای یک کالا را مدیریت می‌کند."""
        if not item_data: return
        item_id = item_data.get('id')
        item_name = item_data.get('name')
        
        # محاسبه مقدار پیشنهادی
        suggested_qty = item_data.get('max_qty', 1) - item_data.get('non_prod_qty', 0)
        if suggested_qty < 0: suggested_qty = 1.0

        dlg = CreatePurchaseRequestDialog(item_name, suggested_qty, self)
        if dlg.exec_():
            data = dlg.get_data()
            if data:
                try:
                    self.db.create_purchase_request(item_id, data['quantity'], self.user_id, data['notes'])
                    self.toast.show_message("✔ درخواست خرید با موفقیت ثبت و برای بازرگانی ارسال شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست خرید:\n{e}")
                    
# این دو متد جدید را به کلاس MainWindow اضافه کنید

# در کلاس MainWindow، این متد را جایگزین کنید
    def _approve_selected_pr(self):
        """درخواست خرید انتخاب شده را برای ارسال به مدیر واحد، تایید اولیه می‌کند."""
        if not hasattr(self, 'tbl_purchase_requests'): return
        
        selected_rows = self.tbl_purchase_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را برای تایید انتخاب کنید.", "warning")
            return
            
        row = selected_rows[0].row()
        request_id = int(self.tbl_purchase_requests.item(row, 0).text())
        item_name = self.tbl_purchase_requests.item(row, 1).text()

        reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا از تایید اولیه درخواست خرید برای «{item_name}» و ارسال آن برای مدیر واحد مطمئنید؟")
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.process_purchase_request(request_id, self.user_id, is_approved=True)
                self.toast.show_message("✔ درخواست خرید با موفقیت برای تایید مدیر واحد ارسال شد.", "success")
                self._load_pending_purchase_requests() # رفرش کردن لیست
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند تایید با خطا مواجه شد:\n{e}")
                
                
    def _reject_selected_pr(self):
        """درخواست خرید انتخاب شده را پس از دریافت دلیل، رد می‌کند."""
        if not hasattr(self, 'tbl_purchase_requests'): return
        
        selected_rows = self.tbl_purchase_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را برای رد کردن انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        request_id = int(self.tbl_purchase_requests.item(row, 0).text())
        item_name = self.tbl_purchase_requests.item(row, 1).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد درخواست", f"لطفاً دلیل رد کردن درخواست برای «{item_name}» را وارد کنید:")
        if ok and reason.strip():
            try:
                self.db.process_purchase_request(request_id, self.user_id, is_approved=False, reason=reason.strip())
                self.toast.show_message("✖ درخواست خرید رد شد.", "info")
                self._load_pending_purchase_requests() # رفرش کردن لیست
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "warning")
            
    def _augment_qa_page_with_command_center(self):
        """
        مرکز فرماندهی + پنل تنظیمات QA را به تب QA تزریق می‌کند.
        """
        try:
            # Command Center
            box1 = QtWidgets.QGroupBox("مرکز فرماندهی QA")
            v1 = QtWidgets.QVBoxLayout(box1)
            v1.addWidget(QaCommandCenterWidget(self.db, self))

            # Settings Panel
            box2 = QtWidgets.QGroupBox("تنظیمات قوانین QA")
            v2 = QtWidgets.QVBoxLayout(box2)
            v2.addWidget(QaSettingsPanelWidget(self.db, self))

            if self.pg_qa.layout():
                self.pg_qa.layout().addWidget(box1)
                self.pg_qa.layout().addWidget(box2)
            else:
                lay = QtWidgets.QVBoxLayout(self.pg_qa)
                lay.addWidget(box1)
                lay.addWidget(box2)
        except Exception as e:
            print("WARN: mount QA widgets failed:", e)
            
    # --- [OPTIONAL-HOOK] استفاده‌ی سریع از Orchestrator در MainWindow -------------
    def _get_orchestrator(self):
        """
        این متد را داخل MainWindow اضافه کن تا هرجا لازم شد از یک orchestrator مشترک استفاده کنیم.
        """
        if not hasattr(self, '_qa_orchestrator'):
            self._qa_orchestrator = QaOrchestrator(self.db)
        return self._qa_orchestrator
    
    # ─────────────────────────────────────────────────────────────────────────────
    # [NEW in MainWindow] گِیت ساده‌ی UI قبل از تغییر وضعیت
    # ─────────────────────────────────────────────────────────────────────────────

    def _qa_gate_or_block(self, table_name: str, record_id: int, transition_status: str) -> bool:
        """
        اگر فرم‌های الزامی تکمیل/تأیید نشده باشند، پیام می‌دهد و عملیات را متوقف می‌کند.
        True یعنی عبور مجاز؛ False یعنی بلوکه شد.
        """
        try:
            ok, errs = self.db.check_qa_gates(table_name, record_id, transition_status)
        except Exception as e:
            QMessageBox.warning(self, "گِیت کیفیت", f"بررسی گِیت با خطا مواجه شد:\n{e}")
            return False

        if ok:
            return True

        msg = "برای انجام این عملیات، موارد زیر باید تکمیل شوند:\n\n- " + "\n- ".join(errs)
        QMessageBox.warning(self, "گِیت کیفیت", msg)
        return False




            

                
                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _build_all_pages(self):
        """Builds all pages of the application."""
        # The line "self.notification_buttons.clear()" has been removed from here.
        
        self._build_dashboard_page()
        self._build_items_page()
        self._build_trans_page()
        self._build_purchasing_page()
        self._build_qa_page()
        self._augment_qa_page_with_command_center()

        self._build_qc_page() # <<< --- اصلاح کلیدی اینجاست: فراخوانی تابع فراموش شده
        self._build_production_page()
        self._build_inventory_page()
        self._build_kanban_page()
        self._build_communications_page()
        self._build_tracker_page()
        self._build_forms_page()
        self._build_settings_page()
        
                                            
    def _build_forms_page(self):
            layout = self.create_page_layout(self.pg_forms, "مدیریت فرم‌ها")
            # --- اصلاح کلیدی اینجاست ---
            main_widget = FormsPage(self.db, self.user, self._viewer(), self) # آرگومان self اضافه شد
            # --- پایان اصلاح ---
            layout.addWidget(main_widget)        



# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def create_page_layout(self, page_widget, title: str, show_back_button=False) -> QtWidgets.QVBoxLayout:
        if page_widget.layout() is not None:
            QtWidgets.QWidget().setLayout(page_widget.layout())
        page_layout = QtWidgets.QVBoxLayout(page_widget)
        page_layout.setContentsMargins(20, 15, 20, 20); page_layout.setSpacing(15)
        header_layout = QtWidgets.QHBoxLayout(); header_layout.setContentsMargins(0, 0, 0, 10)
        title_label = QtWidgets.QLabel(title); title_label.setProperty("class", "title")
        header_layout.addWidget(title_label)
        if show_back_button:
            btn_back = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " بازگشت به داشبورد")
            btn_back.setProperty("class", "primary"); btn_back.setMinimumHeight(35)
            btn_back.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_dash))
            header_layout.addWidget(btn_back); header_layout.addSpacing(20)
        header_layout.addStretch()
        btn_notifications = QtWidgets.QPushButton()
        btn_notifications.setToolTip("کارتابل اعلانات و موارد نیازمند اقدام")
        btn_notifications.setFixedSize(55, 40) # دکمه بزرگتر
        btn_notifications.setObjectName("notificationButtonHeader")
        btn_notifications.clicked.connect(self._open_notifications_dialog)
        icon_path = BASE_DIR / 'icons' / 'bell.png'
        icon = QtGui.QIcon(str(icon_path))
        if icon.isNull():
            icon = QtGui.QIcon.fromTheme("dialog-information")
        btn_notifications.setIcon(icon)
        # --- *** اصلاح کلیدی: بزرگتر کردن سایز آیکون *** ---
        btn_notifications.setIconSize(QtCore.QSize(26, 26))
        user_icon = QtWidgets.QLabel(); user_icon.setPixmap(QtGui.QIcon.fromTheme("user-identity").pixmap(22, 22))
        user_label = QtWidgets.QLabel(f"کاربر: <b>{self.user}</b> ({self.role})"); user_label.setStyleSheet("background-color: transparent;")
        logout_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-log-out"), " خروج از حساب"); logout_btn.clicked.connect(self._logout)
        header_layout.addWidget(btn_notifications); header_layout.addSpacing(15)
        header_layout.addWidget(user_icon); header_layout.addWidget(user_label); header_layout.addSpacing(15)
        header_layout.addWidget(logout_btn)
        page_layout.addLayout(header_layout)
        separator = QtWidgets.QFrame(); separator.setFrameShape(QtWidgets.QFrame.HLine); separator.setFrameShadow(QtWidgets.QFrame.Sunken); separator.setStyleSheet("background-color: #dfe6e9;"); page_layout.addWidget(separator)
        return page_layout
            
        
            
            
        
                
    def _build_communications_page(self):
        """صفحه اختصاصی و تمام-صفحه مرکز ارتباطات داخلی را می‌سازد."""
        layout = self.create_page_layout(self.pg_communications, "مرکز ارتباطات داخلی", show_back_button=True)
        
        main_widget = QtWidgets.QWidget()
        main_layout = QtWidgets.QVBoxLayout(main_widget)
        
        actions_layout = QtWidgets.QHBoxLayout()
        btn_new_memo = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-message-new"), "ارسال نامه جدید")
        btn_new_memo.setProperty("class", "primary"); btn_new_memo.setMinimumHeight(40)
        btn_new_memo.clicked.connect(self._open_memo_dialog)
        actions_layout.addStretch(); actions_layout.addWidget(btn_new_memo)
        main_layout.addLayout(actions_layout)

        self.comm_page_widget = CommunicationWidget(self.db, self.user_id, self)
        main_layout.addWidget(self.comm_page_widget)
        
        layout.addWidget(main_widget)

# در کلاس MainWindow، این متد را جایگزین کنید
    def _build_tracker_page(self):
        """صفحه اختصاصی و تمام-صفحه ردیاب فرآیند را می‌سازد."""
        layout = self.create_page_layout(self.pg_tracker, "ردیاب فرآیند", show_back_button=True)
        
        # --- اصلاح کلیدی: ارسال صحیح user_id و self به عنوان parent ---
        self.tracker_page_widget = ProcessTrackerWidget(self.db, self.user_id, self)
        layout.addWidget(self.tracker_page_widget)                    
                
            
# این متد را در کلاس MainWindow جایگزین کنید
    def _open_notifications_dialog(self):
        """پنل کشویی اعلانات را باز می‌کند."""
        button = self.sender()
        if button:
            self.notification_panel.show_panel(button)
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _update_notification_count(self):
        """تعداد اعلانات را شمارش کرده و روی دکمه اعلان صفحه فعال، انیمیشن تپش را کنترل می‌کند."""
        count = len(self.notifications_cache)
        current_page = self.pages.currentWidget()
        if not current_page: return
        btn = current_page.findChild(QtWidgets.QPushButton, "notificationButtonHeader")
        if not btn: return
        btn.setText(str(count) if count > 0 else "")
        if count > 0:
            if self.notification_animation is None:
                self.notification_animation = QtCore.QSequentialAnimationGroup(self)
                # --- *** اصلاح کلیدی: انیمیشن قوی‌تر و واضح‌تر *** ---
                anim1 = QtCore.QPropertyAnimation(btn, b"iconSize"); anim1.setDuration(350); anim1.setStartValue(QtCore.QSize(26, 26)); anim1.setEndValue(QtCore.QSize(38, 38)); anim1.setEasingCurve(QtCore.QEasingCurve.OutQuad)
                anim2 = QtCore.QPropertyAnimation(btn, b"iconSize"); anim2.setDuration(1000); anim2.setStartValue(QtCore.QSize(38, 38)); anim2.setEndValue(QtCore.QSize(26, 26)); anim2.setEasingCurve(QtCore.QEasingCurve.OutBounce)
                self.notification_animation.addAnimation(anim1); self.notification_animation.addAnimation(anim2)
                self.notification_animation.setLoopCount(-1)
            if self.notification_animation.state() != QtCore.QAbstractAnimation.Running:
                self.notification_animation.start()
            btn.setStyleSheet("""
                QPushButton { background-color: #e74c3c; color: white; border-radius: 8px; font-weight: bold; padding: 0 8px; }
                QPushButton:hover { background-color: #c0392b; }
            """)
        else:
            if self.notification_animation and self.notification_animation.state() == QtCore.QAbstractAnimation.Running:
                self.notification_animation.stop()
                btn.setIconSize(QtCore.QSize(26, 26))
            btn.setStyleSheet("""
                QPushButton { background-color: transparent; border: none; }
                QPushButton:hover { background-color: #dfe6e9; border-radius: 4px; }
            """)
                                    
                        
                        
# این متد را جایگزین _open_notifications_dialog کنید
    def _toggle_notification_panel(self):
        """پنل کشویی اعلانات را زیر دکمه سراسری نوار کناری باز می‌کند."""
        self.notification_panel.show_panel(self.sidebar_notification_button)
            
                                                                    
    # در کلاس MainWindow جایگزینِ کاملِ متد قبلی
    def _handle_notification_action(self, action_key, action_data):
        """
        هدایت امن بر اساس اعلان‌ها:
        - حالت جدید: پنجرهٔ مستقل «عملیات انبار…» و تب‌های داخلش
        - حالت قدیم (fallback): سوییچ به پنل داخلی صفحهٔ تراکنش‌ها اگر هنوز وجود دارد
        """

        def safe_toast(msg, level='info'):
            if hasattr(self, 'toast') and hasattr(self.toast, 'show_message'):
                try:
                    self.toast.show_message(msg, level)
                except Exception:
                    pass

        if action_key == 'VIEW_COMMUNICATIONS':
            self.pages.setCurrentWidget(self.pg_communications)
            if hasattr(self, 'notification_panel'): self.notification_panel.hide()
            return

        if action_key == 'CEO_APPROVE_WORKFLOW':
            self.pages.setCurrentWidget(self.pg_dash)
            if hasattr(self, 'dashboard_selector'):
                index = self.dashboard_selector.findData('CEO')
                if index != -1:
                    self.dashboard_selector.setCurrentIndex(index)
            if hasattr(self, 'notification_panel'): self.notification_panel.hide()
            return

        if action_key == 'REWORK_WORKFLOW':
            self.pages.setCurrentWidget(self.pg_qa)
            # بازکردن مدیر گردش‌کار بعد از یک tik برای اینکه UI کامل رندر شود
            QtCore.QTimer.singleShot(50, lambda: self._open_workflow_manager(workflow_id=action_data))
            if hasattr(self, 'notification_panel'): self.notification_panel.hide()
            return

        # --- عملیات انبار: سه اکشن زیر باید به تب‌های متناظر بروند
        if action_key in ('FULFILL_REQUEST', 'APPROVE_DELIVERY', 'APPROVE_RETURN'):
            tab_map = {
                'FULFILL_REQUEST': 'requests',     # درخواست‌های مواد اولیه
                'APPROVE_DELIVERY': 'deliveries',  # محصولات منتظر تایید
                'APPROVE_RETURN': 'returns'        # برگشتی‌ها از تولید
            }

            # حالت جدید (ترجیحی): اگر متد پنجرهٔ عملیات انبار وجود دارد، از آن استفاده کن
            if hasattr(self, '_open_warehouse_ops'):
                self._open_warehouse_ops(tab_map[action_key])
                if hasattr(self, 'notification_panel'): self.notification_panel.hide()
                return

            # حالت قدیم (fallback): اگر هنوز پنل داخلی صفحه تراکنش‌ها وجود دارد
            self.pages.setCurrentWidget(self.pg_trans)
            if hasattr(self, 'prod_interface_page') and hasattr(self, 'tab_widget_trans'):
                try:
                    self.tab_widget_trans.setCurrentWidget(self.prod_interface_page)
                except Exception:
                    pass

            # سوییچ به تب داخلیِ قدیم اگر هنوز ساخته شده باشد
            if hasattr(self, 'interface_tabs'):
                target_attr = {
                    'FULFILL_REQUEST': 'requests_page_tab',
                    'APPROVE_DELIVERY': 'deliveries_page_tab',
                    'APPROVE_RETURN': 'returns_page_tab'
                }[action_key]
                page_obj = getattr(self, target_attr, None)
                if page_obj is not None:
                    try:
                        self.interface_tabs.setCurrentWidget(page_obj)
                    except Exception:
                        pass
                else:
                    safe_toast("این بخش برای نقش کاربری شما فعال نیست یا هنوز ساخته نشده.", "warning")
            else:
                safe_toast("پنجرهٔ عملیات انبار در دسترس نیست.", "warning")

            if hasattr(self, 'notification_panel'): self.notification_panel.hide()
            return

        if action_key == 'APPROVE_TRANSFER':
            # مسیر قبلی دست‌نخورده
            self.pages.setCurrentWidget(self.pg_prod)
            if hasattr(self, 'notification_panel'): self.notification_panel.hide()
            return

        # اگر کلید ناشناخته بود
        safe_toast("اکشن اعلان نامعتبر است یا پشتیبانی نمی‌شود.", "warning")
        if hasattr(self, 'notification_panel'): self.notification_panel.hide()
                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _build_inventory_page(self):
        """
        نسخه نهایی (اصلاح شده):
        - استایل تب‌ها برای حل قطعی مشکل عرض، به صورت مستقیم اعمال شده است.
        """
        layout = self.create_page_layout(self.pg_inventory, "مدیریت انبارگردانی")
        
        action_bar = QtWidgets.QHBoxLayout()
        if self.has_permission('inventory:start_count'):
            btn_start_count = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " شروع انبارگردانی جدید")
            btn_start_count.setProperty("class", "primary"); btn_start_count.setMinimumHeight(35)
            btn_start_count.clicked.connect(self._start_new_count)
            action_bar.addWidget(btn_start_count)
        
        action_bar.addStretch()
        layout.addLayout(action_bar)
        
        self.inventory_tabs = QtWidgets.QTabWidget()
        self.inventory_tabs.setObjectName("interfaceTabWidget")

        # --- اصلاح کلیدی و نهایی: استفاده از همان روش موفق صفحه تولید ---
        # یک استایل مستقیم که حداقل عرض و پدینگ مناسب را به تب‌ها می‌دهد.
        self.inventory_tabs.setStyleSheet("QTabBar::tab { min-width: 220px; padding: 10px; }")

        layout.addWidget(self.inventory_tabs, 1)

        # تب اول: شمارش‌های در حال انجام
        open_counts_page = QtWidgets.QWidget()
        open_counts_layout = QtWidgets.QVBoxLayout(open_counts_page)
        open_counts_layout.setContentsMargins(0, 10, 0, 0)
        self.tbl_open_counts = QtWidgets.QTableWidget()
        self._style_table(self.tbl_open_counts)
        self.tbl_open_counts.itemDoubleClicked.connect(self._open_count_sheet)
        open_counts_layout.addWidget(self.tbl_open_counts)
        self.inventory_tabs.addTab(open_counts_page, "شمارش‌های در حال انجام")

        # تب دوم: شمارش‌های منتظر بازبینی
        if self.has_permission('inventory:review_count'):
            review_counts_page = QtWidgets.QWidget()
            review_counts_layout = QtWidgets.QVBoxLayout(review_counts_page)
            review_counts_layout.setContentsMargins(0, 10, 0, 0)
            self.tbl_review_counts = QtWidgets.QTableWidget()
            self._style_table(self.tbl_review_counts)
            self.tbl_review_counts.itemDoubleClicked.connect(self._open_count_sheet)
            review_counts_layout.addWidget(self.tbl_review_counts)
            self.inventory_tabs.addTab(review_counts_page, "شمارش‌های منتظر بازبینی")
                                                                    
    def _open_count_sheet(self, item: QtWidgets.QTableWidgetItem):
            """
            نسخه ۲.۰ (هوشمند):
            - این متد حالا به جای یک جدول ثابت، با هر جدولی که به آن متصل شود کار می‌کند.
            - با استفاده از item.tableWidget()، منبع کلیک را تشخیص داده و اطلاعات را از آن می‌خواند.
            """
            if not item: return
            
            table = item.tableWidget() # تشخیص خودکار جدول منبع
            if not table: return

            try:
                row = item.row()
                count_id = int(table.item(row, 0).text())
                status = table.item(row, 2).text()
            except (AttributeError, ValueError, TypeError) as e:
                print(f"Could not get count details from table: {e}")
                return
            
            # بقیه منطق بدون تغییر باقی می‌ماند
            if status == 'OPEN':
                if not self.has_permission('inventory_count:perform'):
                    self.toast.show_message("شما دسترسی لازم برای انجام شمارش را ندارید.", "error")
                    return
                dlg = CountSheetDialog(self.db, self.user_id, count_id, self)
                if dlg.exec_():
                    self._load_open_counts()
                    self._load_review_counts() # ممکن است یک آیتم از باز به بازبینی برود
            
            elif status == 'REVIEW':
                if not self.has_permission('inventory_count:review'):
                    self.toast.show_message("شما دسترسی لازم برای بازبینی این سند را ندارید.", "error")
                    return
                dlg = ReviewCountDialog(self.db, self.user_id, count_id, self)
                if dlg.exec_():
                    # بعد از بازبینی، یک آیتم از لیست بازبینی حذف می‌شود
                    self._load_review_counts()
            else:
                self.toast.show_message(f"این سند در وضعیت '{status}' قرار دارد و عملیات بیشتری روی آن ممکن نیست.", "info")
                        
        
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _start_new_count(self):
        """دیالوگ شروع شمارش جدید را باز کرده و در صورت تایید، سند را در دیتابیس ایجاد می‌کند."""
        # جلوگیری از شروع شمارش جدید وقتی یک شمارش باز وجود دارد (برای آینده)
        # if self.db.has_open_count():
        #     QtWidgets.QMessageBox.warning(self, "خطا", "یک انبارگردانی باز وجود دارد. ابتدا آن را ببندید.")
        #     return

        dlg = StartCountDialog(self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            count_type, notes = dlg.get_data()
            try:
                count_id = self.db.create_new_count_session(count_type, notes, self.user_id)
                self.toast.show_message(f"✔ انبارگردانی جدید با ID={count_id} شروع شد.")
                self._load_counts_list() # رفرش کردن لیست برای نمایش سند جدید
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد سند انبارگردانی:\n{e}")
                
    def _load_open_counts(self):
            """جدول شمارش‌های باز را بارگذاری می‌کند."""
            if not hasattr(self, 'tbl_open_counts'): return
            
            table = self.tbl_open_counts
            table.setRowCount(0)
            sessions = [s for s in self.db.get_count_sessions() if s.get('status') == 'OPEN']
            
            headers = ["ID سند", "نوع شمارش", "وضعیت", "تاریخ ایجاد", "ایجاد کننده"]
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setColumnHidden(0, True)
            table.setRowCount(len(sessions))

            for r, session in enumerate(sessions):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(session['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(session.get('type', '')))
                status_item = QtWidgets.QTableWidgetItem(session.get('status', ''))
                status_item.setForeground(QtGui.QColor('#2980b9'))
                status_item.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
                table.setItem(r, 2, status_item)
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(session.get('created_at'))))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(session.get('created_by', '')))
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)

    def _load_review_counts(self):
        """جدول شمارش‌های منتظر بازبینی را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_review_counts'): return

        table = self.tbl_review_counts
        table.setRowCount(0)
        sessions = [s for s in self.db.get_count_sessions() if s.get('status') == 'REVIEW']

        headers = ["ID سند", "نوع شمارش", "وضعیت", "تاریخ ایجاد", "شمارشگر"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setColumnHidden(0, True)
        table.setRowCount(len(sessions))

        for r, session in enumerate(sessions):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(session['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(session.get('type', '')))
            status_item = QtWidgets.QTableWidgetItem(session.get('status', ''))
            status_item.setForeground(QtGui.QColor('#fd7e14')) # Orange color for review
            status_item.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
            table.setItem(r, 2, status_item)
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(session.get('created_at'))))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(session.get('created_by', '')))
            
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        
    def _create_kpi_card(self, title, value, color, icon_name):
        """یک ویجت KPI گرافیکی و قابل کلیک برای داشبورد می‌سازد."""
        card = ClickableFrame()
        card.setObjectName("kpiCard")
        
        card.setStyleSheet(f"""
            QFrame#kpiCard {{
                background-color: {color};
                border-radius: 8px;
            }}
            QFrame#kpiCard:hover {{
                background-color: {QtGui.QColor(color).lighter(115).name()};
            }}
            QFrame#kpiCard QLabel {{
                color: white;
                background-color: transparent;
                border: none;
            }}
        """)
        
        card_layout = QtWidgets.QHBoxLayout(card)
        card_layout.setContentsMargins(20, 15, 20, 15)
        card_layout.setSpacing(15)

        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(32, 32))
        
        text_layout = QtWidgets.QVBoxLayout(); text_layout.setSpacing(0)
        title_label = QtWidgets.QLabel(title); title_label.setFont(QFont(FONT_FAMILY, 11, QFont.Bold))
        value_label = QtWidgets.QLabel(value); value_label.setFont(QFont(FONT_FAMILY, 18, QFont.Bold))
        text_layout.addWidget(title_label); text_layout.addWidget(value_label)
        
        card_layout.addLayout(text_layout, 1)
        card_layout.addWidget(icon_label)
            
        card.value_label = value_label
        return card

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _build_dashboard_page(self):
        """داشبورد را به صورت پویا بر اساس لیست داشبوردهای مجاز کاربر ایجاد می‌کند."""
        base_layout = self.create_page_layout(self.pg_dash, "داشبورد")
        
        if base_layout.count() > 2:
            item = base_layout.takeAt(2)
            if item and item.widget():
                item.widget().deleteLater()

        dashboard_keys = self.user_dashboards
        
        if self.role == 'Admin':
            dashboard_keys = ["DEFAULT", "WAREHOUSE", "PURCHASING", "CEO"]

        if not dashboard_keys:
            base_layout.addWidget(self._build_standard_user_panel())
            return
        
        if len(dashboard_keys) == 1:
            key = dashboard_keys[0]
            builder_func = getattr(self, f"_build_{key.lower()}_dashboard", self._build_standard_user_panel)
            base_layout.addWidget(builder_func())
            return

        container_widget = QtWidgets.QWidget()
        container_layout = QtWidgets.QVBoxLayout(container_widget)
        
        selector_layout = QtWidgets.QHBoxLayout()
        selector_layout.addWidget(QtWidgets.QLabel("<b>نمایش داشبورد:</b>"))
        dashboard_selector = QtWidgets.QComboBox()
        selector_layout.addWidget(dashboard_selector)
        selector_layout.addStretch()
        container_layout.addLayout(selector_layout)

        dashboard_stack = QtWidgets.QStackedWidget()
        container_layout.addWidget(dashboard_stack)
        
        DASHBOARD_NAME_MAP = {
            "DEFAULT": "پنل کاربری استاندارد",
            "WAREHOUSE": "داشبورد انبار",
            "PURCHASING": "داشبورد بازرگانی",
            "CEO": "داشبورد مدیرعامل"
        }

        for key in dashboard_keys:
            if key in DASHBOARD_NAME_MAP:
                builder_func = getattr(self, f"_build_{key.lower()}_dashboard", self._build_standard_user_panel)
                dashboard_widget = builder_func()
                dashboard_stack.addWidget(dashboard_widget)
                dashboard_selector.addItem(DASHBOARD_NAME_MAP[key], key)
            
        dashboard_selector.currentIndexChanged.connect(dashboard_stack.setCurrentIndex)
        
        # --- *** اصلاح کلیدی اینجاست *** ---
        # علاوه بر تغییر صفحه، تابع رفرش را هم فراخوانی می‌کنیم.
        dashboard_selector.currentIndexChanged.connect(self._refresh_dashboard_page)
        
        base_layout.addWidget(container_widget)
                        
        #
    def _build_admin_dashboard_container(self):
        """ویجت کانتینر ویژه داشبورد ادمین که شامل منوی جابجایی است را می‌سازد."""
        admin_dash_widget = QtWidgets.QWidget()
        admin_layout = QtWidgets.QVBoxLayout(admin_dash_widget)
        
        selector_layout = QtWidgets.QHBoxLayout()
        selector_layout.addWidget(QtWidgets.QLabel("<b>نمایش داشبورد به عنوان:</b>"))
        self.dashboard_selector = QtWidgets.QComboBox()
        selector_layout.addWidget(self.dashboard_selector)
        selector_layout.addStretch()
        admin_layout.addLayout(selector_layout)

        self.admin_dashboard_stack = QtWidgets.QStackedWidget()
        admin_layout.addWidget(self.admin_dashboard_stack)
        
        # تمام داشبوردهای موجود را می‌سازیم و به استک و کمبوباکس اضافه می‌کنیم
        dashboards = {
            "پنل کاربری استاندارد": self._build_standard_user_panel(),
            "داشبورد انبار": self._build_warehouse_dashboard(),
            "داشبورد بازرگانی": self._build_purchasing_dashboard(),
            "داشبورد مدیرعامل": self._build_ceo_dashboard(),
        }
        for name, widget in dashboards.items():
            self.admin_dashboard_stack.addWidget(widget)
            self.dashboard_selector.addItem(name)
            
        self.dashboard_selector.currentIndexChanged.connect(self.admin_dashboard_stack.setCurrentIndex)
        return admin_dash_widget
                        
            
                                        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_ceo_dashboard(self):
        """داشبورد استراتژیک مدیرعامل را با ساختار دو بخشی و قابلیت فیلتر می‌سازد."""
        container = QtWidgets.QWidget(); container_layout = QtWidgets.QVBoxLayout(container); container_layout.setContentsMargins(0, 0, 0, 0)
        dashboard_stack = QtWidgets.QStackedWidget(); container_layout.addWidget(dashboard_stack)

        main_dashboard_page = QtWidgets.QWidget(); main_layout = QtWidgets.QVBoxLayout(main_dashboard_page); main_layout.setSpacing(20)
        
        kpi_layout = QtWidgets.QHBoxLayout()
        self.ceo_card_sales = self._create_kpi_card("مجموع فروش (۳۰ روز)", "0 ریال", "#0d6efd", "cash")
        self.ceo_card_production = self._create_kpi_card("سفارشات تولید باز", "0", "#198754", "view-process-tasks")
        self.ceo_card_inventory = self._create_kpi_card("ارزش کل موجودی", "0 ریال", "#6f42c1", "package")
        self.ceo_card_tasks = self._create_kpi_card("کارهای منتظر تایید", "0", "#dc3545", "dialog-warning")
        kpi_layout.addWidget(self.ceo_card_sales); kpi_layout.addWidget(self.ceo_card_production); kpi_layout.addWidget(self.ceo_card_inventory); kpi_layout.addWidget(self.ceo_card_tasks)
        main_layout.addLayout(kpi_layout)

        bottom_layout = QtWidgets.QHBoxLayout()
        sales_group = QtWidgets.QGroupBox("روند فروش ۳۰ روز گذشته (برای فیلتر کردن روی نقاط کلیک کنید)"); sales_layout = QtWidgets.QVBoxLayout(sales_group)
        self.sales_chart_widget = SalesChartWidget(self.db, self); sales_layout.addWidget(self.sales_chart_widget)
        # --- *** اتصال سیگنال نمودار به متد فیلتر *** ---
        self.sales_chart_widget.dateClicked.connect(self._filter_approvals_by_date)
        bottom_layout.addWidget(sales_group, 1)

        approvals_group = QtWidgets.QGroupBox("فرآیندهای منتظر تایید"); approvals_layout = QtWidgets.QVBoxLayout(approvals_group)
        
        # --- *** افزودن دکمه پاک کردن فیلتر *** ---
        approvals_toolbar = QtWidgets.QHBoxLayout()
        self.btn_clear_filter_ceo = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-clear"), "حذف فیلتر تاریخ")
        self.btn_clear_filter_ceo.setVisible(False) # در ابتدا مخفی است
        self.btn_clear_filter_ceo.clicked.connect(self._clear_approvals_filter)
        approvals_toolbar.addStretch()
        approvals_toolbar.addWidget(self.btn_clear_filter_ceo)
        approvals_layout.addLayout(approvals_toolbar)
        # --- *********************************** ---

        self.tbl_workflow_approvals = QtWidgets.QTableWidget(); self._style_table(self.tbl_workflow_approvals); self.tbl_workflow_approvals.itemDoubleClicked.connect(self._review_workflow)
        approvals_layout.addWidget(self.tbl_workflow_approvals)
        bottom_layout.addWidget(approvals_group, 1)
        main_layout.addLayout(bottom_layout, 1)
        
        btn_go_to_analysis = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-statistics"), " ورود به مرکز تحلیل‌های استراتژیک")
        btn_go_to_analysis.setMinimumHeight(40); btn_go_to_analysis.setProperty("class", "primary")
        main_layout.addWidget(btn_go_to_analysis, 0, QtCore.Qt.AlignCenter)

        # ... (بقیه کد این متد برای ساخت صفحه تحلیل‌ها بدون تغییر باقی می‌ماند) ...
        analysis_page = QtWidgets.QWidget()
        analysis_layout = QtWidgets.QGridLayout(analysis_page)
        btn_back = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " بازگشت به داشبورد اصلی"); btn_back.setMinimumHeight(35)
        analysis_layout.addWidget(btn_back, 0, 1, QtCore.Qt.AlignRight)
        production_group = QtWidgets.QGroupBox("تحلیل عملکرد تولید"); prod_layout = QtWidgets.QVBoxLayout(production_group)
        self.production_chart_widget = ProductionChartWidget(self.db, self); prod_layout.addWidget(self.production_chart_widget)
        top_products_group = QtWidgets.QGroupBox("برترین محصولات"); top_products_layout = QtWidgets.QVBoxLayout(top_products_group)
        self.top_products_chart_widget = TopProductsChartWidget(self.db, self); top_products_layout.addWidget(self.top_products_chart_widget)
        inventory_value_group = QtWidgets.QGroupBox("ارزش موجودی به تفکیک دسته"); inv_val_layout = QtWidgets.QVBoxLayout(inventory_value_group)
        self.pie_frame_layout = QtWidgets.QHBoxLayout(); inv_val_layout.addLayout(self.pie_frame_layout)
        analysis_layout.addWidget(production_group, 1, 0); analysis_layout.addWidget(top_products_group, 1, 1); analysis_layout.addWidget(inventory_value_group, 2, 0, 1, 2)
        dashboard_stack.addWidget(main_dashboard_page); dashboard_stack.addWidget(analysis_page)
        btn_go_to_analysis.clicked.connect(lambda: dashboard_stack.setCurrentIndex(1))
        btn_back.clicked.connect(lambda: dashboard_stack.setCurrentIndex(0))
        
        return container
        
# در کلاس MainWindow، این دو متد را به طور کامل جایگزین کنید
    def _filter_approvals_by_date(self, selected_date: dt.date):
        """جدول تاییدها را بر اساس تاریخ انتخاب شده از نمودار، فیلتر می‌کند."""
        if not hasattr(self, 'tbl_workflow_approvals'): return
        
        table = self.tbl_workflow_approvals
        shamsi_date_str_short = to_shamsi(selected_date).split(' ')[0]
        
        # نمایش پیغام و فعال کردن دکمه ریست
        if self.toast:
            self.toast.show_message(f"نمایش فرآیندهای آغاز شده در تاریخ: {shamsi_date_str_short}", "info")
        if hasattr(self, 'btn_clear_filter_ceo'):
            self.btn_clear_filter_ceo.setVisible(True)

        # --- *** منطق اصلی و فراموش شده فیلتر کردن *** ---
        for r in range(table.rowCount()):
            # فرض می‌کنیم ستون تاریخ ایجاد، ستون چهارم (ایندکس 4) است
            date_item_shamsi = table.item(r, 4).text().split(' ')[0]
            if date_item_shamsi == shamsi_date_str_short:
                table.setRowHidden(r, False)
            else:
                table.setRowHidden(r, True)
        # --- ****************************************** ---

    def _clear_approvals_filter(self):
        """فیلتر اعمال شده روی جدول تاییدها را پاک می‌کند."""
        if not hasattr(self, 'tbl_workflow_approvals'): return
        table = self.tbl_workflow_approvals
        for r in range(table.rowCount()):
            table.setRowHidden(r, False)
        
        if self.toast: self.toast.show_message("فیلتر تاریخ حذف شد.", "info")
        if hasattr(self, 'btn_clear_filter_ceo'):
            self.btn_clear_filter_ceo.setVisible(False)
            
                            
            
            
                        
    # این متد جدید را به کلاس MainWindow اضافه کنید

    def _on_ceo_task_selected(self):
        """با انتخاب یک وظیفه در کارتابل مدیرعامل، پنل جزئیات را به‌روز می‌کند."""
        if not hasattr(self, 'ceo_tasks_widget'): return
        
        selected_items = self.ceo_tasks_widget.table.selectedItems()
        if not selected_items:
            self.ceo_task_details_widget.update_with_task(None)
            return
            
        task_data = self.ceo_tasks_widget.table.item(selected_items[0].row(), 0).data(Qt.UserRole)
        self.ceo_task_details_widget.update_with_task(task_data)
            
    #
    # این متد جدید را به کلاس MainWindow اضافه کنید
    #
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_my_tasks(self, table_widget: QtWidgets.QTableWidget):
        """
        نسخه نهایی (هوشمند و داده-محور):
        کارتابل را با تمام وظایف کاربر پر کرده و جزئیات هر وظیفه را به صورت هوشمند نمایش می‌دهد.
        """
        if not table_widget: return
        table_widget.setRowCount(0)
        
        try:
            user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
            role_id = user_role_id_rec['role_id'] if user_role_id_rec else None
            if not role_id:
                set_empty_placeholder(table_widget, "نقش شما برای مشاهده کارتابل تعریف نشده است.")
                return

            tasks = self.db.get_pending_tasks_for_user_role(self.user_id, role_id)
            
            if hasattr(self, 'purch_card_tasks'):
                self.purch_card_tasks.value_label.setText(f"{len(tasks)} مورد")

            headers = ['ID', 'نوع فرآیند', 'مرحله فعلی', 'جزئیات', 'تاریخ ایجاد', 'ارجاع از طرف']
            table_widget.setColumnCount(len(headers)); table_widget.setHorizontalHeaderLabels(headers)
            table_widget.setRowCount(len(tasks))

            for r, task in enumerate(tasks):
                details_text = "جزئیات نامشخص"
                details_json = task.get('details', {})
                
                # --- *** بخش جدید و هوشمند برای نمایش جزئیات غنی *** ---
                if task['related_table_name'] == 'purchase_requests':
                    details_text = f"درخواست خرید برای «{details_json.get('item_name')}» به مقدار {details_json.get('qty')} توسط {details_json.get('requester')}"
                elif task['related_table_name'] == 'stock':
                    details_text = f"کالای «{details_json.get('item_name')}» (بچ: {details_json.get('batch_no')}) به دلیل '{details_json.get('reason')}' رد شده است."
                # ... در آینده می‌توان برای انواع دیگر نیز به اینجا اضافه کرد ...
                # --- ************************************************** ---

                item_id = QtWidgets.QTableWidgetItem(str(task['process_instance_id']))
                item_id.setData(Qt.UserRole, task)
                table_widget.setItem(r, 0, item_id)
                table_widget.setItem(r, 1, QtWidgets.QTableWidgetItem(task['workflow_name']))
                table_widget.setItem(r, 2, QtWidgets.QTableWidgetItem(task['step_name']))
                table_widget.setItem(r, 3, QtWidgets.QTableWidgetItem(details_text))
                table_widget.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(task['started_at'])))
                
                delegation_text = f"به نیابت از {task['original_approver_role']}" if task.get('is_delegated') else "مستقیم"
                table_widget.setItem(r, 5, QtWidgets.QTableWidgetItem(delegation_text))

            table_widget.setColumnHidden(0, True); table_widget.resizeColumnsToContents()
            table_widget.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table_widget, "هیچ کار جدیدی در کارتابل شما وجود ندارد.")
        except Exception as e:
            print(f"Error loading pending tasks into widget {table_widget.objectName()}: {e}")
            
                        
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _update_active_task_details(self, task_data):
        """پنل جزئیات وظیفه را در داشبورد فعال فعلی، با داده‌های جدید به‌روز می‌کند."""
        if self.pages.currentWidget() != self.pg_dash:
            return
            
        # تشخیص اینکه کدام پنل جزئیات فعال است (مدیرعامل یا انبار)
        if hasattr(self, 'ceo_task_details_widget') and self.ceo_task_details_widget.isVisible():
            self.ceo_task_details_widget.update_with_task(task_data)
        elif hasattr(self, 'warehouse_task_details_widget') and self.warehouse_task_details_widget.isVisible():
            # در آینده، این بخش برای نمایش فرم‌ها و اقدامات انباردار تکمیل خواهد شد
            # self.warehouse_task_details_widget.update_with_task(task_data)
            pass # فعلا غیرفعال تا در گام بعد منطق آن را پیاده کنیم
    
# در کلاس MainWindow، این متد را جایگزین کنید
    def _load_workflow_approvals(self):
        """جدول فرآیندهای منتظر تایید در داشبورد مدیرعامل را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_workflow_approvals'): return
        table = self.tbl_workflow_approvals
        table.setRowCount(0)
        print("DEBUG: Refreshing CEO approvals table...")
        try:
            workflows = self.db.get_pending_workflows_for_approval()
            
            # --- بخش تشخیصی ---
            print(f"DEBUG: Found {len(workflows)} workflows pending approval.")
            
            headers = ["ID", "نام فرآیند", "توضیحات", "ایجاد کننده", "تاریخ ایجاد"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(workflows))

            for r, wf in enumerate(workflows):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(wf['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(wf['name']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(wf.get('description', '')))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(wf.get('created_by', '')))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(wf.get('created_at'))))
            
            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ فرآیندی منتظر تایید شما نیست.")
        except Exception as e:
            print(f"Error loading workflow approvals: {e}")
            
    def _review_workflow(self, item: QtWidgets.QTableWidgetItem):
        """دیالوگ بازبینی یک فرآیند منتظر تایید را باز می‌کند."""
        row = item.row()
        workflow_id = int(self.tbl_workflow_approvals.item(row, 0).text())
        
        dlg = WorkflowReviewDialog(self.db, workflow_id, self)
        result = dlg.exec_()
        
        try:
            if result == QtWidgets.QDialog.Accepted:
                self.db.approve_workflow(workflow_id, self.user_id)
                self.toast.show_message("✔ فرآیند با موفقیت تایید و در سیستم فعال شد.", "success")
            elif result == QtWidgets.QDialog.Rejected:
                reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد فرآیند", "لطفاً دلیل بازگرداندن این فرآیند به واحد QA را ذکر کنید:")
                if ok and reason:
                    self.db.reject_workflow(workflow_id, self.user_id, reason)
                    self.toast.show_message("فرآیند به واحد QA بازگردانده شد.", "info")
            
            self.refresh_all() # برای آپدیت شدن کارتابل
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا", f"عملیات با خطا مواجه شد:\n{e}")
                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

# در کلاس MainWindow، این متد را با نسخه زیر جایگزین کنید
    def _build_warehouse_dashboard(self):
        """داشبورد اختصاصی انبار را ساخته و سیگنال آن را به کنترل‌کننده متصل می‌کند."""
        if not hasattr(self, 'warehouse_dashboard_widget_instance'):
            self.warehouse_dashboard_widget_instance = WarehouseDashboardWidget(self.db, self)
            # --- *** اتصال سیگنال داشبورد به متد کنترل‌کننده در MainWindow *** ---
        return self.warehouse_dashboard_widget_instance

                        
# این سه متد جدید را به کلاس MainWindow اضافه کنید

    def _create_kpi_widget(self, title, icon_name, color):
        """یک ویجت KPI گرافیکی برای داشبورد می‌سازد."""
        widget = QtWidgets.QFrame()
        widget.setObjectName("kpiCard")
        widget.setStyleSheet(f"#kpiCard {{ background-color: {color}; border-radius: 8px; }}")
        
        layout = QtWidgets.QVBoxLayout(widget)
        layout.setContentsMargins(15, 10, 15, 10)
        
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(24, 24))
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("color: white; font-weight: bold; background: transparent;")
        
        value_label = QtWidgets.QLabel("0")
        value_label.setStyleSheet("color: white; font-size: 18pt; font-weight: bold; background: transparent;")
        
        top_layout = QtWidgets.QHBoxLayout()
        top_layout.addWidget(icon_label); top_layout.addStretch(); top_layout.addWidget(title_label)
        
        layout.addLayout(top_layout)
        layout.addWidget(value_label, 0, QtCore.Qt.AlignRight)
        
        widget.value_label = value_label
        return widget

                    
# این سه متد جدید را به کلاس MainWindow اضافه کنید

    def _create_kpi_widget(self, title, icon_name, color):
        """یک ویجت KPI گرافیکی برای داشبورد می‌سازد."""
        widget = QtWidgets.QFrame()
        widget.setObjectName("kpiCard")
        widget.setStyleSheet(f"#kpiCard {{ background-color: {color}; border-radius: 8px; }}")
        
        layout = QtWidgets.QVBoxLayout(widget)
        layout.setContentsMargins(15, 10, 15, 10)
        
        icon_label = QtWidgets.QLabel()
        icon_label.setPixmap(QtGui.QIcon.fromTheme(icon_name).pixmap(24, 24))
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("color: white; font-weight: bold; background: transparent;")
        
        value_label = QtWidgets.QLabel("0")
        value_label.setStyleSheet("color: white; font-size: 18pt; font-weight: bold; background: transparent;")
        
        top_layout = QtWidgets.QHBoxLayout()
        top_layout.addWidget(icon_label); top_layout.addStretch(); top_layout.addWidget(title_label)
        
        layout.addLayout(top_layout)
        layout.addWidget(value_label, 0, QtCore.Qt.AlignRight)
        
        widget.value_label = value_label
        return widget


    def _build_standard_user_panel(self):
        """داشبورد عملیاتی و هوشمند را برای کاربر استاندارد می‌سازد."""
        panel = QtWidgets.QWidget(); layout = QtWidgets.QVBoxLayout(panel)
        layout.setContentsMargins(15, 15, 15, 15); layout.setSpacing(20)

        # بخش ۱: کارت‌های KPI
        kpi_layout = QtWidgets.QHBoxLayout()
        self.std_card_tasks = self._create_kpi_widget("کارهای جدید", "view-process-tasks", "#3498db")
        self.std_card_memos = self._create_kpi_widget("پیام‌های خوانده نشده", "mail-mark-unread", "#1abc9c")
        kpi_layout.addWidget(self.std_card_tasks); kpi_layout.addWidget(self.std_card_memos); kpi_layout.addStretch(1)
        layout.addLayout(kpi_layout)
        
        # بخش ۲: مرکز اقدامات پویا
        self.actions_card = CardWidget("مرکز اقدامات", "system-run", "#27ae60")
        self.actions_layout = QtWidgets.QHBoxLayout()
        self.actions_card.setContentLayout(self.actions_layout)
        layout.addWidget(self.actions_card)

        # بخش ۳: کارتابل وظایف
        user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
        role_id = user_role_id_rec['role_id'] if user_role_id_rec else None
        if role_id:
            self.standard_tasks_widget = TasksWidget(self.db, self.user_id, role_id, self, "آخرین وظایف شما (برای اقدام دابل کلیک کنید)")
            layout.addWidget(self.standard_tasks_widget, 1)
        
        # بخش ۴: دسترسی‌های سریع
        quick_nav_card = CardWidget("دسترسی‌های سریع", "go-jump", "#34495e")
        quick_nav_layout = QtWidgets.QHBoxLayout()
        
        btn_kanban = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-kanban"), " مدیر وظایف شخصی (کانبان)"); btn_kanban.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_kanban))
        btn_comms = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-message-new"), " مرکز ارتباطات"); btn_comms.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_communications))
        btn_tracker = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-search"), " ردیاب فرآیند"); btn_tracker.clicked.connect(lambda: self.pages.setCurrentWidget(self.pg_tracker))

        for btn in [btn_kanban, btn_comms, btn_tracker]:
            btn.setMinimumHeight(40)
            quick_nav_layout.addWidget(btn)

        quick_nav_card.setContentLayout(quick_nav_layout)
        layout.addWidget(quick_nav_card)
        
        return panel
                            
    def _build_kanban_page(self):
        """صفحه اختصاصی و تمام-صفحه مدیر وظایف کانبان را می‌سازد."""
        layout = self.create_page_layout(self.pg_kanban, "مدیر وظایف من (کانبان)", show_back_button=True)
        
        user_role_id_rec = self.db.execute_query("SELECT role_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
        role_id = user_role_id_rec['role_id'] if user_role_id_rec else None
        
        if role_id:
            self.kanban_board_page_widget = KanbanBoardWidget(self.db, self.user_id, role_id, self)
            layout.addWidget(self.kanban_board_page_widget)
        else:
            layout.addWidget(QtWidgets.QLabel("نقش شما برای مشاهده وظایف تعریف نشده است."))
            
                            
    def _open_memo_dialog(self):
        """دیالوگ نوشتن نامه جدید را باز می‌کند."""
        dlg = MemoDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    self.db.create_memo(self.user_id, data['subject'], data['body'], data['to_user_ids'], data['cc_user_ids'])
                    self.toast.show_message("✔ نامه با موفقیت ارسال شد.", "success")
                    if hasattr(self, 'comm_widget'): # رفرش کردن ویجت ارتباطات
                        self.comm_widget.refresh_sent()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ارسال نامه:\n{e}")

    
# این متد کاملا جدید را به کلاس MainWindow اضافه کنید
    def _initiate_pr_from_internal_request(self):
        """
        گردش کار ایجاد درخواست خرید توسط انباردار برای یک درخواست داخلی ناموجود را مدیریت می‌کند.
        """
        # این متد باید از داخل کارتابل انباردار فراخوانی شود
        # ما در اینجا فرض می‌کنیم که یک جدول به نام self.tbl_internal_requests در کارتابل انباردار وجود دارد
        table = self.tbl_internal_requests # شما باید این را به نام واقعی جدول در UI خود تغییر دهید
        selected_rows = table.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست نیازمند تامین را انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        status = table.item(row, table.columnCount() - 1).text() # فرض می‌کنیم وضعیت آخرین ستون است
        
        if status != TransactionStatus.IR_PENDING_PURCHASE.value:
            self.toast.show_message("این عملیات فقط برای درخواست‌های 'نیازمند تامین کالا' مجاز است.", "info")
            return

        try:
            item_id = int(table.item(row, 0).data(Qt.UserRole)['item_id']) # خواندن داده از آیتم جدول
            item_name = table.item(row, 1).text()
            quantity = float(table.item(row, 2).text())
            original_request_id = int(table.item(row, 0).text())
        except (AttributeError, ValueError, KeyError):
            self.toast.show_message("اطلاعات ردیف انتخاب شده معتبر نیست.", "error")
            return

        # باز کردن دیالوگ آشنای مرکز تامین کالا با کالای از پیش انتخاب شده
        self._open_replenishment_center(preselected_item_id=item_id)
        
        # در آینده می‌توان پس از ایجاد موفقیت‌آمیز PR، وضعیت درخواست داخلی اصلی را به "در حال تامین" تغییر داد.
                
                                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _load_my_internal_requests(self):
        """جدول تاریخچه درخواست‌های داخلی ثبت شده توسط کاربر فعلی را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_my_internal_requests'):
            return

        table = self.tbl_my_internal_requests
        table.setSortingEnabled(False)
        table.setRowCount(0)
        
        try:
            requests = self.db.get_internal_requests_by_user(self.user_id)
            
            headers = ["ID", "نام کالا", "مقدار درخواستی", "وضعیت", "تاریخ ثبت"]
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(requests))

            # --- *** نقشه وضعیت جدید و کامل مبتنی بر Enum *** ---
            status_map = {
                TransactionStatus.IR_PENDING_FULFILLMENT.value: 'در انتظار رسیدگی انبار',
                TransactionStatus.IR_PENDING_PURCHASE.value: 'نیازمند تامین (کمبود موجودی)',
                TransactionStatus.IR_FULFILLED.value: 'تحویل شده',
                TransactionStatus.IR_REJECTED.value: 'رد شده توسط انبار'
            }
            # --- ****************************************** ---

            for r, req in enumerate(requests):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(req['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(req['item_name']))
                table.setItem(r, 2, NumericTableWidgetItem(str(req['quantity'])))
                
                # استفاده از نقشه جدید برای ترجمه وضعیت
                status_display = status_map.get(req['status'], req['status'])
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(status_display))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(req['created_at'])))
            
            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "شما تا کنون هیچ درخواستی ثبت نکرده‌اید.")
            table.setSortingEnabled(True)

        except Exception as e:
            print(f"Error loading user's internal request history: {e}")
            

    def _fulfill_internal_request(self):
        """گردش کار رسیدگی به یک درخواست داخلی دارای موجودی را مدیریت می‌کند."""
        table = self.tbl_internal_requests
        selected_rows = table.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را برای رسیدگی انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        req_data = table.item(row, 0).data(Qt.UserRole)
        
        if req_data.get('status') != TransactionStatus.IR_PENDING_FULFILLMENT.value:
            self.toast.show_message("این عملیات فقط برای درخواست‌های 'در انتظار رسیدگی انبار' مجاز است.", "info")
            return

        # باز کردن دیالوگ ثبت خروج با اطلاعات از پیش پر شده
        dlg = TransactionDialog(self.db, self.user_id, 'خروج', self, item_id=req_data['item_id'])
        dlg.e_qty.setText(str(req_data['quantity']))
        dlg.e_no.setText(f"IR-{req_data['id']}") # شماره درخواست داخلی به عنوان شماره سند
        
        # اتصال سیگنال دیالوگ به یک تابع کنترلر
        def on_trans_created(trans_data):
            try:
                # ابتدا تراکنش خروج را ثبت می‌کنیم
                trans_id = self.db.add_trans_extended(trans_data, self.user_id)
                # سپس وضعیت درخواست داخلی را آپدیت می‌کنیم
                self.db.fulfill_internal_request(req_data['id'], trans_id, self.user_id)
                self.toast.show_message("✔ کالا با موفقیت تحویل و از انبار خارج شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند با خطا مواجه شد:\n{e}")

        dlg.transaction_data_ready.connect(on_trans_created)
        dlg.exec_()
                                        
    # این متد را در کلاس MainWindow جایگزین کنید
    def _build_purchasing_dashboard(self):
        """داشبورد اختصاصی بازرگانی را ایجاد می‌کند."""
        panel = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(panel)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)

        kpi_layout = QtWidgets.QHBoxLayout()
        kpi_layout.setSpacing(20)

        # --- اصلاح کلیدی در دو خط زیر انجام شده است ---
        self.purch_card_tasks = self._create_kpi_card("کارهای منتظر اقدام", "0", "#3498db", "view-process-tasks")
        self.purch_card_suppliers = self._create_kpi_card("تامین‌کنندگان فعال", "0", "#1abc9c", "system-users")

        kpi_layout.addWidget(self.purch_card_tasks)
        kpi_layout.addWidget(self.purch_card_suppliers)
        kpi_layout.addStretch()
        layout.addLayout(kpi_layout)

        tasks_group = QtWidgets.QGroupBox("کارتابل وظایف من (برای اقدام دابل کلیک کنید)")
        tasks_layout = QtWidgets.QVBoxLayout(tasks_group)
        self.purchasing_tasks_table = QtWidgets.QTableWidget()
        self._style_table(self.purchasing_tasks_table)
        self.purchasing_tasks_table.itemDoubleClicked.connect(self._process_task_action)
        tasks_layout.addWidget(self.purchasing_tasks_table)
        layout.addWidget(tasks_group, 1)
        return panel
    
# این دو متد جدید را به کلاس MainWindow اضافه کنید
    def setup_trigger_engine_timer(self):
        """تایمر اصلی برنامه را برای چک کردن خودکار رویدادها تنظیم می‌کند."""
        self.trigger_timer = QtCore.QTimer(self)
        # هر ۵ دقیقه یک بار چک می‌کند (۳۰۰۰۰۰ میلی‌ثانیه)
        self.trigger_timer.timeout.connect(self._run_system_triggers)
        self.trigger_timer.start(300000)
        print("INFO: System Trigger Engine timer started (Interval: 5 minutes).")

# در کلاس MainWindow، این متد را جایگزین کنید

    def _run_system_triggers(self):
        """محرک‌های سیستمی تعریف شده را اجرا می‌کند."""
        print(f"INFO: [{datetime.now()}] Running system triggers...")
        
        # ۱. چک کردن محرک سطح موجودی
        try:
            # --- *** اصلاح کلیدی اینجاست: انتخاب ستون id به جای workflow_id *** ---
            query = """
                SELECT id AS workflow_id 
                FROM workflows 
                WHERE start_conditions->>'type' = 'system_event' 
                  AND start_conditions->>'event_code' = 'stock.level.below_minimum'
            """
            wf_mappings = self.db.execute_query(query)

            if wf_mappings:
                items_to_reorder = self.db.check_for_stock_triggers()
                
                for item in items_to_reorder:
                    for mapping in wf_mappings:
                        workflow_id = mapping['workflow_id']
                        print(f"TRIGGER: Stock level for '{item['name']}' is below minimum. Starting workflow ID {workflow_id}...")
                        
                        # فرض می‌کنیم درخواست از طرف خود سیستم (user_id=1) و برای واحد انبار (dept_id=1) است
                        # این مقادیر در آینده می‌توانند از تنظیمات خوانده شوند
                        self.db.create_purchase_request(
                            item_id=item['id'],
                            qty=(item['max_qty'] or 1), # درخواست به اندازه حداکثر موجودی
                            user_id=1, # ID کاربر ادمین/سیستم
                            original_dept_id=1, # ID واحد انبار (فرض اولیه)
                            notes=f"درخواست خودکار به دلیل رسیدن به حد سفارش"
                        )
                        self.toast.show_message(f"درخواست خرید خودکار برای کالای «{item['name']}» ایجاد شد.", "info")

        except Exception as e:
            print(f"ERROR in trigger engine: {e}")
            
                    
        
        
    def _refresh_dashboard(self):
        # اطمینان از وجود ویجت‌ها قبل از استفاده
        if not hasattr(self, 'card_total_items'):
            return

        # --- بخش اول: آمار تعدادی برای کارت‌های KPI (کد اصلی شما، بدون تغییر) ---
        cnt, _ = self.db.stats()
        low_items = self.db.min_alert()
        exp_items = self.db.exp_alert()

        self.card_total_items.value_label.setText(str(cnt))
        self.card_shortage.value_label.setText(f"{len(low_items)} مورد")
        self.card_expiring.value_label.setText(f"{len(exp_items)} مورد")

        # --- بخش دوم: آمار ارزش ریالی برای نمودار دایره‌ای (کد اصلی شما، بدون تغییر) ---
        value_stats = self.db.get_category_value_stats()
        cats_for_pie = [(c['category'], c['total_value']) for c in value_stats if c.get('total_value') and c['total_value'] > 0]
        
        # پاک کردن ویجت‌های قبلی
        while self.pie_frame_layout.count():
            child = self.pie_frame_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        if cats_for_pie:
            pie_chart = Pie(cats_for_pie, self._goto_cat)
            self.pie_frame_layout.addWidget(pie_chart)
        else:
            no_data_label = QtWidgets.QLabel("ارزش ریالی برای نمایش در نمودار ثبت نشده است.")
            no_data_label.setAlignment(Qt.AlignCenter)
            no_data_label.setWordWrap(True)
            self.pie_frame_layout.addWidget(no_data_label)
        
        # --- بخش سوم و کلیدی: به‌روزرسانی هوشمند جدول آخرین تراکنش‌ها ---
        # ۱. خواندن آخرین ID پاکسازی شده از تنظیمات دیتابیس
        last_id = self.db.get_setting('last_cleared_trans_id', '0')
        
        # ۲. رفرش کردن جدول با استفاده از این ID
        # متد refresh در PinnedTable حالا یک ورودی قبول می‌کند
        self.pinned_table.refresh(since_id=int(last_id))
        
    # این متد جدید را به کلاس MainWindow اضافه کنید

    # <<< FIX
    def _clear_dashboard_transactions(self):
        """آخرین ID تراکنش را در تنظیمات ذخیره می‌کند تا داشبورد پاک شود."""
        max_id = 0
        # به‌جای self.db._conn از تراکنشِ یک‌دست‌شده استفاده می‌کنیم
        with self.db.transaction() as cur:
            # اسم ستون رو واضح گذاشتم تا با Cursor دیکشنری‌محور سازگار باشه
            cur.execute("SELECT MAX(id) AS max_id FROM trans")
            row = cur.fetchone()
            if row and row.get('max_id') is not None:
                max_id = row['max_id']

        self.db.set_setting('last_cleared_trans_id', str(max_id))
        self._refresh_dashboard()
        self.toast.show_message("✔ لیست تراکنش‌های داشبورد پاکسازی شد.")
        
                
    def _logout(self):
        """برای خروج از حساب کاربری و بازگشت به صفحه لاگین"""
        self.restart_on_close = True # یک فلگ برای حلقه main
        self.close()
            
    # این دو متد جدید را به انتهای کلاس MainWindow اضافه کنید


    def _show_shortage_items(self):
        """کاربر را به صفحه کالاها برده و فیلتر کمبود موجودی را به صورت امن اعمال می‌کند."""
        # --- اصلاح کلیدی: بررسی وجود جدول قبل از هر اقدامی ---
        if not hasattr(self, 'tbl_items'):
            self.toast.show_message("شما به صفحه مدیریت کالاها دسترسی ندارید.", "error")
            return
            
        self.pages.setCurrentWidget(self.pg_items)
        # تاخیر کوچک برای اطمینان از نمایش کامل صفحه قبل از اعمال فیلتر
        QtCore.QTimer.singleShot(50, self._filter_for_shortage)

# در کلاس MainWindow، این متد را جایگزین کنید

    def _show_expiring_items(self):
        """یک دیالوگ برای نمایش لیست کامل کالاهای در شرف انقضا باز می‌کند."""
        expiring_items = self.db.exp_alert() # مقدار پیش‌فرض روز از دیتابیس خوانده می‌شود
        if not expiring_items:
            self.toast.show_message("هیچ کالایی در شرف انقضا یافت نشد.", "info")
            return

        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("کالاهای در شرف انقضا")
        dlg.setMinimumWidth(400)
        
        layout = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(expiring_items), 3)
        table.setHorizontalHeaderLabels(['نام کالا', 'شماره بچ', 'تاریخ انقضا'])
        table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
        for r, item in enumerate(expiring_items):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(item['name']))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(item['batch_no']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(to_shamsi(item['expiry_date'])))
        
        layout.addWidget(table)
        dlg.exec_()
                
# در کلاس MainWindow، این متد را جایگزین کنید

    def _filter_for_shortage(self):
        """منطق اصلی فیلتر کردن کالاهای نیازمند سفارش در نمای درختی."""
        # --- اصلاح کلیدی: پیدا کردن درخت فعال در تب فعلی ---
        if not hasattr(self, 'items_category_tabs'): return
        active_tree = self.items_category_tabs.currentWidget()
        if not isinstance(active_tree, QtWidgets.QTreeWidget): return

        # پیدا کردن ایندکس ستون‌ها از روی هدر
        headers = [active_tree.headerItem().text(i) for i in range(active_tree.columnCount())]
        try:
            qty_col_idx = headers.index('مقدار موجودی')
            min_col_idx = headers.index('حد سفارش')
        except ValueError:
            print("خطای برنامه‌نویسی: ستون‌های مورد نیاز در درخت کالاها یافت نشد.")
            return

        # پیمایش تمام آیتم‌ها در درخت (شامل فرزندان)
        iterator = QtWidgets.QTreeWidgetItemIterator(active_tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            try:
                # فقط آیتم‌هایی که داده کالا دارند را بررسی کن (نه آیتم‌های دسته‌بندی)
                item_data = item.data(0, Qt.UserRole)
                if isinstance(item_data, dict):
                    qty_text = item.text(qty_col_idx)
                    min_text = item.text(min_col_idx)
                    
                    is_short = float(qty_text) < float(min_text) and float(min_text) > 0
                    item.setHidden(not is_short)
                else:
                    # اگر آیتم والد (دسته‌بندی) بود، فعلا مخفی کن
                    item.setHidden(True)
            except (ValueError, AttributeError):
                item.setHidden(True)
            iterator += 1
        
        # نمایش مجدد آیتم‌های والدی که فرزندان قابل نمایش دارند
        root = active_tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            has_visible_child = False
            for j in range(parent_item.childCount()):
                if not parent_item.child(j).isHidden():
                    has_visible_child = True
                    break
            parent_item.setHidden(not has_visible_child)        
                    
    def _filter_for_expiring(self):
        """منطق اصلی فیلتر کردن کالاهای در شرف انقضا."""
        # در طراحی جدید، ستون تاریخ انقضا در نمای اصلی نیست.
        # پس ما باید لیست نام‌ها را از دیتابیس بگیریم و با ستون نام کالا مقایسه کنیم.
        expiring_names = self.db.exp_alert(days=30)
        if not expiring_names:
            QtWidgets.QMessageBox.information(self, "وضعیت", "هیچ کالایی در شرف انقضا (۳۰ روز آینده) یافت نشد.")
            return

        headers = [self.tbl_items.horizontalHeaderItem(i).text() for i in range(self.tbl_items.columnCount())]
        try:
            # پیدا کردن داینامیک ایندکس ستون 'نام کالا'
            name_col_idx = headers.index('نام کالا')
        except ValueError:
            print("خطای برنامه‌نویسی: ستون 'نام کالا' در جدول کالاها یافت نشد.")
            return
            
        for r in range(self.tbl_items.rowCount()):
            name_item = self.tbl_items.item(r, name_col_idx)
            if name_item and name_item.text() in expiring_names:
                self.tbl_items.setRowHidden(r, False)
            else:
                self.tbl_items.setRowHidden(r, True)# در کلاس MainWindow


# در کلاس MainWindow، این متد جدید را اضافه کنید
    def _show_asset_history(self, item: QtWidgets.QTreeWidgetItem):
        """با دابل کلیک روی یک دارایی، دیالوگ تاریخچه آن را نمایش می‌دهد."""
        if not item or item.parent() is None: # فقط روی آیتم‌های فرزند (خود دارایی) کار کند
            return
            
        try:
            # استخراج کد دارایی از متن آیتم
            asset_code_name = item.text(0).strip()
            asset_code = asset_code_name.split('(')[-1].replace(')', '').strip()
            
            # پیدا کردن اطلاعات کامل دارایی از دیتابیس
            asset_data = self.db.execute_query("SELECT * FROM assets WHERE code = %s", (asset_code,), fetch_one=True)
            if not asset_data:
                self.toast.show_message("اطلاعات دارایی یافت نشد.", "error")
                return

            # باز کردن دیالوگ جدید
            AssetHistoryDialog(self.db, asset_data['id'], asset_data['name'], self).exec_()

        except (IndexError, AttributeError) as e:
            print(f"Could not parse asset info from tree item: {e}")


# این سه متد را جایگزین متد _build_items_page قبلی کنید

    def _build_items_page(self):
        """
        متد اصلی و بازنویسی شده: مسئولیت اصلی آن فقط ساخت TabWidget و افزودن پنل‌هاست.
        """
        page_layout = self.create_page_layout(self.pg_items, "کالاها و دارایی‌ها")

        main_tab_widget = QtWidgets.QTabWidget()
        main_tab_widget.setObjectName("itemsAssetsTabs")
        main_tab_widget.setStyleSheet("QTabBar::tab { min-width: 150px; padding: 10px; }")
        
        # ساخت پنل‌ها با استفاده از متدهای کمکی جدید
        items_panel = self._build_items_panel()
        assets_panel = self._build_assets_panel()
        
        main_tab_widget.addTab(items_panel, "مدیریت کالاها")
        main_tab_widget.addTab(assets_panel, "مدیریت دارایی‌ها")
        
        page_layout.addWidget(main_tab_widget, 1)

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_items_panel(self) -> QtWidgets.QWidget:
        """
        (نسخه نهایی و بازنویسی شده)
        - پنل کامل مدیریت کالاها را با منطق فیلتر داخلی و قابل اعتماد ایجاد می‌کند.
        """
        items_panel_widget = QtWidgets.QWidget()
        items_panel_layout = QtWidgets.QHBoxLayout(items_panel_widget)
        items_panel_layout.setContentsMargins(0, 10, 0, 0)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        items_panel_layout.addWidget(splitter)

        def _filter_current_tree(text: str):
            try:
                if not hasattr(self, 'items_category_tabs'): return
                active_tab_widget = self.items_category_tabs.currentWidget()
                if not active_tab_widget: return
                tree = active_tab_widget.findChild(QtWidgets.QTreeWidget)
                if not tree: return

                search_text = text.strip().lower()
                
                iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
                while iterator.value():
                    item = iterator.value()
                    item.setHidden(True)
                    iterator += 1

                if not search_text:
                    iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
                    while iterator.value():
                        iterator.value().setHidden(False)
                        iterator += 1
                    return

                matching_items = tree.findItems(search_text, QtCore.Qt.MatchContains | QtCore.Qt.MatchRecursive, 0)
                
                for item in matching_items:
                    item.setHidden(False)
                    parent = item.parent()
                    if parent:
                        parent.setHidden(False)

            except Exception as e:
                print(f"Error during filter: {e}")

        self.details_panel = QtWidgets.QFrame(); self.details_panel.setFrameShape(QtWidgets.QFrame.StyledPanel); self.details_panel.setFixedWidth(320); self.details_panel_layout = QtWidgets.QVBoxLayout(self.details_panel); self.details_panel_layout.setContentsMargins(0, 0, 0, 0); self.details_stack = QtWidgets.QStackedWidget(); self.details_panel_layout.addWidget(self.details_stack); self.details_placeholder = QtWidgets.QLabel("برای مشاهده جزئیات کامل،\nیک کالا را از لیست انتخاب کنید."); self.details_placeholder.setAlignment(Qt.AlignCenter); self.details_placeholder.setStyleSheet("color: #7f8c8d; font-style: italic; margin: 20px;"); self.details_stack.addWidget(self.details_placeholder); self.details_container = QtWidgets.QWidget(); details_container_layout = QtWidgets.QVBoxLayout(self.details_container); details_container_layout.setContentsMargins(0, 0, 0, 0); details_container_layout.setSpacing(0); self.details_stack.addWidget(self.details_container); scroll_area = QtWidgets.QScrollArea(); scroll_area.setWidgetResizable(True); scroll_area.setStyleSheet("QScrollArea { border: none; background: transparent; }"); self.details_form_widget = QtWidgets.QWidget(); self.details_form_layout = QtWidgets.QFormLayout(self.details_form_widget); self.details_form_layout.setSpacing(12); self.details_form_layout.setContentsMargins(15, 15, 15, 15); scroll_area.setWidget(self.details_form_widget); details_container_layout.addWidget(scroll_area, 1); self.action_bar = QtWidgets.QFrame(); self.action_bar.setObjectName("actionBar"); self.action_bar.setStyleSheet("#actionBar { border-top: 1px solid #dfe6e9; padding-top: 10px; }"); self.action_bar.setFixedHeight(60); self.action_bar_layout = QtWidgets.QHBoxLayout(self.action_bar); self.action_bar_layout.setContentsMargins(15, 0, 15, 10); self.action_bar_layout.setSpacing(8); details_container_layout.addWidget(self.action_bar);

        table_container = QtWidgets.QWidget()
        table_layout = QtWidgets.QVBoxLayout(table_container)
        table_layout.setContentsMargins(0,0,0,0)
        items_toolbar_layout = QtWidgets.QHBoxLayout()
        if self.has_permission('items:create'):
            btn_add = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " افزودن کالای جدید"); btn_add.setProperty("class", "primary"); btn_add.setMinimumHeight(35); btn_add.clicked.connect(self._add_item); items_toolbar_layout.addWidget(btn_add)
        if self.has_permission('warehouse:fulfill_request'):
            btn_replenish = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-process-tasks"), " مرکز تامین کالا"); btn_replenish.setMinimumHeight(35); btn_replenish.clicked.connect(self._open_replenishment_center); items_toolbar_layout.addWidget(btn_replenish)
       #btn_fefo_report = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-sort-ascending"), " گزارش FEFO"); btn_fefo_report.setMinimumHeight(35); btn_fefo_report.clicked.connect(lambda: FefoReportDialog(self.db, self).exec_()); items_toolbar_layout.addWidget(btn_fefo_report)
        items_toolbar_layout.addSpacing(20)
        
        self.search_items = QtWidgets.QLineEdit(placeholderText="جستجوی سریع در تب فعلی..."); self.search_items.setMinimumHeight(35)
        self.search_items.textChanged.connect(_filter_current_tree)
        items_toolbar_layout.addWidget(self.search_items, 1); items_toolbar_layout.addStretch();
        
        if self.has_permission('items:recalc_minmax'):
            btn_recalc = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-refresh"), " بازمحاسبه Min/Max"); btn_recalc.setMinimumHeight(35); btn_recalc.clicked.connect(self._recalc_minmax); items_toolbar_layout.addWidget(btn_recalc)
        table_layout.addLayout(items_toolbar_layout)

        self.items_category_tabs = QtWidgets.QTabWidget(); self.items_category_tabs.setObjectName("interfaceTabWidget")
        table_layout.addWidget(self.items_category_tabs)

        self.pagination_controls = {}
        self.item_page_state = {}
        self.item_trees = {}
        self.ITEMS_PER_PAGE = 50
        
        # --- *** اصلاح کلیدی: افزودن "محصول فله" به لیست تب‌ها *** ---
        categories_to_display = [CATEGORY_FINAL_PRODUCT, CATEGORY_BULK_PRODUCT, CATEGORY_RAW_MATERIAL, CATEGORY_PACKAGING, CATEGORY_CONSUMABLES]

        for fa_name in categories_to_display:
            page_widget = QtWidgets.QWidget()
            page_layout_inner = QtWidgets.QVBoxLayout(page_widget)
            page_layout_inner.setContentsMargins(0, 0, 0, 0)
            tree = QtWidgets.QTreeWidget()
            tree.setObjectName(fa_name) 
            self._style_tree(tree)
            tree.itemClicked.connect(self._show_item_details_panel)
            tree.setContextMenuPolicy(Qt.CustomContextMenu)
            tree.customContextMenuRequested.connect(self._show_items_table_context_menu)
            pagination_widget, controls = self._create_pagination_controls(fa_name)
            self.pagination_controls[fa_name] = controls
            page_layout_inner.addWidget(tree, 1)
            page_layout_inner.addWidget(pagination_widget)
            self.items_category_tabs.addTab(page_widget, fa_name)
            self.item_trees[fa_name] = tree

        self.items_category_tabs.currentChanged.connect(self._on_items_tab_changed)
        
        splitter.addWidget(self.details_panel); splitter.addWidget(table_container); splitter.setSizes([320, 700])
        return items_panel_widget
    
    
    def _build_assets_panel(self) -> QtWidgets.QWidget:
        """(متد کمکی جدید) پنل کامل مدیریت دارایی‌ها را ایجاد کرده و برمی‌گرداند."""
        assets_page_widget = QtWidgets.QWidget()
        assets_layout = QtWidgets.QVBoxLayout(assets_page_widget); assets_layout.setContentsMargins(0, 10, 0, 0); assets_toolbar = QtWidgets.QHBoxLayout();
        if self.has_permission('assets:create'):
            btn_add_asset = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " تعریف دارایی"); btn_add_asset.setProperty("class", "primary"); btn_add_asset.setMinimumHeight(35); btn_add_asset.clicked.connect(self._add_new_asset_action); assets_toolbar.addWidget(btn_add_asset)
        if self.has_permission('assets:edit'):
            btn_edit_asset = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), " ویرایش دارایی"); btn_edit_asset.setMinimumHeight(35); btn_edit_asset.clicked.connect(self._edit_asset_action); assets_toolbar.addWidget(btn_edit_asset)
        assets_toolbar.addStretch(); view_mode_group = QtWidgets.QGroupBox("نمایش بر اساس:"); view_mode_layout = QtWidgets.QHBoxLayout(view_mode_group); self.asset_view_by_status = QtWidgets.QRadioButton("وضعیت"); self.asset_view_by_employee = QtWidgets.QRadioButton("پرسنل"); self.asset_view_by_status.setChecked(True); view_mode_layout.addWidget(self.asset_view_by_status); view_mode_layout.addWidget(self.asset_view_by_employee); assets_toolbar.addWidget(view_mode_group); assets_layout.addLayout(assets_toolbar)
        
        self.tbl_assets = QtWidgets.QTreeWidget()
        self._style_tree(self.tbl_assets)
        self.tbl_assets.itemDoubleClicked.connect(self._show_asset_history)
        self.tbl_assets.setHeaderLabels(['کد / نام دارایی', 'برند', 'مدل', 'ارزش ریالی'])
        self.tbl_assets.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, 4): self.tbl_assets.header().setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        
        assets_layout.addWidget(self.tbl_assets)
        self.asset_view_by_status.toggled.connect(self._load_assets_table)
        return assets_page_widget
    
                        
    def _on_page_changed(self, index):
        """با تغییر صفحه، محتوای آن را رفرش می‌کند (نسخه نهایی و کامل)."""
        page = self.pages.widget(index)
        button_to_activate = self.page_map.get(page)
        if button_to_activate: self._update_sidebar_style(button_to_activate)

        if hasattr(self, '_update_notification_count'):
            self._update_notification_count()

        if page == self.pg_dash:
            if hasattr(self, '_refresh_dashboard_page'): self._refresh_dashboard_page()
        elif page == self.pg_items:
            self._on_items_tab_changed(self.items_category_tabs.currentIndex())
            if hasattr(self, '_load_assets_table'): self._load_assets_table()
        elif page == self.pg_trans:
            if hasattr(self, '_load_trans'): self._load_trans()
        elif page == self.pg_prod:
            if hasattr(self, '_refresh_production_page_data'): self._refresh_production_page_data()
        elif page == self.pg_inventory:
            if hasattr(self, '_load_open_counts'): self._load_open_counts()
            if hasattr(self, '_load_review_counts'): self._load_review_counts()
        elif page == self.pg_purchasing:
            if hasattr(self, '_refresh_purchasing_page'): self._refresh_purchasing_page()
        elif page == self.pg_qa:
            if hasattr(self, '_load_workflows_list'): self._load_workflows_list()
        elif page == self.pg_qc:
            if hasattr(self, '_refresh_qc_page'): self._refresh_qc_page()
        elif page == self.pg_sales:
            # --- **اصلاح کلیدی: تضمین ساخته شدن صفحه قبل از رفرش** ---
            if self.pg_sales.layout() is None or not self.pg_sales.layout().count():
                self._build_sales_page()
            self._on_sales_tab_changed()
        elif page == self.pg_kanban:
            if hasattr(self, 'kanban_board_page_widget'): self.kanban_board_page_widget.refresh_board()
        elif page == self.pg_communications:
            if hasattr(self, 'comm_page_widget'): self.comm_page_widget.refresh_inbox(); self.comm_page_widget.refresh_sent()
        elif page == self.pg_tracker:
            if hasattr(self, 'tracker_page_widget'): self.tracker_page_widget.refresh_history()
    
        
    def _on_items_tab_changed(self, index):
        """اسلات صحیح برای سیگنال currentChanged که index را دریافت می‌کند."""
        if not hasattr(self, 'items_category_tabs') or index == -1: return
        
        category_fa_name = self.items_category_tabs.tabText(index)
        if not category_fa_name: return

        self._load_items_for_page(category_fa_name)

    def _load_items_for_page(self, category_fa_name: str):
        """داده‌های یک صفحه مشخص از یک دسته را خوانده و جدول را پر می‌کند."""
        if category_fa_name not in self.item_page_state:
            total_items = self.db.get_items_count_by_category(category_fa_name)
            total_pages = (total_items + self.ITEMS_PER_PAGE - 1) // self.ITEMS_PER_PAGE if self.ITEMS_PER_PAGE > 0 else 0
            self.item_page_state[category_fa_name] = {'current_page': 1, 'total_pages': total_pages, 'total_items': total_items}
        
        state = self.item_page_state[category_fa_name]
        offset = (state['current_page'] - 1) * self.ITEMS_PER_PAGE
        
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            items_for_page = self.db.items_brief(category_fa_name, self.ITEMS_PER_PAGE, offset)
            self._populate_item_tree(self.item_trees[category_fa_name], items_for_page)
            self._update_pagination_ui(category_fa_name)
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()

# در کلاس MainWindow، این متد را جایگزین کنید

    def _populate_item_tree(self, tree: QtWidgets.QTreeWidget, items: list):
        """یک ویجت درختی مشخص را با لیست کالاهای داده شده پر می‌کند."""
        tree.setSortingEnabled(False)
        tree.clear()

        # --- *** اصلاح کلیدی: تنظیم مجدد هدرها پس از پاک شدن *** ---
        headers = ['کالا (پک/محصول مادر)', 'دسته', 'مقدار موجودی', 'واحد', 'حد سفارش', 'ID']
        tree.setHeaderLabels(headers)
        header = tree.header()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, len(headers)):
            header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        tree.setColumnHidden(headers.index('ID'), True) # مخفی کردن ستون ID
        # --- ****************************************************** ---

        if not items:
            set_empty_placeholder(tree, "هیچ کالایی در این دسته یافت نشد.")
            return

        items_by_id = {item['id']: dict(item) for item in items}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id and parent_id in items_by_id:
                if parent_id not in child_map: child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)
        
        tree.setUpdatesEnabled(False)
        for item_data in top_level_items:
            parent_item = NumericTreeWidgetItem(tree)
            parent_item.setText(0, item_data.get('name', ''))
            parent_item.setText(1, item_data.get('category', ''))
            parent_item.setText(2, str(item_data.get('non_prod_qty', 0)))
            parent_item.setText(3, item_data.get('unit', ''))
            parent_item.setText(4, str(item_data.get('min_qty', 0)))
            parent_item.setText(5, str(item_data.get('id')))
            parent_item.setData(0, Qt.UserRole, item_data)
            
            if item_data.get('min_qty', 0) > 0 and item_data.get('non_prod_qty', 0) < item_data.get('min_qty', 0):
                parent_item.setBackground(0, QtGui.QColor("#fff2f2"))
            
            if item_data['id'] in child_map:
                for child_data in child_map[item_data['id']]:
                    child_item = NumericTreeWidgetItem(parent_item)
                    child_item.setText(0, child_data.get('name', ''))
                    child_item.setText(1, child_data.get('category', ''))
                    child_item.setText(2, str(child_data.get('non_prod_qty', 0)))
                    child_item.setText(3, child_data.get('unit', ''))
                    child_item.setText(4, str(child_data.get('min_qty', 0)))
                    child_item.setText(5, str(child_data.get('id')))
                    child_item.setData(0, Qt.UserRole, child_data)
                    if child_data.get('min_qty', 0) > 0 and child_data.get('non_prod_qty', 0) < child_data.get('min_qty', 0):
                        child_item.setBackground(0, QtGui.QColor("#fff2f2"))
        
        tree.setUpdatesEnabled(True)
        tree.expandAll()
        tree.setSortingEnabled(True)
                        
            
    # این ۴ متد کاملا جدید را به کلاس MainWindow اضافه کنید
    def _create_pagination_controls(self, category_name):
        widget = QtWidgets.QWidget()
        layout = QtWidgets.QHBoxLayout(widget)
        layout.setContentsMargins(0, 5, 0, 0)

        btn_prev = QtWidgets.QPushButton("« قبلی")
        btn_next = QtWidgets.QPushButton("بعدی »")
        lbl_status = QtWidgets.QLabel("صفحه ۰ از ۰")

        layout.addStretch()
        layout.addWidget(btn_prev)
        layout.addWidget(lbl_status)
        layout.addWidget(btn_next)
        layout.addStretch()

        controls = {'prev': btn_prev, 'next': btn_next, 'label': lbl_status}
        btn_prev.clicked.connect(lambda: self._change_item_page(category_name, -1))
        btn_next.clicked.connect(lambda: self._change_item_page(category_name, 1))

        return widget, controls

    
    
    def _update_pagination_ui(self, category_fa_name: str):
        state = self.item_page_state[category_fa_name]
        controls = self.pagination_controls[category_fa_name]

        controls['label'].setText(f"صفحه {state['current_page']} از {state['total_pages']}")
        controls['prev'].setEnabled(state['current_page'] > 1)
        controls['next'].setEnabled(state['current_page'] < state['total_pages'])

    # این متد را با نسخه ساده شده زیر جایگزین کنید
    def _change_item_page(self, category_fa_name: str, delta: int):
        state = self.item_page_state.get(category_fa_name)
        if not state: return
        
        new_page = state['current_page'] + delta
        if 1 <= new_page <= state['total_pages']:
            state['current_page'] = new_page
            self._load_items_for_page(category_fa_name)
        
            


    def _load_active_items_tab_data(self):
        """داده‌های تب فعال فعلی را به صورت مستقیم و مسدودکننده (Blocking) بارگذاری می‌کند."""
        if not hasattr(self, 'items_category_tabs'): return
        
        current_index = self.items_category_tabs.currentIndex()
        if current_index == -1: return

        category_fa_name = self.items_category_tabs.tabText(current_index)
        
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            # فراخوانی مستقیم متد بارگذاری صفحه
            self._load_items_for_page(category_fa_name)
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()

                            
                    
    def _open_replenishment_center(self, preselected_item_id=None):
        """پنجره مرکز تامین کالا را باز می‌کند. در صورت وجود، یک کالا را از پیش انتخاب می‌کند."""
        dlg = ReplenishmentDialog(self.db, self.user_id, self, preselected_item_id)
        dlg.exec_()
                            

        
            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _load_assets_table(self):
        if not hasattr(self, 'tbl_assets'): return
        tree = self.tbl_assets
        tree.clear()
        try:
            if self.asset_view_by_status.isChecked():
                tree.setHeaderLabels(['کد / نام دارایی', 'برند', 'مدل', 'ارزش ریالی'])
                all_assets = self.db.execute_query("SELECT * FROM assets ORDER BY name")
                if not all_assets: tree.addTopLevelItem(QtWidgets.QTreeWidgetItem(["هیچ دارایی ثبت نشده است."])); return
                grouped_assets = {}
                for asset in all_assets:
                    status = asset.get('status', 'نامشخص')
                    if status not in grouped_assets: grouped_assets[status] = []
                    grouped_assets[status].append(asset)
                for status, assets_in_group in sorted(grouped_assets.items()):
                    parent_item = QtWidgets.QTreeWidgetItem(tree, [f"{status} ({len(assets_in_group)} مورد)"])
                    parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
                    for asset in assets_in_group:
                        child_item = QtWidgets.QTreeWidgetItem(parent_item)
                        child_item.setText(0, f"  {asset['name']} ({asset['code']})")
                        child_item.setText(1, asset.get('brand', ''))
                        child_item.setText(2, asset.get('model', ''))
                        cost_str = f"{asset.get('cost', 0):,.0f}"
                        child_item.setText(3, cost_str)
                        child_item.setTextAlignment(3, Qt.AlignRight | Qt.AlignVCenter)
                        # --- *** اصلاح کلیدی اینجاست *** ---
                        child_item.setToolTip(0, "برای مشاهده تاریخچه کامل، روی این ردیف دابل کلیک کنید")
            else:
                tree.setHeaderLabels(['نام شخص / دارایی', 'کد', 'برند', 'مدل'])
                assigned_assets = self.db.get_assets_by_assignee()
                if not assigned_assets: tree.addTopLevelItem(QtWidgets.QTreeWidgetItem(["هیچ دارایی در اختیار پرسنل نیست."])); return
                grouped_by_employee = {}
                for asset in assigned_assets:
                    employee = asset.get('employee_name', 'نامشخص').strip();
                    if not employee: employee = "نامشخص"
                    if employee not in grouped_by_employee: grouped_by_employee[employee] = []
                    grouped_by_employee[employee].append(asset)
                for employee, assets in sorted(grouped_by_employee.items()):
                    parent_item = QtWidgets.QTreeWidgetItem(tree, [f"{employee} ({len(assets)} مورد)"]); parent_item.setFont(0, QFont(FONT_FAMILY, 11, QFont.Bold))
                    for asset in assets:
                        child_item = QtWidgets.QTreeWidgetItem(parent_item, [f"  {asset['name']}", asset['code'], asset['brand'], asset['model']])
                        # --- *** اصلاح کلیدی اینجاست *** ---
                        child_item.setToolTip(0, "برای مشاهده تاریخچه کامل، روی این ردیف دابل کلیک کنید")

            tree.expandAll()
        except Exception as e:
            print(f"Error loading assets table: {e}")
            tree.addTopLevelItem(QtWidgets.QTreeWidgetItem([f"خطا در بارگذاری دارایی‌ها: {e}"]))
                        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _edit_asset_action(self):
        """دیالوگ ویرایش را برای دارایی انتخاب شده در درخت، باز می‌کند."""
        selected_items = self.tbl_assets.selectedItems()
        if not selected_items:
            self.toast.show_message("لطفاً ابتدا یک دارایی را برای ویرایش از لیست انتخاب کنید.", "warning")
            return
            
        item = selected_items[0]
        if item.parent() is None: # اگر روی گروه کلیک شده بود، کاری نکن
            return

        asset_code_name = item.text(0).strip()
        asset_code = asset_code_name.split('(')[-1].replace(')', '').strip()
        asset_data = self.db.execute_query("SELECT * FROM assets WHERE code = %s", (asset_code,), fetch_one=True)
        if not asset_data:
            self.toast.show_message("اطلاعات دارایی در دیتابیس یافت نشد.", "error")
            return

        dlg = AddAssetDialog(self.db, asset_data=dict(asset_data), parent=self)
        if dlg.exec_():
            updated_data = dlg.get_data()
            if updated_data:
                try:
                    self.db.add_asset(
                        code=updated_data['code'], name=updated_data['name'], brand=updated_data['brand'],
                        model=updated_data['model'], cost=updated_data['cost'], user_id=self.user_id
                    )
                    self.toast.show_message("✔ دارایی با موفقیت ویرایش شد.", "success")
                    self._load_assets_table()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ویرایش دارایی: {e}")
            
                                    
                                
                                                                                    
    def _get_selected_asset_id(self):
        """ID دارایی انتخاب شده در جدول دارایی‌ها را برمی‌گرداند. در صورت عدم انتخاب، None برمی‌گرداند."""
        selected_rows = self.tbl_assets.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً ابتدا یک دارایی را از جدول انتخاب کنید.", "warning")
            return None
        try:
            asset_id = int(self.tbl_assets.item(selected_rows[0].row(), 0).text())
            return asset_id
        except (AttributeError, ValueError, IndexError):
            return None
        
    # --- REPLACE in MainWindow ---
    def _add_filter_export_tools(self, target_widget, target_layout, quick_filter_widget=None, custom_filter_dialog_class=None):
        """Toolbar with quick-search, advanced filter, export to Excel, and filter status."""
        bar = QtWidgets.QHBoxLayout()
        search_edit = QtWidgets.QLineEdit(); search_edit.setPlaceholderText("جستجوی سریع در تمام ستون‌ها"); search_edit.setMinimumHeight(30)
        btn_filter = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-filter"), " فیلتر پیشرفته")
        btn_export = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-save"), " خروجی اکسل")
        bar.addWidget(search_edit, 1); bar.addWidget(btn_filter); bar.addWidget(btn_export)
        target_layout.insertLayout(0, bar)

        # status chip
        filter_status_widget = QtWidgets.QFrame(); filter_status_widget.setObjectName("filterStatus")
        filter_status_layout = QtWidgets.QHBoxLayout(filter_status_widget); filter_status_layout.setContentsMargins(10, 5, 10, 5)
        filter_status_icon = QtWidgets.QLabel("ℹ️"); filter_status_label = QtWidgets.QLabel("")
        filter_status_layout.addWidget(filter_status_icon); filter_status_layout.addWidget(filter_status_label, 1)
        btn_clear_quick = QtWidgets.QPushButton("حذف فیلترها"); btn_clear_quick.setProperty("class", "danger")
        filter_status_layout.addWidget(btn_clear_quick)
        filter_status_widget.setStyleSheet("#filterStatus { background-color: #e7f1ff; border: 1px solid #b3d1ff; border-radius: 4px; }")
        target_layout.insertWidget(1, filter_status_widget)

        def get_active_widget():
            if hasattr(target_widget, 'currentWidget'): return target_widget.currentWidget()
            return target_widget

        def update_filter_status():
            table = get_active_widget()
            total_items = 0; visible_items = 0
            is_advanced_filtered = hasattr(table, '_active_filters') and table._active_filters
            is_quick_filtered = bool(search_edit.text().strip())
            is_filtered = is_advanced_filtered or is_quick_filtered

            if isinstance(table, QtWidgets.QTableWidget):
                total_items = table.rowCount()
                if total_items > 0:
                    visible_items = total_items - sum(1 for r in range(total_items) if table.isRowHidden(r))
            elif isinstance(table, QtWidgets.QTreeWidget):
                it = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
                while it.value():
                    if it.value().parent():
                        total_items += 1
                        if not it.value().isHidden(): visible_items += 1
                    it += 1

            if is_filtered:
                filter_type_text = "فیلتر پیشرفته" if is_advanced_filtered else "جستجوی سریع"
                filter_status_label.setText(f"<b>{filter_type_text} فعال است:</b> نمایش {visible_items} از {total_items} رکورد.")
                filter_status_widget.show()
            else:
                filter_status_widget.hide()

        def open_filter_dialog():
            active = get_active_widget()
            dlg_class = custom_filter_dialog_class or FilterDialog
            dlg = dlg_class(active, active.parent(), on_finish=update_filter_status)
            dlg.exec_()

        def reset_all_filters():
            table = get_active_widget()
            if hasattr(table, '_active_filters'): table._active_filters = []
            search_edit.clear()
            if isinstance(table, QtWidgets.QTableWidget):
                for r in range(table.rowCount()): table.setRowHidden(r, False)
            elif isinstance(table, QtWidgets.QTreeWidget):
                it = QtWidgets.QTreeWidgetItemIterator(table, QtWidgets.QTreeWidgetItemIterator.All)
                while it.value(): it.value().setHidden(False); it += 1
            update_filter_status()

        search_edit.textChanged.connect(lambda text: self._quick_filter_table(get_active_widget(), text))
        btn_filter.clicked.connect(open_filter_dialog)
        btn_export.clicked.connect(lambda: self.export_table_to_excel(get_active_widget(), get_active_widget().parent()))
        btn_clear_quick.clicked.connect(reset_all_filters)
        search_edit.textChanged.connect(update_filter_status)

                        
    def _build_trans_page(self):
        """Builds the main transactions page with its tabs and tables."""
        layout = self.create_page_layout(self.pg_trans, "تاریخچه و عملیات انبار")

        # --- Toolbar ---
        toolbar = QtWidgets.QFrame()
        toolbar_layout = QtWidgets.QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(0, 0, 0, 10)
        toolbar_layout.setSpacing(10)

        # ثبت ورود فقط با دسترسی transactions:create_entry
        if self.has_permission('transactions:create_entry'):
            btn_add_entry = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-add"), " ثبت ورود")
            btn_add_entry.setProperty("class", "primary")
            btn_add_entry.clicked.connect(lambda: self._new_trans("ورود"))
            toolbar_layout.addWidget(btn_add_entry)

        # ثبت خروج فقط با دسترسی transactions:create_exit
        if self.has_permission('transactions:create_exit'):
            btn_add_exit = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("list-remove"), " ثبت خروج")
            btn_add_exit.setProperty("class", "primary")
            btn_add_exit.clicked.connect(lambda: self._new_trans("خروج"))
            toolbar_layout.addWidget(btn_add_exit)

        # انتقال داخلی
        if self.has_permission('transactions:transfer'):
            btn_transfer = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-next"), " ثبت انتقال")
            btn_transfer.clicked.connect(self._transfer_generic)
            toolbar_layout.addWidget(btn_transfer)

        # سایر تراکنش‌ها + دریافت از سفارش خرید
        show_other_menu = (
            self.has_permission('transactions:create_other') or
            self.has_permission('purchasing:receive_po') or
            self.has_permission('transactions:create_entry')
        )
        if show_other_menu:
            btn_other_trans = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-more"), " سایر تراکنش‌ها")
            other_menu = QtWidgets.QMenu(self)

            if self.has_permission('transactions:create_other'):
                other_menu.addAction("ثبت برگشت").triggered.connect(lambda: self._new_trans("برگشت"))
                other_menu.addAction("ثبت ضایعات").triggered.connect(lambda: self._new_trans("ضایعات"))

            # اجازه «ورود از سفارش خرید» با دریافت PO یا دسترسی ورود
            if self.has_permission('purchasing:receive_po') or self.has_permission('transactions:create_entry'):
                other_menu.addAction("ورود (از سفارش خرید)").triggered.connect(self._open_po_selection_dialog)

            btn_other_trans.setMenu(other_menu)
            toolbar_layout.addWidget(btn_other_trans)

        toolbar_layout.addSpacing(20)

        # تراکنش دارایی‌ها
        if self.has_permission('assets:transact'):
            btn_asset_trans = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("drive-harddisk"), " تراکنش دارایی")
            asset_menu = QtWidgets.QMenu(self)
            asset_menu.addAction("تحویل به پرسنل").triggered.connect(self._assign_asset_action)
            asset_menu.addSeparator()
            asset_menu.addAction("خروج موقت (تعمیرات/پروژه)").triggered.connect(lambda: self._open_asset_action_dialog('exit'))
            asset_menu.addAction("بازگشت به انبار").triggered.connect(lambda: self._open_asset_action_dialog('return'))
            asset_menu.addSeparator()
            asset_menu.addAction("اسقاط دارایی").triggered.connect(lambda: self._open_asset_action_dialog('scrap'))
            btn_asset_trans.setMenu(asset_menu)
            toolbar_layout.addWidget(btn_asset_trans)

        # ابطال
        if self.has_permission('transactions:void'):
            btn_void = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("edit-delete"), " ابطال تراکنش")
            btn_void.clicked.connect(self._void_master_action)
            toolbar_layout.addWidget(btn_void)

        toolbar_layout.addStretch()
        self.view_mode_check = QtWidgets.QCheckBox("نمایش بر اساس سند")
        self.view_mode_check.setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
        self.view_mode_check.stateChanged.connect(self._toggle_trans_view)
        toolbar_layout.addWidget(self.view_mode_check)

        layout.insertWidget(2, toolbar)

        # --- Tabs & views (بدون تغییرات منطقی نسبت به نسخه فعلی) ---
        self.tab_widget_trans = QtWidgets.QTabWidget()
        layout.addWidget(self.tab_widget_trans)
        self.trans_views = {}
        TYPES = ('همه', 'ورود', 'خروج', 'برگشت', 'انتقال', 'اصلاح انبارگردانی', 'ورود از تولید', 'خروج به تولید', 'ابطال', 'تاریخچه دارایی')
        for tp in TYPES:
            container_widget = QtWidgets.QWidget()
            page_layout = QtWidgets.QVBoxLayout(container_widget)
            page_layout.setContentsMargins(0, 10, 0, 0)
            view_stack = QtWidgets.QStackedWidget()
            if tp == 'تاریخچه دارایی':
                if not self.has_permission('assets:transact'):
                    continue
                table_view = QtWidgets.QTableWidget()
                self._style_table(table_view)
                view_stack.addWidget(table_view)
                self.trans_views[tp] = {'table': table_view, 'tree': None, 'stack': view_stack}
            else:
                table_view = QtWidgets.QTableWidget()
                self._style_table(table_view)
                tree_view = QtWidgets.QTreeWidget()
                self._style_tree(tree_view)
                view_stack.addWidget(table_view)
                view_stack.addWidget(tree_view)
                self.trans_views[tp] = {'table': table_view, 'tree': tree_view, 'stack': view_stack}

            page_layout.addWidget(view_stack)
            self.tab_widget_trans.addTab(container_widget, tp)
            
    # --- add these methods to MainWindow ---

    def _open_warehouse_ops(self, initial_tab_key: str = 'requests'):
        if not hasattr(self, '_warehouse_ops_dlg') or self._warehouse_ops_dlg is None:
            self._warehouse_ops_dlg = WarehouseOpsDialog(self.db, self)
            # اگر کاربر پنجره را ببندد، هندل کنیم
            self._warehouse_ops_dlg.destroyed.connect(lambda: setattr(self, '_warehouse_ops_dlg', None))
        self._warehouse_ops_dlg.show()
        self._warehouse_ops_dlg.raise_()
        self._warehouse_ops_dlg.activateWindow()
        self._warehouse_ops_dlg.select_tab(initial_tab_key)
        # بارگذاری لیست‌ها (متدهای فعلی بدون تغییر استفاده می‌شوند)
        if hasattr(self, '_load_material_requests'): self._load_material_requests()
        if hasattr(self, '_load_pending_deliveries'): self._load_pending_deliveries()
        if hasattr(self, '_load_pending_returns'): self._load_pending_returns()
        if hasattr(self, '_load_pending_internal_requests_for_warehouse'):
            self._load_pending_internal_requests_for_warehouse()

    def _detach_warehouse_ops_refs(self):
        # پاک کردن رفرنس جدول‌ها از MainWindow (ایمن)
        for attr in ('tbl_material_requests','tbl_pending_deliveries','tbl_material_returns','tbl_internal_requests'):
            if hasattr(self, attr):
                delattr(self, attr)

        
# این متد کاملا جدید را به کلاس MainWindow اضافه کنید
    def _execute_workflow_initial_action(self, action_key: str, form_data: dict, requester_id: int):
        """بر اساس کلید، اقدام اولیه یک فرآیند را اجرا می‌کند."""
        if action_key == "CREATE_GENERAL_INTERNAL_REQUEST":
            try:
                item_data = form_data.get('کالای مورد نیاز', {})
                item_id = item_data.get('id')
                quantity = float(form_data.get('مقدار درخواستی', 0))
                notes = form_data.get('توضیحات', '')

                if not item_id or quantity <= 0:
                    raise ValueError("اطلاعات کالا و مقدار در فرم به درستی وارد نشده است.")

                result = self.db.create_general_internal_request(item_id, quantity, requester_id, notes)

                if result and result.get('status') == TransactionStatus.IR_PENDING_FULFILLMENT.value:
                    self.toast.show_message("✔ درخواست شما با موفقیت ثبت و برای انباردار ارسال شد.", "success")
                elif result and result.get('status') == TransactionStatus.IR_PENDING_PURCHASE.value:
                    self.toast.show_message("موجودی انبار کافی نبود. درخواست شما ثبت و جهت تامین کالا به انباردار اطلاع داده شد.", "info", msec=8000)
                
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در اجرای اقدام اولیه", str(e))
        else:
            self.toast.show_message(f"اقدام اولیه با کلید '{action_key}' هنوز پیاده‌سازی نشده است.", "warning")
                                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _open_po_selection_dialog(self):
        """گردش کار انتخاب سفارش خرید و ثبت رسید را مدیریت می‌کند."""
        select_dlg = SelectPoDialog(self.db, self)
        if select_dlg.exec_() == QtWidgets.QDialog.Accepted:
            po_id = select_dlg.get_selected_po_id()
            if po_id:
                # حالا که PO ID را داریم، متد قبلی را برای باز کردن دیالوگ رسید فراخوانی می‌کنیم
                self._receive_po_action(preselected_po_id=po_id)
            else:
                self.toast.show_message("هیچ سفارش خریدی انتخاب نشد.", "warning")
                
                
        
        
    def _void_master_action(self):
        """
        این تابع فقط یک توزیع‌کننده (Dispatcher) است.
        تشخیص می‌دهد که کدام عملیات ابطال باید اجرا شود.
        """
        active_tab_name = self.tab_widget_trans.tabText(self.tab_widget_trans.currentIndex())
        
        if active_tab_name == 'تاریخچه دارایی':
            # اگر در تب دارایی‌ها بودیم، منطق ابطال دارایی را اجرا کن
            self._void_selected_asset_trans()
        else:
            # در غیر این صورت، تابع اصلی و دست‌نخورده برای ابطال کالا فراخوانی می‌شود
            self._void_selected_trans()

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _void_selected_asset_trans(self):
        """تراکنش انتخاب شده در جدول تاریخچه دارایی‌ها را باطل می‌کند."""
        # پیدا کردن جدول تاریخچه دارایی‌ها
        view_dict = self.trans_views.get('تاریخچه دارایی')
        if not view_dict: return
        
        asset_table = view_dict.get('table')
        if not asset_table: return

        selected_rows = asset_table.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک تراکنش را از جدول تاریخچه دارایی برای ابطال انتخاب کنید.", "warning")
            return

        # فقط اولین ردیف انتخاب شده را در نظر می‌گیریم
        row_index = selected_rows[0].row()
        try:
            trans_id = int(asset_table.item(row_index, 0).text())
        except (AttributeError, ValueError):
            self.toast.show_message("ردیف انتخاب شده معتبر نیست.", "error")
            return

        reply = QtWidgets.QMessageBox.question(self, "تایید نهایی ابطال",
                                             f"آیا از ابطال تراکنش دارایی شماره {trans_id} و بازگرداندن وضعیت آن به حالت قبل مطمئنید؟",
                                             QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                self.db.void_asset_transaction(trans_id, self.user_id)
                self.toast.show_message("✔ تراکنش دارایی با موفقیت باطل شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ابطال با خطا مواجه شد:\n{e}")
                    
                        
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _reject_selected_return(self):
        """درخواست برگشت انتخاب شده را پس از دریافت دلیل از کاربر، رد می‌کند."""
        if not hasattr(self, 'tbl_material_returns'): return
        
        selected_rows = self.tbl_material_returns.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
            return
            
        row = selected_rows[0].row()
        trans_id = int(self.tbl_material_returns.item(row, 0).text())
        
        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کردن", "لطفاً دلیل رد کردن این درخواست برگشتی را وارد کنید:")
        if ok and reason:
            try:
                self.db.reject_material_return(trans_id, self.user_id, reason)
                self.toast.show_message("درخواست برگشت با موفقیت رد شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"عملیات رد کردن با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")                

    def _load_pending_returns(self):
        """جدول درخواست‌های برگشتی را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_material_returns'): return
        table = self.tbl_material_returns
        table.setRowCount(0)
        try:
            requests = self.db.get_pending_returns_from_production()
            headers = ['ID', 'نام کالا', 'مقدار برگشتی', 'شماره بچ', 'دلیل (یادداشت)', 'درخواست دهنده', 'تاریخ']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(requests))

            for r, req in enumerate(requests):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(req['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(req['item_name']))
                table.setItem(r, 2, NumericTableWidgetItem(str(req['qty'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(req['batch_no']))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(req['notes']))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(req['requester_name']))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(to_shamsi(req['t_date'])))
            
            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.Stretch)
        except Exception as e:
            print(f"Error loading pending returns: {e}")

    # داخل کلاس MainWindow

    def _approve_selected_delivery(self):
        """تأیید دریافت محصول از تولید → حتماً گِیت QA را قبل از تغییر وضعیت چک می‌کنیم."""
        row = self._get_selected_row(self.tbl_pending_deliveries, friendly_name="تحویل تولید")
        if row is None:
            return
        delivery_id = self.tbl_pending_deliveries.item(row, 0).data(Qt.UserRole)  # فرض: ID در UserRole
        item_id     = self.tbl_pending_deliveries.item(row, 1).data(Qt.UserRole)  # یا جایی که item_id ذخیره شده
        qty         = float(self.tbl_pending_deliveries.item(row, 4).text() or 0)

        # مقصد را از UI بگیر (لوکیشن مقصد انبارِ آماده)
        dest_loc_id = self._get_default_receiving_location_id()

        # ✅ گِیت QA (UI-level) — اگر رد شد، ادامه نمی‌دهیم
        ok, msg = self._qa_gate_or_block(
            table_name='production_deliveries',
            record_id=delivery_id,
            target_status='تایید شده'
        )
        if not ok:
            self.toast.show_message(msg or "شرایط QA برای این گذار وضعیت برآورده نیست.", "warning")
            return

        # ادامه: تأیید سمت DB
        try:
            self.db.finalize_delivery(delivery_id, self.user_id, dest_loc_id)
            self.toast.show_message("تحویل از تولید با موفقیت تایید شد.", "success")
            # Refresh
            if hasattr(self, '_load_pending_deliveries'):
                self._load_pending_deliveries()
            if hasattr(self, '_refresh_stock_kpis'):
                self._refresh_stock_kpis()
        except Exception as e:
            self._handle_exception("خطا در تایید دریافت محصول از تولید", e)

    def _approve_selected_return(self):
        """تأیید برگشت مواد از تولید به انبار → گِیت QA قبل از تغییر وضعیت."""
        row = self._get_selected_row(self.tbl_material_returns, friendly_name="برگشت از تولید")
        if row is None:
            return
        trans_id = self.tbl_material_returns.item(row, 0).data(Qt.UserRole)  # شناسه‌ی تراکنش برگشت
        dest_loc_id = self._get_default_receiving_location_id()

        # ✅ گِیت QA
        ok, msg = self._qa_gate_or_block(
            table_name='trans',
            record_id=trans_id,
            target_status='تایید شده'
        )
        if not ok:
            self.toast.show_message(msg or "شرایط QA برای این گذار وضعیت برآورده نیست.", "warning")
            return

        try:
            self.db.approve_material_return(trans_id, self.user_id, dest_loc_id)
            self.toast.show_message("برگشت مواد با موفقیت تایید شد.", "success")
            if hasattr(self, '_load_pending_returns'):
                self._load_pending_returns()
            if hasattr(self, '_refresh_stock_kpis'):
                self._refresh_stock_kpis()
        except Exception as e:
            self._handle_exception("خطا در تایید برگشت مواد", e)
        
    def _reject_selected_delivery(self):
        """گردش کار رد کردن یک ردیف انتخاب شده از جدول تحویل‌های در انتظار را آغاز می‌کند."""
        if not hasattr(self, 'tbl_pending_deliveries'): return

        selected_rows = self.tbl_pending_deliveries.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک ردیف را برای رد کردن انتخاب کنید.", "warning")
            return
        
        row = selected_rows[0].row()
        delivery_id = int(self.tbl_pending_deliveries.item(row, 0).text())
        item_name = self.tbl_pending_deliveries.item(row, 1).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد کردن تحویل", f"چرا تحویل محصول «{item_name}» را رد می‌کنید؟")
        if ok and reason.strip():
            try:
                self.db.reject_delivery(delivery_id, reason.strip(), self.user_id)
                self.toast.show_message("تحویل محصول رد و به تولید اطلاع داده شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند رد کردن با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")
                
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _reject_material_request(self):
        """گردش کار رد کردن یک درخواست مواد اولیه را مدیریت می‌کند."""
        if not hasattr(self, 'tbl_material_requests'): return

        selected_rows = self.tbl_material_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را از لیست برای رد کردن انتخاب کنید.", "warning")
            return

        row = selected_rows[0].row()
        request_id = int(self.tbl_material_requests.item(row, 0).text())
        item_name = self.tbl_material_requests.item(row, 2).text()

        reason, ok = QtWidgets.QInputDialog.getText(self, "دلیل رد درخواست", f"چرا درخواست برای کالای «{item_name}» را رد می‌کنید؟")
        
        if ok and reason.strip():
            try:
                self.db.reject_material_request(request_id, self.user_id, reason.strip())
                self.toast.show_message("✔ درخواست با موفقیت رد و دلیل آن ثبت شد.", "success")
                self.refresh_all() # رفرش کردن همه چیز برای آپدیت شدن لیست‌ها
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند رد کردن درخواست با خطا مواجه شد:\n{e}")
        elif ok:
            self.toast.show_message("عملیات لغو شد چون دلیلی وارد نشد.", "info")
        
# این سه متد را در MainWindow با نسخه‌های زیر جایگزین کنید

    def _temporary_asset_exit(self):
        """گردش کار خروج موقت یک دارایی با قابلیت انتخاب از لیست."""
        # ابتدا پنجره انتخاب دارایی‌های "در انبار" باز می‌شود
        select_dlg = SelectAssetDialog(self.db, "انتخاب دارایی برای خروج", ["در انبار"], self)
        if select_dlg.exec_() and select_dlg.get_selected_asset_id():
            asset_id = select_dlg.get_selected_asset_id()
            
            # سپس دیالوگ ورود اطلاعات باز می‌شود
            exit_dlg = TemporaryExitDialog(self)
            if exit_dlg.exec_():
                data = exit_dlg.get_data()
                self.db.log_asset_event(asset_id, data['t_type'], data['notes'], data['t_no'], self.user_id)
                self.refresh_all()
                self.toast.show_message("خروج موقت دارایی ثبت شد.", "success")

    def _return_asset(self):
        """گردش کار بازگرداندن یک دارایی به انبار با قابلیت انتخاب از لیست."""
        # ابتدا پنجره انتخاب دارایی‌های "خارج شده" باز می‌شود
        select_dlg = SelectAssetDialog(self.db, "انتخاب دارایی برای بازگشت", ["خروج (تعمیرات)", "خروج (پروژه)"], self)
        if select_dlg.exec_() and select_dlg.get_selected_asset_id():
            asset_id = select_dlg.get_selected_asset_id()
            
            t_no, ok = QtWidgets.QInputDialog.getText(self, "ثبت بازگشت", "شماره رسید یا سند بازگشت را وارد کنید:")
            if ok and t_no:
                self.db.log_asset_event(asset_id, "بازگشت به انبار", "دارایی به انبار بازگردانده شد", t_no, self.user_id)
                self.refresh_all()
                self.toast.show_message("بازگشت دارایی به انبار ثبت شد.", "success")

    def _scrap_asset(self):
        """گردش کار اسقاط کردن یک دارایی با قابلیت انتخاب از لیست."""
        # ابتدا پنجره انتخاب دارایی‌های "در انبار" باز می‌شود
        select_dlg = SelectAssetDialog(self.db, "انتخاب دارایی برای اسقاط", ["در انبار"], self)
        if select_dlg.exec_() and select_dlg.get_selected_asset_id():
            asset_id = select_dlg.get_selected_asset_id()
            
            reply = QtWidgets.QMessageBox.warning(self, "تایید عملیات", "آیا از اسقاط کردن این دارایی مطمئن هستید؟", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if reply == QtWidgets.QMessageBox.Yes:
                t_no, ok = QtWidgets.QInputDialog.getText(self, "ثبت اسقاط", "شماره سند یا مجوز اسقاط را وارد کنید:")
                if ok and t_no:
                    self.db.log_asset_event(asset_id, "اسقاط", "دارایی اسقاط شد", t_no, self.user_id)
                    self.refresh_all()
                    self.toast.show_message("دارایی اسقاط شد.", "info")
                
    def _asset_exit_action(self):
        """گردش کار کامل خروج دارایی با پیوست چندگانه."""
        dlg = AssetExitDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    new_trans_id = self.db.asset_exit(
                        asset_id=data['asset_id'],
                        t_no=data['doc_no'],
                        t_date=datetime.now(),
                        notes=data['notes'],
                        user_id=self.user_id
                    )
                    self.toast.show_message("تراکنش ثبت شد. اکنون فایل‌های پیوست را اضافه کنید.", "info")
                    # باز کردن دیالوگ جدید پیوست‌ها برای این تراکنش
                    AssetAttachDialog(self.db, new_trans_id, self).exec_()
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت خروج دارایی: {e}")
                    

                    
# این متد را به کلاس MainWindow اضافه کنید
    def _open_adjustment_dialog(self):
        """پنجره ثبت سند اصلاحی را باز کرده و عملیات را انجام می‌دهد."""
        dlg = InventoryAdjustmentDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if not data:
                self.toast.show_message("اطلاعات ورودی ناقص یا نامعتبر است.", "warning")
                return

            try:
                # فراخوانی تابع اصلی دیتابیس که قبلا اصلاح کردیم
                self.db.apply_inventory_adjustment(
                    item_id=data['item_id'],
                    counted_qty=data['counted_qty'],
                    location_id=data['location_id'],
                    batch_no=data['batch_no'], # این پارامتر را اضافه می‌کنیم
                    reason=data['reason'],
                    user_id=self.user_id
                )
                self.toast.show_message("✔ سند اصلاحی با موفقیت ثبت شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطای پایگاه داده", f"خطایی در هنگام ثبت رخ داد:\n{e}")
                print(traceback.format_exc())

# این دو متد جدید را به کلاس MainWindow اضافه کنید

    def _load_asset_trans(self):
        """جدول و درخت تاریخچه تراکنش‌های دارایی را بارگذاری می‌کند."""
        view_dict = self.trans_views.get('تاریخچه دارایی')
        if not view_dict: return

        table = view_dict['table']
        table.setRowCount(0)

        rows = self.db.asset_trans_recent()

        if not rows:
            set_empty_placeholder(table, "هیچ تراکنش دارایی تا کنون ثبت نشده است.")
            return
        
        table_headers = ["ID", "دارایی", "نوع تراکنش", "شماره سند", "تاریخ", "کاربر", "یادداشت‌ها", "پیوست‌ها"]
        table.setColumnCount(len(table_headers))
        table.setHorizontalHeaderLabels(table_headers)
        table.setColumnHidden(0, True)
        table.setRowCount(len(rows))

        for r, row in enumerate(rows):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(row['id'])))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(row['asset_lbl']))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem(row.get('t_type', '')))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(row.get('t_no', '')))
            table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(row['t_date'])))
            table.setItem(r, 5, QtWidgets.QTableWidgetItem(row.get('user_name', '')))
            table.setItem(r, 6, QtWidgets.QTableWidgetItem(row.get('notes', '')))
            
            files_count = row.get('files_count', 0)
            btn_attach = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-attachment"), f" ({files_count})")
            btn_attach.setFlat(True)
            btn_attach.setCursor(Qt.PointingHandCursor)
            btn_attach.setToolTip(f"مدیریت پیوست‌ها ({files_count} فایل)")
            btn_attach.clicked.connect(lambda _, tid=row['id']: AssetAttachDialog(self.db, tid, self).exec_())
            table.setCellWidget(r, 7, btn_attach)
        
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        table.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.Stretch)

        
    def _open_asset_action_dialog(self, action_type: str):
        """یک دیالوگ برای انجام عملیات مختلف روی دارایی‌ها باز می‌کند."""
        handler_map = {
            'exit':   {'title': "خروج موقت دارایی",    'status': ["در انبار"],                      'handler': self._temporary_asset_exit},
            'return': {'title': "بازگشت دارایی به انبار",'status': ["خروج (تعمیرات)", "خروج (پروژه)"], 'handler': self._return_asset},
            'scrap':  {'title': "اسقاط دارایی",         'status': ["در انبار"],                      'handler': self._scrap_asset}
        }

        config = handler_map.get(action_type)
        if not config:
            return

        # 🔑 اصلاح کلیدی: مجوز درست برای عملیات دارایی
        if not self.has_permission('assets:transact'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return

        config['handler']()

                        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _add_new_asset_action(self):
        """دیالوگ افزودن دارایی جدید را باز کرده و در صورت تایید، آن را ثبت و جدول را رفرش می‌کند."""
        # --- اصلاح کلیدی: ارسال صحیح آرگومان‌ها ---
        # ما به دیالوگ می‌گوییم که هیچ داده اولیه‌ای (asset_data) وجود ندارد و این یک فرم جدید است.
        dlg = AddAssetDialog(self.db, parent=self)
        
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data and hasattr(self, 'user_id'):
                try:
                    self.db.add_asset(
                        code=data['code'], name=data['name'], 
                        brand=data['brand'], model=data['model'], 
                        cost=data['cost'], user_id=self.user_id
                    )
                    self._load_assets_table() # رفرش کردن لیست دارایی‌ها
                    self.toast.show_message("✔ دارایی جدید با موفقیت ثبت شد.", "success")
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"دارایی با این کد از قبل موجود است یا خطای دیگری رخ داد.\n{e}")
                    
                    

                
# در کلاس MainWindow، این دو متد را جایگزین کنید

    def _style_tree(self, tree: QtWidgets.QTreeWidget, headers: list = None):
        """
        یک استایل استاندارد را بر روی ویجت درختی اعمال کرده و سرستون‌های آن را تنظیم می‌کند.
        """
        tree.setAlternatingRowColors(True)
        tree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tree.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        tree.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        tree.header().setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
        
        if headers:
            tree.setHeaderLabels(headers)

        tree.setStyleSheet("""
            QTreeWidget {
                border: 1px solid #dfe4ea;
                font-size: 10pt;
            }
            QTreeWidget::item {
                padding: 7px;
                border-bottom: 1px solid #f0f0f0;
            }
            QTreeWidget::item:selected {
                background-color: #e7f1ff;
                color: #2c3e50;
            }
            QTreeWidget::item:hover {
                background-color: #f7f9fa;
            }
            QHeaderView::section {
                background-color: #ecf0f1;
                color: #34495e;
                padding: 10px 5px;
                border: none;
                border-bottom: 2px solid #3498db;
                font-weight: bold;
            }
        """)

    def _populate_item_tree(self, tree: QtWidgets.QTreeWidget, items: list):
        """یک ویجت درختی مشخص را با لیست کالاهای داده شده پر می‌کند."""
        tree.setSortingEnabled(False)
        tree.clear()

        # --- *** اصلاح کلیدی: فراخوانی متد متمرکز برای تنظیم هدرها *** ---
        headers = ['کالا (پک/محصول مادر)', 'دسته', 'مقدار موجودی', 'واحد', 'حد سفارش', 'ID']
        self._style_tree(tree, headers=headers)
        
        header = tree.header()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        for i in range(1, len(headers)):
            header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeToContents)
        tree.setColumnHidden(headers.index('ID'), True)
        # --- ********************************************************** ---

        if not items:
            set_empty_placeholder(tree, "هیچ کالایی در این دسته یافت نشد.")
            return

        items_by_id = {item['id']: dict(item) for item in items}
        child_map = {}
        top_level_items = []

        for item_id, item_data in items_by_id.items():
            parent_id = item_data.get('parent_item_id')
            if parent_id and parent_id in items_by_id:
                if parent_id not in child_map: child_map[parent_id] = []
                child_map[parent_id].append(item_data)
            else:
                top_level_items.append(item_data)
        
        tree.setUpdatesEnabled(False)
        for item_data in top_level_items:
            parent_item = NumericTreeWidgetItem(tree)
            parent_item.setText(0, item_data.get('name', ''))
            parent_item.setText(1, item_data.get('category', ''))
            parent_item.setText(2, str(item_data.get('non_prod_qty', 0)))
            parent_item.setText(3, item_data.get('unit', ''))
            parent_item.setText(4, str(item_data.get('min_qty', 0)))
            parent_item.setText(5, str(item_data.get('id')))
            parent_item.setData(0, Qt.UserRole, item_data)
            
            if item_data.get('min_qty', 0) > 0 and item_data.get('non_prod_qty', 0) < item_data.get('min_qty', 0):
                parent_item.setBackground(0, QtGui.QColor("#fff2f2"))
            
            if item_data['id'] in child_map:
                for child_data in child_map[item_data['id']]:
                    child_item = NumericTreeWidgetItem(parent_item)
                    child_item.setText(0, child_data.get('name', ''))
                    child_item.setText(1, child_data.get('category', ''))
                    child_item.setText(2, str(child_data.get('non_prod_qty', 0)))
                    child_item.setText(3, child_data.get('unit', ''))
                    child_item.setText(4, str(child_data.get('min_qty', 0)))
                    child_item.setText(5, str(child_data.get('id')))
                    child_item.setData(0, Qt.UserRole, child_data)
                    if child_data.get('min_qty', 0) > 0 and child_data.get('non_prod_qty', 0) < child_data.get('min_qty', 0):
                        child_item.setBackground(0, QtGui.QColor("#fff2f2"))
        
        tree.setUpdatesEnabled(True)
        tree.expandAll()
        tree.setSortingEnabled(True)                                                
                
    def _toggle_trans_view(self, state):
        """بین نمای لیستی و درختی جابجا می‌شود."""
        index = 1 if state == Qt.Checked else 0
        for view_dict in self.trans_views.values():
            view_dict['stack'].setCurrentIndex(index)
                                                                        
                                                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_settings_page(self):
        if self.pg_settings.layout() is not None:
            while self.pg_settings.layout().count():
                item = self.pg_settings.layout().takeAt(0)
                if item.widget(): item.widget().deleteLater()
        
        layout = self.create_page_layout(self.pg_settings, "تنظیمات و ابزارها")
        
        scroll_area = QScrollArea(); scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("QScrollArea { border: none; background-color: transparent; }")
        layout.addWidget(scroll_area)
        
        content_widget = QWidget(); scroll_area.setWidget(content_widget)
        content_layout = QVBoxLayout(content_widget); content_layout.setSpacing(20)

        action_groups = {
            "مدیریت کاربران و دسترسی": [
                {'title': "مدیریت کاربران", 'subtitle': "افزودن، ویرایش و حذف حساب‌ها", 'icon': "system-users", 'color': "#e7f1ff", 'handler': self._open_user_manager, 'permission': 'settings:manage_users'},
                {'title': "مدیریت نقش‌ها", 'subtitle': "ایجاد نقش و تعیین سطح دسترسی‌ها", 'icon': "preferences-system", 'color': "#e7f1ff", 'handler': lambda: RoleManagerDialog(self.db, self).exec_(), 'permission': 'settings:manage_users'},
                {'title': "مدیریت تفویض اختیار", 'subtitle': "تعیین جانشین برای تایید فرآیندها", 'icon': "system-run", 'color': "#e7f1ff", 'handler': self._open_delegation_manager, 'permission': 'settings:manage_users'},
            ],
            "پیکربندی انبار": [
                {'title': "مدیریت لوکیشن‌ها", 'subtitle': "تعریف راهرو، قفسه و طبقه‌های انبار", 'icon': "folder-blue", 'color': "#e8f8f5", 'handler': lambda: LocationDialog(self.db, self).exec_(), 'permission': 'settings:manage_locations'},
                {'title': "مدیریت واحدها", 'subtitle': "تعریف واحدهای شمارش (کیلوگرم، عدد...)", 'icon': "view-fullscreen", 'color': "#e8f8f5", 'handler': self._open_uom_manager, 'permission': 'settings:manage_units'},
                {'title': "تنظیمات برنامه", 'subtitle': "تغییر پارامترهای حد سفارش و انقضا", 'icon': "configure", 'color': "#e8f8f5", 'handler': self._open_app_settings_dialog, 'permission': 'settings:manage_app'},
            ],
            "ابزارهای داده و گزارش‌گیری": [
                {'title': "تهیه پشتیبان", 'subtitle': "ایجاد فایل پشتیبان از کل دیتابیس", 'icon': "document-save-as", 'color': "#fef9e7", 'handler': self._backup_now, 'permission': 'settings:backup_restore'},
                {'title': "بازیابی اطلاعات", 'subtitle': "بازگرداندن اطلاعات از یک فایل پشتیبان", 'icon': "document-revert", 'color': "#fef9e7", 'handler': self._restore_db, 'permission': 'settings:backup_restore'},
                # --- *** کارت جدید برای ابزار تشخیصی *** ---
                {'title': "بررسی وضعیت سیستم", 'subtitle': "نمایش اطلاعات کاربر و دسترسی‌های فعلی", 'icon': "utilities-terminal", 'color': "#fef9e7", 'handler': lambda: SystemStatusDialog(self.user_info, self).exec_(), 'permission': 'page:view:settings'},
            ],
            "منطقه خطر": [
                {'title': "ریست کامل برنامه", 'subtitle': "حذف تمام داده‌ها و بازگشت به تنظیمات اولیه", 'icon': "dialog-warning", 'color': "#fdedec", 'handler': self._factory_reset_confirmed, 'permission': 'settings:factory_reset'},
                {'title': "گزارش تشخیصی سیستم", 'subtitle': "بررسی وضعیت داخلی فرآیندها و تنظیمات", 'icon': "utilities-terminal", 'color': "#fef9e7", 'handler': self._run_diagnostic_report, 'permission': 'settings:manage_app'},

            ]
        }
        
        row, col = 0, 0
        grid_layout = QtWidgets.QGridLayout(); grid_layout.setSpacing(20)

        for group_title, actions in action_groups.items():
            if not any(self.has_permission(action['permission']) for action in actions): continue
            
            group_container = QWidget(); group_layout = QVBoxLayout(group_container)
            
            title_label = QLabel(group_title); title_label.setFont(QFont(FONT_FAMILY, 12, QFont.Bold)); title_label.setStyleSheet("color: #34495e; margin-bottom: 5px; border-bottom: 2px solid #e0e0e0; padding-bottom: 5px;")
            group_layout.addWidget(title_label)

            for action_data in actions:
                if self.has_permission(action_data['permission']):
                    card = SettingsActionCard(action_data['icon'], action_data['color'], action_data['title'], action_data['subtitle'])
                    card.clicked.connect(action_data['handler'])
                    group_layout.addWidget(card)
            
            group_layout.addStretch()
            grid_layout.addWidget(group_container, row, col)
            
            col += 1
            if col > 1:
                col = 0
                row += 1
        
        content_layout.addLayout(grid_layout)
        content_layout.addStretch()
                
            
    def _create_my_tasks_widget(self):
        """ویجت کارتابل وظایف من را می‌سازد."""
        group = QtWidgets.QGroupBox("کارتابل وظایف من (برای اقدام دابل کلیک کنید)")
        layout = QtWidgets.QVBoxLayout(group)
        table = QtWidgets.QTableWidget(); self._style_table(table)
        table.itemDoubleClicked.connect(self._process_task_action)
        layout.addWidget(table)
        # یک نام مشخص به جدول می‌دهیم تا در رفرش پیدا شود
        table.setObjectName("tasks_table")
        return group
        
    def _open_delegation_manager(self):
        """دیالوگ مدیریت تفویض اختیار را باز می‌کند."""
        # فرض می‌کنیم هر کاربری می‌تواند اختیارات خود را تفویض کند
        DelegationManagerDialog(self.db, self.user_id, self).exec_()

    
                
                    
# این متد باید در کلاس MainWindow وجود داشته باشد
    def setup_auto_backup_timer(self):
        """تایمر اصلی برنامه را برای چک کردن زمان بکاپ تنظیم و فعال می‌کند."""
        self.backup_check_timer = QtCore.QTimer(self)
        # هر ۳۰ ثانیه یک بار چک می‌کند
        self.backup_check_timer.timeout.connect(self._check_for_scheduled_backup)
        self.backup_check_timer.start(5000000)
        print("INFO: Auto-backup check timer started (Interval: 30 seconds).")
                
# در کلاس MainWindow، این دو متد را جایگزین کنید

# در کلاس MainWindow، این متد را با نسخه تشخیصی زیر جایگزین کنید
    def _check_for_scheduled_backup(self):
        """نسخه تشخیصی: تمام مراحل چک کردن بکاپ را در کنسول چاپ می‌کند."""
        print("\n--- Running Auto-Backup Check ---")

        if self.role != 'Admin':
            print(f"DEBUG: Check failed. User role is '{self.role}', not 'Admin'.")
            return
        print("DEBUG: Role check passed (User is Admin).")

        is_enabled = self.db.get_setting('autobackup_enabled', 'false') == 'true'
        if not is_enabled:
            print("DEBUG: Check failed. Auto-backup is disabled in settings.")
            return
        print("DEBUG: Auto-backup is enabled.")

        try:
            # ۱. خواندن تنظیمات
            frequency_days = int(self.db.get_setting('autobackup_frequency_days', '1'))
            scheduled_time_str = self.db.get_setting('autobackup_time', '02:00')
            last_backup_date_str = self.db.get_setting('last_autobackup_date', '1970-01-01')

            print(f"DEBUG: Frequency set to: {frequency_days} day(s)")
            print(f"DEBUG: Scheduled time set to: {scheduled_time_str}")
            print(f"DEBUG: Last backup date found: {last_backup_date_str}")

            # ۲. تبدیل تاریخ و زمان‌ها
            scheduled_time = QtCore.QTime.fromString(scheduled_time_str, "HH:mm")
            last_backup_dt = dt.date.fromisoformat(last_backup_date_str)
            today_dt = dt.date.today()
            now_time = QtCore.QTime.currentTime()

            # ۳. محاسبه شرایط
            days_since_last_backup = (today_dt - last_backup_dt).days
            is_period_passed = days_since_last_backup >= frequency_days
            is_time_passed = now_time >= scheduled_time

            print(f"DEBUG: Current time is: {now_time.toString('HH:mm:ss')}")
            print(f"DEBUG: Days since last backup: {days_since_last_backup}")
            print(f"DEBUG: Condition 'is_period_passed' (>= {frequency_days} days): {is_period_passed}")
            print(f"DEBUG: Condition 'is_time_passed' (>= {scheduled_time_str}): {is_time_passed}")

            # ۴. تصمیم‌گیری نهایی
            if is_period_passed and is_time_passed:
                print("SUCCESS: Both conditions met. Triggering backup.")
                self._trigger_background_backup(is_auto=True)
            else:
                print("INFO: Conditions not met. No backup triggered this time.")

        except Exception as e:
            print(f"CRITICAL ERROR in auto-backup check logic: {e}")
            
                        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _on_backup_finished(self, success, message, is_auto=False):
        """این متد زمانی اجرا می‌شود که عملیات پشتیبان‌گیری تمام شده باشد."""
        if success:
            # برای بکاپ خودکار، فقط یک پیغام کوچک در پس‌زمینه نشان می‌دهیم
            if is_auto:
                self.toast.show_message("پشتیبان‌گیری خودکار با موفقیت انجام شد.", "info")
            else:
                self.toast.show_message(message, "success")

            # اگر بکاپ از نوع خودکار بود، تاریخ آن را در تنظیمات ثبت می‌کنیم
            if is_auto:
                today_str = dt.date.today().isoformat()
                self.db.set_setting('last_autobackup_date', today_str)
                print(f"INFO: Auto-backup successful. Updated last_autobackup_date to {today_str}")
        else:
            # برای بکاپ خودکار، خطا را در کنسول نشان می‌دهیم تا مزاحم کاربر نشود
            if is_auto:
                print(f"ERROR: Automatic backup failed: {message}")
            else:
                QtWidgets.QMessageBox.critical(self, "خطای پشتیبان‌گیری", message)
                                                
                                
    def _open_app_settings_dialog(self):
            """پنجره مدیریت تنظیمات برنامه را باز می‌کند."""
            AppSettingsDialog(self.db, self).exec_()
                    
    def _open_uom_manager(self):
        """پنجره مدیریت واحدهای اندازه‌گیری را باز می‌کند."""
        UomManagerDialog(self.db, self).exec_()
        
    def _factory_reset_confirmed(self):
            """
            نسخه نهایی: بدون نیاز به رمز عبور، فقط یک هشدار بسیار جدی
            برای تایید نهایی عملیات نمایش می‌دهد.
            """
            # گام نهایی: دریافت تایید با هشدار جدی
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Critical)
            msg_box.setWindowTitle("تایید نهایی عملیات بسیار خطرناک")
            msg_box.setText("<b>هشدار! شما در آستانه حذف تمام داده‌های انبار هستید.</b>")
            msg_box.setInformativeText(
                "این عملیات، تمام کالاها، تراکنش‌ها، فرمول‌ها، و سایر اطلاعات ثبت شده را برای همیشه پاک می‌کند و به هیچ وجه قابل بازگشت نیست.\n\n"
                "فقط اطلاعات کاربران و نقش‌ها دست نخورده باقی می‌ماند.\n\n"
                "<b>آیا کاملاً از این کار اطمینان دارید؟</b>"
            )
            msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.Cancel)
            yes_button = msg_box.button(QMessageBox.Yes)
            yes_button.setText("بله، تمام داده‌ها پاک شود")
            msg_box.setDefaultButton(QMessageBox.Cancel)
            
            reply = msg_box.exec_()

            if reply == QMessageBox.Yes:
                try:
                    self.toast.show_message("عملیات ریست فکتوری شروع شد...", "info", msec=5000)
                    self.db.factory_reset()
                    self.toast.show_message("✔ عملیات با موفقیت انجام شد. برنامه مجدداً راه‌اندازی می‌شود.", "success", msec=5000)
                    
                    self.restart_on_close = True
                    self.close()
                except Exception as e:
                    self.toast.show_message(f"خطا در عملیات ریست: {e}", "critical")
                    print(traceback.format_exc())
                            
                    
# این دو تابع کاملا جدید را به کلاس MainWindow اضافه کن
    def _refresh_roles_cache(self):
        """لیست نقش‌ها را از دیتابیس می‌خواند و در حافظه موقت برنامه آپدیت می‌کند."""
        print("SYSTEM: Refreshing roles cache from database...")
        self.ALL_ROLES_CACHE = self.db.get_all_roles()

    def _open_user_manager_with_fresh_data(self):
        """پنجره مدیریت کاربران را با پاس دادن لیست به‌روز نقش‌ها باز می‌کند."""
        # این تابع همیشه از لیست کش شده و آپدیت شده استفاده می‌کند
        UserManager(self.db, self.ALL_ROLES_CACHE, self).exec_()            
                    
    # این دو تابع کاملا جدید را به کلاس MainWindow اضافه کن
    def _load_app_data(self):
        """داده‌های پراستفاده برنامه مثل لیست نقش‌ها را یک بار می‌خواند و ذخیره می‌کند."""
        print("INFO: Loading fresh app data (roles)...")
        self.ALL_ROLES_CACHE = self.db.get_all_roles()


    def _open_user_manager(self):
        """
        پنجره مدیریت کاربران را باز می‌کند و قبل از آن، لیست نقش‌ها را رفرش می‌کند.
        """
        # --- *** اصلاح کلیدی در این بخش *** ---
        # قبل از باز کردن دیالوگ، کش نقش‌ها را از دیتابیس رفرش می‌کنیم
        self._load_app_data()
        
        UserManager(self.db, self.ALL_ROLES_CACHE, self.user, self).exec_()
                    
    # این تابع کمکی جدید را هم به کلاس MainWindow اضافه کن
    def _handle_settings_click(self, item):
        """تابع کلیک آیتم‌های صفحه تنظیمات را اجرا می‌کند"""
        title = item.text()
        handler = self.settings_action_handlers.get(title)
        if handler:
            handler()
            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _open_workflow_manager(self, item=None, workflow_id=None):
        """دیالوگ طراح فرآیند را با فراخوانی صحیح و ساده‌شده باز می‌کند."""
        final_workflow_id = None
        if workflow_id:
            final_workflow_id = workflow_id
        elif item:
            try:
                final_workflow_id = int(self.tbl_workflows.item(item.row(), 0).text())
            except (AttributeError, ValueError): pass

        if self.has_permission('qa:manage_workflows'):
            dlg = WorkflowManagerDialog(self.db, self.user_id, self, workflow_id=final_workflow_id)
            dlg.exec_()
            self._load_workflows_list()
        else:
            self.toast.show_message("شما دسترسی لازم برای طراحی فرآیندها را ندارید.", "error")
                        
                                                            
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _on_workflow_action_finished(self, success: bool, message: str):
        """پس از اتمام کار نخ پس‌زمینه، نتیجه را به کاربر نمایش داده و برنامه را رفرش می‌کند."""
        if success:
            self.toast.show_message(f"✔ {message}", "success")
            self.refresh_all()
        else:
            QtWidgets.QMessageBox.critical(self, "خطا در پردازش فرآیند", f"عملیات با خطا مواجه شد:\n{message}")
            

                                            
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _update_sidebar_style(self, active_button):
        # استایل دکمه فعال با متن وسط‌چین
        active_style = """
            QPushButton {
                color: white;
                background-color: #4a6582;
                border: none;
                text-align: center;
                padding: 13px 22px;
                font-weight: bold;
            }
        """
        # استایل دکمه‌های غیرفعال با متن وسط‌چین
        inactive_style = """
            QPushButton {
                color: #eceff1;
                background-color: transparent;
                border: none;
                text-align: center;
                padding: 13px 22px;
            }
            QPushButton:hover {
                background-color: #34495e;
            }
        """
        
        for btn in self.sidebar_buttons:
            if not isinstance(btn, NotificationButton):
                if btn == active_button:
                    btn.setStyleSheet(active_style)
                else:
                    btn.setStyleSheet(inactive_style)
                                                                                                                    
    # ─── ساخت ردیف فیلتر برای یک QTableWidget ───────────────────────────────
    def _make_filter_row(self, table: QtWidgets.QTableWidget):
        if getattr(table, '_filter_done', False):
            return
        table._filter_done = True
        hdr = table.horizontalHeader()
        roww = QtWidgets.QWidget(table)
        lay  = QtWidgets.QHBoxLayout(roww); lay.setContentsMargins(0,0,0,0)
        edits=[]
        for col in range(table.columnCount()):
            edit = QtWidgets.QLineEdit(placeholderText='🔍')
            edit.setFixedHeight(20); edits.append(edit); lay.addWidget(edit, 1)
            edit.textChanged.connect(
                lambda txt, c=col, t=table:
                    [t.setRowHidden(r,
                        txt.lower() not in (t.item(r,c).text() if t.item(r,c) else '').lower())
                    for r in range(t.rowCount())])
        roww.setGeometry(hdr.geometry().adjusted(0, hdr.height(), 0, 0))
        roww.show()
        table.setViewportMargins(0, 25, 0, 0)   # فضا برای ردیف فیلتر

        
    # <<< FIX
    def _handle_attach(self, *_):
        """
        اگر دکمۀ پیوست فایلی نداشته باشد → دیالوگ انتخاب فایل را باز می‌کند
        اگر فایلی ثبت شده باشد → آن فایل را با برنامهٔ پیش‌فرض سیستم باز می‌کند
        """
        btn = self.sender()
        if not isinstance(btn, QtWidgets.QPushButton):
            return

        tid    = btn.property('trans_id')
        attach = btn.property('attach_path') or ''

        if attach and Path(attach).exists():
            QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(attach))
            return

        new_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if not new_path:
            return

        # یک‌دست با Pool/Transaction
        with self.db.transaction() as cur:
            cur.execute("UPDATE trans SET attach_path=%s WHERE id=%s", (new_path, tid))

        btn.setText('📎')
        btn.setProperty('attach_path', new_path)
        
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _show_pending_voids_dialog(self):
        """پنجره مدیریت ابطال‌های در انتظار تایید را باز می‌کند."""
        ApproveVoidDialog(self.db, self.user, self).exec_()
        
    # این متد جدید را به انتهای کلاس MainWindow اضافه کنید
    def _open_approve_void_dialog(self):
        """پنجره مدیریت ابطال‌های در انتظار تایید را باز می‌کند."""
        if not self.has_permission('transactions:void'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return
        ApproveVoidDialog(self.db, self.user, self).exec_()
        
        
# در کلاس MainWindow
    def _style_table(self, tbl):
        tbl.setAlternatingRowColors(True) # <<-- این خط مشکل‌ساز بود، غیرفعال می‌شود
        tbl.verticalHeader().setDefaultSectionSize(42)
        tbl.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tbl.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tbl.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        tbl.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        tbl.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        tbl.horizontalHeader().setDefaultAlignment(Qt.AlignCenter)
        tbl.setStyleSheet("""
            QTableWidget::item { qproperty-alignment:AlignCenter; padding: 5px; }
            QTableWidget::item:selected { background-color: #dbeafe; color: #2c3e50; }
            QTableWidget::item:!selected:hover { background-color: #f1f2f6; }
            QHeaderView::section { background-color: #ecf0f1; color: #34495e; padding: 10px 5px; border: none; border-bottom: 2px solid #3498db; font-weight: bold; }
            QTableWidget::corner { background-color: #ecf0f1; }
            QTableWidget::gridline { color: #dfe6e9; }
        """)
        tbl.verticalHeader().hide()
                                                                        
    # ─── کمک: آیا کاربر فقط ناظر است؟ ───
    def _viewer(self) -> bool:
            return self.role == "Viewer"
        
        
    def has_permission(self, required_perm: str) -> bool:
            """
            بررسی می‌کند که آیا کاربر فعلی دسترسی مورد نیاز را دارد یا خیر.
            """
            # ادمین همیشه و به همه چیز دسترسی دارد
            if self.role == 'Admin':
                return True
            return required_perm in self.permissions
        
    def _open_attach_dialog(self, trans_id: int):
        AttachDialog(self.db, trans_id, self).exec_()


        
    def _transfer(self):
        dlg=TransferDialog(self.db, self.user)
        if dlg.exec_():
            self.refresh_all(); self.toast.show_message('⇄ انتقال انجام شد')


        
        
    def export_table_to_excel(self, table: QtWidgets.QTableWidget):
            """
            این متد داخلی، کار را به تابع اصلی و قدرتمند سراسری واگذار می‌کند
            تا تاریخ‌های شمسی به درستی در خروجی اکسل نمایش داده شوند.
            """
            # فراخوانی تابع عمومی و پاس دادن پارامترهای لازم (جدول و خود پنجره اصلی به عنوان والد)
            export_table_to_excel(table, self)
        
    def _add_filter_row(self, table: QtWidgets.QTableWidget):
        """زیر هدر یک ردیف فیلتر (QLineEdit) می‌سازد."""
        hdr = table.horizontalHeader()
        # اگر قبلاً ساخته‌ایم دوباره نساز
        if getattr(table, '_filter_row', None):
            return
        filt_row = QtWidgets.QWidget(table)
        lay = QtWidgets.QHBoxLayout(filt_row); lay.setContentsMargins(0,0,0,0)
        edits = []
        for c in range(table.columnCount()):
            e = QtWidgets.QLineEdit(placeholderText='🔍')
            e.setFixedHeight(20)
            idx = c
            e.textChanged.connect(lambda txt, col=idx: self._column_filter(table, col, txt))
            edits.append(e); lay.addWidget(e)
        table.setCellWidget(0, 0, QtWidgets.QWidget())   # dummy to reserve row-0
        table.setViewportMargins(0, 25, 0, 0)
        filt_row.setGeometry(hdr.geometry().adjusted(0, hdr.height(), 0, 0))
        table._filter_row = filt_row
        filt_row.show()

    def _column_filter(self, table, col, pattern):
        for r in range(1, table.rowCount()):         # ردیف ۰ رزرو فیلتر است
            txt = table.item(r, col).text() if table.item(r, col) else ''
            hidden = pattern.lower() not in txt.lower()
            table.setRowHidden(r, hidden)

    def _quick_filter_table(self, table, pattern):
        for r in range(table.rowCount()):
            matched = any(pattern.lower() in (table.item(r,c).text()
                        if table.item(r,c) else '').lower()
                        for c in range(table.columnCount()))
            table.setRowHidden(r, not matched)

            
    def _void_selected_trans(self):
            # ... (بخش انتخاب آیتم از جدول که صحیح بود، بدون تغییر باقی می‌ماند) ...
            tab_widget = self.pg_trans.findChild(QtWidgets.QTabWidget)
            if not tab_widget: return
            
            view_dict = self.trans_views.get(tab_widget.tabText(tab_widget.currentIndex()))
            if not view_dict: return
            
            active_view = view_dict['stack'].currentWidget()
            selected_items = active_view.selectedItems()

            if not selected_items:
                self.toast.show_message("لطفاً یک تراکنش را برای ابطال انتخاب کنید.", "warning")
                return

            trans_id = None
            try:
                item = selected_items[0]
                if isinstance(item, QtWidgets.QTableWidgetItem):
                    trans_id = int(item.tableWidget().item(item.row(), 0).text())
                elif isinstance(item, QtWidgets.QTreeWidgetItem):
                    data = item.data(0, Qt.UserRole)
                    if data and data.get('type') == 'item' and data.get('trans_id'):
                        trans_id = data['trans_id']
                if not trans_id: return
            except (ValueError, AttributeError, IndexError):
                return

            # ... (بخش دریافت تایید از کاربر بدون تغییر است) ...
            reply = QtWidgets.QMessageBox.question(self, "تایید عملیات", f"آیا از لغو یا ابطال تراکنش شماره {trans_id} اطمینان دارید؟", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)

            if reply == QtWidgets.QMessageBox.Yes:
                try:
                    # --- اصلاح کلیدی در این بخش ---
                    # نتیجه‌ی بازگشتی از تابع دیتابیس حالا یک عضو Enum است
                    result_status_enum = self.db.void_transaction(trans_id, self.user_id)
                    
                    # بر اساس نوع نتیجه، پیام مناسب را نمایش می‌دهیم
                    if result_status_enum == TransactionStatus.VOIDED:
                        self.toast.show_message("✔ ابطال با موفقیت انجام شد.", "success")
                    elif result_status_enum == TransactionStatus.PENDING_VOID_APPROVAL:
                        self.toast.show_message("✔ درخواست ابطال برای تایید ارسال شد.", "info")
                    elif result_status_enum == TransactionStatus.CANCELLED:
                        self.toast.show_message("✔ درخواست تایید نشده با موفقیت لغو شد.", "success")
                    
                    self.refresh_all()
                except Exception as e:
                    self.toast.show_message(f"خطا در عملیات ابطال: {str(e)}", "critical")
                    print(f"ERROR during voiding transaction {trans_id}: {traceback.format_exc()}")
                
                                                                
        
# این دو متد را به کلاس MainWindow اضافه کنید

    def _open_void_batch_dialog(self):
        """دیالوگ انتخاب بچ فعال برای ابطال را با لیستی خوانا باز می‌کند."""
        if not self.has_permission('production:void_production'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return

        available_batches = self.db.get_available_bulk_products()
        if not available_batches:
            self.toast.show_message("هیچ بچ تولید فعالی برای ابطال وجود ندارد.", "info")
            return
        
        # ساخت لیست خوانا برای نمایش به کاربر
        choices = [f"{item['product_name']} (بچ: {item['production_batch_no']})" for item in available_batches]
        
        choice, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب بچ برای ابطال",
                                                    "کدام بچ تولید را می‌خواهید به طور کامل باطل کنید؟",
                                                    choices, 0, False)
        
        if ok and choice:
            # پیدا کردن بچ نامبر واقعی از روی آیتم انتخاب شده
            selected_index = choices.index(choice)
            selected_batch_no = available_batches[selected_index]['production_batch_no']
            self._void_production_batch_action(selected_batch_no)

# در کلاس MainWindow، این دو متد را جایگزین کنید
    def _void_production_batch_action(self, product_batch_no: str):
        """یک بچ تولید را پس از دریافت دلیل از کاربر، به طور کامل باطل می‌کند."""
        if not product_batch_no: return
        
        # استفاده از دیالوگ سفارشی جدید
        dlg = ReasonDialog("ابطال بچ تولید", f"لطفاً دلیل ابطال کامل بچ <b>{product_batch_no}</b> را وارد کنید:", self)
        if dlg.exec_():
            reason = dlg.reason # دلیل معتبر را از دیالوگ می‌خوانیم
            try:
                self.db.void_production_batch(product_batch_no, self.user_id, reason)
                self.toast.show_message(f"✔ بچ تولید {product_batch_no} با موفقیت باطل شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ابطال بچ با خطا مواجه شد:\n{e}")
                print(traceback.format_exc())

    def _open_void_packing_dialog(self):
        """پنجره انتخاب بچ بسته‌بندی شده برای ابطال را باز کرده و دلیل دریافت می‌کند."""
        if not self.has_permission('production:void_production'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error"); return

        prod_loc_id = self.db.get_production_floor_location()
        if not prod_loc_id:
            self.toast.show_message("انبار تولید در سیستم تعریف نشده است.", "critical"); return

        packed_batches = self.db.get_packed_batches_in_location(prod_loc_id)
        if not packed_batches:
            self.toast.show_message("هیچ محصول بسته‌بندی شده‌ای برای ابطال در انبار تولید وجود ندارد.", "info"); return
        
        choices = [f"{b['name']} (بچ: {b['batch_no']}, موجودی: {b['qty']})" for b in packed_batches]
        choice, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب بچ برای ابطال", "کدام عملیات بسته‌بندی را می‌خواهید باطل کنید؟", choices, 0, False)
        
        if ok and choice:
            selected_index = choices.index(choice)
            selected_batch_no = packed_batches[selected_index]['batch_no']
            
            # استفاده از دیالوگ سفارشی جدید
            reason_dlg = ReasonDialog("دلیل ابطال بسته‌بندی", f"لطفاً دلیل ابطال بسته‌بندی بچ <b>{selected_batch_no}</b> را وارد کنید:", self)
            if reason_dlg.exec_():
                reason = reason_dlg.reason
                try:
                    self.db.void_packing_operation(selected_batch_no, self.user_id, reason)
                    self.toast.show_message(f"✔ بسته‌بندی بچ {selected_batch_no} با موفقیت باطل شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ابطال بسته‌بندی با خطا مواجه شد:\n{e}")
                    print(traceback.format_exc())
                    
                                    
    def _add_item(self):
        if self.has_permission('items:create'):
            dlg = ItemDialog(self.db, self.user_id, self.role, item_id=None)
            if dlg.exec_() == QtWidgets.QDialog.Accepted:
                # ریست جستجو و صفحه‌بندی، سپس ریفرش تب فعلی
                if hasattr(self, 'search_items'):
                    self.search_items.blockSignals(True)
                    self.search_items.clear()
                    self.search_items.blockSignals(False)
                if hasattr(self, 'items_category_tabs'):
                    idx = self.items_category_tabs.currentIndex()
                    if idx >= 0:
                        cur_tab = self.items_category_tabs.tabText(idx)
                        self.item_page_state.pop(cur_tab, None)
                        self._load_items_for_page(cur_tab)
                self.refresh_all()
                self.toast.show_message('✔ کالا با موفقیت اضافه شد', 'success')


    def _edit_item_from_table(self, item_id):
        if not item_id or not self.has_permission('items:edit'):
            return
        dlg = ItemDialog(self.db, self.user_id, self.role, item_id=item_id)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            if hasattr(self, 'search_items'):
                self.search_items.blockSignals(True)
                self.search_items.clear()
                self.search_items.blockSignals(False)
            if hasattr(self, 'items_category_tabs'):
                idx = self.items_category_tabs.currentIndex()
                if idx >= 0:
                    cur_tab = self.items_category_tabs.tabText(idx)
                    self.item_page_state.pop(cur_tab, None)
                    self._load_items_for_page(cur_tab)
            self.refresh_all()
            self.toast.show_message('✔ کالا با موفقیت ویرایش شد', 'success')
                                                                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _recalc_minmax(self):
        """
        نسخه نهایی و پایدار:
        - منطق محاسبه را از UI جدا کرده و داده‌ها را مستقیماً از دیتابیس می‌خواند.
        """
        if not self.has_permission('items:recalc_minmax'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return

        days, ok = QtWidgets.QInputDialog.getInt(self, "Lead Time", "روزهای زمان تأمین (Lead Time):", 14, 1, 90)
        if not ok:
            return

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            # گام ۱: دریافت لیست کالاها مستقیماً از دیتابیس
            all_items = self.db.get_all_transactional_items()
            if not all_items:
                self.toast.show_message("هیچ کالایی برای محاسبه یافت نشد.", "warning")
                return

            n = 0
            # گام ۲: اجرای محاسبه برای هر کالا
            for item in all_items:
                if self.db.calc_min_max(item['id'], days):
                    n += 1
            
            # گام ۳: رفرش کردن صفحه برای نمایش نتایج جدید
            self.refresh_all()

            if n > 0:
                self.toast.show_message(f"✅ Min/Max برای {n} کالا با موفقیت به‌روزرسانی شد.", "success")
            else:
                self.toast.show_message("هیچ کالایی با سابقه مصرف کافی برای محاسبه یافت نشد.", "warning")
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
                        
    # ----------------------------------------
# در کلاس MainWindow، این متد را با نسخه ساده‌شده زیر جایگزین کنید

    def _new_trans(self, t_type, item_id=None, qty=None, doc_no=None, request_id=None):
        """
        نسخه نهایی: این تابع فقط دیالوگ را باز کرده و سیگنال آن را
        به متد پردازشگر اصلی کلاس متصل می‌کند.
        """
        dlg = TransactionDialog(self.db, self.user_id, t_type, self, item_id)
        if qty: dlg.e_qty.setText(str(qty))
        if doc_no: dlg.e_no.setText(doc_no)
        
        # FIX: اتصال سیگنال به متد اصلی و صحیح کلاس، به جای تابع داخلی
        # با این تغییر، دیگر از تابع process_and_fulfill استفاده نمی‌شود.
        dlg.transaction_data_ready.connect(
            lambda data: self._process_transaction_data(data, request_id)
        )
        dlg.exec_()
        
                
                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _process_transaction_data(self, data: dict, request_id: int = None):
        """
        نسخه نهایی (V4.2 - رویداد-محور و استاندارد):
        - تنها نقطه پردازش تراکنش است.
        - از ثابت‌های استاندارد برای انواع تراکنش استفاده می‌کند.
        - پس از ثبت موفق تراکنش‌های کلیدی، رویداد مربوطه را به موتور مرکزی ارسال می‌کند.
        """
        try:
            t_type = data['t_type']
            new_trans_id = None

            if t_type == TransactionType.EXIT_TO_PROD.value:
                dest_loc_id = self.db.get_production_floor_location()
                if not dest_loc_id:
                    raise ValueError("لوکیشن پیش‌فرض تولید تعریف نشده است.")
                
                new_trans_id = self.db.transfer(
                    item_id=data['item_id'], qty=data['qty'],
                    src_loc_id=data['loc_id'], dest_loc_id=dest_loc_id, 
                    user_id=self.user_id, 
                    notes=f"بر اساس درخواست مواد اولیه شماره {request_id}" if request_id else "خروج دستی",
                    batch_no=data['batch_no'], expiry_date=data.get('expiry_date')
                )
                self.toast.show_message("✔ درخواست خروج به تولید ثبت و منتظر تایید است.", "success")
            else:
                new_trans_id = self.db.add_trans_extended(data, self.user_id)
                self.toast.show_message("✔ تراکنش با موفقیت ثبت شد.", "success")

            if new_trans_id:
                if t_type == TransactionType.ENTRY.value:
                    self.db.trigger_event(
                        event_name='WAREHOUSE_RECEIPT_CONFIRMED',
                        record_id=new_trans_id, table_name='trans', user_id=self.user_id
                    )
                elif t_type == TransactionType.WASTE.value:
                    self.db.trigger_event(
                        event_name='ITEM_DISPOSED_AS_WASTE',
                        record_id=new_trans_id, table_name='trans', user_id=self.user_id
                    )

            if request_id and new_trans_id:
                self.db.fulfill_material_request(request_id, self.user_id, new_trans_id)

            self.refresh_all()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در عملیات ثبت تراکنش", str(e))
            print(traceback.format_exc())
            
                                                                                                
                                                            
    def _filter_items(self, txt):
        for r in range(self.tbl_items.rowCount()):
            match = any(txt.lower() in self.tbl_items.item(r, c).text().lower()
                        for c in range(self.tbl_items.columnCount()))
            self.tbl_items.setRowHidden(r, not match)
            
    def _reset_items_filter(self):
        for r in range(self.tbl_items.rowCount()):
            self.tbl_items.setRowHidden(r, False)
        self.search_items.clear()


# این دو متد را در MainWindow جایگزین کنید
    def _backup_now(self):
        """پشتیبان‌گیری دستی را آغاز می‌کند."""
        self._trigger_background_backup(is_auto=False)

    # در کلاس MainWindow، این متد را جایگزین کنید
    def _trigger_background_backup(self, is_auto=False):
        """عملیات پشتیبان‌گیری را در یک رشته مجزا و با استفاده از مسیر سفارشی اجرا می‌کند."""
        try:
            with open(BASE_DIR / 'config.json', 'r', encoding='utf-8') as f: config = json.load(f)
        except Exception as e:
            self.toast.show_message(f"خطا در خواندن فایل کانفیگ: {e}", "critical"); return

        if is_auto:
            default_path = str(BASE_DIR / 'Auto_Backups')
            backup_path_str = self.db.get_setting('autobackup_path', default_path)
            backup_dir = Path(backup_path_str); backup_dir.mkdir(exist_ok=True)
            timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
            fname = str(backup_dir / f"auto_backup_{config.get('dbname', 'db')}_{timestamp}.backup")
        else:
            fname, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره فایل پشتیبان', f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.backup", "Backup Files (*.backup)")

        if not fname: return

        self.toast.show_message("عملیات پشتیبان‌گیری در پس‌زمینه شروع شد...", "info")

        self.backup_thread = QtCore.QThread()
        self.backup_worker = BackupWorker(config, fname)
        self.backup_worker.moveToThread(self.backup_thread)
        self.backup_thread.started.connect(self.backup_worker.run)
        self.backup_worker.finished.connect(partial(self._on_backup_finished, is_auto=is_auto))
        self.backup_worker.finished.connect(self.backup_thread.quit)
        self.backup_worker.finished.connect(self.backup_worker.deleteLater)
        self.backup_thread.finished.connect(self.backup_thread.deleteLater)

        # --- *** اصلاح کلیدی: پاک کردن متغیر پس از اتمام کار نخ *** ---
        self.backup_thread.finished.connect(lambda: setattr(self, 'backup_thread', None))

        self.backup_thread.start()
                    
            
                            
    def _restore_db(self):
            try:
                with open(BASE_DIR / 'config.json', 'r', encoding='utf-8') as f:
                    config = json.load(f)
            except Exception as e:
                # **FIX**: استفاده صحیح از متد show_message
                self.toast.show_message(f"خطا در خواندن فایل کانفیگ: {e}", "critical")
                return

            reply = QtWidgets.QMessageBox.warning(self, 'تایید بازیابی اطلاعات',
                                                "<b>هشدار جدی!</b><br><br>"
                                                "این عملیات، تمام اطلاعات فعلی برنامه را پاک کرده و اطلاعات فایل پشتیبان را جایگزین آن می‌کند. این عمل غیرقابل بازگشت است.<br><br>"
                                                "آیا کاملاً مطمئن هستید که می‌خواهید ادامه دهید؟",
                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel,
                                                QtWidgets.QMessageBox.Cancel)

            if reply != QtWidgets.QMessageBox.Yes:
                return

            fname, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل پشتیبان برای بازیابی', '', "Backup Files (*.backup)")
            if not fname:
                return

            # **FIX**: استفاده صحیح از متد show_message
            self.toast.show_message("در حال بازیابی اطلاعات... این عملیات ممکن است کمی طول بکشد.", "info", msec=5000)
            QtWidgets.QApplication.processEvents()
            
            if self.db and hasattr(self.db, 'conn') and self.db.conn:
                self.db.close()

            success, message = restore_database(config, fname)
            
            if success:
                QtWidgets.QMessageBox.information(self, "عملیات موفق", message)
                self.restart_on_close = True
                self.close()
            else:
                QtWidgets.QMessageBox.critical(self, "خطای بازیابی", message)
                sys.exit()
            
                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _load_dynamic_actions(self):
        """منوی اقدامات پویا را بر اساس جدول دسترسی چندگانه دپارتمان‌ها بارگذاری می‌کند."""
        if not hasattr(self, 'actions_layout'): return
        
        # پاک کردن دکمه‌های قبلی
        while self.actions_layout.count():
            child = self.actions_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        user_dept_rec = self.db.execute_query("SELECT department_id FROM users WHERE id = %s", (self.user_id,), fetch_one=True)
        if not user_dept_rec or not user_dept_rec['department_id']:
            self.actions_layout.addWidget(QtWidgets.QLabel("<i>شما به هیچ واحد سازمانی تخصیص داده نشده‌اید.</i>"))
            return

        user_dept_id = user_dept_rec['department_id']
        
        # --- کوئری جدید برای خواندن از جدول دسترسی ---
        query = """
            SELECT w.id, w.name FROM workflows w
            JOIN manual_workflow_access mwa ON w.id = mwa.workflow_id
            WHERE w.is_active = TRUE 
              AND w.is_manual_start = TRUE
              AND mwa.department_id = %s
            ORDER BY w.name
        """
        accessible_workflows = self.db.execute_query(query, (user_dept_id,))
        # --- ********************************************* ---
        
        if not accessible_workflows:
            self.actions_layout.addWidget(QtWidgets.QLabel("<i>هیچ فرآیند دستی برای واحد شما تعریف نشده است.</i>"))
            return

        for wf in accessible_workflows:
            btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), f" {wf['name']}")
            btn.setMinimumHeight(40)
            btn.setToolTip(f"شروع فرآیند: {wf['name']}")
            btn.clicked.connect(partial(self._start_manual_process_from_dashboard, wf['id']))
            self.actions_layout.addWidget(btn)
        
        self.actions_layout.addStretch()
                
                        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _start_manual_process_from_dashboard(self, workflow_id):
        """
        نسخه نهایی و یکپارچه:
        - یک فرآیند دستی را شروع کرده و بلافاصله کاربر را به پنجره اقدام مناسب هدایت می‌کند.
        """
        try:
            workflow_data = self.db.execute_query("SELECT name, form_def_id, initial_action_key FROM workflows WHERE id = %s", (workflow_id,), fetch_one=True)
            if not workflow_data or not workflow_data.get('form_def_id'):
                self.toast.show_message("فرآیند انتخاب شده فرم مشخصی برای شروع ندارد.", "error"); return

            form_id = workflow_data['form_def_id']
            form_title = f"شروع فرآیند: {workflow_data['name']}"
            
            form_dlg = DynamicFormDialog(self.db, form_id, form_title, self)
            
            if form_dlg.exec_() == QtWidgets.QDialog.Accepted:
                form_data = form_dlg.get_data()
                if form_data:
                    action_key = workflow_data.get('initial_action_key')
                    
                    # --- *** مسیر ۱: فرآیندهای آغازگر (با اقدام اولیه) *** ---
                    if action_key:
                        self._execute_workflow_initial_action(action_key, form_data, self.user_id)
                    
                    # --- *** مسیر ۲: فرآیندهای تاییدی (با مراحل) *** ---
                    else:
                        process_instance_id = None
                        with self.db.transaction() as cur:
                            entry_id = self.db.add_or_update_form_entry(form_id, self.user_id, json.dumps(form_data, ensure_ascii=False))
                            process_instance_id = self.db.start_workflow_instance(workflow_id, entry_id, 'form_entries', cur, self.user_id)
                        
                        # --- ** اصلاح کلیدی: هدایت به پنجره اقدام ** ---
                        if process_instance_id:
                            self.toast.show_message("✔ فرآیند آغاز شد. لطفاً فرم مرحله اول را تکمیل کنید.", "success")
                            self._process_task_action_from_id(process_instance_id)
                        # --- ************************************** ---

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در شروع فرآیند", f"یک خطای پیش‌بینی نشده رخ داد:\n{e}")
                                        

                                        

# در کلاس MainWindow، این متد را با نسخه جدید جایگزین کنید

    def refresh_all(self):
        """عملیات رفرش کامل برنامه را در یک رشته پس‌زمینه آغاز می‌کند."""
        self._start_background_refresh()
        
        #
    def _load_actionable_purchase_requests(self):
        """لیست درخواست‌های خرید آماده استعلام را در میزکار بازرگانی بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_actionable_prs'): return
        
        table = self.tbl_actionable_prs
        table.setSortingEnabled(False)
        table.setRowCount(0)
        
        try:
            requests = self.db.get_actionable_purchase_requests()
            headers = ['ID', 'نام کالا', 'مقدار درخواستی', 'فوریت', 'وضعیت']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(requests))

            for r, req in enumerate(requests):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(req['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(req['item_name']))
                table.setItem(r, 2, NumericTableWidgetItem(str(req['requested_qty'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(req.get('urgency', '---')))
                
                status_item = QtWidgets.QTableWidgetItem(req['status'])
                if req['status'] == 'تامین‌کننده انتخاب شد':
                    status_item.setBackground(QtGui.QColor("#d1e7dd")) # هایلایت سبز
                table.setItem(r, 4, status_item)

            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ درخواست فعالی برای استعلام قیمت وجود ندارد.")
            table.setSortingEnabled(True)
        except Exception as e:
            print(f"Error loading actionable purchase requests: {e}")
    
    
    def _load_purchase_orders(self):
        """جدول تاریخچه سفارشات خرید را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_purchase_orders'): return
        table = self.tbl_purchase_orders
        table.setRowCount(0)
        
        try:
            orders = self.db.get_all_purchase_orders()
            headers = ["ID", "شماره PO", "تامین‌کننده", "تاریخ صدور", "مبلغ کل", "وضعیت"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(orders))

            for r, order in enumerate(orders):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['po_number']))
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(order['supplier_name']))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(to_shamsi(order['issue_date'])))
                table.setItem(r, 4, NumericTableWidgetItem(f"{order.get('total_amount', 0):,.0f}"))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(order['status']))

            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ سفارش خریدی تا کنون ثبت نشده است.")
        except Exception as e:
            print(f"Error loading purchase orders: {e}")
                                    
        
                    
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _on_item_load_finished(self, all_items_data):
        """پس از اتمام کار Worker، داده‌های جدید را در تب‌های کالا توزیع می‌کند."""
        try:
            if not all_items_data:
                return

            items_by_category = {
                "Finished Goods": [i for i in all_items_data if i['category'] == 'محصول نهایی'],
                "Raw Materials": [i for i in all_items_data if i['category'] == 'مواد اولیه'],
                "Packaging Supplies": [i for i in all_items_data if i['category'] == 'لوازم بسته‌بندی'],
                "Bulk Products": [i for i in all_items_data if i['category'] == 'محصول فله']
            }

            for key, tree in self.item_trees.items():
                self._populate_item_tree(tree, items_by_category.get(key, []))
            
            # پس از بارگذاری موفق، پنل جزئیات را پاک می‌کنیم
            if hasattr(self, 'details_stack'):
                self.details_stack.setCurrentWidget(self.details_placeholder)

        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            print("INFO: Items page UI updated from background thread.")
                    

                        
    def _assign_asset_action(self):
        """گردش کار تخصیص دارایی به پرسنل را با استفاده از log_asset_event مدیریت می‌کند."""
        dlg = AssignAssetDialog(self.db, self)
        if dlg.exec_():
            data = dlg.get_data()
            if data:
                try:
                    # --- اصلاح کلیدی: فراخوانی متد عمومی و هوشمند شده ---
                    full_notes = f"تحویل به: {data['employee_name']}"
                    self.db.log_asset_event(
                        asset_id=data['asset_id'],
                        t_type="تحویل به پرسنل", # نوع تراکنش را مشخص می‌کنیم
                        notes=full_notes,
                        t_no=data['doc_no'],
                        user_id=self.user_id
                    )
                    self.toast.show_message("✔ دارایی با موفقیت به پرسنل تحویل داده شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا در عملیات", str(e))

                            

                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_material_requests(self):
        """
        نسخه نهایی (با بازخورد شفاف و Tooltip):
        - برای ستون یادداشت، یک Tooltip برای نمایش متن کامل اضافه می‌کند.
        """
        if not hasattr(self, 'tbl_material_requests'): return
        
        table = self.tbl_material_requests
        table.setSortingEnabled(False)
        table.setRowCount(0)
        
        try:
            requests = self.db.get_pending_material_requests()
            
            headers = ['ID درخواست', 'ID کالا', 'نام کالا', 'مقدار درخواستی', 'درخواست دهنده', 'تاریخ درخواست', 'وضعیت', 'یادداشت/دلیل رد']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(requests))

            REWORK_COLOR = QtGui.QColor("#fff3cd")

            for r, req in enumerate(requests):
                # ... (بخش ثبت آیتم‌های دیگر بدون تغییر است) ...
                values = [str(req.get('id')), str(req.get('item_id')), req.get('item_name'), str(req.get('requested_qty')), req.get('requester_name'), to_shamsi(req.get('created_at'))]
                for c, value in enumerate(values):
                    item = QtWidgets.QTableWidgetItem(value); item.setToolTip(value); table.setItem(r, c, item)
                
                status_text = req.get('status', '')
                notes_text = req.get('notes', '')
                
                status_item = QtWidgets.QTableWidgetItem(status_text)
                notes_item = QtWidgets.QTableWidgetItem(notes_text)
                
                # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
                notes_item.setToolTip(notes_text) # افزودن Tooltip به سلول یادداشت
                
                table.setItem(r, 6, status_item)
                table.setItem(r, 7, notes_item)

                if status_text == TransactionStatus.MR_REWORK_WAREHOUSE.value:
                    for c in range(len(headers)):
                        table.item(r, c).setBackground(REWORK_COLOR)

            table.setColumnHidden(0, True); table.setColumnHidden(1, True); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(headers.index('نام کالا'), QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(headers.index('یادداشت/دلیل رد'), QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ درخواست فعالی برای رسیدگی وجود ندارد.")

        except Exception as e:
            print(f"Error loading material requests: {e}")
        
        table.setSortingEnabled(True)
                
        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _load_pending_deliveries(self, table_widget=None):
            """
            نسخه نهایی: نام کامل محصول (مادر + فرزند) را در جدول نمایش می‌دهد.
            """
            table = table_widget if table_widget is not None else getattr(self, 'tbl_pending_deliveries', None)
            if not table: return

            table.setSortingEnabled(False)
            table.setRowCount(0)
            
            try:
                rows = self.db.get_pending_deliveries()
                headers = ['ID', 'نام محصول کامل', 'شماره بچ', 'مقدار', 'درخواست دهنده (سرپرست)', 'تاریخ درخواست']
                table.setColumnCount(len(headers))
                table.setHorizontalHeaderLabels(headers)
                table.setRowCount(len(rows))

                for r, row in enumerate(rows):
                    # --- *** اصلاح کلیدی اینجاست: ساختن نام کامل محصول *** ---
                    full_product_name = row.get('product_name')
                    if row.get('parent_name'):
                        full_product_name = f"{row['parent_name']} / {row['product_name']}"
                    # --- ************************************************* ---

                    values = [
                        str(row['id']), 
                        full_product_name, # <-- استفاده از نام کامل
                        row.get('production_batch_no'),
                        str(row.get('quantity')), 
                        row.get('supervisor_name'), 
                        to_shamsi(row.get('created_at'))
                    ]
                    for c, value in enumerate(values):
                        item = QtWidgets.QTableWidgetItem(value)
                        item.setToolTip(value)
                        table.setItem(r, c, item)
                
                table.setColumnHidden(0, True)
                table.resizeColumnsToContents()
                table.horizontalHeader().setSectionResizeMode(headers.index('نام محصول کامل'), QtWidgets.QHeaderView.Stretch)
                set_empty_placeholder(table, "هیچ محصول جدیدی برای تحویل به انبار وجود ندارد.")
            except Exception as e:
                print(f"Error loading pending deliveries: {e}")
            
            table.setSortingEnabled(True)
            

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _load_trans(self, index=None):
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            if index is None:
                if not hasattr(self, 'tab_widget_trans'): return
                index = self.tab_widget_trans.currentIndex()
            
            active_tab_name = self.tab_widget_trans.tabText(index)
            
            if active_tab_name == 'تاریخچه دارایی':
                self.view_mode_check.setEnabled(False) 
                self._load_asset_trans()
                return 
            
            if active_tab_name == 'مرکز عملیات انبار':
                self.view_mode_check.setEnabled(False)
                if hasattr(self, 'tbl_material_requests'): self._load_material_requests()
                if hasattr(self, 'tbl_pending_deliveries'): self._load_pending_deliveries()
                if hasattr(self, '_load_pending_returns'): self._load_pending_returns()
                
                if hasattr(self, '_load_pending_internal_requests_for_warehouse'):
                    self._load_pending_internal_requests_for_warehouse()
                return

            self.view_mode_check.setEnabled(True)
            view_dict = self.trans_views.get(active_tab_name)
            if not view_dict: return
            
            transactions = self.db.get_all_transactions_detailed(t_type_filter=active_tab_name)
            
            table = view_dict['table']; tree = view_dict['tree']
            table.setSortingEnabled(False); table.setRowCount(0); tree.clear()

            STATUS_VISUALS = {
                TransactionStatus.APPROVED: {'color': QtGui.QColor("#e7f5e7"), 'text': 'تایید شده', 'strike': False},
                TransactionStatus.VOIDED: {'color': QtGui.QColor("#e9ecef"), 'text': 'باطل شده', 'strike': True},
                TransactionStatus.CANCELLED: {'color': QtGui.QColor("#e9ecef"), 'text': 'لغو شده', 'strike': True},
                TransactionStatus.PENDING_APPROVAL: {'color': QtGui.QColor("#cfe2ff"), 'text': 'در انتظار تایید', 'strike': False},
                TransactionStatus.PENDING_PRODUCTION_APPROVAL: {'color': QtGui.QColor("#cfe2ff"), 'text': 'در انتظار تایید تولید', 'strike': False},
                TransactionStatus.PENDING_VOID_APPROVAL: {'color': QtGui.QColor("#fff3cd"), 'text': 'در انتظار تایید ابطال', 'strike': False},
                TransactionStatus.REJECTED: {'color': QtGui.QColor("#f8d7da"), 'text': 'رد شده', 'strike': False},
            }
            DEFAULT_VISUAL = {'color': QtGui.QColor("white"), 'text': 'نامشخص', 'strike': False}
            
            source_list = transactions
            
            headers = ['ID', 'نوع', 'کالا', 'شماره سند', 'تاریخ', 'مقدار', 'شماره بچ', 'تاریخ انقضا', 'وضعیت', 'یادداشت', 'کاربر', 'لوکیشن','پیوست']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setColumnHidden(0, True)
            table.setRowCount(len(source_list))

            for r_idx, rec in enumerate(source_list):
                status_enum = next((s for s in TransactionStatus if s.value == rec.get('status', '').strip()), None)
                visual_style = STATUS_VISUALS.get(status_enum, DEFAULT_VISUAL)
                
                full_item_name = rec.get('item_name', '')
                if rec.get('parent_name'):
                    full_item_name = f"{rec['parent_name']} - {full_item_name}"
                
                row_values = {
                    'ID': str(rec['id']), 'نوع': rec.get('t_type', ''), 'کالا': full_item_name,
                    'شماره سند': rec.get('t_no', ''), 'تاریخ': to_shamsi(rec.get('t_date')),
                    'مقدار': str(rec.get('qty')), 'شماره بچ': rec.get('batch_no', ''),
                    'تاریخ انقضا': to_shamsi(rec.get('expiry_date')), 'وضعیت': visual_style['text'], 
                    'یادداشت': rec.get('notes', ''), 'کاربر': rec.get('username', 'حذف شده'), 
                    'لوکیشن': rec.get('loc_label', ''),
                }
                
                if 'files_count' in rec: self._add_attachment_button(table, r_idx, headers.index('پیوست'), rec['id'], rec.get('files_count', 0))
                
                for c_idx, header in enumerate(headers):
                    if header == 'پیوست': continue
                    cell_data = row_values.get(header, '')
                    item = NumericTableWidgetItem(cell_data) if header == 'مقدار' else QtWidgets.QTableWidgetItem(cell_data)
                    item.setToolTip(str(cell_data)); item.setData(Qt.BackgroundRole, visual_style['color'])
                    if visual_style['strike']:
                        font = item.font(); font.setStrikeOut(True); item.setFont(font)
                    table.setItem(r_idx, c_idx, item)
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(headers.index('کالا'), QtWidgets.QHeaderView.Stretch)
            table.setSortingEnabled(True)
            
            grouped_trans = {}
            for rec in source_list:
                doc_no = rec.get('t_no') or f"سند متفرقه #{rec['id']}"
                if doc_no not in grouped_trans: grouped_trans[doc_no] = []
                grouped_trans[doc_no].append(rec)
            
            tree.setHeaderLabels(['کالا / شماره سند', 'تاریخ', 'مقدار', 'وضعیت', 'یادداشت', 'کاربر', 'لوکیشن'])
            tree.clear()
            for doc_no, records in grouped_trans.items():
                parent_item = QtWidgets.QTreeWidgetItem(tree, [doc_no])
                
                # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
                # شماره ستون (0) به تابع setFont اضافه شده است
                parent_item.setFont(0, QFont(FONT_FAMILY, 10, QFont.Bold))
                # --- ************************************* ---

                parent_item.setData(0, Qt.UserRole, {'type': 'doc', 'doc_no': doc_no})
                for rec in records:
                    status_enum = next((s for s in TransactionStatus if s.value == rec.get('status', '').strip()), None)
                    visual_style = STATUS_VISUALS.get(status_enum, DEFAULT_VISUAL)
                    
                    full_item_name_tree = rec.get('item_name','')
                    if rec.get('parent_name'):
                        full_item_name_tree = f"{rec['parent_name']} - {full_item_name_tree}"

                    child_values = [
                        full_item_name_tree, to_shamsi(rec.get('t_date')), str(rec.get('qty')), 
                        visual_style['text'], rec.get('notes',''), rec.get('username','حذف شده'), 
                        rec.get('loc_label', '')
                    ]
                    child_item = QtWidgets.QTreeWidgetItem(parent_item, child_values)
                    child_item.setData(0, Qt.UserRole, {'type': 'item', 'id': rec['item_id'], 'trans_id': rec['id']})
                    
                    for i in range(len(child_values)):
                        child_item.setBackground(i, visual_style['color'])
                        if visual_style['strike']:
                            font = child_item.font(i); font.setStrikeOut(True); child_item.setFont(i, font)
            tree.expandAll()
            
            if self.pending_focus_trans_id is not None:
                target_id = self.pending_focus_trans_id
                self.pending_focus_trans_id = None
                active_table = view_dict['table']
                found = False
                for r in range(active_table.rowCount()):
                    item = active_table.item(r, 0)
                    if item and item.text() == str(target_id):
                        active_table.selectRow(r)
                        active_table.scrollToItem(item, QtWidgets.QAbstractItemView.ScrollHint.PositionAtCenter)
                        self.toast.show_message(f"جزئیات تراکنش شماره {target_id} نمایش داده شد.", "info")
                        found = True
                        break
                if not found:
                    self.toast.show_message("تراکنش مورد نظر در این نما یافت نشد.", "warning")
        
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()                                    
                                                            
    # در کلاس MainWindow
    def _add_attachment_button(self, table, row_index, col_index, trans_id, files_count):
        """یک دکمه پیوست زیبا به سلول مشخص شده در جدول اضافه می‌کند."""
        # این نسخه، تعداد فایل را به عنوان ورودی می‌گیرد و دیگر به دیتابیس کوئری نمی‌زند.
        attach_icon = self.style().standardIcon(QtWidgets.QStyle.SP_FileLinkIcon)
        btn_attach = QtWidgets.QPushButton(attach_icon, "")
        btn_attach.setProperty("class", "cell-button") # <-- این خط جدید را اضافه کنید

        
        btn_attach.setFixedSize(32, 32)
        btn_attach.setCursor(Qt.PointingHandCursor)
        btn_attach.setToolTip(f"مدیریت پیوست‌ها ({files_count} فایل)")
        btn_attach.setStyleSheet("""
            QPushButton { border: none; background-color: transparent; }
            QPushButton:hover { background-color: #e8e8e8; border-radius: 4px; }
        """)
        
        if files_count == 0:
            opacity_effect = QtWidgets.QGraphicsOpacityEffect()
            opacity_effect.setOpacity(0.4)
            btn_attach.setGraphicsEffect(opacity_effect)
        
        btn_attach.clicked.connect(partial(self._open_attach_dialog, trans_id))
        
        cell_widget = QtWidgets.QWidget()
        cell_layout = QtWidgets.QHBoxLayout(cell_widget)
        cell_layout.addWidget(btn_attach)
        cell_layout.setAlignment(Qt.AlignCenter)
        cell_layout.setContentsMargins(0, 0, 0, 0)
        table.setCellWidget(row_index, col_index, cell_widget)        
                
                                                                        
    def _create_graphical_action(self, icon_path, title, subtitle, parent_menu):
        """یک اکشن گرافیکی سفارشی برای استفاده در منو ایجاد می‌کند."""
        
        # ویجت اصلی که داخل منو قرار می‌گیرد
        widget = QtWidgets.QWidget()
        layout = QtWidgets.QHBoxLayout(widget)
        layout.setContentsMargins(15, 10, 15, 10) # حاشیه داخلی برای زیبایی
        layout.setSpacing(15)

        # بخش آیکون
        icon_label = QtWidgets.QLabel()
        pixmap = QtGui.QPixmap(icon_path).scaled(32, 32, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        icon_label.setPixmap(pixmap)
        
        # بخش متن (عنوان و زیرنویس)
        text_layout = QtWidgets.QVBoxLayout()
        text_layout.setSpacing(2)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt;")
        
        subtitle_label = QtWidgets.QLabel(subtitle)
        subtitle_label.setStyleSheet("color: #636e72;")

        text_layout.addWidget(title_label)
        text_layout.addWidget(subtitle_label)
        
        layout.addWidget(icon_label)
        layout.addLayout(text_layout)
        layout.addStretch()

        # ساخت QWidgetAction
        action = QtWidgets.QWidgetAction(parent_menu)
        action.setDefaultWidget(widget)
        return action
            

# در کلاس MainWindow، این متد را جایگزین کنید
    def _show_item_details_panel(self, item, column):
        """نسخه نهایی با منطق هوشمند کارتکس برای دکمه پنل جزئیات."""
        if not item:
            self.details_stack.setCurrentWidget(self.details_placeholder)
            return
        
        item_data = item.data(0, Qt.UserRole)
        if not isinstance(item_data, dict):
            self.details_stack.setCurrentWidget(self.details_placeholder)
            return

        self.details_stack.setCurrentWidget(self.details_container)
        while self.details_form_layout.count():
            child = self.details_form_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        def add_detail_row(label, value, is_numeric=False):
            if is_numeric:
                try: value = f"{float(value):,}"
                except (ValueError, TypeError): pass
            lbl_widget = QtWidgets.QLabel(f"<b>{value or '---'}</b>")
            lbl_widget.setTextInteractionFlags(Qt.TextSelectableByMouse)
            self.details_form_layout.addRow(label, lbl_widget)

        # ... (بخش نمایش اطلاعات مثل قبل) ...
        add_detail_row("نام کامل:", item_data.get('name')); add_detail_row("شناسه کالا (SKU):", item_data.get('sku')); add_detail_row("دسته:", item_data.get('category'))
        parent_id = item_data.get('parent_item_id')
        if parent_id:
            parent_info = self.db.get_item_details(parent_id)
            parent_name = parent_info.get('name', f"ID: {parent_id}") if parent_info else f"ID: {parent_id}"
            add_detail_row("محصول مادر:", parent_name)
        add_detail_row("وزن خالص:", f"{item_data.get('net_weight', 0)} Kg")
        total_qty_str = f"{item_data.get('non_prod_qty', 0)} {item_data.get('unit')}"
        add_detail_row("موجودی در دسترس:", total_qty_str); add_detail_row("حد سفارش (Min):", item_data.get('min_qty', 0), is_numeric=True); add_detail_row("حداکثر موجودی (Max):", item_data.get('max_qty', 0), is_numeric=True); add_detail_row("تأمین‌کننده:", item_data.get('supplier'))
        entry_date = item_data.get('ent_date')
        add_detail_row("تاریخ تعریف:", to_shamsi(entry_date.date() if hasattr(entry_date, 'date') else entry_date))
        details_btn = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("zoom-in"), "مشاهده جزئیات کامل موجودی..."); details_btn.clicked.connect(lambda: DetailedStockViewDialog(self.db, item_data, self).exec_()); self.details_form_layout.addRow(details_btn)
        
        action_bar = self.action_bar
        while action_bar.layout().count():
            child = action_bar.layout().takeAt(0)
            if child.widget(): child.widget().deleteLater()
        
        item_id = item_data['id']
        item_name = item_data['name']
        button_style = "QPushButton { background-color: #f0f2f5; border: 1px solid #dcdcdc; border-radius: 5px; padding: 8px 12px; font-weight: bold; } QPushButton:hover { background-color: #e4e6e8; border-color: #b0b0b0; }"
        
        btn_barcode = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("barcodescanner"), " لیبل"); btn_barcode.setStyleSheet(button_style)
        btn_barcode.clicked.connect(lambda: BarcodeLabelDialog(item_name, str(item_id), self).exec_())
        action_bar.layout().addWidget(btn_barcode)
        
        if self.has_permission('items:edit'):
            btn_edit = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-edit"), " ویرایش"); btn_edit.setStyleSheet(button_style)
            btn_edit.clicked.connect(lambda: self._edit_item_from_table(item_id))
            action_bar.layout().addWidget(btn_edit)

        if self.has_permission('page:view:transactions'):
            btn_stock_card = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("x-office-document"), " کارتکس"); btn_stock_card.setStyleSheet(button_style)
            
            def export_smart_stock_card():
                ids_to_export = []
                filename_base = "Report"
                
                if item_data.get('is_parent_product'):
                    child_items = self.db.get_child_items(item_id)
                    ids_to_export = [child['id'] for child in child_items]
                    filename_base = item_data.get('name', 'Report')
                    if not ids_to_export:
                        self.toast.show_message("این محصول مادر هیچ پک (فرزند) تعریف شده‌ای برای گزارش‌گیری ندارد.", "warning")
                        return
                else:
                    ids_to_export = [item_id]
                    filename_base = item_data.get('name', 'Report')

                safe_filename_base = filename_base.replace('/', '-').replace('\\', '-')
                default_filename = f"Stock_Card_{safe_filename_base}.xlsx"
                
                path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره کارتکس انبار', default_filename, 'Excel (*.xlsx)')
                
                if path:
                    export_transactions_of_items(self.db, ids_to_export, path, self)
            
            btn_stock_card.clicked.connect(export_smart_stock_card)
            action_bar.layout().addWidget(btn_stock_card)
        
        action_bar.layout().addStretch()
        
        if self.has_permission('items:delete'):
            btn_delete = QtWidgets.QPushButton("🗑️"); btn_delete.setToolTip("حذف این کالا"); btn_delete.setStyleSheet("QPushButton { background-color: #ffebee; border: 1px solid #e57373; border-radius: 5px; font-size: 16pt; padding: 0px; } QPushButton:hover { background-color: #ffcdd2; }"); btn_delete.setFixedSize(38, 38); btn_delete.clicked.connect(lambda: self._delete_items([item_id])); action_bar.layout().addWidget(btn_delete)
            
                                                
# این متد جدید را به کلاس MainWindow اضافه کنید
# در کلاس MainWindow
    def _generate_multiple_barcodes(self, selected_ids: list):
        """برای لیستی از ID های کالا، بارکد تولید کرده و در یک پوشه ذخیره می‌کند."""
        if not selected_ids: return

        folder_path = QtWidgets.QFileDialog.getExistingDirectory(self, "پوشه‌ای برای ذخیره لیبل‌ها انتخاب کنید")
        if not folder_path:
            self.toast.show_message("عملیات لغو شد.", "info")
            return
            
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        success_count = 0
        error_count = 0
        try:
            for item_id in selected_ids:
                item_data = self.db.get_item_details(item_id)
                if item_data:
                    item_name = item_data.get('name', str(item_id))
                    file_name = f"Label_{item_data.get('sku') or item_name.replace(' ', '_')}.png"
                    full_path = Path(folder_path) / file_name
                    
                    # --- اصلاح: ارسال item_name به دیالوگ ---
                    dialog = BarcodeLabelDialog(item_name, str(item_id), self)
                    barcode_bytes = dialog.barcode_image_bytes
                    dialog.close() 

                    if barcode_bytes:
                        with open(full_path, 'wb') as f:
                            f.write(barcode_bytes)
                        success_count += 1
                    else:
                        error_count += 1
                else:
                    error_count += 1
        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
        if success_count > 0:
            self.toast.show_message(f"✔ تعداد {success_count} لیبل با موفقیت در پوشه انتخابی ذخیره شد.", "success")
        if error_count > 0:
            self.toast.show_message(f"هشدار: برای {error_count} کالا لیبل تولید نشد.", "warning")
            
        
                                                                                                                                    
    def _open_item_action_menu(self, button, item_id):
        """یک منوی عملیات برای ردیف انتخاب شده در جدول کالاها باز می‌کند."""
        if not item_id: return

        menu = QtWidgets.QMenu(self)
        edit_action = menu.addAction(QtGui.QIcon.fromTheme("document-edit"), "ویرایش این کالا")
        trans_action = menu.addAction(QtGui.QIcon.fromTheme("view-history"), "مشاهده تاریخچه تراکنش‌ها")
        
        action = menu.exec_(button.mapToGlobal(QtCore.QPoint(0, button.height())))
        
        if action == edit_action:
            self._edit_item_from_table(item_id)
        elif action == trans_action:
            self._show_item_transactions(item_id)
            
# این متد جدید را به کلاس MainWindow اضافه کن
    def _iterate_all_tree_items(self, tree_widget):
        """یک generator برای پیمایش تمام آیتم‌های یک QTreeWidget (والد و فرزند)."""
        root = tree_widget.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            yield parent_item
            for j in range(parent_item.childCount()):
                yield parent_item.child(j)
                            
    def _show_item_transactions(self, item_id):
        """به صفحه تراکنش‌ها رفته و آن را برای کالای انتخاب شده فیلتر می‌کند."""
        if not item_id: return
        
        # پیدا کردن نام کالا برای استفاده در فیلتر
        item_data = self.db.get_item_details(item_id)
        if not item_data: return
        item_name = item_data.get('name')

        # رفتن به صفحه تراکنش‌ها
        self.pages.setCurrentWidget(self.pg_trans)
        
        # فیلتر کردن تمام تب‌های تراکنش
        for tab_name, table in self.trans_tabs.items():
            if tab_name == 'خروج دارایی': continue # این تب مربوط به کالا نیست
            
            # پیدا کردن ایندکس ستون 'کالا'
            try:
                header_labels = [table.horizontalHeaderItem(i).text() for i in range(table.columnCount())]
                name_col_idx = header_labels.index('کالا')
            except (ValueError, AttributeError):
                continue # اگر ستون وجود نداشت، از این تب بگذر

            # اعمال فیلتر
            for r in range(table.rowCount()):
                cell_item = table.item(r, name_col_idx)
                if cell_item and cell_item.text() == item_name:
                    table.setRowHidden(r, False)
                else:
                    table.setRowHidden(r, True)
                
        # ──────────────────────────────────────────────────────────────
    #  Helper: هم‌تراز کردن فیلد فیلتر با عرض واقعی هر ستون
    # ──────────────────────────────────────────────────────────────
    def _sync_filter_row(self, tbl: QtWidgets.QTableWidget):
        fr = getattr(tbl, '_filter_row', None)
        if not fr:                              # اگر هنوز ساخته نشده
            return

        hdr = tbl.horizontalHeader()
        lay = fr.layout()

        # پهنای هر QLineEdit = پهنای ستون متناظر
        for col in range(tbl.columnCount()):
            w = hdr.sectionSize(col)
            lay.itemAt(col).widget().setFixedWidth(w)

        # ردیف فیلتر دقیقاً زیر هدر بنشیند
        g = hdr.geometry()
        fr.setGeometry(g.left(), g.bottom(),
                    g.width(), fr.sizeHint().height())
        
    # ──────────────────────────────────────────────────────────────
    #  وقتی کاربر بین تب‌های «ورود/خروج/…» جابه‌جا می‌شود
    # ──────────────────────────────────────────────────────────────
    def _on_trans_tab_changed(self, idx: int):
        # idx همان ترتیب TYPES است که در _build_trans_page تعریف شده
        types = ('ورود', 'خروج', 'برگشت', 'انتقال', 'خروج دارایی')
        tp = types[idx] if idx < len(types) else None
        if tp and tp in self.trans_tabs:
            self._sync_filter_row(self.trans_tabs[tp])
            


        
    def _show_details_for_trans_item(self, item): # <<-- توجه: آرگومان column به طور کامل حذف شد
        """
        با دابل کلیک روی آیتم، کارت کالا را نمایش می‌دهد.
        این نسخه برای حل قطعی مشکل، دیگر به آرگومان column وابسته نیست.
        """
        data = None
        
        # ابتدا بررسی می‌کنیم که آیا آیتم از نوع درخت است یا خیر
        # این روش مطمئن‌تر از isinstance است
        if hasattr(item, 'childCount'): # فقط QTreeWidgetItem این متد را دارد
            # چون آیتم درخت است، داده را از ستون اول (0) می‌خوانیم
            data = item.data(0, Qt.UserRole)
        else:
            # اگر آیتم درخت نبود، پس حتما آیتم جدول است و متد data آن یک آرگومان می‌گیرد
            try:
                data = item.data(Qt.UserRole)
            except Exception as e:
                print(f"Error getting data from QTableWidgetItem: {e}")
                return
        
        if not data:
            return

        # بقیه منطق برای پردازش داده استخراج شده
        item_id = None
        if isinstance(data, dict):
            if data.get('type') == 'item':
                item_id = data.get('id')
        elif isinstance(data, int):
            item_id = data
            
        if item_id:
            StockCardDialog(self.db, item_id, self).exec_()
                                                                                                                            
    # <<< FIX
    def _handle_asset_attach(self, btn, trans_id, current_path):
        if current_path and Path(current_path).exists():
            QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(current_path))
            return

        new_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل پیوست')
        if not new_path:
            return

        # یک‌دست با Pool/Transaction
        with self.db.transaction() as cur:
            cur.execute("UPDATE asset_trans SET attach=%s WHERE id=%s", (new_path, trans_id))

        btn.setText("📎")
            
            

    def _style_asset_tree(self, tree: QtWidgets.QTreeWidget):
        """یک استایل اختصاصی برای درخت تاریخچه دارایی‌ها اعمال می‌کند."""
        tree.setAlternatingRowColors(True)
        tree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        tree.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        tree.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        
        headers = ['سند / دارایی', 'نوع تراکنش', 'تاریخ', 'کاربر', 'یادداشت', 'پیوست‌ها']
        tree.setHeaderLabels(headers)
        tree.header().setFont(QFont(FONT_FAMILY, 10, QFont.Bold))
        tree.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        tree.header().setSectionResizeMode(5, QtWidgets.QHeaderView.ResizeToContents) # ستون پیوست
                
    # -----------------------------------------------------------------
    #  رویداد فیلتر براى resize TableViewport
    # -----------------------------------------------------------------
    def eventFilter(self, obj, ev):
        if ev.type() == QtCore.QEvent.Resize and isinstance(obj.parent(), QtWidgets.QTableWidget):
            self._sync_filter_row(obj.parent())
        return super().eventFilter(obj, ev)

    # ------------------------------------------------------------------
    #   نمایش ریزِ موجودی یک کالا در تمام لوکیشن‌ها
    #   (روی سطر جدول «کالاها» دوبار کلیک شود)
    # ------------------------------------------------------------------
    def _show_stock_locations(self, itm: QtWidgets.QTableWidgetItem):
        """
        روی هر ردیفِ جدول کالاها دابل-کلیک کنید تا پنجره‌ای باز شود
        که مقدار موجودی همان کالا را در تمام موقعیت‌های انبار نشان می‌دهد.
        """
        try:
            row = itm.row()
            iid = int(self.tbl_items.item(row, 0).text())   # ستون 0 = ID
        except (AttributeError, ValueError):
            return                                         # دادهٔ غیر معتبر

        StockLocationsDialog(self.db, iid, self).exec_()
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _apply_bom_advanced_filter(self, filters):
        """فیلترهای سفارشی را روی درخت تاریخچه مصرف اعمال می‌کند."""
        tree = self.tbl_bom
        product_filter = filters.get("product")
        material_filter = filters.get("material")
        batch_filter = filters.get("batch")

        root = tree.invisibleRootItem()
        for i in range(root.childCount()):
            parent_item = root.child(i)
            
            # بررسی مطابقت در آیتم والد (محصول)
            parent_text = parent_item.text(0).lower()
            parent_matches = not product_filter or product_filter in parent_text

            # بررسی مطابقت در آیتم‌های فرزند (مواد اولیه)
            any_child_matches = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j)
                material_name = child_item.text(0).lower()
                batch_name = child_item.text(1).lower()

                material_matches = not material_filter or material_filter in material_name
                batch_matches = not batch_filter or batch_filter in batch_name
                
                child_matches_this_row = material_matches and batch_matches
                child_item.setHidden(not child_matches_this_row)
                if not child_item.isHidden():
                    any_child_matches = True
            
            # تصمیم‌گیری نهایی برای نمایش والد
            parent_item.setHidden(not (parent_matches and any_child_matches))


    # <<< FIX
    def _asset_attach_click(self):
        btn  = self.sender()
        path = btn.property('path') or ''
        tid  = btn.property('row_id')

        # اگر فایل موجود است → باز کن
        if path and Path(path).exists():
            QtGui.QDesktopServices.openUrl(QtCore.QUrl.fromLocalFile(path))
            return

        # در غیر این صورت انتخاب/ذخیره فایل جدید
        new_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'انتخاب فایل')
        if not new_path:
            return

        # قبلاً اینجا اشتباه به‌صورت مستقیم روی Connection، execute صدا زده می‌شد.
        # الان استاندارد و ایمن:
        with self.db.transaction() as cur:
            cur.execute("UPDATE asset_trans SET attach=%s WHERE id=%s", (new_path, tid))

        btn.setText('📎')
        btn.setProperty('path', new_path)


            
    def _goto_cat(self, cat):
        self.pages.setCurrentWidget(self.pg_items)
        self.search_items.setText(cat)
        
    # Override resizeEvent برای Toast
    def resizeEvent(self, e):
        super().resizeEvent(e)
        if self.toast.isVisible():
            g = self.geometry()
            self.toast.move(g.right()-self.toast.width()-20,
                            g.bottom()-self.toast.height()-40)
    # ═════════════════════════════════════════════
    #                رخدادهای جدول‌ها
    # ═════════════════════════════════════════════

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _delete_items(self, item_ids: list):
        """منطق کامل و صحیح حذف یک یا چند کالا."""
        reply = QtWidgets.QMessageBox.question(self, 'تایید حذف', 
            f"آیا از حذف {len(item_ids)} کالا و تمام رکوردهای وابسته به آن‌ها مطمئن هستید؟\nاین عمل غیرقابل بازگشت است!",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                # --- اصلاح کلیدی: ارسال self.user_id به عنوان آرگومان دوم ---
                self.db.delete_items_by_ids(item_ids, self.user_id)
                self.refresh_all()
                self.toast.show_message(f'🗑 {len(item_ids)} کالا با موفقیت حذف شد', 'success')
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در حذف", f"عملیات حذف با خطا مواجه شد:\n{e}")                

    def _show_items_table_context_menu(self, pos: QtCore.QPoint):
        """
        نسخه نهایی و اصلاح‌شده:
        - منو دقیقاً زیر اشاره‌گر باز می‌شود (viewport).
        - انتخاب ردیف موقت در صورت راست‌کلیک روی ردیف غیرمنتخب.
        - دسترسی‌ها granular شده‌اند.
        """
        if not hasattr(self, 'items_category_tabs'):
            return

        # درخت فعال در تب جاری
        active_tab_widget = self.items_category_tabs.currentWidget()
        if not active_tab_widget:
            return
        tree = active_tab_widget.findChild(QtWidgets.QTreeWidget)
        if not tree:
            return

        # آیتم‌های انتخاب‌شده یا آیتم زیرِ مکان‌نما
        selected_items = tree.selectedItems()
        if not selected_items:
            item = tree.itemAt(pos)  # pos در مختصات viewport است
            if not item:
                return
            selected_items = [item]

        item_data = selected_items[0].data(0, Qt.UserRole)
        if not isinstance(item_data, dict) or not item_data.get('id'):
            return

        is_transactional_item = not item_data.get('is_parent_product', False)
        item_id = item_data['id']

        menu = QtWidgets.QMenu(self)

        # اکشن‌های سریع (ورود/خروج) فقط در صورتی که کاربر حداقل یکی از دسترسی‌های ورود/خروج را داشته باشد
        can_quick_entry = self.has_permission('transactions:create_entry')
        can_quick_exit  = self.has_permission('transactions:create_exit')
        if is_transactional_item and (can_quick_entry or can_quick_exit):
            if can_quick_entry:
                quick_entry_action = menu.addAction(QtGui.QIcon.fromTheme("list-add"), "ثبت ورود سریع برای این کالا")
                quick_entry_action.triggered.connect(lambda: self._new_trans("ورود", item_id=item_id))
            if can_quick_exit:
                quick_exit_action = menu.addAction(QtGui.QIcon.fromTheme("list-remove"), "ثبت خروج سریع برای این کالا")
                quick_exit_action.triggered.connect(lambda: self._new_trans("خروج", item_id=item_id))
            menu.addSeparator()

        # محاسبه لیست IDها برای گزارش/لیبل و ...
        ids_for_export = []
        is_single_parent_selected = False
        report_name = "Report"

        if len(selected_items) == 1:
            report_name = item_data.get('name', 'Report')
            if item_data.get('is_parent_product'):
                is_single_parent_selected = True
                parent_id = item_data.get('id')
                child_items = self.db.get_child_items(parent_id)
                ids_for_export.extend([child['id'] for child in child_items])

        if not is_single_parent_selected:
            selected_ids_data = [it.data(0, Qt.UserRole) for it in selected_items]
            ids_for_export.extend([
                d.get('id') for d in selected_ids_data
                if isinstance(d, dict) and d.get('id') is not None
            ])
            if len(selected_items) > 1:
                report_name = "Multiple_Items"

        if not ids_for_export and not is_transactional_item:
            return

        def handler_for_export():
            safe_filename = report_name.replace('/', '-').replace('\\', '-')
            default_filename = f"Stock_Card_{safe_filename}.xlsx"
            path, _ = QtWidgets.QFileDialog.getSaveFileName(
                self, 'ذخیره کارتکس انبار', default_filename, 'Excel (*.xlsx)'
            )
            if path:
                export_transactions_of_items(self.db, ids_for_export, path, self)

        actions_data = [
            {'icon': 'icons/edit.png',   'color': '#3498db', 'title': "ویرایش کالا",        'subtitle': "تغییر مشخصات اصلی کالا", 'handler': lambda: self._edit_item_from_table(item_id), 'single_only': True,  'permission': 'items:edit'},
            {'icon': 'icons/info.png',   'color': '#9b59b6', 'title': "نمایش لوکیشن‌ها",     'subtitle': "نمایش تمام مکان‌های نگهداری کالا",         'handler': lambda: StockLocationsDialog(self.db, item_id, self).exec_(), 'single_only': True,  'permission': 'page:view:items'},
            {'icon': 'icons/excel.png',  'color': '#1abc9c', 'title': "دریافت کارتکس انبار",'subtitle': f"خروجی اکسل برای {len(ids_for_export)} کالای انتخابی", 'handler': handler_for_export, 'single_only': False, 'permission': 'page:view:transactions'},
            {'icon': 'icons/barcode.png','color': '#2c3e50', 'title': "چاپ لیبل بارکد",      'subtitle': f"تولید لیبل برای {len(ids_for_export)} کالای انتخابی", 'handler': lambda: self._generate_multiple_barcodes(ids_for_export), 'single_only': False, 'permission': 'page:view:items'},
            {'icon': 'icons/delete.png', 'color': '#e74c3c', 'title': "حذف کالا(ها)",        'subtitle': f"حذف کامل {len(ids_for_export)} کالای انتخابی",         'handler': lambda: self._delete_items(ids_for_export), 'single_only': False, 'permission': 'items:delete'},
            # 🔧 اصلاح کلیدی: این اکشن باید روی دسترسی بازرگانی باشد
            {'icon': 'icons/cart.png',   'color': '#e67e22', 'title': "ایجاد درخواست خرید",  'subtitle': "ثبت درخواست تامین این کالا برای بازرگانی",  'handler': lambda: self._open_replenishment_center(preselected_item_id=item_id), 'single_only': True, 'permission': 'purchasing:create_request'},
        ]

        added_actions = 0
        for data in actions_data:
            if self.has_permission(data['permission']):
                if data['single_only'] and len(selected_items) > 1:
                    continue
                action_widget = MenuActionWidget(data['icon'], data['title'], data['subtitle'], data['color'])
                action_widget.triggered.connect(data['handler'])
                action_widget.triggered.connect(menu.close)
                q_action = QtWidgets.QWidgetAction(menu)
                q_action.setDefaultWidget(action_widget)
                menu.addAction(q_action)
                added_actions += 1
                if data['title'] in ["دریافت کارتکس انبار", "چاپ لیبل بارکد"]:
                    menu.addSeparator()

        # باز کردن منو دقیقاً زیر نشانگر
        if added_actions > 0 or (is_transactional_item and (can_quick_entry or can_quick_exit)):
            global_pos = tree.viewport().mapToGlobal(pos)
            menu.exec_(global_pos)
                                                
            
                                                                        
                                                
    def _transfer_generic(self):
        """دیالوگ انتقال عمومی بین تمام انبارها را باز می‌کند"""
        # <<<<<<< اصلاح کلیدی: ارسال self.user_id >>>>>>>
        dlg = TransferDialog(self.db, self.user_id)
        if dlg.exec_():
            self.refresh_all()
            self.toast.show_message("✔ انتقال با موفقیت ثبت شد.")
            
    # در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def closeEvent(self, e: QtGui.QCloseEvent):
        """قبل از بستن برنامه، به صورت امن منتظر اتمام کار نخ‌های پس‌زمینه می‌ماند."""
        reply = QtWidgets.QMessageBox.question(
            self, 'خروج', 'آیا مطمئن هستید؟',
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        if reply == QtWidgets.QMessageBox.Yes:
            print("INFO: Close event accepted. Safely shutting down background threads...")

            # --- بلوک ایمن برای مدیریت نخ رفرش ---
            try:
                if hasattr(self, 'refresh_thread') and self.refresh_thread and self.refresh_thread.isRunning():
                    print("INFO: Waiting for refresh thread to finish...")
                    self.refresh_thread.quit()
                    self.refresh_thread.wait(2000) # حداکثر ۲ ثانیه منتظر بمان
            except RuntimeError:
                # این خطا زمانی رخ می‌دهد که نخ از قبل حذف شده باشد که مشکلی نیست
                print("INFO: Refresh thread was already deleted. Continuing shutdown.")

            # --- بلوک ایمن برای مدیریت نخ پشتیبان‌گیری ---
            try:
                if hasattr(self, 'backup_thread') and self.backup_thread and self.backup_thread.isRunning():
                    print("INFO: Waiting for backup thread to finish...")
                    self.backup_thread.quit()
                    self.backup_thread.wait(5000) # حداکثر ۵ ثانیه منتظر بمان
            except RuntimeError:
                print("INFO: Backup thread was already deleted. Continuing shutdown.")

            print("INFO: All threads shut down. Closing application.")
            e.accept()
        else:
            e.ignore()
                
# در کلاس MainWindow، این دو متد را پیدا کرده و با کدهای زیر جایگزین کنید

    def _filter_bom_tree(self, column, text):
        """نمای درختی تاریخچه مصرف را بر اساس ستون و متن مشخص شده فیلتر می‌کند."""
        root = self.tbl_bom.invisibleRootItem()
        
        for i in range(root.childCount()):
            parent_item = root.child(i)
            
            # منطق فیلتر بر اساس ستون انتخابی
            parent_matches = False
            if column == 'کد/نام محصول نهایی':
                parent_matches = text in parent_item.text(0).lower()
            elif column == 'کاربر':
                parent_matches = text in parent_item.text(4).lower()

            child_matches_found = False
            for j in range(parent_item.childCount()):
                child_item = parent_item.child(j)
                
                child_matches = False
                if column == 'نام ماده اولیه':
                    child_matches = text in child_item.text(0).lower()
                elif column == 'بچ ماده اولیه':
                    child_matches = text in child_item.text(1).lower()
                
                if child_matches:
                    child_item.setHidden(False)
                    child_matches_found = True
                else:
                    # اگر فیلتر روی ستون‌های والد اعمال شده، فرزندان را نمایش بده
                    child_item.setHidden(parent_matches)

            if parent_matches or child_matches_found:
                parent_item.setHidden(False)
                # اگر والد به تنهایی مچ شده، تمام فرزندانش را نمایش بده
                if parent_matches and not child_matches_found:
                    for j in range(parent_item.childCount()):
                        parent_item.child(j).setHidden(False)
            else:
                parent_item.setHidden(True)
                

# در کلاس MainWindow، این متد را با نسخه زیر جایگزین کنید
    def _request_material(self):
        """
        دیالوگ درخواست مواد اولیه را باز کرده و نتیجه را در دیتابیس ثبت می‌کند.
        این نسخه به تابع صحیح submit_material_request متصل است.
        """
        dlg = RequestMaterialDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_request_data()
            if data:
                try:
                    # فراخوانی تابع صحیح برای ثبت درخواست مواد تولید
                    self.db.submit_material_request(
                        item_id=data['item_id'],
                        requested_qty=data['quantity'],
                        requester_id=self.user_id 
                    )
                    # پیام موفقیت توسط خود تابع دیتابیس نمایش داده خواهد شد
                except ValueError as e:
                    QtWidgets.QMessageBox.warning(self, "خطای عملیات", str(e))
                except Exception as e:
                    self.toast.show_message(f"خطا در ثبت درخواست: {e}", "critical")                    
                                                                    
    def _open_deliver_to_lab_dialog(self):
        """دیالوگ ثبت خروج به آزمایشگاه را باز کرده و عملیات را انجام می‌دهد."""
        if not self.has_permission('production:report'): # فرض می‌کنیم دسترسی اینکار با گزارش تولید یکی است
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return
            
        dlg = DeliverToLabDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    self.db.add_lab_delivery_trans(
                        item_id=data['item_id'],
                        qty=data['qty'],
                        batch_no=data['batch_no'],
                        expiry_date=data['expiry_date'],
                        notes=data['notes'],
                        user_id=self.user_id
                    )
                    self.toast.show_message("✔ خروج به آزمایشگاه با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ثبت خروج به آزمایشگاه با خطا مواجه شد:\n{e}")
                    print(traceback.format_exc())
                            

        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _build_production_page(self):
        """
        نسخه نهایی و کامل:
        - شامل داشبورد KPI و کارتابل سفارشات تولید.
        - دارای دکمه برای بسته‌بندی دستی (Ad-hoc) و همچنین میزکار هوشمند مبتنی بر سفارش.
        """
        layout = self.create_page_layout(self.pg_prod, "داشبورد و عملیات تولید")
        self.prod_stack = QtWidgets.QStackedWidget(); layout.addWidget(self.prod_stack)
        
        # === پنل اصلی: داشبورد ===
        dashboard_panel_frame = QtWidgets.QWidget()
        dashboard_layout = QtWidgets.QVBoxLayout(dashboard_panel_frame)
        dashboard_layout.setContentsMargins(0, 10, 0, 0); dashboard_layout.setSpacing(15)
        top_layout = QtWidgets.QHBoxLayout(); top_layout.setSpacing(20)
        self.prod_card_new_orders = self._create_kpi_card("سفارشات تولید جدید", "0", "#3498db", "view-process-tasks")
        self.prod_card_bulk = self._create_kpi_card("محصولات فله فعال", "0", "#1abc9c", "view-list-tree")
        self.prod_card_ready = self._create_kpi_card("محصولات آماده تحویل", "0", "#9b59b6", "go-up")
        top_layout.addWidget(self.prod_card_new_orders); top_layout.addWidget(self.prod_card_bulk); top_layout.addWidget(self.prod_card_ready); top_layout.addStretch()
        btn_go_to_ops = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("system-run"), " ورود به بخش عملیات و گزارش‌ها")
        btn_go_to_ops.setMinimumHeight(55); btn_go_to_ops.setMinimumWidth(280); btn_go_to_ops.setProperty("class", "primary")
        btn_go_to_ops.setStyleSheet("font-size: 12pt; font-weight: bold;"); btn_go_to_ops.clicked.connect(self._go_to_prod_operations)
        top_layout.addWidget(btn_go_to_ops); dashboard_layout.addLayout(top_layout)
        workbench_group = QtWidgets.QGroupBox("کارتابل سفارشات تولید (برای برنامه‌ریزی، روی ردیف دابل کلیک کنید)"); workbench_layout = QtWidgets.QVBoxLayout(workbench_group)
        self.tbl_prod_orders = QtWidgets.QTableWidget(); self._style_table(self.tbl_prod_orders); self.tbl_prod_orders.itemDoubleClicked.connect(self._start_production_from_order)
        workbench_layout.addWidget(self.tbl_prod_orders); dashboard_layout.addWidget(workbench_group, 1);
        self.prod_stack.addWidget(dashboard_panel_frame)
        
        # === پنل دوم: عملیات و گزارش‌ها ===
        operations_panel_frame = QtWidgets.QWidget(); operations_layout = QtWidgets.QVBoxLayout(operations_panel_frame); operations_layout.setContentsMargins(0, 10, 0, 0);
        action_bar = QtWidgets.QHBoxLayout(); action_bar.setContentsMargins(0, 0, 0, 10); action_bar.setSpacing(10);
        btn_back_to_dash = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-previous"), " بازگشت به داشبورد"); btn_back_to_dash.setMinimumHeight(35); btn_back_to_dash.clicked.connect(self._go_to_prod_dashboard); action_bar.addWidget(btn_back_to_dash); action_bar.addSpacing(20);
        
        if self.has_permission('production:report'):
            btn_report_prod = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("document-new"), " ثبت گزارش تولید"); btn_report_prod.setProperty("class", "primary"); btn_report_prod.setMinimumHeight(35); btn_report_prod.clicked.connect(self._open_report_production_dialog); action_bar.addWidget(btn_report_prod)
        
        # --- *** دکمه بسته‌بندی دستی به اینجا بازگردانده شد *** ---
        if self.has_permission('production:packing'):
            btn_packing = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("utilities-x-archive"), " بسته‌بندی محصول"); btn_packing.setMinimumHeight(35)
            btn_packing.clicked.connect(self._open_packing_dialog)
            action_bar.addWidget(btn_packing)

        if self.has_permission('production:request_materials'):
            btn_req_mat = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("go-down"), " درخواست مواد/لوازم"); btn_req_mat.setMinimumHeight(35); btn_req_mat.clicked.connect(self._request_material); action_bar.addWidget(btn_req_mat)
        
        btn_other_ops = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("view-more"), " سایر عملیات"); btn_other_ops.setMinimumHeight(35); other_menu = QtWidgets.QMenu(self)
        other_menu.addAction("تحویل محصول بسته‌بندی شده به انبار").triggered.connect(self._open_deliver_packaged_good_dialog)
        other_menu.addSeparator()
        if self.has_permission('production:approve_transfer'): 
            other_menu.addAction("تایید دریافت مواد اولیه").triggered.connect(self._open_approve_material_dialog)
            action_approve_void = other_menu.addAction("تایید/رد ابطال‌های انبار"); action_approve_void.triggered.connect(self._open_approve_void_dialog)
        other_menu.addAction("برگشت مواد اولیه به انبار").triggered.connect(self._open_return_material_dialog)
        if self.has_permission('production:report'):
            other_menu.addSeparator(); other_menu.addAction(QtGui.QIcon.fromTheme("lab-flask"), "خروج به آزمایشگاه").triggered.connect(self._open_deliver_to_lab_dialog); other_menu.addAction(QtGui.QIcon.fromTheme("system-search"), "ابزار ردیابی محصول").triggered.connect(lambda: TraceabilityDialog(self.db, self).exec_())
        if self.has_permission('production:void_production'):
            other_menu.addSeparator(); other_menu.addAction(QtGui.QIcon.fromTheme("edit-delete"), "ابطال بچ تولید").triggered.connect(self._open_void_batch_dialog); other_menu.addAction("ابطال عملیات بسته‌بندی").triggered.connect(self._open_void_packing_dialog)
        if self.has_permission('production:manage_recipes'):
            other_menu.addSeparator(); other_menu.addAction("مدیریت فرمول‌ها").triggered.connect(self._open_recipe_manager)
        btn_other_ops.setMenu(other_menu); action_bar.addWidget(btn_other_ops); action_bar.addStretch(); operations_layout.addLayout(action_bar)
        
        main_tabs = QtWidgets.QTabWidget(); main_tabs.setObjectName("mainProdTabs"); operations_layout.addWidget(main_tabs, 1); main_tabs.setStyleSheet("QTabBar::tab { min-width: 200px; padding: 10px; }")
        inventory_panel_frame = QtWidgets.QWidget(); inventory_layout = QtWidgets.QVBoxLayout(inventory_panel_frame); inventory_layout.setContentsMargins(0, 10, 0, 0); inventory_tabs = QtWidgets.QTabWidget(); inventory_tabs.setObjectName("interfaceTabWidget"); inventory_layout.addWidget(inventory_tabs); inventory_tabs.tabBar().setExpanding(True); self.tbl_prod_raw = QtWidgets.QTableWidget(); self._style_table(self.tbl_prod_raw); inventory_tabs.addTab(self.tbl_prod_raw, "مواد اولیه"); self.tbl_prod_bulk = QtWidgets.QTableWidget(); self._style_table(self.tbl_prod_bulk); inventory_tabs.addTab(self.tbl_prod_bulk, "محصولات فله"); self.tbl_prod_supplies = QtWidgets.QTableWidget(); self._style_table(self.tbl_prod_supplies); inventory_tabs.addTab(self.tbl_prod_supplies, "لوازم بسته‌بندی"); self.tbl_prod_packaged = QtWidgets.QTableWidget(); self._style_table(self.tbl_prod_packaged); inventory_tabs.addTab(self.tbl_prod_packaged, "محصولات بسته‌بندی شده")
        history_panel_frame = QtWidgets.QWidget(); history_layout = QtWidgets.QVBoxLayout(history_panel_frame); history_layout.setContentsMargins(0, 10, 0, 0); history_tabs = QtWidgets.QTabWidget(); history_tabs.setObjectName("interfaceTabWidget"); history_layout.addWidget(history_tabs); history_tabs.tabBar().setExpanding(True)
        bom_page = QtWidgets.QWidget(); bom_layout = QtWidgets.QVBoxLayout(bom_page); bom_toolbar = QtWidgets.QHBoxLayout(); bom_search_edit = QtWidgets.QLineEdit(placeholderText="جستجوی سریع در محصول، ماده اولیه یا بچ..."); bom_search_edit.textChanged.connect(self._filter_bom_tree_quick); bom_toolbar.addWidget(bom_search_edit); bom_layout.addLayout(bom_toolbar); self.tbl_bom = QtWidgets.QTreeWidget(); self.tbl_bom.setObjectName("bom_tree"); self.tbl_bom.setItemDelegate(CustomTreeDelegate(self.tbl_bom)); self.tbl_bom.setAlternatingRowColors(True); self.tbl_bom.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers); headers_bom = ['شرح (محصول / ماده اولیه)', 'بچ', 'مقدار مصرف', 'تاریخ', 'کاربر', 'پیوست', 'وضعیت']; self.tbl_bom.setHeaderLabels(headers_bom); self.tbl_bom.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch); self.tbl_bom.setColumnWidth(5, 40); self.tbl_bom.setContextMenuPolicy(Qt.CustomContextMenu); self.tbl_bom.customContextMenuRequested.connect(self._show_bom_context_menu); self.tbl_bom.itemClicked.connect(self._on_bom_tree_item_clicked); bom_layout.addWidget(self.tbl_bom); history_tabs.addTab(bom_page, "تاریخچه مصرف (BOM)")
        delivery_status_page = QtWidgets.QWidget(); delivery_layout = QtWidgets.QVBoxLayout(delivery_status_page); self.tbl_delivery_history = QtWidgets.QTableWidget(); self._style_table(self.tbl_delivery_history); add_filter_export_tools(self.tbl_delivery_history, delivery_layout); delivery_layout.addWidget(self.tbl_delivery_history); history_tabs.addTab(delivery_status_page, "تاریخچه تحویل‌ها")
        lab_page = QtWidgets.QWidget(); lab_layout = QtWidgets.QVBoxLayout(lab_page); self.tbl_lab_deliveries = QtWidgets.QTableWidget(); self._style_table(self.tbl_lab_deliveries); add_filter_export_tools(self.tbl_lab_deliveries, lab_layout); lab_layout.addWidget(self.tbl_lab_deliveries); history_tabs.addTab(lab_page, "ارسال به آزمایشگاه")
        my_requests_page = QtWidgets.QWidget(); my_requests_layout = QtWidgets.QVBoxLayout(my_requests_page); self.tbl_my_requests = QtWidgets.QTableWidget(); self._style_table(self.tbl_my_requests); add_filter_export_tools(self.tbl_my_requests, my_requests_layout); my_requests_layout.addWidget(self.tbl_my_requests); history_tabs.addTab(my_requests_page, "تاریخچه درخواست‌های من")
        main_tabs.addTab(inventory_panel_frame, "موجودی کف کارگاه")
        main_tabs.addTab(history_panel_frame, "گزارش‌ها و تاریخچه")
        self.prod_stack.addWidget(operations_panel_frame)
        
# این متد را به کلاس MainWindow اضافه کنید
    def _open_packing_dialog(self):
        """پنجره بسته‌بندی دستی و هوشمند را باز می‌کند."""
        if not self.has_permission('production:packing'):
            self.toast.show_message("شما دسترسی لازم برای این عملیات را ندارید.", "error")
            return
            
        dlg = PackingDialog(self.db, self)
        if dlg.exec_():
            self.refresh_all()
                            
                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _show_stock_card_from_prod_inventory(self, item: QtWidgets.QTableWidgetItem):
        """
        با دابل-کلیک، دیالوگ اختصاصی جزئیات موجودی تولید را باز می‌کند.
        """
        if not item: return
        
        table = item.tableWidget()
        row = item.row()
        item_name = table.item(row, 0).text() # نام کالا از سلول اول خوانده می‌شود
        
        try:
            item_with_data = table.item(row, 0)
            item_data = item_with_data.data(Qt.UserRole)
            
            if not isinstance(item_data, dict): return

            # ID کالا را بسته به نوع جدول (محصول فله یا عادی) استخراج می‌کنیم
            item_id = item_data.get('item_id') or self.db.get_item_by_name(item_data['product_name'])['id']

            if item_id:
                # فراخوانی دیالوگ جدید و اختصاصی
                ProductionStockDetailDialog(self.db, item_id, item_name, self).exec_()

        except (AttributeError, ValueError, TypeError, KeyError) as e:
            print(f"Could not retrieve item ID for production stock detail view: {e}")
                                    
# این متد باید در کلاس MainWindow وجود داشته باشد
    def _refresh_production_page_data(self):
        """داده‌های داشبورد و عملیات صفحه تولید را به صورت غیرهمزمان و تکه‌تکه رفرش می‌کند."""
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            # فراخوانی‌ها به صورت تکه‌تکه با تایمر برای جلوگیری از فریز شدن UI
            QtCore.QTimer.singleShot(0, self._refresh_production_dashboard_tab)
            QtCore.QTimer.singleShot(50, self._load_production_inventory)
            QtCore.QTimer.singleShot(100, self._load_bom)
            QtCore.QTimer.singleShot(150, self._load_delivery_history)
            QtCore.QTimer.singleShot(200, self._load_my_request_history)
            QtCore.QTimer.singleShot(250, self._load_lab_delivery_history)
        finally:
            # یک تایمر کوچک برای بازگرداندن نشانگر موس پس از اتمام آخرین عملیات
            QtCore.QTimer.singleShot(300, lambda: QtWidgets.QApplication.restoreOverrideCursor())
                    
                                                                        
# این سه متد جدید را به کلاس MainWindow اضافه کنید

    # در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _refresh_production_dashboard_tab(self):
        """داده‌های داشبورد عملیاتی تولید شامل کارت‌ها و کارتابل جدید را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_prod_orders'): 
            return

        try:
            # --- ۱. به‌روزرسانی کارت‌های KPI ---
            pending_orders = self.db.get_pending_production_orders()
            bulk_products = self.db.get_available_bulk_products()
            prod_loc_id = self.db.get_production_floor_location()
            ready_items = self.db.get_finished_goods_at_location(prod_loc_id, packed_only=True) if prod_loc_id else []
            
            # آپدیت کردن متن ویجت‌های KPI با نام‌های جدید
            self.prod_card_new_orders.value_label.setText(f"{len(pending_orders)} سفارش")
            self.prod_card_bulk.value_label.setText(f"{len(bulk_products)} بچ")
            self.prod_card_ready.value_label.setText(f"{len(ready_items)} بچ")

            # --- ۲. بارگذاری کارتابل اصلی سفارشات تولید ---
            # این تابع از پیشنهاد قبلی وجود دارد و جدول اصلی داشبورد را پر می‌کند
            self._load_pending_production_orders()

        except Exception as e:
            print(f"Error refreshing production dashboard: {e}")
            if self.toast:
                self.toast.show_message(f"خطا در به‌روزرسانی داشبورد تولید: {e}", "critical")
                                                         
            
    def _create_production_chart(self):
        """نمودار آمار تولید ۷ روز گذشته را ایجاد یا به‌روزرسانی می‌کند."""
        # پاک کردن نمودار قبلی
        while self.chart_layout.count():
            child = self.chart_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        prod_data = self.db.get_production_summary_last_n_days(7)
        if not prod_data:
            self.chart_layout.addWidget(QtWidgets.QLabel("آماری برای نمایش در نمودار تولید یافت نشد."))
            return
            
        df = pd.DataFrame(prod_data)
        df['production_date'] = pd.to_datetime(df['production_date'])
        
        # تبدیل تاریخ میلادی به شمسی برای نمایش
        df['shamsi_date'] = df['production_date'].apply(lambda d: to_shamsi(d))
        
        fig, ax = plt.subplots(figsize=(8, 3), dpi=100)
        bars = ax.bar(df['shamsi_date'], df['total_quantity'], color='#27ae60')
        ax.set_ylabel(fa("مقدار تولید (واحد اصلی)"))
        ax.set_title(fa("خلاصه تولید ۷ روز گذشته"), fontsize=12, weight='bold')
        ax.tick_params(axis='x', rotation=25, labelsize=9)
        ax.grid(axis='y', linestyle='--', alpha=0.7)
        
        # اضافه کردن لیبل مقدار بالای هر میله
        ax.bar_label(bars, fmt='{:,.0f}', padding=3)

        fig.tight_layout()
        canvas = Canvas(fig)
        self.chart_layout.addWidget(canvas)

    def _handle_dashboard_list_double_click(self, item: QtWidgets.QTableWidgetItem, action_key: str):
        if not item: return

        table = item.tableWidget()
        row = item.row()
        record_id = int(table.item(row, 0).text())

        if action_key == 'approve_transfer':
            self._open_approve_material_dialog(preselect_id=record_id)
            self.prod_page_loaded = False # <-- این خط را اضافه کن
        elif action_key == 'deliver_good':
            self._create_delivery_request_action(preselect_id=record_id)
            self.prod_page_loaded = False # <-- این خط را اضافه کن
                
                

    def _go_to_prod_dashboard(self):
        """کاربر را از صفحه عملیات به داشبورد اصلی تولید برمی‌گرداند."""
        if hasattr(self, 'prod_stack'):
            self.prod_stack.setCurrentIndex(0)
            
# در کلاس MainWindow، این متد را جایگزین کنید
    def _load_pending_production_orders(self):
        """جدول کارتابل سفارشات تولید را با داده‌های جدید و ستون وضعیت بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_prod_orders'): return
        table = self.tbl_prod_orders
        table.setRowCount(0)
        try:
            orders = self.db.get_pending_production_orders()
            # --- اصلاح: افزودن ستون وضعیت ---
            headers = ["ID", "محصول مورد نیاز", "مقدار", "برای سفارش فروش", "مشتری", "تاریخ ثبت", "وضعیت"]
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(orders))

            for r, order in enumerate(orders):
                table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(order['id'])))
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(order['item_name']))
                table.setItem(r, 2, NumericTableWidgetItem(str(order['quantity'])))
                table.setItem(r, 3, QtWidgets.QTableWidgetItem(order.get('so_number', '---')))
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(order.get('customer_name', 'داخلی')))
                table.setItem(r, 5, QtWidgets.QTableWidgetItem(to_shamsi(order['created_at'])))
                table.setItem(r, 6, QtWidgets.QTableWidgetItem(order.get('status', 'نامشخص'))) # نمایش وضعیت

            table.setColumnHidden(0, True)
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
            set_empty_placeholder(table, "هیچ سفارش تولید جدیدی در کارتابل وجود ندارد.")
        except Exception as e:
            print(f"Error loading pending production orders: {e}")
            
            
    def _start_production_from_order(self, item: QtWidgets.QTableWidgetItem):
        """با دابل-کلیک روی یک سفارش، 'میزکار برنامه‌ریزی تولید' را باز می‌کند."""
        if not item: return
        try:
            prod_order_id = int(self.tbl_prod_orders.item(item.row(), 0).text())
            
            # این دیالوگ در مراحل بعدی تکمیل خواهد شد. فعلا یک placeholder است.
            dlg = ProductionWorkbenchDialog(self.db, self.user_id, prod_order_id, self)
            dlg.exec_()
            
            # پس از بسته شدن میزکار، کل داده‌ها را رفرش می‌کنیم
            self.refresh_all()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند با خطا مواجه شد:\n{e}")
            print(traceback.format_exc())

    def _go_to_prod_operations(self):
        """کاربر را از داشبورد به صفحه عملیات (تب‌ها) می‌برد."""
        if hasattr(self, 'prod_stack'):
            self.prod_stack.setCurrentIndex(1)
            
    def _refresh_production_page_data(self):
        """داده‌های داشبورد و عملیات صفحه تولید را به صورت غیرهمزمان و تکه‌تکه رفرش می‌کند."""
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            QtCore.QTimer.singleShot(0, self._refresh_production_dashboard_tab)
            QtCore.QTimer.singleShot(50, self._load_production_inventory)
            QtCore.QTimer.singleShot(100, self._load_bom)
            QtCore.QTimer.singleShot(150, self._load_delivery_history)
            QtCore.QTimer.singleShot(200, self._load_my_request_history)
            QtCore.QTimer.singleShot(250, self._load_lab_delivery_history)
            # --- فراخوانی جدید برای بارگذاری کارتابل ---
            QtCore.QTimer.singleShot(300, self._load_pending_production_orders)
        finally:
            QtCore.QTimer.singleShot(350, lambda: QtWidgets.QApplication.restoreOverrideCursor())
                
    def _create_delivery_request_action(self, preselect_id=None):
        """دیالوگ انتخاب محصول از کف کارگاه برای ایجاد درخواست تحویل را باز می‌کند."""
        # در آینده می‌توان preselect_id را برای هایلایت کردن ردیف مربوطه استفاده کرد
        dlg = DeliverFinishedGoodDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    new_delivery_id = self.db.create_delivery_request(
                        product_item_id=data['item_id'],
                        batch_no=data['batch_no'],
                        quantity=data['qty'],
                        expiry_date=data.get('expiry_date'),
                        supervisor_user_id=self.user_id
                    )
                    if new_delivery_id:
                        self.db.submit_delivery_request(new_delivery_id)
                    self.toast.show_message("✔ درخواست تحویل محصول به انبار با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                    self.prod_page_loaded = False # <-- این خط را اضافه کن

                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست تحویل:\n{e}")
                                                        
                                    
# این متد جدید را به کلاس MainWindow اضافه کنید
    def _load_lab_delivery_history(self):
        """جدول تاریخچه ارسال کالا به آزمایشگاه را در صفحه تولید بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_lab_deliveries'): return
        
        table = self.tbl_lab_deliveries
        table.setSortingEnabled(False)
        table.setRowCount(0)
        
        try:
            # فقط تراکنش‌های مربوط به آزمایشگاه را می‌خوانیم
            rows = self.db.execute_query("SELECT t.*, i.name as item_name, u.username FROM trans t LEFT JOIN items i ON t.item_id = i.id LEFT JOIN users u ON t.user_id = u.id WHERE t.t_type = 'خروج به آزمایشگاه' ORDER BY t.id DESC")
            
            headers = ['کالا', 'شماره بچ', 'مقدار', 'تاریخ ارسال', 'کاربر', 'یادداشت']
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(rows))

            for r, row in enumerate(rows):
                values = [
                    row.get('item_name'),
                    row.get('batch_no'),
                    str(row.get('qty')),
                    to_shamsi(row.get('t_date')),
                    row.get('username'),
                    row.get('notes')
                ]
                for c, value in enumerate(values):
                    item = QtWidgets.QTableWidgetItem(value)
                    item.setToolTip(value)
                    table.setItem(r, c, item)
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch) # Stretch item name
            table.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.Stretch) # Stretch notes
        except Exception as e:
            print(f"Error loading lab delivery history: {e}")
        
        table.setSortingEnabled(True)
                        
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _open_return_material_dialog(self):
        """پنجره ثبت درخواست برگشت مواد را باز می‌کند."""
        dlg = ReturnMaterialDialog(self.db, self)
        if dlg.exec_():
            data = dlg.get_data()
            if data:
                try:
                    self.db.request_material_return(data['component'], data['qty'], data['reason'], self.user_id)
                    self.toast.show_message("✔ درخواست برگشت مواد با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست برگشت:\n{e}")
                    
    # این متد کاملاً جدید را به کلاس MainWindow اضافه کنید

    def _on_bom_tree_item_clicked(self, item, column):
        """
        وقتی روی یک آیتم در درخت BOM کلیک می‌شود، این متد فراخوانی می‌شود.
        """
        # ستون "پیوست" ایندکس 5 را دارد
        if column == 5 and item.parent() is None: # چک می‌کنیم که آیتم والد باشد
            bom_id = item.data(0, Qt.UserRole)
            if bom_id:
                self._open_bom_attach_dialog(bom_id)
                
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _filter_bom_tree_quick(self, text: str):
        """درخت تاریخچه مصرف (BOM) را بر اساس متن ورودی به صورت آنی فیلتر می‌کند."""
        if not hasattr(self, 'tbl_bom'): return

        tree = self.tbl_bom
        text = text.lower().strip()
        
        # پیمایش تمام آیتم‌های درخت
        iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            parent = item.parent()
            
            item_text = ""
            # برای آیتم‌های فرزند (مواد اولیه)، در نام و بچ جستجو کن
            if parent: 
                item_text = item.text(0).lower() + item.text(1).lower()
            # برای آیتم‌های والد (محصول)، در نام محصول جستجو کن
            else: 
                item_text = item.text(0).lower()
            
            item.setHidden(text not in item_text)
            iterator += 1

        # در یک پیمایش دوم، والدانی که فرزند قابل نمایش دارند را مجدداً نمایش بده
        iterator = QtWidgets.QTreeWidgetItemIterator(tree, QtWidgets.QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            parent = item.parent()
            if parent and not item.isHidden():
                parent.setHidden(False)
            iterator += 1
            

    def _show_bom_context_menu(self, pos):
        """با راست‌کلیک روی تاریخچه مصرف، منوی عملیات را نمایش می‌دهد."""
        item = self.tbl_bom.itemAt(pos)
        if not item:
            return

        # فقط برای آیتم‌های والد (محصولات) منو را نمایش می‌دهیم
        if item.parent() is None:
            bom_id = item.data(0, Qt.UserRole) # ID که قبلا ذخیره کردیم را می‌خوانیم
            if not bom_id:
                return

            menu = QtWidgets.QMenu(self)
            
            attach_action = menu.addAction(QtGui.QIcon.fromTheme("mail-attachment"), "مدیریت پیوست‌ها")
            
            # اجرای منو و دریافت اکشن انتخاب شده
            action = menu.exec_(self.tbl_bom.mapToGlobal(pos))
            
            if action == attach_action:
                self._open_bom_attach_dialog(bom_id)
        

# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _open_report_production_dialog(self, prefill_data=None):
        """دیالوگ گزارش تولید را باز کرده و در صورت تایید، عملیات را در دیتابیس ثبت می‌کند."""
        dlg = ReportProductionDialog(self.db, self, prefill_data=prefill_data)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        data = dlg.get_data()
        if not data: return

        expiry_date = dt.date.today() + dt.timedelta(days=730)

        try:
            # --- *** اصلاح کلیدی و نهایی اینجاست *** ---
            # ما دیگر از data['product_name'] که نام فرمول بود استفاده نمی‌کنیم.
            # در عوض، نام محصول واقعی را از recipe_data که در دیالوگ ذخیره شده می‌خوانیم.
            recipe_data = dlg.recipe_combo.currentData()
            actual_product_name = recipe_data.get('produced_item_name')
            if not actual_product_name:
                raise ValueError("نام محصول خروجی در اطلاعات فرمول یافت نشد!")
            # --- ****************************************** ---

            self.db.report_production(
                recipe_id=data['recipe_id'],
                production_batch_no=data['batch_no'],
                quantity=data['quantity'],
                consumption_plan=data['consumption_plan'],
                product_name=actual_product_name, # <--- ارسال نام صحیح به دیتابیس
                expiry_date=expiry_date,
                user_id=self.user_id,
                linked_pack_order_id=prefill_data.get('linked_pack_order_id') if prefill_data else None
            )
            self.toast.show_message(f"✔ تولید بچ {data['batch_no']} گزارش شد و آماده تحویل به انبار است.", "success")
            self.refresh_all()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطای عملیات", f"فرآیند ثبت گزارش تولید با خطا مواجه شد:\n{e}")
            print(traceback.format_exc())
                                        
                                                        
    # در کلاس MainWindow
    def _open_deliver_to_warehouse_dialog(self):
        """
        نسخه نهایی:
        پس از ایجاد درخواست، وضعیت آن را برای تایید انباردار آماده می‌کند.
        """
        dlg = CreateDeliveryRequestDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_selected_data()
            if data:
                try:
                    # --- اصلاح کلیدی: فراخوانی تابع جدید برای تغییر وضعیت ---
                    delivery_id = self.db.request_delivery_from_production(
                        product_name=data['name'],
                        batch_no=data['batch_no'],
                        quantity=data['qty'],
                        supervisor_user_id=self.user_id,
                        expiry_date=data.get('expiry_date')
                    )
                    self.db.submit_delivery_request(delivery_id)
                    
                    self.toast.show_message("✔ درخواست تحویل محصول به انبار با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"خطا در ثبت درخواست تحویل:\n{e}")
                    print(traceback.format_exc())
                                                
                                        
        
    
    # در کلاس MainWindow، این تابع را به طور کامل جایگزین کنید
    def _load_my_request_history(self):
        """جدول تاریخچه تمام درخواست‌های کاربر (مواد و برگشتی) را بارگذاری می‌کند."""
        if not hasattr(self, 'tbl_my_requests'): return

        table = self.tbl_my_requests
        table.setRowCount(0)
        try:
            # فراخوانی تابع جدید و جامع
            requests = self.db.get_all_user_initiated_requests(self.user_id)
            
            # افزودن ستون جدید "نوع درخواست"
            headers = ['نوع درخواست', 'نام کالا', 'مقدار', 'وضعیت', 'تاریخ درخواست', 'تاریخ پردازش', 'یادداشت/دلیل']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(requests))

            STATUS_TRANSLATE = {'PENDING': 'در انتظار', 'FULFILLED': 'انجام شده', 'REJECTED': 'رد شده', 'تایید شده': 'تایید شده', 'در انتظار تایید انبار': 'در انتظار تایید'}
            
            for r, req in enumerate(requests):
                item_name = self.db.get_item_details(req['item_id'])['name'] if req.get('item_id') else 'نامشخص'
                status_text = STATUS_TRANSLATE.get(req['status'], req['status'])
                processed_date = to_shamsi(req['processed_at']) if req['processed_at'] else ""
                
                values = [
                    req.get('request_type', 'نامشخص'),
                    item_name,
                    str(req['qty']),
                    status_text,
                    to_shamsi(req['created_at']),
                    processed_date,
                    req.get('notes', '')
                ]
                for c, value in enumerate(values):
                    item = QtWidgets.QTableWidgetItem(value)
                    item.setToolTip(value)
                    table.setItem(r, c, item)
            
            table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(headers.index('نام کالا'), QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(headers.index('یادداشت/دلیل'), QtWidgets.QHeaderView.Stretch)
        except Exception as e:
            print(f"Error loading user's request history: {e}")
        
    def _open_manual_batch_selection_dialog(self, request_id, item_id, item_name, qty_needed):
            """
            یک دیالوگ برای انتخاب دستی بچ توسط کاربر باز می‌کند.
            این مسیر override برای زمانی است که پیشنهاد FEFO سیستم مناسب نیست.
            """
            self.toast.show_message("انتخاب دستی فعال شد. لطفاً بچ مورد نظر را انتخاب کنید.", "info")
            
            available_stock_records = self.db.stock_breakdown(item_id)
            if not available_stock_records:
                QtWidgets.QMessageBox.warning(self, "موجودی ناکافی", f"کالای «{item_name}» در انبار موجودی ندارد.")
                return

            # ساخت دیکشنری برای نمایش در دیالوگ
            batch_map = { 
                f"{rec['loc']} | بچ: {rec['batch_no']} | انقضا: {to_shamsi(rec.get('expiry_date'))} (موجودی: {rec['qty']})": rec 
                for rec in available_stock_records 
            }
            
            selected_batch_text, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب دستی بچ", f"کدام بچ از کالای «{item_name}» را می‌خواهید ارسال کنید؟", batch_map.keys(), 0, False)
            
            if not ok:
                self.toast.show_message("عملیات انتخاب دستی لغو شد.", "info")
                return
            
            selected_stock_info = batch_map[selected_batch_text]
            
            # بررسی اینکه بچ انتخابی موجودی کافی دارد یا خیر
            if selected_stock_info['qty'] < qty_needed:
                QtWidgets.QMessageBox.warning(self, "موجودی بچ ناکافی", f"موجودی بچ انتخابی ({selected_stock_info['qty']}) کمتر از مقدار درخواستی ({qty_needed}) است. لطفاً دوباره تلاش کنید.")
                return

            # دریافت شماره سند
            doc_no, ok = QtWidgets.QInputDialog.getText(self, "شماره سند", "شماره سند/حواله انبار را وارد کنید:")
            if not ok or not doc_no.strip():
                self.toast.show_message("عملیات به دلیل عدم ورود شماره سند لغو شد.", "info")
                return

            # ارسال درخواست به دیتابیس با بچ انتخاب شده دستی
            try:
                trans_data = {
                    'item_id': item_id,
                    'qty': qty_needed,
                    'src_loc_id': selected_stock_info['loc_id'],
                    'notes': f"خروج طبق حواله «{doc_no.strip()}» برای درخواست #{request_id} (انتخاب دستی کاربر)",
                    'batch_no': selected_stock_info['batch_no'],
                    'expiry_date': selected_stock_info.get('expiry_date'),
                    'doc_no': doc_no.strip()
                }
                self.db.fulfill_material_request(request_id, self.user_id, trans_data)
                
                self.toast.show_message(f"✔ مقدار {qty_needed} واحد از بچ انتخابی با موفقیت برای تولید ارسال شد.", "success")
                self.refresh_all()

            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ارسال کالا با خطا مواجه شد:\n{e}")
                print(traceback.format_exc())
            
                                                
                                    
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _fulfill_material_request(self):
        """
        نسخه نهایی و هوشمند (V4.1):
        - در صورت عدم وجود موجودی، به جای نمایش خطا، به کاربر پیشنهاد ایجاد درخواست خرید می‌دهد.
        """
        if not hasattr(self, 'tbl_material_requests'): return
        
        selected_rows = self.tbl_material_requests.selectionModel().selectedRows()
        if not selected_rows:
            self.toast.show_message("لطفاً یک درخواست را برای رسیدگی انتخاب کنید.", "warning")
            return

        try:
            row = selected_rows[0].row()
            request_id = int(self.tbl_material_requests.item(row, 0).text())
            item_id = int(self.tbl_material_requests.item(row, 1).text())
            item_name = self.tbl_material_requests.item(row, 2).text()
            qty_needed = float(self.tbl_material_requests.item(row, 3).text())
        except (AttributeError, ValueError):
            self.toast.show_message("اطلاعات درخواست انتخاب شده معتبر نیست.", "error")
            return

        # گام ۱: تلاش برای پیدا کردن پلن برداشت بر اساس موجودی
        pick_list = self.db.fefo_pick(item_id, qty_needed)
        
        # --- *** منطق جدید و هوشمند اینجاست *** ---
        if pick_list:
            # مسیر عادی: موجودی کافی است
            dialog = FefoPickDialog(pick_list, item_name, qty_needed, self)
            result = dialog.exec_()
            
            if not result:
                if dialog.manual_override:
                    self._open_manual_batch_selection_dialog(request_id, item_id, item_name, qty_needed)
                else:
                    self.toast.show_message("عملیات لغو شد.", "info")
                return

            doc_no, ok = QtWidgets.QInputDialog.getText(self, "شماره سند", f"لطفاً شماره سند/حواله انبار را برای خروج {qty_needed} واحد «{item_name}» وارد کنید:")
            if ok and doc_no.strip():
                try:
                    self.db.fulfill_request_with_fefo(request_id, item_id, qty_needed, doc_no.strip(), self.user_id)
                    self.toast.show_message(f"✔ درخواست با موفقیت انجام و برای تایید تولید ارسال شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ارسال کالا با خطا مواجه شد:\n{e}")
            else:
                self.toast.show_message("عملیات به دلیل عدم ورود شماره سند لغو شد.", "info")
        else:
            # مسیر جدید: موجودی کافی نیست
            reply = QtWidgets.QMessageBox.question(self, "کمبود موجودی",
                f"موجودی کالای «{item_name}» برای تامین این درخواست کافی نیست.\n\n"
                f"آیا می‌خواهید برای تامین این کالا یک درخواست خرید جدید ایجاد کنید؟",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            
            if reply == QtWidgets.QMessageBox.Yes:
                # فراخوانی پنجره مرکز تامین با کالای از پیش انتخاب شده
                self._open_replenishment_center(preselected_item_id=item_id)
        # --- ************************************** ---
        
                                
            
    def _open_approve_material_dialog(self, preselect_id=None):
        """دیالوگ تایید دریافت مواد اولیه را برای کاربر فعلی باز می‌کند."""
        # در آینده می‌توان preselect_id را برای هایلایت کردن ردیف مربوطه استفاده کرد
        ApproveMaterialTransferDialog(self.db, self.user_id, self).exec_()                                            
                                                                                                                                                                        
                                                        
    def _open_confidentiality_manager(self):
            """پنجره مرکز کنترل محرمانگی را باز می‌کند."""
            AdvancedConfidentialityDialog(self.db, self).exec_()

    def _generate_financial_bom_report(self):
        """گزارش مالی را بر اساس قوانین ذخیره شده در دیتابیس تولید می‌کند."""
        product_codes = self.db.get_distinct_product_codes()
        if not product_codes:
            self.toast.show_message("هیچ تاریخچه مصرفی برای گزارش‌گیری وجود ندارد.", "warning"); return
        pcode, ok = QtWidgets.QInputDialog.getItem(self, "انتخاب بچ محصول", "لطفاً بچ محصول را برای گزارش انتخاب کنید:", product_codes, 0, False)
        if ok and pcode:
            try:
                report_data = self.db.list_bom_financial(pcode)
                if not report_data:
                    self.toast.show_message(f"داده‌ای برای بچ '{pcode}' یافت نشد.", "warning"); return
                path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ذخیره گزارش مالی', f"Financial_BOM_{pcode}.xlsx", 'Excel (*.xlsx)')
                if not path: return
                import pandas as pd
                df = pd.DataFrame(report_data)
                df.to_excel(path, index=False)
                self.toast.show_message("✔ گزارش مالی با موفقیت ذخیره شد.", "success")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ایجاد گزارش مالی: {e}")
                                            
    def _load_delivery_history(self):
            if not hasattr(self, 'tbl_delivery_history'): return
            table = self.tbl_delivery_history
            table.setSortingEnabled(False); table.setRowCount(0)
            try:
                rows = self.db.get_deliveries_by_supervisor(self.user_id)
            except Exception as e:
                print(f"Error loading delivery history: {e}"); rows = []
            
            headers = ['محصول', 'شماره بچ', 'مقدار', 'تاریخ ثبت', 'وضعیت', 'توضیحات (دلیل رد)']
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers); table.setRowCount(len(rows))

            STATUS_VISUALS = {
                'تایید شده': {'color': QtGui.QColor("#d4edda"), 'text': 'تایید شده توسط انبار'},
                'رد شده': {'color': QtGui.QColor("#f8d7da"), 'text': 'رد شده توسط انبار'},
                'در انتظار تایید تولید': {'color': QtGui.QColor("#fff3cd"), 'text': 'در انتظار تایید انبار'},
                'produced': {'color': QtGui.QColor("#cfe2ff"), 'text': 'تولید شده (منتظر ارسال)'}
            }
            
            for r, row in enumerate(rows):
                status = row.get('status', 'نامشخص')
                visuals = STATUS_VISUALS.get(status, {'color': QtGui.QColor("white"), 'text': status})
                
                notes = row.get('rejection_reason', '') or ''
                
                values = [
                    row['product_name'], row['production_batch_no'], str(row['quantity']), 
                    to_shamsi(row['created_at']), visuals['text'], notes
                ]
                for c, value in enumerate(values):
                    item = QtWidgets.QTableWidgetItem(value)
                    item.setToolTip(value)
                    item.setBackground(visuals['color'])
                    table.setItem(r, c, item)

            table.resizeRowsToContents(); table.resizeColumnsToContents()
            table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
            table.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.Stretch)
            table.setSortingEnabled(True)
            
                
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_production_inventory(self):
        """
        نسخه نهایی: تمام موجودی‌ها را مستقیماً از انبار تولید (جدول stock) می‌خواند.
        """
        if not all(hasattr(self, name) for name in ['tbl_prod_raw', 'tbl_prod_bulk', 'tbl_prod_supplies', 'tbl_prod_packaged']):
            return

        def populate_stock_table(table, data, headers):
            # ... (این تابع داخلی بدون تغییر باقی می‌ماند)
            tooltip_text = "برای مشاهده جزئیات بچ در انبار تولید، دابل کلیک کنید"
            table.setSortingEnabled(False); table.setRowCount(0)
            table.setColumnCount(len(headers)); table.setHorizontalHeaderLabels(headers)
            table.setRowCount(len(data))
            for r, item_row_data in enumerate(data):
                name_item = QtWidgets.QTableWidgetItem(item_row_data.get('name'))
                name_item.setData(Qt.UserRole, dict(item_row_data))
                name_item.setToolTip(tooltip_text)
                table.setItem(r, 0, name_item)
                values = [item_row_data.get('batch_no'), str(item_row_data.get('total_qty', 0)), item_row_data.get('unit'), to_shamsi(item_row_data.get('expiry_date'))]
                for c_offset, value in enumerate(values):
                    cell_item = QtWidgets.QTableWidgetItem(value); cell_item.setToolTip(tooltip_text); table.setItem(r, 1 + c_offset, cell_item)
            set_empty_placeholder(table, "هیچ موردی یافت نشد."); table.resizeColumnsToContents(); table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch); table.setSortingEnabled(True)

        try:
            # --- *** اصلاح کلیدی و نهایی اینجاست: منبع داده به stock تغییر کرد *** ---
            stock_in_prod = self.db.get_stock_for_warehouse('Production')
            headers = ['نام کالا', 'شماره بچ', 'مقدار موجود', 'واحد', 'تاریخ انقضا']

            populate_stock_table(self.tbl_prod_raw, [i for i in stock_in_prod if i.get('category') == CATEGORY_RAW_MATERIAL], headers)
            populate_stock_table(self.tbl_prod_supplies, [i for i in stock_in_prod if i.get('category') == CATEGORY_PACKAGING], headers)
            # برای محصولات فله نیز از همین منبع استفاده می‌کنیم
            populate_stock_table(self.tbl_prod_bulk, [i for i in stock_in_prod if i.get('category') == CATEGORY_BULK_PRODUCT], headers)

            packaged_stock = [i for i in stock_in_prod if i.get('category') == CATEGORY_FINAL_PRODUCT]
            table = self.tbl_prod_packaged
            table.setSortingEnabled(False); table.setRowCount(0)
            pkg_headers = ['محصول مادر', 'مشخصات پک', 'شماره بچ', 'موجودی', 'تاریخ انقضا']
            table.setColumnCount(len(pkg_headers)); table.setHorizontalHeaderLabels(pkg_headers)
            table.setRowCount(len(packaged_stock))
            tooltip_text = "برای مشاهده جزئیات بچ در انبار تولید، دابل کلیک کنید"
            for r, item in enumerate(packaged_stock):
                item_data = dict(item); parent_name = "نامشخص"
                if item_data.get('parent_item_id'):
                    parent_info = self.db.get_item_details(item_data['parent_item_id']); parent_name = parent_info.get('name', 'نامشخص') if parent_info else 'نامشخص'
                parent_name_item = QtWidgets.QTableWidgetItem(parent_name); parent_name_item.setData(Qt.UserRole, item_data); parent_name_item.setToolTip(tooltip_text); table.setItem(r, 0, parent_name_item)
                table.setItem(r, 1, QtWidgets.QTableWidgetItem(item_data['name'])); table.item(r, 1).setToolTip(tooltip_text)
                table.setItem(r, 2, QtWidgets.QTableWidgetItem(item_data['batch_no'])); table.item(r, 2).setToolTip(tooltip_text)
                table.setItem(r, 3, NumericTableWidgetItem(str(item_data['total_qty']))); table.item(r, 3).setToolTip(tooltip_text)
                table.setItem(r, 4, QtWidgets.QTableWidgetItem(to_shamsi(item_data.get('expiry_date')))); table.item(r, 4).setToolTip(tooltip_text)
            table.resizeColumnsToContents(); table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch); table.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch); table.setSortingEnabled(True)

        except Exception as e:
            print(f"Error loading production inventory: {e}"); self.toast.show_message("خطا در بارگذاری موجودی تولید.", "critical")                        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید
    def _load_bom(self):
        if not hasattr(self, 'tbl_bom'): return
        tree = self.tbl_bom
        tree.clear()

        try:
            rows = self.db.list_bom(limit=500)
            if not rows:
                tree.addTopLevelItem(QtWidgets.QTreeWidgetItem(["هیچ تاریخچه مصرفی ثبت نشده است."]))
                return
            
            # --- اصلاح ۱: ترتیب صحیح ستون‌ها ---
            headers = ['شرح (محصول / ماده اولیه)', 'بچ', 'مقدار مصرف', 'تاریخ', 'کاربر', 'پیوست', 'وضعیت']
            tree.setHeaderLabels(headers)
            
            # --- اصلاح ۲: اندازه بهینه ستون‌ها ---
            header = tree.header()
            header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch) # ستون شرح
            header.setSectionResizeMode(headers.index('پیوست'), QtWidgets.QHeaderView.ResizeToContents) # ستون پیوست
            header.setSectionResizeMode(headers.index('وضعیت'), QtWidgets.QHeaderView.ResizeToContents) # ستون وضعیت


            grouped_by_product_code = {}
            for row in rows:
                pcode = row['product_code']
                if pcode not in grouped_by_product_code: grouped_by_product_code[pcode] = []
                grouped_by_product_code[pcode].append(row)

            for pcode, materials in grouped_by_product_code.items():
                if not materials: continue
                
                details = materials[0]
                is_voided = details.get('status') == 'باطل شده'
                
                parent_display_name = f"{details.get('product_name', 'نامشخص')} (بچ: {pcode})"
                
                parent_item = QtWidgets.QTreeWidgetItem(tree)
                parent_item.setText(0, parent_display_name)
                parent_item.setText(3, to_shamsi(details.get('ts')))
                parent_item.setText(4, details.get('user_', 'کاربر حذف شده'))
                parent_item.setText(6, "باطل شده" if is_voided else "فعال") # ستون وضعیت در جای جدید
                
                parent_item.setData(0, Qt.UserRole, details.get('id'))
                
                # --- اصلاح ۳: اعمال صحیح استایل به ردیف والد و فرزندان ---
                font = parent_item.font(0) # گرفتن فونت پیش‌فرض
                font.setBold(True)
                parent_item.setFont(0, font)

                if is_voided:
                    strike_font = QFont(font) # یک فونت جدید بر اساس فونت والد بساز
                    strike_font.setStrikeOut(True)
                    for i in range(tree.columnCount()):
                        parent_item.setFont(i, strike_font)
                        parent_item.setForeground(i, QtGui.QColor("#7f8c8d"))
                else:
                    for i in range(tree.columnCount()):
                        parent_item.setBackground(i, QtGui.QColor('#f8f9fa'))

                # دکمه پیوست در ستون جدید
                files_count = details.get('files_count', 0)
                btn_attach = QtWidgets.QPushButton(QtGui.QIcon.fromTheme("mail-attachment"), f" ({files_count})")
                btn_attach.setIconSize(QtCore.QSize(20, 20)); btn_attach.setFixedHeight(30)
                btn_attach.setFlat(True); btn_attach.setCursor(Qt.PointingHandCursor)
                btn_attach.setToolTip("مدیریت پیوست‌های این سند مصرف")
                btn_attach.clicked.connect(lambda _, bom_id=details.get('id'): self._open_bom_attach_dialog(bom_id))
                tree.setItemWidget(parent_item, 5, btn_attach) # ستون پیوست در جای جدید

                for mat in materials:
                    child_item = QtWidgets.QTreeWidgetItem(parent_item)
                    child_values = [mat['raw_item_name'], mat['raw_batch'], str(mat['qty']), "", "", ""]
                    for i, val in enumerate(child_values):
                        child_item.setText(i, val)
                    if is_voided:
                        for i in range(tree.columnCount()):
                            child_item.setFont(i, strike_font)
                            child_item.setForeground(i, QtGui.QColor("#7f8c8d"))

            tree.expandAll()

        except Exception as e:
            print(f"Error loading BOM: {e}")
            tree.addTopLevelItem(QtWidgets.QTreeWidgetItem([f"خطا در بارگذاری اطلاعات: {e}"]))
                                                            
                                                
    # بقیه توابع مربوط به صفحه تولید...
    def _open_recipe_manager(self): RecipeManagementDialog(self.db, self).exec_()


                
                
    def _approve_delivery(self, delivery_id: int):
        """
        نسخه نهایی و امن (V3.0) + گِیت QA:
        - قبل از تایید نهایی، بررسی می‌کند فرم‌های QC لازم برای «APPROVED» شدن این تحویل تکمیل شده باشد.
        """
        try:
            # گام ۱: خواندن اطلاعات کامل و قابل اعتماد مستقیم از دیتابیس
            delivery_details = self.db.get_delivery_details(delivery_id)
            if not delivery_details or delivery_details['status'] != 'در انتظار تایید انبار':
                self.toast.show_message("این درخواست معتبر نیست یا قبلاً پردازش شده.", "warning")
                self.refresh_all()
                return

            # گام ۱.۵: گِیت QA برای انتقال به وضعیت APPROVED روی جدول production_deliveries
            if not self._qa_gate_or_block('production_deliveries', delivery_id, 'APPROVED'):
                return

            product_name = delivery_details['product_name']

            # گام ۲: دریافت لوکیشن مقصد از انباردار
            all_valid_locations = self.db.list_locations(exclude_warehouses=['Production'])
            if not all_valid_locations:
                raise ValueError("هیچ لوکیشن مقصدی (خارج از انبار تولید) تعریف نشده است.")

            loc_map = {f"{r['wh']}/{r['loc']}": r['id'] for r in all_valid_locations}
            loc_name, ok = QtWidgets.QInputDialog.getItem(
                self, "انتخاب لوکیشن مقصد",
                f"محصول «{product_name}» در کدام لوکیشن دریافت شود؟",
                list(loc_map.keys()), 0, False
            )
            if not ok or not loc_name:
                return

            # گام ۳: فراخوانی دیتابیس
            self.db.finalize_delivery(
                delivery_id=delivery_id,
                approver_user_id=self.user_id,
                dest_loc_id=loc_map[loc_name]
            )

            self.toast.show_message("محصول با موفقیت در انبار دریافت و ثبت شد.", "success")
            self.refresh_all()

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند تایید دریافت با خطا مواجه شد:\n{e}")
            import traceback; print(traceback.format_exc())
            
                                
                                                                                
    def _open_bom_attach_dialog(self, bom_id): BOMAttachDialog(self.db, bom_id, self).exec_()
    def _export_tree_to_excel(self):
            """محتوای نمای درختی تاریخچه مصرف را به یک فایل اکسل خوانا صادر می‌کند."""
            tree = self.tbl_bom
            if not tree.topLevelItemCount():
                self.toast.show_message("اطلاعاتی برای صدور وجود ندارد.", "warning")
                return
                
            path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "ذخیره فایل اکسل", "تاریخچه_مصرف.xlsx", "Excel Files (*.xlsx)")
            if not path:
                return

            try:
                import pandas as pd
                
                data_to_export = []
                headers = [tree.headerItem().text(i) for i in range(tree.columnCount())]
                
                root = tree.invisibleRootItem()
                for i in range(root.childCount()):
                    parent_item = root.child(i)
                    if not parent_item.isHidden():
                        # اضافه کردن ردیف والد (محصول نهایی)
                        parent_data = [parent_item.text(j) for j in range(tree.columnCount())]
                        data_to_export.append(parent_data)
                        
                        # اضافه کردن ردیف‌های فرزند (مواد اولیه)
                        for j in range(parent_item.childCount()):
                            child_item = parent_item.child(j)
                            if not child_item.isHidden():
                                child_data = [child_item.text(k) for k in range(tree.columnCount())]
                                # ایجاد تورفتگی برای نمایش بهتر سلسله مراتب
                                child_data[0] = "    " + child_data[0] 
                                data_to_export.append(child_data)
                
                df = pd.DataFrame(data_to_export, columns=headers)
                df.to_excel(path, index=False, engine='openpyxl')
                
                self.toast.show_message("✔ فایل اکسل با موفقیت ذخیره شد.", "success")

            except ImportError:
                self.toast.show_message("خطا: کتابخانه pandas یا openpyxl نصب نیست.", "critical")
            except Exception as e:
                self.toast.show_message(f"خطا در ذخیره فایل: {e}", "critical")
            


                
        
    # این متد را در کلاس MainWindow به طور کامل جایگزین کنید
    def _start_background_refresh(self):
        """یک رشته جدید برای رفرش داده‌ها را به صورت امن و بدون تداخل آغاز می‌کند."""
        # تلاش برای قفل کردن؛ اگر قفل بود یعنی یک رفرش دیگر در حال اجراست
        if not self.refresh_mutex.tryLock():
            print("INFO: Refresh operation already in progress. Skipping new request.")
            return

        print("INFO: Starting background refresh job...")
        try:
            self.refresh_thread = QtCore.QThread()
            user_role_id = self.user_info.get('role_id')

            self.refresh_worker = RefreshWorker(self.db, self.user_id, user_role_id, self.permissions, self.role)
            self.refresh_worker.moveToThread(self.refresh_thread)

            self.refresh_thread.started.connect(self.refresh_worker.run)
            self.refresh_worker.finished.connect(self._update_ui_with_refreshed_data)
            self.refresh_worker.finished.connect(self.refresh_thread.quit)
            self.refresh_worker.finished.connect(self.refresh_worker.deleteLater)
            self.refresh_thread.finished.connect(self.refresh_thread.deleteLater)

            # --- اصلاح کلیدی: پس از اتمام کار، قفل را آزاد می‌کنیم ---
            self.refresh_thread.finished.connect(self.refresh_mutex.unlock)

            self.refresh_thread.start()
        except Exception as e:
            # اطمینان از آزاد شدن قفل در صورت بروز خطا هنگام ساخت نخ
            print(f"ERROR: Failed to start the refresh thread: {e}")
            self.refresh_mutex.unlock()
                                    
                        
# این متد جدید را به انتهای کلاس MainWindow اضافه کنید

    def _on_refresh_finished(self):
        """پس از اتمام کامل رشته رفرش، فلگ را ریست می‌کند."""
        print("INFO: Background refresh thread has finished.")
        self._is_refreshing = False
# در کلاس MainWindow، این متد را جایگزین کنید
# در کلاس MainWindow، این متد را جایگزین کنید
    def _update_ui_with_refreshed_data(self, data: dict):
        """پس از اتمام کار Worker، داده‌های جدید را به صورت امن در رابط کاربری نمایش می‌دهد."""
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            print("INFO: Updating UI with data from background thread...")
            
            # --- *** اصلاح کلیدی: ابتدا کش اعلان‌ها را آپدیت می‌کنیم *** ---
            self.notifications_cache = data.get('actionable_notifications', [])
            self._update_notification_count() # سپس تابع آپدیت UI را صدا می‌زنیم
            
            cnt, _ = data.get('kpi_stats', (0, []))
            low_items = data.get('min_alert', [])
            exp_items = data.get('exp_alert', [])
            
            if hasattr(self, 'card_total_items'):
                self.card_total_items.value_label.setText(str(cnt))
            if hasattr(self, 'card_shortage'):
                self.card_shortage.value_label.setText(f"{len(low_items)} مورد")
            if hasattr(self, 'card_expiring'):
                self.card_expiring.value_label.setText(f"{len(exp_items)} مورد")
            if hasattr(self, 'std_card_tasks') and self.user_info.get('role_id'):
                self.std_card_tasks.value_label.setText(str(self.db.get_new_tasks_count(self.user_id, self.user_info['role_id'])))
            if hasattr(self, 'std_card_memos'):
                 self.std_card_memos.value_label.setText(str(self.db.get_unread_memos_count(self.user_id)))

            if hasattr(self, 'pie_frame_layout'):
                value_stats = data.get('category_value_stats', [])
                cats_for_pie = [(c['category'], c['total_value']) for c in value_stats if c.get('total_value') and c['total_value'] > 0]
                while self.pie_frame_layout.count():
                    child = self.pie_frame_layout.takeAt(0)
                    if child.widget(): child.widget().deleteLater()
                if cats_for_pie:
                    self.pie_frame_layout.addWidget(Pie(cats_for_pie, self._goto_cat))
            
            if hasattr(self, 'pinned_table'):
                last_id = data.get('last_cleared_trans_id', '0')
                self.pinned_table.refresh(since_id=int(last_id))

            self._on_page_changed(self.pages.currentIndex())
            print("INFO: UI update complete.")

        finally:
            QtWidgets.QApplication.restoreOverrideCursor()
            
                        
# در کلاس MainWindow، این متد را به طور کامل جایگزین کنید

    def _refresh_dashboard_page(self):
        """کارگردان داشبورد: داشبورد فعال را تشخیص داده و تمام ویجت‌های آن را رفرش می‌کند."""
        if not hasattr(self, 'pg_dash') or not self.pg_dash.layout():
            return

        key = 'DEFAULT'
        # پیدا کردن ویجت انتخاب داشبورد در صفحه فعلی
        dashboard_selector = self.pg_dash.findChild(QtWidgets.QComboBox)
        if dashboard_selector:
            # خواندن کلید داشبورد از داده‌های آیتم انتخاب شده
            key = dashboard_selector.currentData() 
        elif self.user_dashboards:
            key = self.user_dashboards[0]

        # --- بخش ۱: رفرش داشبوردهای استاندارد ---
        if key == 'WAREHOUSE':
            warehouse_dash = self.pg_dash.findChild(WarehouseDashboardWidget)
            if warehouse_dash:
                warehouse_dash.refresh_data()
        
        elif key == 'PURCHASING':
            tasks_table = self.pg_dash.findChild(QtWidgets.QTableWidget)
            if tasks_table: self._load_my_tasks(tasks_table)
            if hasattr(self, 'purch_card_suppliers'):
                suppliers = self.db.get_all_suppliers(active_only=True)
                self.purch_card_suppliers.value_label.setText(f"{len(suppliers)} تامین‌کننده")
        
        elif key == 'DEFAULT':
            if hasattr(self, 'standard_tasks_widget'): self.standard_tasks_widget.refresh_tasks()
            if hasattr(self, '_load_dynamic_actions'): self._load_dynamic_actions()

        # --- بخش ۲: رفرش کامل و جامع داشبورد مدیرعامل (CEO) ---
        elif key == 'CEO':
            # رفرش کارت‌های KPI
            if hasattr(self, 'ceo_card_sales'):
                sales_data = self.db.get_sales_summary_by_day(30)
                total_sales = sum(d['total_sales'] for d in sales_data) if sales_data else 0
                self.ceo_card_sales.value_label.setText(f"{total_sales:,.0f} ریال")
            
            if hasattr(self, 'ceo_card_production'):
                pending_orders = self.db.get_pending_production_orders()
                self.ceo_card_production.value_label.setText(f"{len(pending_orders)} سفارش")

            if hasattr(self, 'ceo_card_inventory'):
                value_stats = self.db.get_category_value_stats()
                total_value = sum(c['total_value'] for c in value_stats) if value_stats else 0
                self.ceo_card_inventory.value_label.setText(f"{total_value:,.0f} ریال")
                # رفرش نمودار دایره‌ای ارزش موجودی در صفحه تحلیل
                if hasattr(self, 'pie_frame_layout'):
                    cats_for_pie = [(c['category'], c['total_value']) for c in value_stats if c.get('total_value') and c['total_value'] > 0]
                    while self.pie_frame_layout.count():
                        child = self.pie_frame_layout.takeAt(0)
                        if child.widget(): child.widget().deleteLater()
                    if cats_for_pie:
                        self.pie_frame_layout.addWidget(Pie(cats_for_pie, self._goto_cat))

            if hasattr(self, 'ceo_card_tasks'):
                approvals = self.db.get_pending_workflows_for_approval()
                self.ceo_card_tasks.value_label.setText(f"{len(approvals)} مورد")

            # رفرش تمام ویجت‌های نموداری و جدول‌ها
            if hasattr(self, 'sales_chart_widget'): self.sales_chart_widget.refresh_data()
            if hasattr(self, '_load_workflow_approvals'): self._load_workflow_approvals()
            if hasattr(self, 'production_chart_widget'): self.production_chart_widget.refresh_data()
            if hasattr(self, 'top_products_chart_widget'): self.top_products_chart_widget.refresh_data()
                                    
                        
                                                                        
# این متد جدید را به کلاس MainWindow اضافه کنید

    def _on_warehouse_task_selected(self):
        """با انتخاب یک وظیفه در کارتابل انبار، پنل جزئیات را به‌روز می‌کند."""
        if not hasattr(self, 'warehouse_tasks_widget'): return
        
        selected_items = self.warehouse_tasks_widget.table.selectedItems()
        if not selected_items:
            self.warehouse_task_details_widget.update_with_task(None)
            return
            
        task_data = self.warehouse_tasks_widget.table.item(selected_items[0].row(), 0).data(Qt.UserRole)
        self.warehouse_task_details_widget.update_with_task(task_data)
        
# این متد را در کلاس MainWindow با نسخه جدید جایگزین کنید
    def _receive_po_action(self, preselected_po_id=None):
        """گردش کار ثبت رسید برای یک سفارش خرید را آغاز می‌کند."""
        po_id = preselected_po_id
        
        if po_id is None:
            if not hasattr(self, 'tbl_open_pos'): return
            selected = self.tbl_open_pos.selectedItems()
            if not selected:
                self.toast.show_message("لطفاً ابتدا یک سفارش خرید را از لیست انتخاب کنید.", "warning")
                return
            row = selected[0].row()
            po_id = int(self.tbl_open_pos.item(row, 0).text())
        
        po_data = self.db.execute_query("SELECT po.*, s.name as supplier_name FROM purchase_orders po JOIN suppliers s ON po.supplier_id = s.id WHERE po.id = %s", (po_id,), fetch_one=True)

        if not po_data:
            self.toast.show_message("اطلاعات سفارش خرید یافت نشد.", "error")
            return
            
        dlg = ReceivePoDialog(self.db, dict(po_data), self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            received_data = dlg.get_received_data()
            if not received_data:
                self.toast.show_message("هیچ کالایی برای دریافت ثبت نشد. عملیات لغو شد.", "info")
                return
            
            try:
                self.db.receive_purchase_order(po_id, received_data, self.user_id)
                self.toast.show_message("✔ رسید کالا با موفقیت در انبار ثبت شد.", "success")
                self.refresh_all()
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "خطا در عملیات", f"فرآیند ثبت رسید با خطا مواجه شد:\n{e}")
                
    # این متد جدید را به کلاس MainWindow اضافه کنید
    def _run_diagnostic_report(self):
        """گزارش تشخیصی سیستم را اجرا کرده و در یک پنجره نمایش می‌دهد."""
        report_data = self.db.get_diagnostic_report_data()
        report_str = "--- System Diagnostic Report ---\n\n"

        wf = report_data.get('sales_workflow')
        report_str += "== Sales Workflow Configuration ==\n"
        if wf:
            report_str += f"Name: {wf['name']} (ID: {wf['id']}, v{wf['version']})\n"
            report_str += f"Status: {wf.get('status')}\n"
            report_str += f"FINAL ACTION KEY: --> {wf.get('final_action_key')} <--\n"
            if wf.get('final_action_key') == 'CREATE_PROD_ORDER_FROM_SO':
                report_str += "  [OK] کلید اقدام نهایی به درستی تنظیم شده است.\n"
            else:
                report_str += "  [!! PROBLEM !!] کلید اقدام نهایی تنظیم نشده یا اشتباه است. باید 'CREATE_PROD_ORDER_FROM_SO' باشد.\n"
        else:
            report_str += "[!! PROBLEM !!] هیچ فرآیندی با نام حاوی 'تایید فروش' یافت نشد.\n"

        report_str += "\n== Last 5 Completed Process Instances ==\n"
        for inst in report_data.get('last_completed_instances', []):
            report_str += f"- Instance ID: {inst['id']}, Workflow: {inst['name']} (ID: {inst['workflow_id']}), Status: {inst['status']}, Completed: {to_shamsi(inst['completed_at'])}\n"

        report_str += "\n== Last 10 Audit Logs ==\n"
        for log in report_data.get('last_audit_logs', []):
            report_str += f"[{to_shamsi(log['stamp'])}] Action: {log['action']}, Details: {log['details']}\n"

        report_str += "\n--- End of Report ---"

        DebugReportDialog(report_str, self).exec_()
        
# در کلاس MainWindow، این متد را جایگزین کنید
    def _open_deliver_packaged_good_dialog(self):
        """دیالوگ ثبت درخواست تحویل محصول نهایی (بسته‌بندی شده) را باز می‌کند."""
        dlg = DeliverFinishedGoodDialog(self.db, self)
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            data = dlg.get_data()
            if data:
                try:
                    new_delivery_id = self.db.create_delivery_request(
                        product_item_id=data['item_id'],
                        batch_no=data['batch_no'],
                        quantity=data['qty'],
                        expiry_date=data.get('expiry_date'),
                        supervisor_user_id=self.user_id,
                        # --- ارسال پارامتر جدید ---
                        production_order_id=data.get('production_order_id') 
                    )
                    if new_delivery_id:
                        self.db.submit_delivery_request(new_delivery_id)
                    
                    self.toast.show_message("✔ درخواست تحویل محصول به انبار با موفقیت ثبت شد.", "success")
                    self.refresh_all()
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "خطا", f"خطا در ثبت درخواست تحویل:\n{e}")
                    
# این متد جدید را به انتهای کلاس MainWindow اضافه کنید
    def _process_task_action_from_id(self, process_instance_id: int):
        """یک وظیفه را بر اساس ID آن پیدا کرده و پنجره اقدام مربوطه را باز می‌کند."""
        # ابتدا اطلاعات کامل وظیفه را از دیتابیس می‌خوانیم
        task_data = self.db.execute_query(
            """
            SELECT pi.*, w.name as workflow_name, ws.step_name 
            FROM process_instances pi
            JOIN workflows w ON pi.workflow_id = w.id
            JOIN workflow_steps ws ON pi.current_step_id = ws.id
            WHERE pi.id = %s
            """,
            (process_instance_id,), fetch_one=True
        )
        if not task_data:
            self.toast.show_message("وظیفه مورد نظر برای اقدام یافت نشد.", "error")
            return

        # سپس آن را به متد اصلی که از قبل برای باز کردن دیالوگ داشتیم، ارسال می‌کنیم
        self._process_task_action_from_data(dict(task_data))

                                    
            

class DatabaseConnectionDialog(QtWidgets.QDialog):
    """نسخه نهایی: با کلیدهای استاندارد psycopg2 کار می‌کند."""
    def __init__(self, parent=None, current_config=None):
        super().__init__(parent)
        self.setWindowTitle("تنظیمات اتصال به دیتابیس")
        self.setMinimumWidth(450)
        self.config_path = BASE_DIR / 'config.json'
        self.current_config = current_config or {}

        layout = QFormLayout(self)
        # --- اصلاح: خواندن از کلیدهای استاندارد ---
        self.host_edit = QLineEdit(self.current_config.get("host", "localhost"))
        self.port_edit = QLineEdit(str(self.current_config.get("port", "5433")))
        self.dbname_edit = QLineEdit(self.current_config.get("dbname", "Megatite_db"))
        self.user_edit = QLineEdit(self.current_config.get("user", "postgres"))
        self.pass_edit = QLineEdit(self.current_config.get("password", ""))
        self.pass_edit.setEchoMode(QLineEdit.Password)

        self.ssl_combo = QComboBox()
        self.ssl_combo.addItems(["غیرفعال", "ترجیحاً", "الزامی"])
        ssl_map = {"disable": 0, "prefer": 1, "require": 2}
        self.ssl_combo.setCurrentIndex(ssl_map.get(self.current_config.get("sslmode", "prefer"), 1))

        layout.addRow("آدرس سرور (IP/Hostname):", self.host_edit)
        layout.addRow("پورت:", self.port_edit)
        layout.addRow("نام دیتابیس:", self.dbname_edit)
        layout.addRow("نام کاربری دیتابیس:", self.user_edit)
        layout.addRow("رمز عبور دیتابیس:", self.pass_edit)
        layout.addRow("حالت اتصال امن (SSL):", self.ssl_combo)

        btn_layout = QHBoxLayout()
        btn_test = QPushButton("تست اتصال")
        btn_box = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        
        btn_layout.addWidget(btn_test); btn_layout.addStretch(); btn_layout.addWidget(btn_box)
        layout.addRow(btn_layout)

        btn_test.clicked.connect(self._test_connection)
        btn_box.accepted.connect(self._save_config)
        btn_box.rejected.connect(self.reject)

    def _get_config_from_form(self):
        ssl_map = {0: "disable", 1: "prefer", 2: "require"}
        # --- اصلاح: ذخیره با کلیدهای استاندارد ---
        return {
            "host": self.host_edit.text(),
            "port": int(self.port_edit.text()),
            "dbname": self.dbname_edit.text(),
            "user": self.user_edit.text(),
            "password": self.pass_edit.text(),
            "sslmode": ssl_map.get(self.ssl_combo.currentIndex(), "prefer")
        }

    def _test_connection(self):
        config = self._get_config_from_form()
        try:
            conn = psycopg2.connect(**config, connect_timeout=5)
            conn.close()
            QMessageBox.information(self, "موفقیت", "اتصال به دیتابیس با موفقیت برقرار شد.")
        except Exception as e:
            QMessageBox.critical(self, "خطا در اتصال", f"برقراری ارتباط با دیتابیس ناموفق بود.\n\n{e}")

    def _save_config(self):
        config_data = self._get_config_from_form()
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, indent=4, ensure_ascii=False)
            self.accept()
        except Exception as e:
            QMessageBox.critical(self, "خطا در ذخیره فایل", f"فایل config.json قابل نوشتن نیست.\n\n{e}")
                    
# این کلاس را به طور کامل با نسخه نهایی زیر جایگزین کنید
class CustomTreeDelegate(QtWidgets.QStyledItemDelegate):
    """
    نسخه نهایی نقاش سفارشی با خطوط خوانا و جهت‌گیری صحیح راست-به-چپ.
    """
    def paint(self, painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex):
        super().paint(painter, option, index)

        if index.column() != 0:
            return

        if not index.parent().isValid():
            return

        painter.save()
        
        # --- اصلاح ۱: خطوط ضخیم‌تر و پررنگ‌تر ---
        pen = QtGui.QPen(QtGui.QColor("#909090"), 2, QtCore.Qt.SolidLine)
        painter.setPen(pen)

        rect = option.rect
        indentation = 5
        mid_y = int(option.rect.center().y())

        # --- اصلاح ۲: محاسبات مختصات برای چیدمان راست-به-چپ (RTL) ---
        vline_x = int(rect.right() - indentation // 2)
        hline_start_x = int(rect.right() - indentation)
        
        # رسم خط افقی (چنگال)
        painter.drawLine(QtCore.QPoint(hline_start_x, mid_y), QtCore.QPoint(vline_x, mid_y))

        is_last_child = (index.row() == index.model().rowCount(index.parent()) - 1)

        # رسم خط عمودی
        if is_last_child:
            painter.drawLine(QtCore.QPoint(vline_x, rect.top()), QtCore.QPoint(vline_x, mid_y))
        else:
            painter.drawLine(QtCore.QPoint(vline_x, rect.top()), QtCore.QPoint(vline_x, rect.bottom()))
            
        painter.restore()
        
                        
# تابع main را به طور کامل با این نسخه نهایی جایگزین کنید

def main():
    MatplotlibConfig.ensure()

    app = QtWidgets.QApplication(sys.argv)
    app.setFont(QFont(FONT_FAMILY, 10))
    app.setLayoutDirection(QtCore.Qt.RightToLeft)

    app.setStyleSheet(f"""
        /* === General & Fonts === */
        QWidget {{
            background-color: #f4f6f9;
            color: #263238; 
        }}
        QLabel, QPushButton, QLineEdit, QTextEdit, QComboBox, QSpinBox {{
            font-family: '{FONT_FAMILY}', Tahoma;
            font-size: 10pt;
        }}

        /* === **NEW**: Dialog Styling === */
        QDialog {{
            background-color: #f8f9fa;
            border-radius: 6px;
        }}
        
        /* === Sidebar === */
        QFrame[objectName="sidebar"] {{
            background-color: #263238;
            border-right: 1px solid #37474f;
        }}

        QPushButton[class="sidebar-button"] {{
            color: #eceff1;
            background-color: transparent;
            border: none;
            direction: center; /* <<<< مهم‌ترین تغییر اینجاست */
            text-align: left;
            padding: 13px 22px;
            font-size: 11pt;
            font-weight: bold;
        }}
        QPushButton[class="sidebar-button"]:hover {{
            background-color: #34495e;
        }}        
        /* === Tables & Trees === */
        QTableWidget, QTreeWidget {{
            border: 1px solid #dfe4ea;
            gridline-color: #e9ecef;
            background-color: #ffffff;
            alternate-background-color: #f7f9fc;
        }}
        QTableWidget[status_colored="true"] {{
            alternate-background-color: transparent;
        }}
        
        QHeaderView::section {{
            background-color: #e9ecef;
            padding: 8px 5px;
            border: none;
            border-bottom: 2px solid #ced4da;
            font-weight: bold;
        }}
        QTableWidget::item, QTreeWidget::item {{
            padding: 6px 8px;
            border-bottom: 1px solid #f1f3f5;
        }}
        QTableWidget::item:selected, QTreeWidget::item:selected {{
            background-color: rgba(0, 120, 212, 0.3);
            color: #000;
        }}
        
        /* === Buttons === */
        QPushButton {{
            padding: 4px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: #ffffff;
            font-weight: bold;
            min-height: 28px;
        }}
        QPushButton:hover {{
            background-color: #e9ecef;
            border-color: #adb5bd;
        }}
        
        QPushButton[class="primary"] {{
            background-color: #0d6efd;
            color: white;
            border: 1px solid #0d6efd;
        }}
        QPushButton[class="primary"]:hover {{
            background-color: #0b5ed7;
            border-color: #0a58ca;
        }}
        QPushButton[class="danger"] {{
            background-color: #dc3545;
            color: white;
            border: 1px solid #dc3545;
        }}
        QPushButton[class="danger"]:hover {{
            background-color: #bb2d3b;
            border-color: #b02a37;
        }}

        /* === Input Fields === */
        QLineEdit, QTextEdit, QComboBox, QSpinBox {{
            border: 1px solid #ced4da;
            border-radius: 5px;
            padding: 6px;
            background-color: white;
        }}
        QLineEdit:focus, QTextEdit:focus, QComboBox:focus, QSpinBox:focus {{
            border-color: #86b7fe;
            outline: 0;
        }}
        
        /* === GroupBox as Cards === */
        QGroupBox {{
            background-color: #ffffff;
            border: 1px solid #dfe4ea;
            border-radius: 8px;
            margin-top: 15px;
            padding-top: 10px;
            font-weight: bold;
        }}
        QGroupBox::title {{
            subcontrol-origin: margin;
            subcontrol-position: top center;
            padding: 5px 15px;
            background-color: #f1f3f5;
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            color: #495057;
        }}

        /* === Tabs, Splitter, Tooltip === */
        QTabWidget::pane {{ border: 1px solid #dfe4ea; border-top: none; }}
        QTabBar::tab {{
            padding: 10px 20px;
            border-bottom: 3px solid transparent;
            font-weight: bold;
            color: #6c757d;
        }}
        
        QTabBar::tab:hover {{
            color: #212529;
        }}
        QTabBar::tab:selected {{
            border-bottom: 3px solid #0d6efd;
            color: #0d6efd;
        }}
        
        QTabWidget[objectName="mainProdTabs"] > QTabBar,
        QTabWidget[objectName="interfaceTabWidget"] > QTabBar {{
            qproperty-expanding: true;
        }}

        QToolTip {{
            border: 1px solid #343a40;
            padding: 6px;
            border-radius: 4px;
            background-color: #212529;
            color: white;
            font-weight: bold;
        }}

        /* === Menus === */
        QMenu {{
            background-color: #2c3e50;
            color: #ecf0f1;
            border: 1px solid #34495e;
            border-radius: 6px;
            padding: 8px;
        }}
        QMenu::item {{
            padding: 8px 20px;
            background-color: transparent;
            border-radius: 4px;
        }}
        QMenu::item:selected {{
            background-color: #3498db;
            color: #ffffff;
        }}
        QMenu::separator {{
            height: 1px;
            background: #4a6572;
            margin: 6px 4px;
        }}

        /* === **NEW**: CheckBox Styling === */
        QCheckBox {{
            spacing: 5px;
        }}
        QCheckBox::indicator {{
            width: 16px;
            height: 16px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }}
        QCheckBox::indicator:checked {{
            background-color: #0d6efd;
            border-color: #0d6efd;
            image: url({(BASE_DIR / 'icons' / 'check.png').as_posix()});
        }}

        /* === **FIX for ScrollBar**: Explicitly style scrollbars to ensure visibility === */
        QScrollBar:vertical {{
            border: 1px solid #e0e0e0;
            background: #f8f9fa;
            width: 15px;
            margin: 0px 0px 0px 0px;
        }}
        QScrollBar::handle:vertical {{
            background: #adb5bd;
            min-height: 25px;
            border-radius: 7px;
        }}
        QScrollBar::handle:vertical:hover {{
            background: #6c757d;
        }}
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
            border: none;
            background: none;
        }}
        QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
            background: none;
        }}

        QListWidget {{
            border: 1px solid #dfe4ea;
            background-color: #ffffff;
        }}
        QListWidget::item {{
            padding: 8px;
            border-bottom: 1px solid #f1f3f5;
        }}
    """)

    # --- اتصال به DB و بارگذاری کانفیگ ---
    config = {}
    db = None
    while db is None:
        try:
            if not (BASE_DIR / 'config.json').exists():
                create_config_if_not_exists()
                QMessageBox.information(
                    None,
                    "فایل تنظیمات ایجاد شد",
                    "فایل 'config.json' یافت نشد و یک نسخه پیش‌فرض ایجاد گردید. لطفاً اطلاعات اتصال به دیتابیس را در آن وارد کرده و برنامه را مجدداً اجرا کنید."
                )
                sys.exit(0)

            with open(BASE_DIR / 'config.json', 'r', encoding='utf-8') as f:
                config = json.load(f)

            db = DB(config)

        except (IOError, FileNotFoundError, json.JSONDecodeError) as e:
            QMessageBox.critical(None, "خطای فایل کانفیگ", f"مشکلی در خواندن فایل config.json وجود دارد: {e}")
            dlg = DatabaseConnectionDialog(current_config=config)
            if dlg.exec_() != QDialog.Accepted:
                sys.exit(0)

        except (ConnectionError, psycopg2.OperationalError) as e:
            QMessageBox.warning(None, "خطای اتصال", f"برقراری ارتباط با دیتابیس ناموفق بود.\nلطفاً اطلاعات اتصال را بررسی و اصلاح کنید.\n\nخطا: {e}")
            dlg = DatabaseConnectionDialog(current_config=config)
            if dlg.exec_() != QDialog.Accepted:
                sys.exit(0)


    # --- چرخهٔ لاگین و اجرای برنامه ---
    restart_app = True
    while restart_app:
        restart_app = False
        login = LoginDialog(db)
        if login.exec_() == QtWidgets.QDialog.Accepted:
            win = MainWindow(db, login.user_info)
            win.showMaximized()
            app.exec_()
            if getattr(win, 'restart_on_close', False):
                restart_app = True
        else:
            break
                                                                                                        
if __name__ == '__main__':
    main()